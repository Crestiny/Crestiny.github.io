<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Crestiny&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Crestiny&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CrestinyCoco">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Crestiny's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Crestiny's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Life is fantastic ! </p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/03/Chapter2-ARM%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CrestinyCoco">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crestiny's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/03/Chapter2-ARM%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">Chapter2 ARM技术概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-03 11:01:32 / 修改时间：11:39:24" itemprop="dateCreated datePublished" datetime="2021-03-03T11:01:32+08:00">2021-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Courses/" itemprop="url" rel="index"><span itemprop="name">Courses</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Courses/%E3%80%8A%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《嵌入式系统开发与应用教程》</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Courses/%E3%80%8A%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%E3%80%8B/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">嵌入式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>ARM是一种处理器</strong>，在32位嵌入式应用中使用得比较广泛</p>
<h2 id="2-1-ARM体系结构及技术特征"><a class="header-anchor" href="#2-1-ARM体系结构及技术特征">¶</a>2.1 ARM体系结构及技术特征</h2>
<p>SoC芯片：</p>
<blockquote>
<p>一般说来， SoC称为系统级芯片，也有称片上系统，意指它是一个产品，是一个有专用目标的集成电路，其中包含完整系统并有嵌入软件的全部内容。 同时它又是一种技术，用以实现从确定系统功能开始，到软/硬件划分，并完成设计的整个过程。</p>
</blockquote>
<p>所以各公司可以基于ARM来开发面向各种应用的SoC芯片</p>
<h3 id="2-1-1-ARM的发展历程"><a class="header-anchor" href="#2-1-1-ARM的发展历程">¶</a>2.1.1 ARM的发展历程</h3>
<h3 id="2-1-2-RISC体系结构概述"><a class="header-anchor" href="#2-1-2-RISC体系结构概述">¶</a>2.1.2 RISC体系结构概述</h3>
<p>RISC是一种体系结构，而ARM是最成功的RISC实例，也就是说，<strong>ARM是基于RISC的处理器</strong></p>
<p>本节先来介绍RISC</p>
<h4 id="1-CISC体系结构"><a class="header-anchor" href="#1-CISC体系结构">¶</a>1. CISC体系结构</h4>
<p>CISC的全名是：Complex Instruction Set Computer，也就是带有小型计算机指令集的单片<strong>复杂指令集</strong>计算机</p>
<p>复杂指令集不是很划算，所以我们发展了RISC来简化指令集</p>
<h4 id="2-RISC体系结构"><a class="header-anchor" href="#2-RISC体系结构">¶</a>2. RISC体系结构</h4>
<p>RISC的<strong>中心思想</strong>：简化指令集的复杂度；硬件被设计成只执行一部分简单指令，其他复杂指令由这些简单指令合成——这样可以简化硬件设计</p>
<h4 id="3-RISC体系结构的特点"><a class="header-anchor" href="#3-RISC体系结构的特点">¶</a>3. RISC体系结构的特点</h4>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/03/Chapter1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CrestinyCoco">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crestiny's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/03/Chapter1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Chapter1 嵌入式系统开发基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-03 11:01:13" itemprop="dateCreated datePublished" datetime="2021-03-03T11:01:13+08:00">2021-03-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/02/Chapter8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CrestinyCoco">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crestiny's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/02/Chapter8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">Chapter8 文件系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-02 15:02:50" itemprop="dateCreated datePublished" datetime="2021-03-02T15:02:50+08:00">2021-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-04 19:00:28" itemprop="dateModified" datetime="2021-03-04T19:00:28+08:00">2021-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Courses/" itemprop="url" rel="index"><span itemprop="name">Courses</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Courses/%E3%80%8ALinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8-E2-%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《Linux操作系统原理与应用(E2)》</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="8-1-Linux文件系统基础"><a class="header-anchor" href="#8-1-Linux文件系统基础">¶</a>8.1 Linux文件系统基础</h2>
<h3 id="8-1-1-Linux文件结构"><a class="header-anchor" href="#8-1-1-Linux文件结构">¶</a>8.1.1 Linux文件结构</h3>
<p>文件结构：文件存放在磁盘等存储设备上的组织方法，包括对文件的组织、对目录的组织</p>
<p>Linux是有相对固定的目录组织形式的，每个目录都有自己特定的作用：</p>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210302153129000.png" alt="image-20210302153129000" style="height:500px;width:700px">
<h3 id="8-1-2-文件类型"><a class="header-anchor" href="#8-1-2-文件类型">¶</a>8.1.2 文件类型</h3>
<p>Linux有以下文件类型：</p>
<ul>
<li>常规文件
<ul>
<li>文本文件</li>
<li>二进制文件</li>
</ul>
</li>
<li>目录文件：只允许系统进行修改</li>
<li>设备文件：Linux把所有的外设都当做文件来看待</li>
<li>管道文件：用于在进程间传输数据</li>
<li>（符号）链接文件：可以通过链接文件中包含的指向文件的指针来实现对文件的访问</li>
</ul>
<h3 id="8-1-3-存取权限和文件模式"><a class="header-anchor" href="#8-1-3-存取权限和文件模式">¶</a>8.1.3 存取权限和文件模式</h3>
<p>就是一种文件保护模式，包含：</p>
<ul>
<li>
<p>三级访问权限：</p>
<ul>
<li>属主</li>
<li>属组</li>
<li>其他用户</li>
</ul>
</li>
<li>
<p>三种处理操作</p>
<ul>
<li>读R</li>
<li>写W</li>
<li>执行X</li>
</ul>
<p>组合一下，一共有九种情况：</p>
<img src="https://github.com/Crestiny/BlogImgBed/blob/main/img/image-20210302204854981.png?raw=true" style="height:200px;width:500px">
</li>
</ul>
<h3 id="8-1-4-Linux文件系统"><a class="header-anchor" href="#8-1-4-Linux文件系统">¶</a>8.1.4 Linux文件系统</h3>
<p><strong>Linux系统中每一个分区都是一个文件系统，都有自己的目录层级结构</strong></p>
<p>Linux会将这些不同分区的文件系统按一定方式组织成一个系统总的目录层次结构</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">❓</span>什么是分区</p>
<h4 id="1-索引结点"><a class="header-anchor" href="#1-索引结点">¶</a>1.索引结点</h4>
<p><strong>Linux文件系统使用索引节点来记录文件信息，也靠这个结点来识别文件</strong></p>
<p>索引结点是一个数据结构，其中的信息有：</p>
<ul>
<li>文件的长度</li>
<li>创建时间</li>
<li>修改时间</li>
<li>权限</li>
<li>所属关系</li>
<li>磁盘中的位置</li>
<li>等等……</li>
</ul>
<h4 id="2-软链接和硬链接"><a class="header-anchor" href="#2-软链接和硬链接">¶</a>2. 软链接和硬链接</h4>
<ul>
<li>硬链接：一个文件可以对应一个及以上的文件名</li>
<li>软链接：符号链接？<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">❓</span></li>
</ul>
<h4 id="3-安装文件系统"><a class="header-anchor" href="#3-安装文件系统">¶</a>3. 安装文件系统</h4>
<p>这个安装不是install，而是mount；就是把一个文件系统的顶层目录挂载到另一个文件系统的子目录上</p>
<h4 id="4-文件系统创建示例"><a class="header-anchor" href="#4-文件系统创建示例">¶</a>4. 文件系统创建示例</h4>
<h2 id="8-2-虚拟文件系统"><a class="header-anchor" href="#8-2-虚拟文件系统">¶</a>8.2 虚拟文件系统</h2>
<p>什么是虚拟文件系统VFS？</p>
<p>就是一个统一、抽象、虚拟的文件系统界面，背后可以是实现细节不同的文件系统</p>
<p>为什么需要VFS？</p>
<p>由于Linux的开放性，需要支持不同的文件系统</p>
<h3 id="8-2-1-虚拟文件系统的引入"><a class="header-anchor" href="#8-2-1-虚拟文件系统的引入">¶</a>8.2.1 虚拟文件系统的引入</h3>
<h3 id="8-2-2-VFS中对象的演绎"><a class="header-anchor" href="#8-2-2-VFS中对象的演绎">¶</a>8.2.2 VFS中对象的演绎</h3>
<p>解释一下“虚拟”这个词：</p>
<p>VFS只管理挂载到系统中的实际文件系统，而Linux支持的十几种文件系统，并不是全部都挂载在系统上的，而是<strong>按需挂载</strong></p>
<p><strong>VFS其实是一个管家的角色</strong></p>
<p>UNIX在文件系统的设计中抽象出的4个概念，也就是VFS要管理的4个对象：</p>
<ul>
<li>文件对象：文件可以看做有序字节串；典型的文件操作有：读、写、创建、删除</li>
<li>目录项对象：一个文件路径的每一部分被称作目录项（<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span>目录项和目录不一样​，<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">❓</span>目录是什么）</li>
<li>索引结点对象：描述了一个文件的属性，就像PCB描述了进程的属性一样</li>
<li>超级块对象：描述了已安装的整个文件系统的信息</li>
</ul>
<p><strong>UNIX中，目录∈普通文件，所以目录=文件，两者的处理方式在系统看来没有什么不同</strong></p>
<h3 id="8-2-3-VFS的超级块"><a class="header-anchor" href="#8-2-3-VFS的超级块">¶</a>8.2.3 VFS的超级块</h3>
<p>​	之前说到，VFS背后可以支持几十个不同的文件系统，比如Ext2文件系统。每个文件系统都有自己的超级块，比如Ext2超级块，这是在<strong>磁盘</strong>上的。假如我们安装了Ext2文件系统（初始化+注册），那么系统就会在<strong>内存</strong>为Ext2文件系统分配一个<strong>VFS超级块</strong>——所以VFS超级块只存在于内存中</p>
<h3 id="8-2-4-VFS的索引结点"><a class="header-anchor" href="#8-2-4-VFS的索引结点">¶</a>8.2.4 VFS的索引结点</h3>
<p>和超级块类似，每个具体的文件系统的索引结点是存放在磁盘上的（静态结构）；<strong>索引结点包含了文件系统处理文件所需要的所有信息</strong>，当要使用它的时候，就可以将它调入内存，填写<strong>VFS的索引结点（动态结构）</strong></p>
<h3 id="8-2-5-目录项对象"><a class="header-anchor" href="#8-2-5-目录项对象">¶</a>8.2.5 目录项对象</h3>
<p>每个文件有索引结点inode数据结构+目录项dentry数据结构，<strong>两者都是对文件各方面属性的描述</strong>，但侧重点不同：</p>
<ul>
<li>索引结点inode数据结构：
<ul>
<li>在磁盘上有对应的映像</li>
<li>记录的是文件<strong>物理</strong>上的属性</li>
<li>代表的是物理意义上的文件</li>
</ul>
</li>
<li>目录项dentry数据结构：
<ul>
<li>在磁盘上并没有对应的映像</li>
<li>记录的是文件<strong>逻辑</strong>上的属性</li>
<li>代表的是逻辑意义上的文件</li>
</ul>
</li>
</ul>
<p>（虽然不是很懂物理的和逻辑的是什么意思……）</p>
<h3 id="8-2-6-与进程相关的文件结构"><a class="header-anchor" href="#8-2-6-与进程相关的文件结构">¶</a>8.2.6 与进程相关的文件结构</h3>
<p>进程访问文件的时候，<strong>所打开的文件是通过文件描述符来抽象表示的</strong>（<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">❓</span>这句话也好抽象啊）</p>
<p>那么进程打开<strong>文件描述符的使用情况</strong>，又是通过用户打开文件表来描述和记录的</p>
<h4 id="1-文件对象struct-file"><a class="header-anchor" href="#1-文件对象struct-file">¶</a>1. 文件对象struct file</h4>
<p>file对象保存了一些文件相关的信息，其中比较重要的是一个叫做“Open File Description”的东西，描述了打开文件的文件位置（也就是下一个要读或写的字节位置）</p>
<h4 id="2-用户打开文件表struct-files-struct"><a class="header-anchor" href="#2-用户打开文件表struct-files-struct">¶</a>2. 用户打开文件表struct files_struct</h4>
<p>是进程的私有数据</p>
<h4 id="3-fs-struct结构"><a class="header-anchor" href="#3-fs-struct结构">¶</a>3. fs_struct结构</h4>
<p>描述进程与文件系统的关系</p>
<h3 id="8-2-7-主要数据结构间的关系"><a class="header-anchor" href="#8-2-7-主要数据结构间的关系">¶</a>8.2.7 主要数据结构间的关系</h3>
<h3 id="8-2-8-实例——观察数据结构中的数据"><a class="header-anchor" href="#8-2-8-实例——观察数据结构中的数据">¶</a>8.2.8 实例——观察数据结构中的数据</h3>
<h2 id="8-3-文件系统的注册、安装与卸载"><a class="header-anchor" href="#8-3-文件系统的注册、安装与卸载">¶</a>8.3 文件系统的注册、安装与卸载</h2>
<h3 id="8-3-1-文件系统的注册和注销"><a class="header-anchor" href="#8-3-1-文件系统的注册和注销">¶</a>8.3.1 文件系统的注册和注销</h3>
<h3 id="8-3-2-文件系统的安装"><a class="header-anchor" href="#8-3-2-文件系统的安装">¶</a>8.3.2 文件系统的安装</h3>
<h3 id="8-3-3-文件系统的卸载"><a class="header-anchor" href="#8-3-3-文件系统的卸载">¶</a>8.3.3 文件系统的卸载</h3>
<h2 id="8-4-文件的打开与读写"><a class="header-anchor" href="#8-4-文件的打开与读写">¶</a>8.4 文件的打开与读写</h2>
<h3 id="8-4-1-文件打开open"><a class="header-anchor" href="#8-4-1-文件打开open">¶</a>8.4.1 文件打开open()</h3>
<h3 id="8-4-2-文件读写read-和write"><a class="header-anchor" href="#8-4-2-文件读写read-和write">¶</a>8.4.2 文件读写read()和write()</h3>
<h2 id="8-5-编写一个文件系统"><a class="header-anchor" href="#8-5-编写一个文件系统">¶</a>8.5 编写一个文件系统</h2>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/01/%E5%8F%88%E4%B8%B4%E4%B8%80%E5%BE%80%E6%97%A0%E5%89%8D%E6%97%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CrestinyCoco">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crestiny's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/%E5%8F%88%E4%B8%B4%E4%B8%80%E5%BE%80%E6%97%A0%E5%89%8D%E6%97%B6/" class="post-title-link" itemprop="url">又临一往无前时</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-01 00:06:08" itemprop="dateCreated datePublished" datetime="2021-03-01T00:06:08+08:00">2021-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-06 18:31:00" itemprop="dateModified" datetime="2021-03-06T18:31:00+08:00">2021-03-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Insights-on-Life/" itemprop="url" rel="index"><span itemprop="name">Insights on Life</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="无知的勇气"><a class="header-anchor" href="#无知的勇气">¶</a>无知的勇气</h2>
<p>​	翻到高中的小笔记本，那时候前面一半记作业，后面一半记日记。</p>
<p>​	几年以来，每当我需要勇气的时候，都会打开它。随年岁增长，我对这世界的认知越发清晰；不像以前，窗内是生活，窗外是想象中的生活——现在，窗内窗外都是我可以看到的。</p>
<blockquote>
<p>​	世上只有一种英雄主义，就是在认清生活真相之后依然热爱生活。</p>
</blockquote>
<p>​	罗曼·罗兰的这句话很有名，而这确实不容易做到。我有两个时段最有勇气：一是无知而无畏的小孩子时期，浮夸的理想和幼稚的逻辑，虽然或许不切实际，但是小时候的我同现在的我是一颗心，她的幼稚，只是我如今在现实的重围下，不曾再表露在人前的真正心中所想；另一是经历一些挫折之后，开始切身体会到“树的结痂处最坚硬”这句谚语的内涵。</p>
<p>​	然而知道便是知道，见过一部分生活的真相之后，好像很难伪装成从未见过一样。</p>
<p>​	生活的广场上，脚步匆匆的人们彼此心事重重地擦肩而过；各有所向，又各不知为何向。深夜的地铁站和夜幕下的空荡街头听闻过世人偶尔的崩溃，那是与成年人的身份不匹配的“放纵”。他们身上有一副沉重的镣铐禁锢了他们的灵魂，无声的呐喊与有声的崩溃，那是他们希望生活将他们的灵魂放逐回天堂。</p>
<p>​	我或许也是他们中的一员，虽然没有到崩溃的地步，但也曾怀疑过自己的生活。现在的我，却希望向那个十六七岁的我借一份勇气。她身上有着“无知”的勇气，纵然幼稚，但也有效。</p>
<p>​	她曾在繁忙的学习生活中，记录下自己的情绪碎片。她竟然也有着那样有趣的思想——之所以会这样评价，或许是这几年的生活一拳将我打得连连倒退，勉强刹住；回首望见五年前的她，不禁感叹她比我有勇气多了。她的小本子里这样写道：</p>
<blockquote>
<p>​	会被人嘲笑的梦想，才有实现的价值。我是个偏执、要强、好面子的人，有时候我想，正是由于害怕失败后的尴尬，所以才更渴望也更懂得如何去避免那一份尴尬。人总有不足之处，拼尽全力也赶不上，那是“无能为力”，而我不介意这个词；比起“无能为力”，“我本可以”听起来更让人心烦……永远不要去联想最苦难的处境，而是要想想你克服他们之后的欢愉……胜固欣然，败也如常。</p>
</blockquote>
<p>​	但不可以过分崇尚苦难，过度的苦是一种精神疾病，也会给自己的经历和努力带来不开心的调子。</p>
<p>​	接受这一份无知的勇气，然后——</p>
<p>​	向前吧，理所应当地超越那个十六七岁的自己；让现在的自己，成为新的勇气来源。</p>
<p>​	去走在那个永不止歇的方向上吧，不论是十六七岁，还是二十几岁，人尚年轻，她们两个，理应有着延续的勇气；并从无知的勇气，走向清醒的勇气。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/26/Chapter7-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CrestinyCoco">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crestiny's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/26/Chapter7-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5/" class="post-title-link" itemprop="url">Chapter7 内核中的同步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-26 18:02:22" itemprop="dateCreated datePublished" datetime="2021-02-26T18:02:22+08:00">2021-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-02 15:01:57" itemprop="dateModified" datetime="2021-03-02T15:01:57+08:00">2021-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Courses/" itemprop="url" rel="index"><span itemprop="name">Courses</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Courses/%E3%80%8ALinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8-E2-%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《Linux操作系统原理与应用(E2)》</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>内核中很多数据都是共享资源，对这些资源的访问必须遵循一定的访问规则</p>
<h2 id="7-1-临界区和竞争状态"><a class="header-anchor" href="#7-1-临界区和竞争状态">¶</a>7.1 临界区和竞争状态</h2>
<p><strong>临界区</strong>：是一段代码段——实现了“访问和操作共享数据”的代码段</p>
<p>临界区的代码在执行期间不可以被打断，也就是需要被<strong>原子地</strong>执行</p>
<p>如果两个内核任务都处于同一个临界区中，就是<strong>竞争状态</strong>；避免并发和竞争状态称为<strong>同步</strong></p>
<h3 id="7-1-1-临界区举例"><a class="header-anchor" href="#7-1-1-临界区举例">¶</a>7.1.1 临界区举例</h3>
<p>比如<code>i++</code></p>
<h3 id="7-1-2-共享队列和加锁"><a class="header-anchor" href="#7-1-2-共享队列和加锁">¶</a>7.1.2 共享队列和加锁</h3>
<p>当共享资源是一个比较<strong>复杂的数据结构</strong>的时候，<strong>竞争状态</strong>往往会使该数据结构<strong>遭到破坏</strong>（比如把需要处理的请求做成队列，然后不同的内核任务去读取这些请求）</p>
<p>所以为了避免竞争状态，<strong>锁机制</strong>可以避免竞争状态；简单来说，就是一个任务要操作共享数据的时候，先上个锁（占住锁）；处理完了就打开锁</p>
<p>锁也是有几种不一样的种类的</p>
<h3 id="7-1-3-确定保护对象"><a class="header-anchor" href="#7-1-3-确定保护对象">¶</a>7.1.3 确定保护对象</h3>
<p>也就是找出哪些数据是需要被保护的</p>
<ul>
<li>不需要保护的数据：
<ul>
<li>内核任务的局部数据</li>
<li>局部自动变量</li>
<li>只被特定的进程访问的数据</li>
</ul>
</li>
<li>需要保护的数据：
<ul>
<li>有不止一个的内核任务可以访问到的数据</li>
<li>任何其他东西能看到的数据</li>
</ul>
</li>
</ul>
<h3 id="7-1-4-死锁"><a class="header-anchor" href="#7-1-4-死锁">¶</a>7.1.4 死锁</h3>
<p>死锁的情境我已经知道了，说说预防死锁的方法：</p>
<ul>
<li>注意加锁的顺序</li>
<li>防止饥饿</li>
<li>不要重复请求同一个锁</li>
<li>加锁方案不要太复杂</li>
</ul>
<h3 id="7-1-5-并发执行的原因"><a class="header-anchor" href="#7-1-5-并发执行的原因">¶</a>7.1.5 并发执行的原因</h3>
<p>什么是并发执行呢？首先，并发执行分为两类：</p>
<ul>
<li>伪并发：交叉运行的两个进程</li>
<li>真并发：比如对称多处理器的机器，两个进程是真的可以同时在临界区执行</li>
</ul>
<p><strong>虽然有这两种并发，但共同点是它们都会引发竞争状态，都需要保护</strong></p>
<p>什么原因会造成并发呢？比如：</p>
<ul>
<li>中断：可以打断当前正在执行的代码（没懂为什么）</li>
<li>内核抢占：具有抢占性的内核，内核中的任务会被另一任务抢占</li>
<li>睡眠：假如内核执行的进程睡眠了，那么调度程序或许会调来一个新的进程执行</li>
<li>对称多处理</li>
</ul>
<p>理解这些原因可以帮助我们在写代码的时候，判断哪里需要加锁</p>
<h2 id="7-2-内核同步措施"><a class="header-anchor" href="#7-2-内核同步措施">¶</a>7.2 内核同步措施</h2>
<p>内核提供了<strong>一组同步方法来提供对共享数据的保护</strong>，可以避免并发，防止竞争</p>
<h3 id="7-2-1-原子操作"><a class="header-anchor" href="#7-2-1-原子操作">¶</a>7.2.1 原子操作</h3>
<p>Linux定义了原子类型，和对应的一些原子操作函数来实现这个机制</p>
<h3 id="7-2-2-自旋锁"><a class="header-anchor" href="#7-2-2-自旋锁">¶</a>7.2.2 自旋锁</h3>
<p>之前说过中断会引起并发执行，对于单处理器，关闭中断就可以了；但是对于多处理器，我们引入<strong>自旋锁</strong>来防止并发</p>
<p>自旋锁<strong>最多只能被一个</strong>内核任务持有，如果一个内核任务试图请求一个已被持有的自旋锁，那么这个任务就会一直<strong>忙等</strong></p>
<h3 id="7-2-3-信号量"><a class="header-anchor" href="#7-2-3-信号量">¶</a>7.2.3 信号量</h3>
<p>信号量是一种睡眠锁，也就是说，当内核任务等不到锁时，它就被放入等待队列，进入睡眠状态</p>
<p>（突然想顺带一提，这本书里任务=进程）</p>
<p>信号量的使用可以看以前的操作系统笔记</p>
<h2 id="7-3-生产者-消费者并发实例"><a class="header-anchor" href="#7-3-生产者-消费者并发实例">¶</a>7.3 生产者-消费者并发实例</h2>
<h2 id="7-4-内核多任务并发实例"><a class="header-anchor" href="#7-4-内核多任务并发实例">¶</a>7.4 内核多任务并发实例</h2>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/26/Chapter5-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CrestinyCoco">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crestiny's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/26/Chapter5-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">Chapter5 中断和异常</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-26 16:42:28" itemprop="dateCreated datePublished" datetime="2021-02-26T16:42:28+08:00">2021-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-01 21:20:51" itemprop="dateModified" datetime="2021-03-01T21:20:51+08:00">2021-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Courses/" itemprop="url" rel="index"><span itemprop="name">Courses</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Courses/%E3%80%8ALinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8-E2-%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《Linux操作系统原理与应用(E2)》</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>中断的出现，改变了处理器需要不断查询的情况。中断分为外部中断（硬件中断）、内部中断（异常）</p>
<h2 id="5-1-中断是什么"><a class="header-anchor" href="#5-1-中断是什么">¶</a>5.1 中断是什么</h2>
<h3 id="5-1-1-中断向量"><a class="header-anchor" href="#5-1-1-中断向量">¶</a>5.1.1 中断向量</h3>
<p>什么是中断向量？</p>
<p>就是一个数，系统把中断源编号了，每个数字对应一种中断源，所以中断向量就可以帮助我们了解中断源。</p>
<p>中断向量一共有256种，分为异常和中断；异常又分为陷阱trap和故障fault，中断又分为外部可/非屏蔽中断</p>
<h3 id="5-1-2-外设可屏蔽中断"><a class="header-anchor" href="#5-1-2-外设可屏蔽中断">¶</a>5.1.2 外设可屏蔽中断</h3>
<h3 id="5-1-3-异常及非屏蔽中断"><a class="header-anchor" href="#5-1-3-异常及非屏蔽中断">¶</a>5.1.3 异常及非屏蔽中断</h3>
<h3 id="5-1-4-中断描述符表"><a class="header-anchor" href="#5-1-4-中断描述符表">¶</a>5.1.4 中断描述符表</h3>
<p>描述了更多信息？</p>
<h3 id="5-1-5-相关汇编指令"><a class="header-anchor" href="#5-1-5-相关汇编指令">¶</a>5.1.5 相关汇编指令</h3>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/24/Chapter4-%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CrestinyCoco">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crestiny's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/Chapter4-%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/" class="post-title-link" itemprop="url">Chapter4 内存寻址</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-24 09:58:54" itemprop="dateCreated datePublished" datetime="2021-02-24T09:58:54+08:00">2021-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-26 16:38:58" itemprop="dateModified" datetime="2021-02-26T16:38:58+08:00">2021-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Courses/" itemprop="url" rel="index"><span itemprop="name">Courses</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Courses/%E3%80%8ALinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8-E2-%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《Linux操作系统原理与应用(E2)》</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="4-1-Linux的内存管理概述"><a class="header-anchor" href="#4-1-Linux的内存管理概述">¶</a>4.1 Linux的内存管理概述</h2>
<p>Linux是多用户多任务的，并实现了虚存技术</p>
<h3 id="4-1-1-虚拟内存、内核空间和用户空间"><a class="header-anchor" href="#4-1-1-虚拟内存、内核空间和用户空间">¶</a>4.1.1 虚拟内存、内核空间和用户空间</h3>
<p>Linux简化了分段机制，使得虚拟地址和线性地址总是一致的。</p>
<p>虚拟地址空间是4GB，最高1GB是内核空间（放的是内核代码和数据），下面3GB是用户空间（放的是用户代码和数据）。内核空间是所有进程共享的，结构示意图如下：</p>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210224165919056.png" alt="image-20210224165919056" style="height:250px;width:500px">
<p>任何一个时刻CPU上只有一个进程在运行，所以每一时刻系统都只有一个4GB的虚拟地址空间。</p>
<p>**用户空间不是被进程共享的，而是被进程隔离的。**不同的进程的同一个地址对应的是不同的内容哦。这是为什么呢？</p>
<p>因为CPU将虚拟地址转换为物理地址，靠的是每个进程的页表；既然每个进程的页表不同，那么转换的结果也就不同了。</p>
<p><strong>内核空间中的内核程序，和用户空间中的用户程序，它们编译链接后形成的地址空间是一个虚拟地址空间。</strong></p>
<h4 id="1-内核空间到物理内存的映射"><a class="header-anchor" href="#1-内核空间到物理内存的映射">¶</a>1. 内核空间到物理内存的映射</h4>
<p>见下图：</p>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210224172008342.png" alt="image-20210224172008342" style="height:400px;width:430px">
<h4 id="2-内核映像"><a class="header-anchor" href="#2-内核映像">¶</a>2. 内核映像</h4>
<p>内核映像这个词听起来比较抽象，它其实是：内核的代码和数据。</p>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210224173830494.png" alt="image-20210224173830494" style="height:150px;width:700px">
<p>（这一段我看的好晕QWQ）</p>
<h3 id="4-1-2-虚拟内存实现机制间的关系"><a class="header-anchor" href="#4-1-2-虚拟内存实现机制间的关系">¶</a>4.1.2 虚拟内存实现机制间的关系</h3>
<p>实现虚存需要很多机制的支持，比如：</p>
<ul>
<li>地址映射机制</li>
<li>请页机制</li>
<li>内存分配和回收机制</li>
<li>交换机制</li>
<li>缓存和刷新机制</li>
</ul>
<p>它们之间的关系如下图所示：</p>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210224231527062.png" alt="image-20210224231527062" style="height:330px;width:700px">
<h2 id="4-2-进程的用户空间管理"><a class="header-anchor" href="#4-2-进程的用户空间管理">¶</a>4.2 进程的用户空间管理</h2>
<p>每个进程最大可以拥有3GB的私有虚存空间，那么这3GB是如何划分的？如下图所示：</p>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210225001310006.png" alt="image-20210225001310006" style="height:500px;width:200px">
<p>BSS=Block Started by Symbol，是未初始化的数据段。</p>
<p>内核在创建进程时，并不是为整个用户空间都分配物理空间，而是采用请页的方法（按需调页）</p>
<h3 id="4-2-1-进程用户空间的描述"><a class="header-anchor" href="#4-2-1-进程用户空间的描述">¶</a>4.2.1 进程用户空间的描述</h3>
<p>用两个数据结构来描述：</p>
<ul>
<li>mm_struct内存描述符：描述一个进程的虚拟地址空间</li>
<li>VM_AREA_STRUCT：用来描述进程用户空间的一个虚拟内存区间（虚存区=代码区+未初始化数据区+数据区+堆栈区）</li>
</ul>
<p>这两个结构之间也是有关系的</p>
<h3 id="4-2-2-进程用户空间的创建"><a class="header-anchor" href="#4-2-2-进程用户空间的创建">¶</a>4.2.2 进程用户空间的创建</h3>
<ul>
<li>进程的用户空间创建，是fork()来完成的</li>
<li>对于用户进程，子进程采用<strong>写时复制</strong>的方法逐渐建立完全属于自己的用户空间；内核进程，子进程继承父进程的用户空间</li>
</ul>
<h3 id="4-2-3-虚存映射"><a class="header-anchor" href="#4-2-3-虚存映射">¶</a>4.2.3 虚存映射</h3>
<p>什么是虚存映射？</p>
<p>首先来捋一下概念，程序运行时，它的代码数据等等（可执行映像），会从磁盘装入内存，但是内存分为有两种说法，一种是虚拟内存（用户空间、线性地址），一种是物理内存；Linux的实际做法，是把可执行映像装入虚存中，也就是用户空间。</p>
<p>这样操作之后，对磁盘上文件的访问，就变成了对虚存区的访问，这就叫<strong>虚存映射</strong>。</p>
<p>虚存映射分为三类：</p>
<ul>
<li>共享映射：几个进程共享这一映射（比如几个进程都用到同一文件，这份文件对应的虚存被大家共享？），一个进程对虚存区写，会改变磁盘文件，且其他进程能“看到”</li>
<li>私有映射：这种映射只有读文件的功能，效率比共享映射高</li>
<li>匿名映射：映射与文件无关（？？？）</li>
</ul>
<h3 id="4-2-4-进程的虚存区举例"><a class="header-anchor" href="#4-2-4-进程的虚存区举例">¶</a>4.2.4 进程的虚存区举例</h3>
<h3 id="4-2-5-与用户空间相关的系统调用"><a class="header-anchor" href="#4-2-5-与用户空间相关的系统调用">¶</a>4.2.5 与用户空间相关的系统调用</h3>
<ul>
<li>fork()</li>
<li>mmap()</li>
<li>munmap()</li>
<li>exec()</li>
<li>Exit()</li>
</ul>
<h2 id="4-3-请页机制"><a class="header-anchor" href="#4-3-请页机制">¶</a>4.3 请页机制</h2>
<p>为了节约物理内存，用户空间中的少量页才会被调入物理内存。当对应的虚存页面没有被装入物理内存时，就会报告页故障。页故障有以下三个产生原因：</p>
<ul>
<li>程序出错。例如要访问的虚地址超过用户空间范围</li>
<li>缺页异常。就是虚地址有效但对应的物理页面不在范围内</li>
<li>保护错误。要访问的虚地址被“写保护”，根据不同情况，处理方法不同</li>
</ul>
<p>缺页异常整个处理流程（简单版和完整版）：</p>
<p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210225143752072.png" alt="image-20210225143752072"></p>
<h3 id="4-3-2-请求调页"><a class="header-anchor" href="#4-3-2-请求调页">¶</a>4.3.2 请求调页</h3>
<p>请求调页大部分还是好处多多的，但是也要付出额外的开销：浪费CPU的周期去处理缺页异常。不过幸好，按规律来说，缺页异常算是稀有事件。</p>
<p>有两种情况，被寻址的页面可以不在物理内存中：（？？？）</p>
<ul>
<li>进程永远也没有访问到这个页</li>
<li>进程已经访问过这个页，但这个页的内容被临时保存在磁盘上</li>
</ul>
<h3 id="4-3-3-写时复制"><a class="header-anchor" href="#4-3-3-写时复制">¶</a>4.3.3 写时复制</h3>
<p>写时复制是一种可以推迟甚至免除拷贝数据的技术</p>
<h2 id="4-4-物理内存分配与回收"><a class="header-anchor" href="#4-4-物理内存分配与回收">¶</a>4.4 物理内存分配与回收</h2>
<h3 id="4-4-1-页描述符"><a class="header-anchor" href="#4-4-1-页描述符">¶</a>4.4.1 页描述符</h3>
<p>从虚存的角度来看，页就是最小单位。</p>
<p>内核用struct page结构来表示系统中的每个物理页（也叫作页描述符）</p>
<h3 id="4-4-2-伙伴算法"><a class="header-anchor" href="#4-4-2-伙伴算法">¶</a>4.4.2 伙伴算法</h3>
<p>看不太懂</p>
<h3 id="4-4-3-物理页面的分配"><a class="header-anchor" href="#4-4-3-物理页面的分配">¶</a>4.4.3 物理页面的分配</h3>
<p>Linux使用伙伴算法有效地分配和回收物理页块</p>
<h3 id="4-4-4-物理页面的回收"><a class="header-anchor" href="#4-4-4-物理页面的回收">¶</a>4.4.4 物理页面的回收</h3>
<p>页回收的过程与页分配的过程相反，只要可能，它就把小页块合并成大的页块</p>
<h3 id="4-4-5-Slab分配机制"><a class="header-anchor" href="#4-4-5-Slab分配机制">¶</a>4.4.5 Slab分配机制</h3>
<p>伙伴算法来做页分配的话，每次一个页面起步；但如果需要更少的空间，就用Slab</p>
<h3 id="4-4-6-内核空间非连续内存区的分配"><a class="header-anchor" href="#4-4-6-内核空间非连续内存区的分配">¶</a>4.4.6 内核空间非连续内存区的分配</h3>
<p>非连续内存位于3GB-4GB之间，是内核空间</p>
<p>什么时候才会分配非连续的内存呢？</p>
<h3 id="4-4-7-物理内存分配举例"><a class="header-anchor" href="#4-4-7-物理内存分配举例">¶</a>4.4.7 物理内存分配举例</h3>
<ul>
<li>伙伴算法的_get_free_pages()能分配一个或多个连续的物理页面</li>
<li>kmalloc()可以为不足一个页面的需求分配内存</li>
<li>vmalloc()可以获得大块的内存区</li>
</ul>
<h2 id="4-5-交换机制"><a class="header-anchor" href="#4-5-交换机制">¶</a>4.5 交换机制</h2>
<p>当物理内存不足时，Linux内存管理子系统需要释放部分物理内存页面</p>
<h3 id="4-5-1-交换的基本原理"><a class="header-anchor" href="#4-5-1-交换的基本原理">¶</a>4.5.1 交换的基本原理</h3>
<p>页面交换是用时间换空间，要考虑以下三个因素：</p>
<ul>
<li>哪种页面被换出</li>
<li>如何在交换区中存放页面</li>
<li>如何选择被交换出的页面</li>
</ul>
<h4 id="1-哪种页面被换出"><a class="header-anchor" href="#1-哪种页面被换出">¶</a>1. 哪种页面被换出</h4>
<p>映射到用户空间的页面可以被换出，内核空间的不会被换出</p>
<h4 id="2-如何在交换区中存放页面"><a class="header-anchor" href="#2-如何在交换区中存放页面">¶</a>2. 如何在交换区中存放页面</h4>
<p>交换区也是被划分成页面大小的一块一块的，每一块叫一个页插槽；也就是说，一个物理页面插入一个插槽中。</p>
<p>存到交换区中时，要尽量把页面放在相邻的插槽中。</p>
<h4 id="3-如何选择被交换出的页面"><a class="header-anchor" href="#3-如何选择被交换出的页面">¶</a>3. 如何选择被交换出的页面</h4>
<p>有几种不同的策略可供讨论：</p>
<ul>
<li>需要时才交换：每当缺页异常发生时，就给它分配一个物理页面</li>
<li>系统空闲时才交换：（这是积极的交换策略）预先腾出一些页面，维持空闲区域，使得发生缺页的时候总有位置可用</li>
<li>换出但不立即释放：将释放推迟到必要时才进行</li>
<li>把页面换出推迟到不能再推迟为止：</li>
</ul>
<h3 id="4-5-2-页面交换守护进程kswapd"><a class="header-anchor" href="#4-5-2-页面交换守护进程kswapd">¶</a>4.5.2 页面交换守护进程kswapd</h3>
<p>为了避免在换页的时候临时去处理从而增加CPU的负担，所以提前用这个进程来定期将页面换出</p>
<h2 id="4-6-内存管理实例"><a class="header-anchor" href="#4-6-内存管理实例">¶</a>4.6 内存管理实例</h2>
<p>这一节中我们要做的：</p>
<p>将内核的一部分虚拟内存映射到用户空间</p>
<h3 id="4-6-1-相关背景知识"><a class="header-anchor" href="#4-6-1-相关背景知识">¶</a>4.6.1 相关背景知识</h3>
<p>在内核空间中，用kmalloc()分配连续物理空间，用vmalloc()分配非连续物理空间</p>
<p><strong>内核虚地址-PAGE_OFFSET=实际的物理地址</strong></p>
<h3 id="4-6-2-代码体系结构介绍"><a class="header-anchor" href="#4-6-2-代码体系结构介绍">¶</a>4.6.2 代码体系结构介绍</h3>
<p>虚拟字符设备驱动程序，可以将系统内核空间映射到用户空间，这其中包括了两步：</p>
<ol>
<li>找到内核空间的地址对应的物理地址</li>
<li>建立新的用户页表项</li>
</ol>
<p>经过以上两步，可以使得用户空间和内核空间映射到同一物理地址；物理地址作为中介的话，访问用户空间就等于访问了内核空间</p>
<p>【未完待续】</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/19/Chapter3-%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CrestinyCoco">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crestiny's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/19/Chapter3-%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">Chapter3 进程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-19 08:34:28" itemprop="dateCreated datePublished" datetime="2021-02-19T08:34:28+08:00">2021-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-24 08:41:24" itemprop="dateModified" datetime="2021-02-24T08:41:24+08:00">2021-02-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Courses/" itemprop="url" rel="index"><span itemprop="name">Courses</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Courses/%E3%80%8ALinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8-E2-%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《Linux操作系统原理与应用(E2)》</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="3-1-进程介绍"><a class="header-anchor" href="#3-1-进程介绍">¶</a>3.1 进程介绍</h2>
<p>​	操作系统的设计者抽象出了进程这样一个逻辑概念，使得并行更容易被理解和处理</p>
<h3 id="3-1-1-程序和进程"><a class="header-anchor" href="#3-1-1-程序和进程">¶</a>3.1.1 程序和进程</h3>
<h4 id="（1）程序和进程的区别"><a class="header-anchor" href="#（1）程序和进程的区别">¶</a>（1）程序和进程的区别</h4>
<ul>
<li>程序是一个普通的可执行文件，是机器代码指令和数据的集合</li>
<li>进程有点像运行中的程序，除了程序所包含的内容，有一些额外的数据（如寄存器的值等等）；它是动态的，随着程序指令执行而不断变化，某时刻进程的内容被称为进程映像</li>
</ul>
<h4 id="（2）进程的定义"><a class="header-anchor" href="#（2）进程的定义">¶</a>（2）进程的定义</h4>
<p>​	进程是由正文段+用户数据段+系统数据段组成的执行环境</p>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210219090126874.png" alt="image-20210219090126874" style="width:500px;height:280px">
<h3 id="3-1-2-进程的层次结构"><a class="header-anchor" href="#3-1-2-进程的层次结构">¶</a>3.1.2 进程的层次结构</h3>
<p><strong>一个进程不会平白无故地诞生，它总有自己的父母。</strong>（除了init进程）</p>
<p>一个进程只有一个父进程，但可以有多个子进程。Linux系统有进程树：</p>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210223102330119.png" alt="image-20210223102330119" style="height:280px;width:500px">
<h3 id="3-1-3-进程状态"><a class="header-anchor" href="#3-1-3-进程状态">¶</a>3.1.3 进程状态</h3>
<p>有三种基本的进程状态和四种它们之间的转换关系：</p>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210223103526357.png" alt="image-20210223103526357" style="width:600px;height:260px">
<h2 id="3-2-Linux系统中的进程控制块PCB"><a class="header-anchor" href="#3-2-Linux系统中的进程控制块PCB">¶</a>3.2 Linux系统中的进程控制块PCB</h2>
<p>在Linux系统实现中，PCB对应的数据结构是：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>{</span></span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>PCB是一个相当庞大的结构体，它的所有域可以这样分类：</p>
<p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210223113320811.png" alt="image-20210223113320811"></p>
<p><strong>系统是根据进程的PCB感知进程的存在的。所以说，PCB是进程存在和运行的唯一标志</strong></p>
<p>系统创建新进程时，为它建立了一个PCB；在进程运行过程中，会读写其中的信息（所以PCB应该常驻内存结构）；进程结束时系统会回收PCB</p>
<p>Linux系统中，进程和线程的实现采用了同样的方式</p>
<h3 id="3-2-1-进程状态"><a class="header-anchor" href="#3-2-1-进程状态">¶</a>3.2.1 进程状态</h3>
<p>这里貌似和操作系统课里面学的状态不太一样了……下图展示了Linux进程状态的转换及其所调用的内核函数：</p>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210223130856361.png" alt="image-20210223130856361" style="height:500px;width:750px">
<h3 id="3-2-2-进程标识符"><a class="header-anchor" href="#3-2-2-进程标识符">¶</a>3.2.2 进程标识符</h3>
<p>每个进程都有如下三种标识符：</p>
<ul>
<li>进程标识符PID：唯一的；被顺序编号，后一个进程的PID是一般是前一个进程PID+1</li>
<li>用户标识符UID和组标识符GID：用于安全控制</li>
</ul>
<h3 id="3-2-3-进程之间的亲属关系"><a class="header-anchor" href="#3-2-3-进程之间的亲属关系">¶</a>3.2.3 进程之间的亲属关系</h3>
<p>每个进程的PCB结构里面是有亲属信息的，大概有以下几种：</p>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210223134858644.png" alt="image-20210223134858644" style="height:300px;width:450px">
<h3 id="3-2-4-进程控制块的存放"><a class="header-anchor" href="#3-2-4-进程控制块的存放">¶</a>3.2.4 进程控制块的存放</h3>
<p>就是说PCB放在哪里的问题，有用的话回头看看</p>
<h3 id="3-2-5-当前进程"><a class="header-anchor" href="#3-2-5-当前进程">¶</a>3.2.5 当前进程</h3>
<h2 id="3-3-Linux系统中进程的组织方式"><a class="header-anchor" href="#3-3-Linux系统中进程的组织方式">¶</a>3.3 Linux系统中进程的组织方式</h2>
<p>如何用适当的方式把PCB组织起来呢？</p>
<h3 id="3-3-1-进程链表"><a class="header-anchor" href="#3-3-1-进程链表">¶</a>3.3.1 进程链表</h3>
<p>系统用一个双向循环链表把所有进程的PCB联系起来</p>
<h3 id="3-3-2-哈希表"><a class="header-anchor" href="#3-3-2-哈希表">¶</a>3.3.2 哈希表</h3>
<p>为了使得内核可以根据对应进程的PID导出对应的PCB，我们可以把PID哈希成表的索引。关于冲突问题，可以这样解决：</p>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210223204147381.png" alt="image-20210223204147381" style="height:300px;width:600px;">
<h3 id="3-3-3-就绪队列"><a class="header-anchor" href="#3-3-3-就绪队列">¶</a>3.3.3 就绪队列</h3>
<p>就绪队列也是一个双向循环链表组织起来的哦</p>
<h3 id="3-3-4-等待队列"><a class="header-anchor" href="#3-3-4-等待队列">¶</a>3.3.4 等待队列</h3>
<p>等待也叫睡眠，Linux有两种睡眠：深度和浅度</p>
<h4 id="1-等待队列的数据结构"><a class="header-anchor" href="#1-等待队列的数据结构">¶</a>1. 等待队列的数据结构</h4>
<h4 id="2-等待队列头"><a class="header-anchor" href="#2-等待队列头">¶</a>2. 等待队列头</h4>
<h4 id="3-等待队列的操作"><a class="header-anchor" href="#3-等待队列的操作">¶</a>3. 等待队列的操作</h4>
<h2 id="3-4-进程调度"><a class="header-anchor" href="#3-4-进程调度">¶</a>3.4 进程调度</h2>
<h3 id="3-4-1-基本原理"><a class="header-anchor" href="#3-4-1-基本原理">¶</a>3.4.1 基本原理</h3>
<p>一个好的调度策略主要考虑以下几个方面：</p>
<ul>
<li>公平</li>
<li>高效</li>
<li>响应时间</li>
<li>周转时间</li>
<li>吞吐量</li>
</ul>
<p>了解一下以下调度算法</p>
<h4 id="1-时间片轮转调度算法"><a class="header-anchor" href="#1-时间片轮转调度算法">¶</a>1. 时间片轮转调度算法</h4>
<h4 id="2-优先权调度算法"><a class="header-anchor" href="#2-优先权调度算法">¶</a>2. 优先权调度算法</h4>
<ul>
<li>抢占式</li>
<li>非抢占式</li>
</ul>
<h4 id="3-多级反馈队列调度"><a class="header-anchor" href="#3-多级反馈队列调度">¶</a>3. 多级反馈队列调度</h4>
<p>综合了时间片轮转与抢占式优先权：优先权高的进程先运行给定的时间片，相同优先权的进程轮流运行给定的时间片</p>
<h4 id="4-实时调度"><a class="header-anchor" href="#4-实时调度">¶</a>4. 实时调度</h4>
<p>这是实时系统中的调度，对外部事件有求必应、尽快响应，一般是抢占式</p>
<h3 id="3-4-2-时间片"><a class="header-anchor" href="#3-4-2-时间片">¶</a>3.4.2 时间片</h3>
<p>时间片表明进程在被抢占前所能持续运行的时间</p>
<h3 id="3-4-3-Linux进程调度时机"><a class="header-anchor" href="#3-4-3-Linux进程调度时机">¶</a>3.4.3 Linux进程调度时机</h3>
<p>在以下几种情况中需要调度：</p>
<ul>
<li>进程状态转换：进程终止、进程睡眠</li>
<li>进程时间片用完</li>
<li>设备驱动程序运行时</li>
<li>从内核态返回用户态时（？？？）</li>
</ul>
<h3 id="3-4-4-进程调度的依据"><a class="header-anchor" href="#3-4-4-进程调度的依据">¶</a>3.4.4 进程调度的依据</h3>
<p>也就是，从就绪态进程中选择一个来运行的依据。</p>
<p>进程的PCB中有一些域可以帮助选择</p>
<h3 id="3-4-5-调度函数shedule-的实现"><a class="header-anchor" href="#3-4-5-调度函数shedule-的实现">¶</a>3.4.5 调度函数shedule()的实现</h3>
<p>**调度程序在内核中就是一个函数。**书上贴了源代码和部分注释，可以看一下。</p>
<h3 id="3-4-6-Linux-2-6调度程序的改进"><a class="header-anchor" href="#3-4-6-Linux-2-6调度程序的改进">¶</a>3.4.6 Linux 2.6调度程序的改进</h3>
<p>**单就绪队列是影响调度性能的主要问题之一。**所以改进就绪队列就成了改进调度算法的入口点</p>
<h2 id="3-5-进程的创建"><a class="header-anchor" href="#3-5-进程的创建">¶</a>3.5 进程的创建</h2>
<p>Linux通过两个函数的结合使用来实现进程创建</p>
<ul>
<li>创建用fork()：通过拷贝当前进程创建一个子进程</li>
<li>执行进程用exec()：负责读取可执行文件并将其载入进程的地址空间开始运行</li>
</ul>
<h3 id="3-5-1-创建进程"><a class="header-anchor" href="#3-5-1-创建进程">¶</a>3.5.1 创建进程</h3>
<p>新进程是通过克隆父进程来创建的。子进程创建结束，<strong>从内核态返回用户态</strong>，用户态进程来安排子进程和父进程执行不同的代码</p>
<h3 id="3-5-2-线程及其创建"><a class="header-anchor" href="#3-5-2-线程及其创建">¶</a>3.5.2 线程及其创建</h3>
<p>Linux把所有的线程当做进程来实现。但内核线程和普通进程还是有一定区别的</p>
<h2 id="3-6-与进程相关的系统调用及其应用"><a class="header-anchor" href="#3-6-与进程相关的系统调用及其应用">¶</a>3.6 与进程相关的系统调用及其应用</h2>
<p>fork、exec、wait、exit</p>
<p>这一节末尾有一个很好的比喻</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/16/Linux-shell%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CrestinyCoco">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crestiny's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/16/Linux-shell%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Linux shell程序设计学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-16 17:36:13" itemprop="dateCreated datePublished" datetime="2021-01-16T17:36:13+08:00">2021-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-10 22:11:17" itemprop="dateModified" datetime="2021-03-10T22:11:17+08:00">2021-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Courses/" itemprop="url" rel="index"><span itemprop="name">Courses</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-shell简介"><a class="header-anchor" href="#1-shell简介">¶</a>1. shell简介</h2>
<h3 id="1-1-shell环境"><a class="header-anchor" href="#1-1-shell环境">¶</a>1.1 shell环境</h3>
<p>Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p>
<p>Linux 的 Shell 种类众多，常见的有：</p>
<ul>
<li>Bourne Shell（/usr/bin/sh或/bin/sh）</li>
<li>Bourne Again Shell（/bin/bash）</li>
<li>C Shell（/usr/bin/csh）</li>
<li>K Shell（/usr/bin/ksh）</li>
<li>Shell for Root（/sbin/sh）</li>
</ul>
<p>本教程关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。</p>
<p>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。</p>
<p><code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。要写在shell脚本的开头，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo "Hello World !"</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-2-如何运行shell脚本"><a class="header-anchor" href="#1-2-如何运行shell脚本">¶</a>1.2 如何运行shell脚本</h3>
<h4 id="（1）作为可执行程序"><a class="header-anchor" href="#（1）作为可执行程序">¶</a>（1）作为可执行程序</h4>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class="line">./test.sh  #执行脚本</span><br></pre></td></tr></tbody></table></figure>
<p>注意，一定要写成 ./test.sh，而不是 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>，运行其它二进制的程序也一样，直接写 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>，linux 系统会去 PATH 里寻找有没有叫 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a> 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a> 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p>
<h4 id="（2）作为解释器参数"><a class="header-anchor" href="#（2）作为解释器参数">¶</a>（2）作为解释器参数</h4>
<p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh test.sh</span><br><span class="line">/bin/php test.php</span><br></pre></td></tr></tbody></table></figure>
<p>这种方式运行的脚本，<strong>不需要在第一行指定解释器信息</strong>，写了也没用。</p>
<h2 id="2-shell变量"><a class="header-anchor" href="#2-shell变量">¶</a>2. shell变量</h2>
<h3 id="2-1-变量定义"><a class="header-anchor" href="#2-1-变量定义">¶</a>2.1 变量定义</h3>
<h4 id="（1）显式定义"><a class="header-anchor" href="#（1）显式定义">¶</a>（1）显式定义</h4>
<p>规则如下：</p>
<ul>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>
<li>定义变量时，变量名不加美元符号</li>
<li>变量名和等号之间不能有空格</li>
</ul>
<h4 id="（2）用语句定义"><a class="header-anchor" href="#（2）用语句定义">¶</a>（2）用语句定义</h4>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for file in `ls /etc`</span><br><span class="line">或</span><br><span class="line">for file in $(ls /etc)</span><br></pre></td></tr></tbody></table></figure>
<p>以上语句将 /etc 下目录的文件名循环出来</p>
<h3 id="2-2-使用变量"><a class="header-anchor" href="#2-2-使用变量">¶</a>2.2 使用变量</h3>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name="qinjx"</span><br><span class="line">echo $your_name</span><br><span class="line">echo ${your_name} //花括号是可选的，为了区分变量边界（有时候很必要）</span><br></pre></td></tr></tbody></table></figure>
<h4 id="只读变量"><a class="header-anchor" href="#只读变量">¶</a>只读变量</h4>
<p>可以在定义之后写：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myUrl="https://www.google.com"</span><br><span class="line">readonly myUrl</span><br></pre></td></tr></tbody></table></figure>
<p>记上readonly就好啦</p>
<h3 id="2-3-删除变量"><a class="header-anchor" href="#2-3-删除变量">¶</a>2.3 删除变量</h3>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset variable_name</span><br></pre></td></tr></tbody></table></figure>
<p>注意：变量被删除后不能再次使用。unset 命令不能删除只读变量。</p>
<h3 id="2-4-变量类型"><a class="header-anchor" href="#2-4-变量类型">¶</a>2.4 变量类型</h3>
<ul>
<li>局部变量：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li>
<li>环境变量：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>
<li>shell变量：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>
</ul>
<h3 id="2-5-shell字符串"><a class="header-anchor" href="#2-5-shell字符串">¶</a>2.5 shell字符串</h3>
<p>好像shell中的变量基本就是两种类型：数字和字符串……字符串可以用单引号，也可以用双引号，<strong>也可以不用引号</strong>。</p>
<h4 id="（1）单引号"><a class="header-anchor" href="#（1）单引号">¶</a>（1）单引号</h4>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str='this is a string'</span><br></pre></td></tr></tbody></table></figure>
<p>单引号字符串的限制：</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号<strong>字符串中的变量是无效的</strong>；</li>
<li>单引号字串中<strong>不能出现单独一个的单引号</strong>（对单引号使用转义符后也不行），<strong>但可成对出现，作为字符串拼接使用</strong>。</li>
</ul>
<h4 id="（2）双引号"><a class="header-anchor" href="#（2）双引号">¶</a>（2）双引号</h4>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">your_name='runoob'</span><br><span class="line">str="Hello, I know you are \"$your_name\"! \n"</span><br><span class="line">echo -e $str	//-e的作用？</span><br><span class="line"></span><br><span class="line">//输出：Hello, I know you are "runoob"! </span><br></pre></td></tr></tbody></table></figure>
<p>双引号的优点：（这么好的话，那就一直用双引号好啦）</p>
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
<h4 id="（3）字符串拼接"><a class="header-anchor" href="#（3）字符串拼接">¶</a>（3）字符串拼接</h4>
<p>单引号、双引号都可以用于拼接</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">your_name="runoob"</span><br><span class="line"># 使用双引号拼接</span><br><span class="line">greeting="hello, "$your_name" !"</span><br><span class="line">greeting_1="hello, ${your_name} !"</span><br><span class="line">echo $greeting  $greeting_1	//输出： hello, runoob ! hello, runoob !</span><br><span class="line"></span><br><span class="line"># 使用单引号拼接</span><br><span class="line">greeting_2='hello, '$your_name' !'</span><br><span class="line">greeting_3='hello, ${your_name} !'</span><br><span class="line">echo $greeting_2  $greeting_3	//输出：hello, runoob ! hello, ${your_name} !</span><br></pre></td></tr></tbody></table></figure>
<h4 id="（4）获取字符串长度"><a class="header-anchor" href="#（4）获取字符串长度">¶</a>（4）获取字符串长度</h4>
<p>加上<code>#</code>号：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string="abcd"</span><br><span class="line">echo ${#string} #输出 4</span><br></pre></td></tr></tbody></table></figure>
<h4 id="（5）提取子字符串"><a class="header-anchor" href="#（5）提取子字符串">¶</a>（5）提取子字符串</h4>
<p>查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string="runoob is a great site"</span><br><span class="line">echo `expr index "$string" io`  # 输出 4</span><br><span class="line">//或者写成：echo $(expr index "$string" io)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>这个不是从0开始计数的哦~</strong></p>
<h3 id="2-6-shell数组"><a class="header-anchor" href="#2-6-shell数组">¶</a>2.6 shell数组</h3>
<p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。</p>
<p>类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。</p>
<h4 id="（1）定义"><a class="header-anchor" href="#（1）定义">¶</a>（1）定义</h4>
<p>一般形式是（用空格数组元素分开）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名=(值1 值2 ... 值n)</span><br></pre></td></tr></tbody></table></figure>
<p>实际使用中，可以有不同的变式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//常规的</span><br><span class="line">array_name=(value0 value1 value2 value3)</span><br><span class="line"></span><br><span class="line">//竖着写的</span><br><span class="line">array_name=(</span><br><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//一个个写的：可以不使用连续的下标，而且下标的范围没有限制。</span><br><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br></pre></td></tr></tbody></table></figure>
<h4 id="（2）读取数组"><a class="header-anchor" href="#（2）读取数组">¶</a>（2）读取数组</h4>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">${数组名[下标]}</span><br><span class="line"></span><br><span class="line">//读取第n个元素</span><br><span class="line">valuen=${array_name[n]}</span><br><span class="line"></span><br><span class="line">//读取所有元素：用@符号或者*符号</span><br><span class="line">echo ${array_name[@]}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="（3）获取数组的长度"><a class="header-anchor" href="#（3）获取数组的长度">¶</a>（3）获取数组的长度</h4>
<p>其实和获取字符串的长度很像啦：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 取得数组元素的个数</span><br><span class="line">length=${#array_name[@]}</span><br><span class="line"># 或者（是最常见的*代表all诶！）</span><br><span class="line">length=${#array_name[*]}</span><br><span class="line"># 取得数组单个元素的长度</span><br><span class="line">lengthn=${#array_name[n]}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-7-shell注释"><a class="header-anchor" href="#2-7-shell注释">¶</a>2.7 shell注释</h3>
<h4 id="（1）单行"><a class="header-anchor" href="#（1）单行">¶</a>（1）单行</h4>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># slogan：学的不仅是技术，更是梦想！</span><br><span class="line">#--------------------------------------------</span><br><span class="line">##### 用户配置区 开始 #####</span><br></pre></td></tr></tbody></table></figure>
<h4 id="（2）多行"><a class="header-anchor" href="#（2）多行">¶</a>（2）多行</h4>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#方法一</span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">#方法二</span><br><span class="line">:&lt;&lt;'</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">'</span><br><span class="line"></span><br><span class="line">#方法三</span><br><span class="line">:&lt;&lt;!</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">!</span><br></pre></td></tr></tbody></table></figure>
<h4 id="（3）注释代码（需要时不时取消注释的）"><a class="header-anchor" href="#（3）注释代码（需要时不时取消注释的）">¶</a>（3）注释代码（需要时不时取消注释的）</h4>
<p>可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。（好神奇的操作）</p>
<h2 id="3-shell传递参数"><a class="header-anchor" href="#3-shell传递参数">¶</a>3. shell传递参数</h2>
<p>shell的参数有一点命令行参数的味道，应该差不多是一种东西吧。它的引用就很简单粗暴，直接用数字作为序号就可以了。假如我们写了这个脚本：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo "Shell 传递参数实例！";</span><br><span class="line">echo "执行的文件名：$0";</span><br><span class="line">echo "第一个参数为：$1";</span><br><span class="line">echo "第二个参数为：$2";</span><br><span class="line">echo "第三个参数为：$3";</span><br></pre></td></tr></tbody></table></figure>
<p>然后执行它：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh 1 2 3</span><br><span class="line">Shell 传递参数实例！</span><br><span class="line">执行的文件名：./test.sh</span><br><span class="line">第一个参数为：1</span><br><span class="line">第二个参数为：2</span><br><span class="line">第三个参数为：3</span><br></pre></td></tr></tbody></table></figure>
<p>和参数相关的处理还有以下几种：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">参数处理	说明</span><br><span class="line">$#	传递到脚本的参数个数</span><br><span class="line">$*	以一个单字符串显示所有向脚本传递的参数。</span><br><span class="line">如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。</span><br><span class="line">$$	脚本运行的当前进程ID号</span><br><span class="line">$!	后台运行的最后一个进程的ID号</span><br><span class="line">$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。</span><br><span class="line">如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。</span><br><span class="line">$-	显示Shell使用的当前选项，与set命令功能相同。</span><br><span class="line">$?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</span><br></pre></td></tr></tbody></table></figure>
<table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$#</td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程ID号</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td>$@</td>
<td>与$*相同</td>
</tr>
<tr>
<td>$-</td>
<td>显示Shell使用的当前选项，与set命令功能相同</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误</td>
</tr>
</tbody>
</table>
<p>注：对<code>$*</code>和<code>$@</code>的进一步解释</p>
<ul>
<li>如"$*“用「”」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。</li>
<li>与$*相同，但是使用时加引号，并在引号中返回每个参数。如"$@“用「”」括起来的情况、以"$1" “$2” … “$n” 的形式输出所有参数。</li>
</ul>
<p>$* 与 $@ 区别：</p>
<ul>
<li>相同点：都是引用所有参数。</li>
<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo "-- \$* 演示 ---"</span><br><span class="line">for i in "$*"; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "-- \$@ 演示 ---"</span><br><span class="line">for i in "$@"; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh 1 2 3</span><br><span class="line">-- $* 演示 ---</span><br><span class="line">1 2 3</span><br><span class="line">-- $@ 演示 ---</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-shell基本运算符"><a class="header-anchor" href="#4-shell基本运算符">¶</a>4. shell基本运算符</h2>
<h3 id="4-1-算数运算符"><a class="header-anchor" href="#4-1-算数运算符">¶</a>4.1 算数运算符</h3>
<p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。expr 是一款表达式计算工具，使用它能完成表达式的求值操作。写一个你就懂啦：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">val=`expr 2 + 2`</span><br><span class="line">echo "两数之和为 : $val"</span><br></pre></td></tr></tbody></table></figure>
<p>注意：</p>
<ul>
<li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。（该有空格要有，不该有则不能有）</li>
<li>完整的表达式要被一对反引号包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li>
</ul>
<p>常用的算术运算符如下：<br>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116200128.png" alt=""></p>
<p>注意：</p>
<ul>
<li>乘号(*)前边必须加反斜杠()才能实现乘法运算；</li>
<li>if…then…fi 是条件语句，后续将会讲解。</li>
<li>在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 “*” 不需要转义符号 “” 。</li>
</ul>
<h3 id="4-2-关系运算符"><a class="header-anchor" href="#4-2-关系运算符">¶</a>4.2 关系运算符</h3>
<p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：<br>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116200344.png" alt=""></p>
<h3 id="4-3-布尔运算符"><a class="header-anchor" href="#4-3-布尔运算符">¶</a>4.3 布尔运算符</h3>
<p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：<br>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116200417.png" alt=""></p>
<h3 id="4-4-字符串运算符"><a class="header-anchor" href="#4-4-字符串运算符">¶</a>4.4 字符串运算符</h3>
<p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：<br>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116202630.png" alt=""></p>
<h3 id="4-5-文件测试运算符"><a class="header-anchor" href="#4-5-文件测试运算符">¶</a>4.5 文件测试运算符</h3>
<p>文件测试运算符用于检测 Unix 文件的各种属性。</p>
<p>属性检测描述如下：<br>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116202704.png" alt=""></p>
<h2 id="5-shell-echo命令"><a class="header-anchor" href="#5-shell-echo命令">¶</a>5. shell echo命令</h2>
<p>可以看做一个输出命令啦</p>
<h3 id="5-1-显示普通字符串"><a class="header-anchor" href="#5-1-显示普通字符串">¶</a>5.1 显示普通字符串</h3>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo "It is a test"</span><br><span class="line">或</span><br><span class="line">echo It is a test</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-2-显示转义字符"><a class="header-anchor" href="#5-2-显示转义字符">¶</a>5.2 显示转义字符</h3>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo "\"It is a test\""</span><br><span class="line">//输出："It is a test"</span><br></pre></td></tr></tbody></table></figure>
<p>同样地：双引号可以省略</p>
<h3 id="5-3-显示变量"><a class="header-anchor" href="#5-3-显示变量">¶</a>5.3 显示变量</h3>
<p>read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">read name </span><br><span class="line">echo "$name It is a test"</span><br></pre></td></tr></tbody></table></figure>
<p>以上代码保存为 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>，name 接收标准输入的变量，结果将是:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sh test.sh</span><br><span class="line">OK                     #标准输入</span><br><span class="line">OK It is a test        #输出</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-4-显示换行"><a class="header-anchor" href="#5-4-显示换行">¶</a>5.4 显示换行</h3>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo -e "OK! \n" # -e 开启转义（原来如此！）</span><br><span class="line">echo "It is a test"</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OK!</span><br><span class="line"></span><br><span class="line">It is a test</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-5-显示不换行"><a class="header-anchor" href="#5-5-显示不换行">¶</a>5.5 显示不换行</h3>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo -e "OK! \c" # -e 开启转义 \c 不换行</span><br><span class="line">echo "It is a test"</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OK! It is a test</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-6-显示结果定向至文件"><a class="header-anchor" href="#5-6-显示结果定向至文件">¶</a>5.6 显示结果定向至文件</h3>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "It is a test" &gt; myfile</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-7-原样输出字符串，不进行转义或取变量-用单引号"><a class="header-anchor" href="#5-7-原样输出字符串，不进行转义或取变量-用单引号">¶</a>5.7 原样输出字符串，不进行转义或取变量(用单引号)</h3>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo '$name\"'</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$name\"</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-8-显示命令执行结果"><a class="header-anchor" href="#5-8-显示命令执行结果">¶</a>5.8 显示命令执行结果</h3>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo `date`</span><br></pre></td></tr></tbody></table></figure>
<p>注意： 这里使用的是反引号, 而不是单引号。</p>
<p>结果将显示当前日期</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thu Jul 24 10:08:46 CST 2014</span><br></pre></td></tr></tbody></table></figure>
<h2 id="6-shell-printf命令"><a class="header-anchor" href="#6-shell-printf命令">¶</a>6. shell printf命令</h2>
<p>使用格式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf  format-string  [arguments...]</span><br></pre></td></tr></tbody></table></figure>
<p>其实和C语言的printf差不多：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line"># format-string为双引号</span><br><span class="line">printf "%d %s\n" 1 "abc"</span><br><span class="line"></span><br><span class="line"># 单引号与双引号效果一样</span><br><span class="line">printf '%d %s\n' 1 "abc"</span><br><span class="line"></span><br><span class="line"># 没有引号也可以输出</span><br><span class="line">printf %s abcdef</span><br><span class="line"></span><br><span class="line"># 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用</span><br><span class="line">printf %s abc def</span><br><span class="line"></span><br><span class="line">printf "%s\n" abc def</span><br><span class="line"></span><br><span class="line">printf "%s %s %s\n" a b c d e f g h i j</span><br><span class="line"></span><br><span class="line"># 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替</span><br><span class="line">printf "%s and %d \n"</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 abc</span><br><span class="line">1 abc</span><br><span class="line">abcdefabcdefabc</span><br><span class="line">def</span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">g h i</span><br><span class="line">j  </span><br><span class="line"> and 0</span><br></pre></td></tr></tbody></table></figure>
<p>printf中常用的转义序列：<br>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116210218.png" alt=""></p>
<h2 id="7-shell-test命令"><a class="header-anchor" href="#7-shell-test命令">¶</a>7. shell test命令</h2>
<p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p>
<h3 id="7-1-数值测试"><a class="header-anchor" href="#7-1-数值测试">¶</a>7.1 数值测试</h3>
<p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116210357.png" alt=""></p>
<p>实例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">if test $[num1] -eq $[num2]</span><br><span class="line">then</span><br><span class="line">    echo '两个数相等！'</span><br><span class="line">else</span><br><span class="line">    echo '两个数不相等！'</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">a=5</span><br><span class="line">b=6</span><br><span class="line"></span><br><span class="line">result=$[a+b] # 注意等号两边不能有空格</span><br><span class="line">echo "result 为： $result"</span><br></pre></td></tr></tbody></table></figure>
<p><strong>代码中的 [] 执行基本的算数运算</strong>，好神奇诶！</p>
<h3 id="7-2-字符串测试"><a class="header-anchor" href="#7-2-字符串测试">¶</a>7.2 字符串测试</h3>
<p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116210653.png" alt=""></p>
<p>实例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1="ru1noob"</span><br><span class="line">num2="runoob"</span><br><span class="line">if test $num1 = $num2</span><br><span class="line">then</span><br><span class="line">    echo '两个字符串相等!'</span><br><span class="line">else</span><br><span class="line">    echo '两个字符串不相等!'</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure>
<h3 id="7-3-文件测试"><a class="header-anchor" href="#7-3-文件测试">¶</a>7.3 文件测试</h3>
<p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116210740.png" alt=""></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /bin</span><br><span class="line">if test -e ./bash</span><br><span class="line">then</span><br><span class="line">    echo '文件已存在!'</span><br><span class="line">else</span><br><span class="line">    echo '文件不存在!'</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure>
<p>另外，Shell 还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为： ! 最高， -a 次之， -o 最低。例如：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /bin</span><br><span class="line">if test -e ./notFile -o -e ./bash</span><br><span class="line">then</span><br><span class="line">    echo '至少有一个文件存在!'</span><br><span class="line">else</span><br><span class="line">    echo '两个文件都不存在'</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure>
<h2 id="8-shell流程控制"><a class="header-anchor" href="#8-shell流程控制">¶</a>8. shell流程控制</h2>
<p>和 Java、PHP 等语言不一样，sh 的流程控制不可为空，如(以下为 PHP 流程控制写法)：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">// 不做任何事情</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 sh/bash 里可不能这么写，如果 else 分支没有语句执行，就不要写这个 else</p>
<h3 id="if-else"><a class="header-anchor" href="#if-else">¶</a>if/else</h3>
<h4 id="只有if的"><a class="header-anchor" href="#只有if的">¶</a>只有if的</h4>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure>
<p>写成一行（适用于终端命令提示符）：<strong>注意中间要加分号</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi</span><br></pre></td></tr></tbody></table></figure>
<h4 id="有if和else的"><a class="header-anchor" href="#有if和else的">¶</a>有if和else的</h4>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">else</span><br><span class="line">    command</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure>
<h4 id="嵌套的if和else"><a class="header-anchor" href="#嵌套的if和else">¶</a>嵌套的if和else</h4>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure>
<h3 id="for循环"><a class="header-anchor" href="#for循环">¶</a>for循环</h3>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>
<p>写成一行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN; do command1; command2… done;</span><br></pre></td></tr></tbody></table></figure>
<p>一个神奇的例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">for str in This is a string</span><br><span class="line">do</span><br><span class="line">    echo $str</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">//输出：</span><br><span class="line">//This</span><br><span class="line">//is</span><br><span class="line">//a</span><br><span class="line">//string</span><br></pre></td></tr></tbody></table></figure>
<h3 id="while语句"><a class="header-anchor" href="#while语句">¶</a>while语句</h3>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>
<p>一个神奇的例子：</p>
<p>以下是一个基本的 while 循环，测试条件是：如果 int 小于等于 5，那么条件返回真。int 从 1 开始，每次循环处理时，int 加 1。运行上述脚本，返回数字 1 到 5，然后终止。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int	//这个echo好像是输出完要换行的</span><br><span class="line">    let "int++"	//这个let的用法就很神奇</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>
<p>以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量</p>
<p>while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<ctrl-d>结束循环。</ctrl-d></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">echo '按下 &lt;CTRL-D&gt; 退出'</span><br><span class="line">echo -n '输入你最喜欢的网站名: '</span><br><span class="line">while read FILM</span><br><span class="line">do</span><br><span class="line">    echo "是的！$FILM 是一个好网站"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">//输出：</span><br><span class="line">//按下 &lt;CTRL-D&gt; 退出</span><br><span class="line">//输入你最喜欢的网站名:菜鸟教程</span><br><span class="line">//是的！菜鸟教程 是一个好网站</span><br></pre></td></tr></tbody></table></figure>
<h3 id="无限循环"><a class="header-anchor" href="#无限循环">¶</a>无限循环</h3>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>
<p>再或者：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (( ; ; ))</span><br></pre></td></tr></tbody></table></figure>
<h3 id="until循环"><a class="header-anchor" href="#until循环">¶</a>until循环</h3>
<p>until 循环执行一系列命令直至条件为 true 时停止。</p>
<p>until 循环与 while 循环在处理方式上刚好相反。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>
<h3 id="case-…-esac"><a class="header-anchor" href="#case-…-esac">¶</a>case … esac</h3>
<p>这是多选择，类似于switch……case……每个 case 分支用右圆括号开始，用两个分号 <strong>;;</strong> 表示 break，即执行结束，跳出整个 case … esac 语句，esac（就是 case 反过来）作为结束标记。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></tbody></table></figure>
<p>case 工作方式如上所示，取值后面必须为单词 <strong>in</strong>，每一模式必须以右括号结束。取值可以为变量或常数，匹配发现取值符合某一模式后，其间所有命令开始执行直至 <strong>;;</strong>。</p>
<p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值（相当于default），再执行后面的命令。</p>
<p>下面的脚本匹配字符串：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">site="runoob"</span><br><span class="line"></span><br><span class="line">case "$site" in</span><br><span class="line">   "runoob") echo "菜鸟教程"</span><br><span class="line">   ;;</span><br><span class="line">   "google") echo "Google 搜索"</span><br><span class="line">   ;;</span><br><span class="line">   "taobao") echo "淘宝网"</span><br><span class="line">   ;;</span><br><span class="line">   *) echo "无法识别"</span><br><span class="line">   ;;</span><br><span class="line">esac</span><br></pre></td></tr></tbody></table></figure>
<h3 id="跳出循环"><a class="header-anchor" href="#跳出循环">¶</a>跳出循环</h3>
<h4 id="break"><a class="header-anchor" href="#break">¶</a>break</h4>
<p>break命令允许跳出所有循环（终止执行后面的所有循环）。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n "输入 1 到 5 之间的数字:"</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo "你输入的数字为 $aNum!"</span><br><span class="line">        ;;</span><br><span class="line">        *) echo "你输入的数字不是 1 到 5 之间的! 游戏结束"</span><br><span class="line">            break</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>
<h4 id="continue"><a class="header-anchor" href="#continue">¶</a>continue</h4>
<p>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n "输入 1 到 5 之间的数字: "</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo "你输入的数字为 $aNum!"</span><br><span class="line">        ;;</span><br><span class="line">        *) echo "你输入的数字不是 1 到 5 之间的!"</span><br><span class="line">            continue</span><br><span class="line">            echo "游戏结束"</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>
<p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 <strong>echo “游戏结束”</strong> 永远不会被执行。</p>
<h2 id="9-shell函数"><a class="header-anchor" href="#9-shell函数">¶</a>9. shell函数</h2>
<p>linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p>
<p>shell中函数的定义格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ function ] funname [()]</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [return int;]	//参数返回，可以显式加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255）</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">demoFun(){</span><br><span class="line">    echo "这是我的第一个 shell 函数!"</span><br><span class="line">}</span><br><span class="line">echo "-----函数开始执行-----"</span><br><span class="line">demoFun</span><br><span class="line">echo "-----函数执行完毕-----"</span><br></pre></td></tr></tbody></table></figure>
<p>例子2：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">funWithReturn(){</span><br><span class="line">    echo "这个函数会对输入的两个数字进行相加运算..."</span><br><span class="line">    echo "输入第一个数字: "</span><br><span class="line">    read aNum</span><br><span class="line">    echo "输入第二个数字: "</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo "两个数字分别为 $aNum 和 $anotherNum !"</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">}</span><br><span class="line">funWithReturn</span><br><span class="line">echo "输入的两个数字之和为 $? !"	//注意这个$?</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这个函数会对输入的两个数字进行相加运算...</span><br><span class="line">输入第一个数字: </span><br><span class="line">1</span><br><span class="line">输入第二个数字: </span><br><span class="line">2</span><br><span class="line">两个数字分别为 1 和 2 !</span><br><span class="line">输入的两个数字之和为 3 !</span><br></pre></td></tr></tbody></table></figure>
<p><strong>函数返回值在调用该函数后通过 $? 来获得。</strong></p>
<p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。<strong>调用函数仅使用其函数名即可。</strong>（不像别的语言，要带括号什么的）</p>
<h3 id="函数参数"><a class="header-anchor" href="#函数参数">¶</a>函数参数</h3>
<p>在Shell中，调用函数时可以向其传递参数（很神奇的是，定义的时候可以不用在括号里面写？）。在函数体内部，通过 $n 的形式来获取参数的值，例如，​$1表示第一个参数，$2表示第二个参数…</p>
<p><strong>注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">funWithParam(){</span><br><span class="line">    echo "第一个参数为 $1 !"</span><br><span class="line">    echo "第二个参数为 $2 !"</span><br><span class="line">    echo "第十个参数为 $10 !"</span><br><span class="line">    echo "第十个参数为 ${10} !"</span><br><span class="line">    echo "第十一个参数为 ${11} !"</span><br><span class="line">    echo "参数总数有 $# 个!"</span><br><span class="line">    echo "作为一个字符串输出所有参数 $* !"</span><br><span class="line">}</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一个参数为 1 !</span><br><span class="line">第二个参数为 2 !</span><br><span class="line">第十个参数为 10 !</span><br><span class="line">第十个参数为 34 !</span><br><span class="line">第十一个参数为 73 !</span><br><span class="line">参数总数有 11 个!</span><br><span class="line">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</span><br></pre></td></tr></tbody></table></figure>
<p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数处理</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$#</td>
<td style="text-align:left">传递到脚本或函数的参数个数</td>
</tr>
<tr>
<td style="text-align:left">$*</td>
<td style="text-align:left">以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td style="text-align:left">$$</td>
<td style="text-align:left">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td style="text-align:left">$!</td>
<td style="text-align:left">后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td style="text-align:left">$@</td>
<td style="text-align:left">与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td style="text-align:left">$-</td>
<td style="text-align:left">显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td style="text-align:left">$?</td>
<td style="text-align:left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody>
</table>
<h2 id="10-shell-输入-输出重定向"><a class="header-anchor" href="#10-shell-输入-输出重定向">¶</a>10. shell 输入/输出重定向</h2>
<p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，<strong>这恰好是你的终端</strong>。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">command &gt; file</td>
<td style="text-align:left">将输出重定向到 file。（替代）</td>
</tr>
<tr>
<td style="text-align:left">command &lt; file</td>
<td style="text-align:left">将输入重定向到 file。</td>
</tr>
<tr>
<td style="text-align:left">command &gt;&gt; file</td>
<td style="text-align:left">将输出以<strong>追加</strong>的方式重定向到 file。</td>
</tr>
<tr>
<td style="text-align:left">n &gt; file</td>
<td style="text-align:left">将文件描述符为 n 的文件重定向到 file。</td>
</tr>
<tr>
<td style="text-align:left">n &gt;&gt; file</td>
<td style="text-align:left">将文件描述符为 n 的文件以追加的方式重定向到 file。</td>
</tr>
<tr>
<td style="text-align:left">n &gt;&amp; m</td>
<td style="text-align:left">将输出文件 m 和 n 合并。</td>
</tr>
<tr>
<td style="text-align:left">n &lt;&amp; m</td>
<td style="text-align:left">将输入文件 m 和 n 合并。</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt; tag</td>
<td style="text-align:left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>
</tr>
</tbody>
</table>
<p><em>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</em></p>
<h3 id="输入重定向"><a class="header-anchor" href="#输入重定向">¶</a>输入重定向</h3>
<p>输出重定向会覆盖文件内容，请看下面的例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo "菜鸟教程：www.runoob.com" &gt; users</span><br><span class="line">$ cat users</span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">$</span><br></pre></td></tr></tbody></table></figure>
<p>如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo "菜鸟教程：www.runoob.com" &gt;&gt; users</span><br><span class="line">$ cat users</span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">$</span><br></pre></td></tr></tbody></table></figure>
<h3 id="输出重定向"><a class="header-anchor" href="#输出重定向">¶</a>输出重定向</h3>
<p>同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &lt; infile &gt; outfile</span><br></pre></td></tr></tbody></table></figure>
<h3 id="重定向深入讲解"><a class="header-anchor" href="#重定向深入讲解">¶</a>重定向深入讲解</h3>
<p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>
<ul>
<li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li>
<li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li>
<li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li>
</ul>
<p><strong>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</strong>（也就是省略了数字的样子）</p>
<p>如果希望 stderr 重定向到 file，可以这样写：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ command 2&gt;file</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/13/Chapter9-%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CrestinyCoco">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crestiny's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/13/Chapter9-%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Chapter9 软件漏洞挖掘与分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-13 18:16:05" itemprop="dateCreated datePublished" datetime="2021-01-13T18:16:05+08:00">2021-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-14 00:15:05" itemprop="dateModified" datetime="2021-01-14T00:15:05+08:00">2021-01-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《软件安全分析与应用》</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B/Courses/" itemprop="url" rel="index"><span itemprop="name">Courses</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="9-1-软件漏洞基础知识"><a class="header-anchor" href="#9-1-软件漏洞基础知识">¶</a>9.1 软件漏洞基础知识</h2>
<h3 id="9-1-1-概述"><a class="header-anchor" href="#9-1-1-概述">¶</a>9.1.1 概述</h3>
<h4 id="（1）漏洞标准"><a class="header-anchor" href="#（1）漏洞标准">¶</a>（1）漏洞标准</h4>
<p>CVE等</p>
<h4 id="（2）漏洞分类"><a class="header-anchor" href="#（2）漏洞分类">¶</a>（2）漏洞分类</h4>
<p>有不同的分类角度</p>
<h4 id="（3）软件漏洞的利用方法"><a class="header-anchor" href="#（3）软件漏洞的利用方法">¶</a>（3）软件漏洞的利用方法</h4>
<h4 id="（4）软件漏洞的危害"><a class="header-anchor" href="#（4）软件漏洞的危害">¶</a>（4）软件漏洞的危害</h4>
<h3 id="9-1-2-软件漏洞典型类型"><a class="header-anchor" href="#9-1-2-软件漏洞典型类型">¶</a>9.1.2 软件漏洞典型类型</h3>
<p>主要介绍控制流劫持类漏洞</p>
<h4 id="（1）栈溢出漏洞"><a class="header-anchor" href="#（1）栈溢出漏洞">¶</a>（1）栈溢出漏洞</h4>
<h4 id="（2）堆溢出"><a class="header-anchor" href="#（2）堆溢出">¶</a>（2）堆溢出</h4>
<p>有两种</p>
<ul>
<li>覆盖后续堆管理结构：把前向后向指针的内容改掉，利用时关注os的堆分配与释放<br>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210113191104.png" alt=""></li>
<li>覆盖后续堆的数据：关注被覆盖的堆中是否有虚函数指针<br>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210113191506.png" alt=""></li>
</ul>
<h4 id="（3）释放后重用漏洞UAF"><a class="header-anchor" href="#（3）释放后重用漏洞UAF">¶</a>（3）释放后重用漏洞UAF</h4>
<p>释放后立刻申请，可能申请到同一块；例如B被释放后，攻击者为C申请内存，A就访问了攻击者希望它去往的恶意代码</p>
<p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210113192112.png" alt=""></p>
<h4 id="（4）整数溢出漏洞"><a class="header-anchor" href="#（4）整数溢出漏洞">¶</a>（4）整数溢出漏洞</h4>
<p>目标也是覆盖堆栈内容，分为宽度溢出和算术溢出</p>
<h4 id="（5）其他类型漏洞"><a class="header-anchor" href="#（5）其他类型漏洞">¶</a>（5）其他类型漏洞</h4>
<ul>
<li>SQL注入</li>
<li>XSS：另外再了解一下（？）</li>
</ul>
<h3 id="9-1-3-软件漏洞利用基础知识"><a class="header-anchor" href="#9-1-3-软件漏洞利用基础知识">¶</a>9.1.3 软件漏洞利用基础知识</h3>
<p>漏洞利用的生成可以分为3类：</p>
<ul>
<li>用调试工具分析以后写</li>
<li>用MetaSploit生成可利用的攻击代码</li>
<li>自动化工具自动生成</li>
</ul>
<p>控制流劫持类漏洞的利用=修改程序流程+绕过操作系统防护机制的各种方法</p>
<p>对于后者：</p>
<h4 id="（1）内存喷射技术"><a class="header-anchor" href="#（1）内存喷射技术">¶</a>（1）内存喷射技术</h4>
<p>核心思想是，在内存中申请很多固定大小的对象，填入相同的内容（攻击代码+NOP指令），这样控制流被劫持以后，攻击者设计跳转的地址只要落在一定范围内就可以成功了（也就是允许一些误差）</p>
<h4 id="（2）ROP攻击技术"><a class="header-anchor" href="#（2）ROP攻击技术">¶</a>（2）ROP攻击技术</h4>
<p>似懂非懂（？）</p>
<h4 id="（3）基于内存地址信息泄露构造利用"><a class="header-anchor" href="#（3）基于内存地址信息泄露构造利用">¶</a>（3）基于内存地址信息泄露构造利用</h4>
<p>从开头说起，自从有了地址随机化技术以后，攻击者有以下两种方法来对抗：</p>
<ul>
<li>找未随机化的模块进行攻击</li>
<li>利用程序运行时泄露的内存地址信息来攻击，注意：地址随机化并不改变相对位置</li>
</ul>
<h3 id="9-1-4-软件漏洞防护机制基础知识"><a class="header-anchor" href="#9-1-4-软件漏洞防护机制基础知识">¶</a>9.1.4 软件漏洞防护机制基础知识</h3>
<h4 id="（1）Stack-Cookie——防栈溢出"><a class="header-anchor" href="#（1）Stack-Cookie——防栈溢出">¶</a>（1）Stack Cookie——防栈溢出</h4>
<p>通过检查cookie值是否变化来判断是否受到攻击</p>
<h4 id="（2）DEP——防控制流劫持攻击（缓冲区溢出）"><a class="header-anchor" href="#（2）DEP——防控制流劫持攻击（缓冲区溢出）">¶</a>（2）DEP——防控制流劫持攻击（缓冲区溢出）</h4>
<p>Windows利用DEP，把只含数据的内存位置标记为非可执行状态</p>
<h4 id="（3）ASLR——防缓冲区溢出"><a class="header-anchor" href="#（3）ASLR——防缓冲区溢出">¶</a>（3）ASLR——防缓冲区溢出</h4>
<p>可以对四类地址进行随机化</p>
<ul>
<li>PE文件加载地址</li>
<li>堆栈随机化</li>
<li>PEB、TEB随机化</li>
</ul>
<h2 id="9-2-软件漏洞机理分析"><a class="header-anchor" href="#9-2-软件漏洞机理分析">¶</a>9.2 软件漏洞机理分析</h2>
<h3 id="9-2-1-软件漏洞脆弱点分析"><a class="header-anchor" href="#9-2-1-软件漏洞脆弱点分析">¶</a>9.2.1 软件漏洞脆弱点分析</h3>
<h4 id="（1）栈溢出的脆弱点和控制流劫持点"><a class="header-anchor" href="#（1）栈溢出的脆弱点和控制流劫持点">¶</a>（1）栈溢出的脆弱点和控制流劫持点</h4>
<h4 id="（2）堆溢出的脆弱点和控制流劫持点"><a class="header-anchor" href="#（2）堆溢出的脆弱点和控制流劫持点">¶</a>（2）堆溢出的脆弱点和控制流劫持点</h4>
<h4 id="（3）整数溢出的……"><a class="header-anchor" href="#（3）整数溢出的……">¶</a>（3）整数溢出的……</h4>
<h3 id="9-2-2-软件漏洞路径分析"><a class="header-anchor" href="#9-2-2-软件漏洞路径分析">¶</a>9.2.2 软件漏洞路径分析</h3>
<p>软件漏洞路径分析的目的是找出（程序入口——&gt;脆弱点）的路径</p>
<p>之前的污点传播可以用过来，将用户输入作为污点，跟踪此数据在漏洞程序中的处理过程</p>
<h4 id="（1）基于污点传播的路径指令序列提取"><a class="header-anchor" href="#（1）基于污点传播的路径指令序列提取">¶</a>（1）基于污点传播的路径指令序列提取</h4>
<h4 id="（2）基于符号执行的路径条件提取"><a class="header-anchor" href="#（2）基于符号执行的路径条件提取">¶</a>（2）基于符号执行的路径条件提取</h4>
<p>路径条件提取关键：确定使控制流转移到脆弱路径的<strong>关键节点</strong>，以及分析这些节点相互之间的<strong>数据依赖</strong>和<strong>控制依赖</strong>关系</p>
<h4 id="（3）软件漏洞分析中的特殊情况"><a class="header-anchor" href="#（3）软件漏洞分析中的特殊情况">¶</a>（3）软件漏洞分析中的特殊情况</h4>
<h3 id="9-2-3-软件漏洞内存布局分析"><a class="header-anchor" href="#9-2-3-软件漏洞内存布局分析">¶</a>9.2.3 软件漏洞内存布局分析</h3>
<p>目标：当脆弱点被触发时：</p>
<ul>
<li>确定<strong>程序读入数据</strong>在内存中的布局情况</li>
<li>分析<strong>漏洞利用所需</strong>的关键数据所在位置</li>
</ul>
<h3 id="9-2-4-软件漏洞分析实例"><a class="header-anchor" href="#9-2-4-软件漏洞分析实例">¶</a>9.2.4 软件漏洞分析实例</h3>
<h2 id="9-3-软件漏洞利用"><a class="header-anchor" href="#9-3-软件漏洞利用">¶</a>9.3 软件漏洞利用</h2>
<p>怎么写出攻击代码？关注3个要素：</p>
<ul>
<li>输入数据：触发脆弱点+含有攻击代码</li>
<li>攻击链：将控制流转移至攻击代码</li>
<li>绕过保护机制</li>
</ul>
<h3 id="9-3-1-漏洞攻击链构造"><a class="header-anchor" href="#9-3-1-漏洞攻击链构造">¶</a>9.3.1 漏洞攻击链构造</h3>
<p>构造攻击链有两个关键步骤：</p>
<ol>
<li>确定内存中可以用于存放控制流转移代码的区域</li>
<li>设计控制流转移关系</li>
</ol>
<p>后者，为了使得跳转成功率变高，我们可以采用：</p>
<ul>
<li>内存喷射</li>
<li>用跳转指令：常用的有……</li>
</ul>
<p>区别与联系：<br>
<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210113215052.png" alt=""></p>
<h3 id="9-3-2-漏洞攻击路径触发"><a class="header-anchor" href="#9-3-2-漏洞攻击路径触发">¶</a>9.3.2 漏洞攻击路径触发</h3>
<p>目标：构造输入数据，使程序能运行到劫持点</p>
<p>如何构造呢？</p>
<ul>
<li>提取程序执行路径中的条件分支</li>
<li>根据分支写出表达式</li>
<li>对表达式求解，得出数据的取值范围</li>
</ul>
<h3 id="9-3-3-保护机制绕过"><a class="header-anchor" href="#9-3-3-保护机制绕过">¶</a>9.3.3 保护机制绕过</h3>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CrestinyCoco</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">100</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CrestinyCoco</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

  

    </div>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/miku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
