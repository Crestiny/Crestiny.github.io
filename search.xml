<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Chapter12 防火墙</title>
      <link href="2021/01/03/Chapter12-%E9%98%B2%E7%81%AB%E5%A2%99/"/>
      <url>2021/01/03/Chapter12-%E9%98%B2%E7%81%AB%E5%A2%99/</url>
      
        <content type="html"><![CDATA[<h2 id="12-1-防火墙的必要性"><a class="header-anchor" href="#12-1-防火墙的必要性">¶</a>12.1 防火墙的必要性</h2><h2 id="12-2-防火墙特征"><a class="header-anchor" href="#12-2-防火墙特征">¶</a>12.2 防火墙特征</h2><h2 id="12-3-防火墙类型"><a class="header-anchor" href="#12-3-防火墙类型">¶</a>12.3 防火墙类型</h2><h2 id="12-4-防火墙载体"><a class="header-anchor" href="#12-4-防火墙载体">¶</a>12.4 防火墙载体</h2><h2 id="12-5-防火墙的位置和配置"><a class="header-anchor" href="#12-5-防火墙的位置和配置">¶</a>12.5 防火墙的位置和配置</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter11 入侵者</title>
      <link href="2021/01/03/Chapter11-%E5%85%A5%E4%BE%B5%E8%80%85/"/>
      <url>2021/01/03/Chapter11-%E5%85%A5%E4%BE%B5%E8%80%85/</url>
      
        <content type="html"><![CDATA[<h2 id="11-1-入侵者"><a class="header-anchor" href="#11-1-入侵者">¶</a>11.1 入侵者</h2><p>一般把入侵者分为3类：</p><ul><li>假冒用户</li><li>违法用户</li><li>隐秘用户</li></ul><p>入侵攻击有无恶意和恶意之分</p><p>入侵例证（一些行为迹象）：</p><h3 id="11-1-1-入侵者行为模式"><a class="header-anchor" href="#11-1-1-入侵者行为模式">¶</a>11.1.1 入侵者行为模式</h3><p>入侵者一般会遵循许多已知行为模式中的一种</p><h4 id="（1）黑客"><a class="header-anchor" href="#（1）黑客">¶</a>（1）黑客</h4><h4 id="（2）犯罪"><a class="header-anchor" href="#（2）犯罪">¶</a>（2）犯罪</h4><h4 id="（3）内部攻击"><a class="header-anchor" href="#（3）内部攻击">¶</a>（3）内部攻击</h4><h3 id="11-1-2-入侵技术"><a class="header-anchor" href="#11-1-2-入侵技术">¶</a>11.1.2 入侵技术</h3><h4 id="（1）口令保护技术"><a class="header-anchor" href="#（1）口令保护技术">¶</a>（1）口令保护技术</h4><h4 id="（2）获取口令"><a class="header-anchor" href="#（2）获取口令">¶</a>（2）获取口令</h4><h4 id="（3）缓冲区溢出提权"><a class="header-anchor" href="#（3）缓冲区溢出提权">¶</a>（3）缓冲区溢出提权</h4><h4 id="（4）检测和防护"><a class="header-anchor" href="#（4）检测和防护">¶</a>（4）检测和防护</h4><h2 id="11-2-入侵检测"><a class="header-anchor" href="#11-2-入侵检测">¶</a>11.2 入侵检测</h2><p>即是最好的入侵防护也可能失效，这时候就需要入侵检测</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE272.png" alt=""></p><p>入侵检测方法：</p><ul><li>统计异常检测：用统计学方法对用户行为进行测试<ul><li>阈值检测：各种事情出现频率的阈值（？）</li><li>基于行为曲线：为每个用户建立行为曲线，之后看变化</li></ul></li><li>基于规则的检测：定义一套能够判断行为是不是入侵行为的规则<ul><li>异常检测：检测当前行为与历史行为的偏离</li><li>渗透检测：家里一个可以用于搜索可疑行为的行为系统</li></ul></li></ul><p>两种检测方法的区别：</p><table><thead><tr><th>统计异常检测</th><th>基于规则的检测</th></tr></thead><tbody><tr><td>定义普通/期望的用户行为</td><td>定义正确的行为</td></tr><tr><td>检测假冒用户的有效手段</td><td>检测违规用户的有效手段</td></tr></tbody></table><p>实践中，要把这两种结合起来</p><h3 id="11-2-1-审计记录"><a class="header-anchor" href="#11-2-1-审计记录">¶</a>11.2.1 审计记录</h3><p>审计记录是入侵检测的一个基本工具</p><p>审计记录有以下两种分类：</p><ul><li>原始审计记录：操作系统直接自带的</li><li>面向检测的审计记录：另外有软件再将原始审计记录处理了一下，可以包括如下域：<ul><li>见书</li></ul></li></ul><p>用户操作可以分解为一系列基本行为，这样有以下三个好处：</p><ul><li>见书</li></ul><h3 id="11-2-2-统计异常检测"><a class="header-anchor" href="#11-2-2-统计异常检测">¶</a>11.2.2 统计异常检测</h3><h3 id="11-2-3-基于规则的入侵检测"><a class="header-anchor" href="#11-2-3-基于规则的入侵检测">¶</a>11.2.3 基于规则的入侵检测</h3><h3 id="11-2-4-基率谬误"><a class="header-anchor" href="#11-2-4-基率谬误">¶</a>11.2.4 基率谬误</h3><p>很难同时满足高检测率和低误报率</p><h3 id="11-2-5-分布式入侵检测"><a class="header-anchor" href="#11-2-5-分布式入侵检测">¶</a>11.2.5 分布式入侵检测</h3><p>是指对由互联网/LAN连接起来的分布式主机进行安全防护</p><p>设计分布式入侵检测系统的主要问题：</p><ul><li>见书</li></ul><p>一套很好的分布式入侵检测系统：</p><p>组成部分：</p><ul><li>见书</li></ul><h3 id="11-2-6-蜜罐"><a class="header-anchor" href="#11-2-6-蜜罐">¶</a>11.2.6 蜜罐</h3><p>顾名思义，蜜罐是一个诱骗系统，用于把攻击者从重要系统引开</p><p>蜜罐设计目的：</p><ul><li>见书</li></ul><p>蜜罐的设计，使得任何访问蜜罐的行为都非常有可能是攻击者</p><p>最开始蜜罐是一个单一主机，后来可以做一个蜜罐网络</p><p>蜜罐的部署位置：</p><ul><li>见书</li></ul><h3 id="11-2-7-入侵检测交换格式"><a class="header-anchor" href="#11-2-7-入侵检测交换格式">¶</a>11.2.7 入侵检测交换格式</h3><p>指定交换格式，是为了共享入侵检测信息</p><p>有一系列RFC：</p><ul><li>见书</li></ul><p>入侵检测交换方法：</p><ul><li>见书</li></ul><h2 id="11-3-口令管理"><a class="header-anchor" href="#11-3-口令管理">¶</a>11.3 口令管理</h2><p>口令系统是抵御入侵者的第一道防线，用于对登录到系统上的ID进行认证，ID通过一下方案保证安全性：</p><ul><li>确定用户是否被授权</li><li>确定用户访问权限</li><li>用于自主访问控制</li></ul><h3 id="11-3-1-口令的脆弱性"><a class="header-anchor" href="#11-3-1-口令的脆弱性">¶</a>11.3.1 口令的脆弱性</h3><p>一些攻击策略和对应的防护措施：</p><ul><li>见书</li></ul><h3 id="11-3-2-使用散列后的口令"><a class="header-anchor" href="#11-3-2-使用散列后的口令">¶</a>11.3.2 使用散列后的口令</h3><p>有一种使用散列后的口令加盐值的方法，可以实现安全</p><p>把用户的口令和加盐值作为散列函数的输入，口令文件中存储：散列值+明文加盐值</p><p>用户登录时，输入口令，系统把明文加盐值拿出来，处理以后比对，正确则过</p><p>salt的三个目的：</p><ul><li>见书</li></ul><h3 id="11-3-3-用户口令选择"><a class="header-anchor" href="#11-3-3-用户口令选择">¶</a>11.3.3 用户口令选择</h3><p>破译器的关键在于，倾向于猜测用户常用的口令</p><p>实验证明，这种攻击成功率很高；防御方法有：访问控制以限制用户对口令文件的读取，强迫用户使用强密码等等</p><h3 id="11-3-4-口令选择策略"><a class="header-anchor" href="#11-3-4-口令选择策略">¶</a>11.3.4 口令选择策略</h3><p>有一些方法，来实现使口令难以猜测且用户容易记住的目标</p><h3 id="11-3-5-Bloom滤波器"><a class="header-anchor" href="#11-3-5-Bloom滤波器">¶</a>11.3.5 Bloom滤波器</h3><p>一种先验口令检查技术，基于拒绝列表上的口令</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter10 恶意软件</title>
      <link href="2021/01/03/Chapter10-%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/"/>
      <url>2021/01/03/Chapter10-%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="10-10-分布式拒绝服务攻击"><a class="header-anchor" href="#10-10-分布式拒绝服务攻击">¶</a>10.10 分布式拒绝服务攻击</h2><h3 id="10-10-1-DDos攻击描述"><a class="header-anchor" href="#10-10-1-DDos攻击描述">¶</a>10.10.1 DDos攻击描述</h3><h4 id="（1）简单DDos攻击（消耗内部资源）"><a class="header-anchor" href="#（1）简单DDos攻击（消耗内部资源）">¶</a>（1）简单DDos攻击（消耗内部资源）</h4><ul><li>SYN突发流量攻击：也就是SYN Flooding</li></ul><p>SYN Flooding其实是以TCP状态数据结构为目标消耗内部资源的一个例子，我们还可以有其他例子：</p><ul><li>消耗进程相关数据结构</li><li>消耗磁盘空间<ul><li>产生过多的邮件信息</li><li>故意产生必须记录的错误</li><li>在匿名ftp空间或网络共享空间中放置文件</li></ul></li></ul><p>消耗数据传送资源，可以是ICMP攻击：</p><ul><li>ICMP攻击：攻击者发很多请求包，目标路由器会被响应应答封包淹没（？）</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210104100103.png" alt=""></p><h4 id="（2）基于突发流量式DDos攻击"><a class="header-anchor" href="#（2）基于突发流量式DDos攻击">¶</a>（2）基于突发流量式DDos攻击</h4><ul><li>直接DDos攻击</li><li>反射DDos攻击</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE273.png" alt=""></p><h3 id="10-10-2-构造攻击网络"><a class="header-anchor" href="#10-10-2-构造攻击网络">¶</a>10.10.2 构造攻击网络</h3><ul><li>首先要有能在大量机器上运行的DDos软件</li><li>目标要有大量系统漏洞</li><li>DDos软件有定位新机器的策略（扫描），扫描方法有多种</li></ul><h3 id="10-10-3-DDos防护措施"><a class="header-anchor" href="#10-10-3-DDos防护措施">¶</a>10.10.3 DDos防护措施</h3><p>书上写了3条，还可以有如算验证码之类的让Attacker慢下来的操作</p><h3 id="Smurf"><a class="header-anchor" href="#Smurf">¶</a>Smurf</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter2 内存寻址</title>
      <link href="2021/01/02/Chapter2-%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/"/>
      <url>2021/01/02/Chapter2-%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-内存寻址"><a class="header-anchor" href="#2-1-内存寻址">¶</a>2.1 内存寻址</h2><h3 id="2-1-1-Intel-x86-CPU寻址的演变"><a class="header-anchor" href="#2-1-1-Intel-x86-CPU寻址的演变">¶</a>2.1.1 Intel x86 CPU寻址的演变</h3><h3 id="2-1-2-80x86寄存器简介"><a class="header-anchor" href="#2-1-2-80x86寄存器简介">¶</a>2.1.2 80x86寄存器简介</h3><h4 id="（1）8个32位通用寄存器"><a class="header-anchor" href="#（1）8个32位通用寄存器">¶</a>（1）8个32位通用寄存器</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210102161511.png" alt=""></p><h4 id="（2）4个16位段寄存器"><a class="header-anchor" href="#（2）4个16位段寄存器">¶</a>（2）4个16位段寄存器</h4><ul><li>CS：代码段</li><li>DS：数据段</li><li>SS：堆栈段</li><li>ES：其他段</li></ul><p>放的都是基地址</p><h4 id="（3）指令指针寄存器和标志寄存器"><a class="header-anchor" href="#（3）指令指针寄存器和标志寄存器">¶</a>（3）指令指针寄存器和标志寄存器</h4><ul><li>EIP：下一条要执行的指令的offset（相对CS），低16位叫IP寄存器</li><li>EFLAGS：控制等</li></ul><h4 id="（4）控制寄存器"><a class="header-anchor" href="#（4）控制寄存器">¶</a>（4）控制寄存器</h4><p>CR系列，主要用于分页机制</p><h3 id="2-1-3-物理地址、虚拟地址、线性地址"><a class="header-anchor" href="#2-1-3-物理地址、虚拟地址、线性地址">¶</a>2.1.3 物理地址、虚拟地址、线性地址</h3><p>物理内存条提供的内存空间就是物理内存空间，每个内存单元的实际地址就是物理地址；而程序员看到的内存空间定义为虚拟地址空间，叫虚拟地址或者逻辑地址</p><p>内存管理单元MMU负责把虚拟地址映射为物理地址，线性地址是指一段连续不分段的地址空间（大小在0~4GB）</p><h2 id="2-2-段机制"><a class="header-anchor" href="#2-2-段机制">¶</a>2.2 段机制</h2><p><strong>段是虚拟地址空间的基本单位</strong></p><h3 id="2-2-1-段描述符"><a class="header-anchor" href="#2-2-1-段描述符">¶</a>2.2.1 段描述符</h3><p>是一个数据结构，包括：</p><ul><li>基地址</li><li>界限</li><li>保护属性</li></ul><p>可以用下图描述：</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《Linux操作系统原理与应用(E2)》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter8 电子邮件安全</title>
      <link href="2021/01/01/Chapter8-%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
      <url>2021/01/01/Chapter8-%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>由于电子邮件应用太广泛了，所以有了两种安全方案：PGP和S/MIME</p><h2 id="8-1-PGP"><a class="header-anchor" href="#8-1-PGP">¶</a>8.1 PGP</h2><p>PGP可以提供保密和认证</p><h3 id="8-1-1-符号约定"><a class="header-anchor" href="#8-1-1-符号约定">¶</a>8.1.1 符号约定</h3><h3 id="8-1-2-操作描述"><a class="header-anchor" href="#8-1-2-操作描述">¶</a>8.1.2 操作描述</h3><p>PGP的实操包括如下服务：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210101233530.png" alt=""></p><h4 id="（1）认证"><a class="header-anchor" href="#（1）认证">¶</a>（1）认证</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE130.png" alt=""></p><h4 id="（2）保密"><a class="header-anchor" href="#（2）保密">¶</a>（2）保密</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE131.png" alt=""></p><h4 id="（3）保密与认证"><a class="header-anchor" href="#（3）保密与认证">¶</a>（3）保密与认证</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE133.png" alt=""></p><h4 id="（4）压缩"><a class="header-anchor" href="#（4）压缩">¶</a>（4）压缩</h4><h4 id="（5）电子邮件兼容性"><a class="header-anchor" href="#（5）电子邮件兼容性">¶</a>（5）电子邮件兼容性</h4><p>总结一下PGP消息的的接收和发送流程如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210102000654.png" alt=""></p><h2 id="8-2-S-MIME"><a class="header-anchor" href="#8-2-S-MIME">¶</a>8.2 S/MIME</h2><p>S/MIME是对MIME的电子邮件格式做安全性增强</p><h3 id="8-2-1-RFC-5322"><a class="header-anchor" href="#8-2-1-RFC-5322">¶</a>8.2.1 RFC 5322</h3><p>RFC 5322定义了一种电子邮件传输的文本消息格式：报头+空行+正文</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue, 16 Jan 1998 10: 37:17(EST)</span><br><span class="line">From: "william stallings" ws@shore.netSubject: The Syntax in RFC 5322</span><br><span class="line">To: Smith@other-host.com</span><br><span class="line">cc: Jones@Yet-Another-Host.com</span><br><span class="line"></span><br><span class="line">Hello.This section begins the actual message body，which is delimited fromthe message heading by a blank line.</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="8-2-2-MIME"><a class="header-anchor" href="#8-2-2-MIME">¶</a>8.2.2 MIME</h3><p>学名叫：多用途网际邮件扩展，是对RFC 5322的扩展，用于解决这个格式存在的问题、协议存在的问题等……</p><p>MIME定义了：</p><ul><li>5种新报头域</li><li>多种内容格式</li><li>编码转换方式</li></ul><h4 id="（1）5种新报头域"><a class="header-anchor" href="#（1）5种新报头域">¶</a>（1）5种新报头域</h4><p>MIME版本MIME-Version：其参数值必须为1.0，表明该消息符合RFC 2045和2046。<br>内容类型Content-Type：详细描述正文中包含的数据，使得用户代理可以选择合适的代理或机制表示数据或正确处理数据。<br>内容传输编码Content-Transfer-Encoding：将消息正文转换为可传输类型的转换方式。<br>内容ID  Content-ID：在多个上下文中唯一标识MIME实体的标识。<br>内容描述 Content-Description：正文对象的文本描述，在该对象不可读（如音频数据）时使用。</p><h4 id="（2）多种内容格式"><a class="header-anchor" href="#（2）多种内容格式">¶</a>（2）多种内容格式</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210102105630.png" alt=""></p><h4 id="（3）编码转换方式"><a class="header-anchor" href="#（3）编码转换方式">¶</a>（3）编码转换方式</h4><p>提供可靠的传输</p><h3 id="8-2-3-S-MIME的功能"><a class="header-anchor" href="#8-2-3-S-MIME的功能">¶</a>8.2.3 S/MIME的功能</h3><p>可以理解成在MIME的基础上多加了一些类型</p><h4 id="（1）S-MIME的功能"><a class="header-anchor" href="#（1）S-MIME的功能">¶</a>（1）S/MIME的功能</h4><ul><li>封装数据：加密内容+接收方解密需要的密钥</li><li>签名数据：内容—&gt;H—&gt;私钥加密，签名加内容再整个Base-64（没有S/MIME能力的不能看到内容，不能验证签名）</li><li>透明签名数据：内容—&gt;H—&gt;私钥加密，只签名Base-64（没有S/MIME能力的能看到内容，不能验证签名）</li><li>签名并封装数据：签名+加密</li></ul><h4 id="（2）加密算法"><a class="header-anchor" href="#（2）加密算法">¶</a>（2）加密算法</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210102121624.png" alt=""></p><p>如何选择加密算法？<br>书上有一些判断规则之类的</p><h3 id="8-2-4-S-MIME消息"><a class="header-anchor" href="#8-2-4-S-MIME消息">¶</a>8.2.4 S/MIME消息</h3><h4 id="（1）保护MIME实体"><a class="header-anchor" href="#（1）保护MIME实体">¶</a>（1）保护MIME实体</h4><p>这里是要讲S/MIME准备消息的一般操作：</p><ul><li>首先我们用传统的MIME格式来生成MIME实体</li><li>然后把MIME实体和安全相关数据交给S/MIME处理</li><li>S/MIME的处理结果是PKCS对象（？）</li><li>在将PKCS对象封装为MIME消息</li></ul><p>S/MIME的内容类型如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210102123027.png" alt=""></p><p>下面逐一介绍这些类型：</p><h4 id="（2）封装数据"><a class="header-anchor" href="#（2）封装数据">¶</a>（2）封装数据</h4><p>准备封装数据MIME实体的步骤如下：</p><ul><li>对对称算法生成伪随机的会话密钥</li><li>用对方公钥加密会话密钥</li><li>准备信息块</li><li>用会话密钥加密消息</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE129.png" alt=""></p><h4 id="（3）签名数据"><a class="header-anchor" href="#（3）签名数据">¶</a>（3）签名数据</h4><p>MIME实体准备签名数据的步骤如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/22RRV%7B8Y50AF0NZSN@N94R5.png" alt=""></p><h4 id="（4）透明签名"><a class="header-anchor" href="#（4）透明签名">¶</a>（4）透明签名</h4><p>主要用在多部分的，消息与签名分离</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE128.png" alt=""></p><h4 id="（5）注册请求"><a class="header-anchor" href="#（5）注册请求">¶</a>（5）注册请求</h4><p>向CA申请公钥证书</p><h4 id="（6）仅证书消息"><a class="header-anchor" href="#（6）仅证书消息">¶</a>（6）仅证书消息</h4><p>在应答注册请求时发送，仅包含证书/CRL</p><h3 id="8-2-5-S-MIME证书处理过程"><a class="header-anchor" href="#8-2-5-S-MIME证书处理过程">¶</a>8.2.5 S/MIME证书处理过程</h3><p>S/MIME使用公钥证书的方式与X.509v3一致</p><h4 id="（1）用户代理职责"><a class="header-anchor" href="#（1）用户代理职责">¶</a>（1）用户代理职责</h4><p>S/MIME的用户要做的事</p><h4 id="（2）VeriSign证书"><a class="header-anchor" href="#（2）VeriSign证书">¶</a>（2）VeriSign证书</h4><p>VeriSign是提供CA服务的公司之一</p><h3 id="8-2-6-增强的安全服务"><a class="header-anchor" href="#8-2-6-增强的安全服务">¶</a>8.2.6 增强的安全服务</h3><h2 id="8-3-DKIM"><a class="header-anchor" href="#8-3-DKIM">¶</a>8.3 DKIM</h2><p>学名叫：域名密钥识别邮件——是电子邮件信息密钥签名规范</p><p>说人话：<br>受到这种信息的一方，可以查询其中的签名域，获取公钥，并且确定对方的身份可信</p><h3 id="8-3-1-互联网邮件体系结构"><a class="header-anchor" href="#8-3-1-互联网邮件体系结构">¶</a>8.3.1 互联网邮件体系结构</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE125.png" alt=""></p><p>补充一个概念：行政管理域ADMD</p><blockquote><p>每个行政管理域可以用不同的决策，比如，组织内部的邮件交换处理，组织之间的……</p></blockquote><h3 id="8-3-2-E-mail威胁"><a class="header-anchor" href="#8-3-2-E-mail威胁">¶</a>8.3.2 E-mail威胁</h3><h4 id="（1）攻击者的3个威胁等级"><a class="header-anchor" href="#（1）攻击者的3个威胁等级">¶</a>（1）攻击者的3个威胁等级</h4><h4 id="（2）攻击者可能具备的能力"><a class="header-anchor" href="#（2）攻击者可能具备的能力">¶</a>（2）攻击者可能具备的能力</h4><h4 id="（3）定位"><a class="header-anchor" href="#（3）定位">¶</a>（3）定位</h4><p>（？）</p><h3 id="8-3-3-DKIM策略"><a class="header-anchor" href="#8-3-3-DKIM策略">¶</a>8.3.3 DKIM策略</h3><p>提供一种对终端用户透明的E-mail认证技术</p><p>透明到底是啥意思（？）</p><p>DKIM工作流程：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE126.png" alt=""></p><p>基本架构和互联网邮件体系结构是一致的</p><h3 id="8-3-4-DKIM的功能流程"><a class="header-anchor" href="#8-3-4-DKIM的功能流程">¶</a>8.3.4 DKIM的功能流程</h3><p>上面是举了一个例子，现在有一份更详细的描述：</p><p>好复杂，不太懂（？）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter7 无线网络安全</title>
      <link href="2021/01/01/Chapter7-%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
      <url>2021/01/01/Chapter7-%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="7-1-无线安全"><a class="header-anchor" href="#7-1-无线安全">¶</a>7.1 无线安全</h2><p>无线网络有一些有线网络中不会遇到的问题：</p><p>无线网络的构成，三部分都有攻击切入点：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210101172029.png" alt=""></p><h3 id="7-1-1-无线网络安全威胁"><a class="header-anchor" href="#7-1-1-无线网络安全威胁">¶</a>7.1.1 无线网络安全威胁</h3><h3 id="7-1-2-无线安全措施"><a class="header-anchor" href="#7-1-2-无线安全措施">¶</a>7.1.2 无线安全措施</h3><p>根据上面的切入点，对应地，我们可以获得安全措施的三个切入点</p><h4 id="（1）安全无线传输"><a class="header-anchor" href="#（1）安全无线传输">¶</a>（1）安全无线传输</h4><p>对于监听攻击：</p><ul><li>信息隐藏技术：施工记者定位无线接入点变得困难</li><li>加密</li></ul><h4 id="（2）安全的无线接入点"><a class="header-anchor" href="#（2）安全的无线接入点">¶</a>（2）安全的无线接入点</h4><p>防止未认证入侵：对基于端口的网络访问进行控制</p><h4 id="（3）安全的无线网络（路由器-终端）"><a class="header-anchor" href="#（3）安全的无线网络（路由器-终端）">¶</a>（3）安全的无线网络（路由器+终端）</h4><p>加密、杀毒、改路由器密码等等</p><h2 id="7-2-移动设备安全"><a class="header-anchor" href="#7-2-移动设备安全">¶</a>7.2 移动设备安全</h2><p>以前设备少，网络边界很好定，现在太多了……</p><h3 id="7-2-1-安全威胁"><a class="header-anchor" href="#7-2-1-安全威胁">¶</a>7.2.1 安全威胁</h3><h4 id="（1）缺乏物理安全控制"><a class="header-anchor" href="#（1）缺乏物理安全控制">¶</a>（1）缺乏物理安全控制</h4><p>比如手机被偷？</p><h4 id="（2）"><a class="header-anchor" href="#（2）">¶</a>（2）</h4><h3 id="7-2-2-移动设备安全策略"><a class="header-anchor" href="#7-2-2-移动设备安全策略">¶</a>7.2.2 移动设备安全策略</h3><p>移动设备安全策略主要包括以下几种</p><h4 id="（1）设备安全"><a class="header-anchor" href="#（1）设备安全">¶</a>（1）设备安全</h4><p>在员工的个人设备访问企业资源的情况下，保证安全</p><h4 id="（2）数据流安全"><a class="header-anchor" href="#（2）数据流安全">¶</a>（2）数据流安全</h4><p>使用加密服务、认证服务</p><h4 id="（3）屏障安全"><a class="header-anchor" href="#（3）屏障安全">¶</a>（3）屏障安全</h4><p>设防火墙等等</p><h2 id="7-3-IEEE-802-11-无线局域网概述"><a class="header-anchor" href="#7-3-IEEE-802-11-无线局域网概述">¶</a>7.3 IEEE 802.11 无线局域网概述</h2><p>IEEE 802.11是个制定无线局域网协议和传输规范的工作组</p><h3 id="7-3-1-WiFi联盟"><a class="header-anchor" href="#7-3-1-WiFi联盟">¶</a>7.3.1 WiFi联盟</h3><p>WiFi联盟是个组织，为什么会出现这个组织呢？<br>首先就要谈到一个问题：不同供应商的产品之间不能呢个确定是否顺利连接，所以就需要互操作认证<br>WiFi联盟制定了一些认证过程、认证系统</p><h3 id="7-3-2-IEEE-802-协议架构"><a class="header-anchor" href="#7-3-2-IEEE-802-协议架构">¶</a>7.3.2 IEEE 802 协议架构</h3><p>IEEE 802.11协议栈如下图，其实和计算机网络中学到的差不多：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210101195554.png" alt=""></p><h3 id="7-3-3-IEEE-802-11-网络组成与架构模型"><a class="header-anchor" href="#7-3-3-IEEE-802-11-网络组成与架构模型">¶</a>7.3.3 IEEE 802.11 网络组成与架构模型</h3><p>这是这个工作组设计的模型</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE115.png" alt=""></p><h3 id="7-3-4-IEEE-802-11-服务"><a class="header-anchor" href="#7-3-4-IEEE-802-11-服务">¶</a>7.3.4 IEEE 802.11 服务</h3><p>为了实现与有线局域网相同的功能，IEEE 802.11为无线局域网定义了以下9种服务：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE116.png" alt=""></p><h2 id="7-4-IEEE-802-11i-无线局域网安全"><a class="header-anchor" href="#7-4-IEEE-802-11i-无线局域网安全">¶</a>7.4 IEEE 802.11i 无线局域网安全</h2><p><em>突然发现老师的课件没怎么讲这一部分，先略过好了</em></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter11 软件项目估算和计划</title>
      <link href="2020/12/31/Chapter11-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E4%BC%B0%E7%AE%97%E5%92%8C%E8%AE%A1%E5%88%92/"/>
      <url>2020/12/31/Chapter11-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E4%BC%B0%E7%AE%97%E5%92%8C%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter10 软件项目管理</title>
      <link href="2020/12/31/Chapter10-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
      <url>2020/12/31/Chapter10-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter9 软件演化和软件维护</title>
      <link href="2020/12/31/Chapter9-%E8%BD%AF%E4%BB%B6%E6%BC%94%E5%8C%96%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4/"/>
      <url>2020/12/31/Chapter9-%E8%BD%AF%E4%BB%B6%E6%BC%94%E5%8C%96%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter8 软件测试</title>
      <link href="2020/12/31/Chapter8-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
      <url>2020/12/31/Chapter8-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter7 面向对象的设计建模</title>
      <link href="2020/12/31/Chapter7-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%BB%BA%E6%A8%A1/"/>
      <url>2020/12/31/Chapter7-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter6 设计工程</title>
      <link href="2020/12/31/Chapter6-%E8%AE%BE%E8%AE%A1%E5%B7%A5%E7%A8%8B/"/>
      <url>2020/12/31/Chapter6-%E8%AE%BE%E8%AE%A1%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>需求工程解决“做什么”，而设计工程则解决“怎么做”的问题；这章超级重要，有很多设计模式，也有4+1视图</p><p><strong>设计工程的成果是设计模型</strong></p><h2 id="6-1-设计工程概述"><a class="header-anchor" href="#6-1-设计工程概述">¶</a>6.1 设计工程概述</h2><h3 id="6-1-1-软件设计过程"><a class="header-anchor" href="#6-1-1-软件设计过程">¶</a>6.1.1 软件设计过程</h3><p>设计的两个阶段：</p><ul><li>架构设计（概要设计）：高抽象层次，定义模块、接口等等</li><li>详细设计（构件级设计）：低抽象层次，定义数据结构、算法等等</li></ul><h3 id="6-1-2-软件设计模型"><a class="header-anchor" href="#6-1-2-软件设计模型">¶</a>6.1.2 软件设计模型</h3><p>分析模型和设计模型的区别：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210107212316.png" alt=""></p><h2 id="6-2-软件设计原则"><a class="header-anchor" href="#6-2-软件设计原则">¶</a>6.2 软件设计原则</h2><h3 id="6-2-1-抽象"><a class="header-anchor" href="#6-2-1-抽象">¶</a>6.2.1 抽象</h3><p>有三种类别：</p><ul><li>过程抽象：就像写函数</li><li>数据抽象：就像写结构体</li><li>对象抽象：就像写类</li></ul><h3 id="6-2-2-分解和模块化"><a class="header-anchor" href="#6-2-2-分解和模块化">¶</a>6.2.2 分解和模块化</h3><p>把大系统分解成几个模块，这里有个“7±2”的原则</p><h3 id="6-2-3-封装和信息隐藏"><a class="header-anchor" href="#6-2-3-封装和信息隐藏">¶</a>6.2.3 封装和信息隐藏</h3><p>封装和信息隐藏的原则是：一个模块内包含的信息（字段+方法）对于不需要这些信息的模块来说是不能访问的</p><h3 id="6-2-4-高内聚和低耦合"><a class="header-anchor" href="#6-2-4-高内聚和低耦合">¶</a>6.2.4 高内聚和低耦合</h3><ul><li>内聚：一个模块内各元素结合</li><li>耦合：不同模块之间的互连</li></ul><h2 id="6-3-软件质量属性的设计策略"><a class="header-anchor" href="#6-3-软件质量属性的设计策略">¶</a>6.3 软件质量属性的设计策略</h2><p>质量属性包括以下几点：</p><h3 id="6-3-1-可用性设计策略"><a class="header-anchor" href="#6-3-1-可用性设计策略">¶</a>6.3.1 可用性设计策略</h3><h3 id="6-3-2-可修改性设计策略"><a class="header-anchor" href="#6-3-2-可修改性设计策略">¶</a>6.3.2 可修改性设计策略</h3><h3 id="6-3-3-性能设计策略"><a class="header-anchor" href="#6-3-3-性能设计策略">¶</a>6.3.3 性能设计策略</h3><h3 id="6-3-4-安全性设计策略"><a class="header-anchor" href="#6-3-4-安全性设计策略">¶</a>6.3.4 安全性设计策略</h3><h3 id="6-3-5-可测试性设计策略"><a class="header-anchor" href="#6-3-5-可测试性设计策略">¶</a>6.3.5 可测试性设计策略</h3><h3 id="6-3-6-易用性设计策略"><a class="header-anchor" href="#6-3-6-易用性设计策略">¶</a>6.3.6 易用性设计策略</h3><h2 id="6-4-架构风格"><a class="header-anchor" href="#6-4-架构风格">¶</a>6.4 架构风格</h2><p>常见的架构风格如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210107214419.png" alt=""></p><h3 id="6-4-1-通用结构的架构风格"><a class="header-anchor" href="#6-4-1-通用结构的架构风格">¶</a>6.4.1 通用结构的架构风格</h3><h3 id="6-4-2-分布式系统的架构风格"><a class="header-anchor" href="#6-4-2-分布式系统的架构风格">¶</a>6.4.2 分布式系统的架构风格</h3><h3 id="6-4-3-交互式系统的架构风格"><a class="header-anchor" href="#6-4-3-交互式系统的架构风格">¶</a>6.4.3 交互式系统的架构风格</h3><h3 id="6-4-4-自适应系统的架构风格"><a class="header-anchor" href="#6-4-4-自适应系统的架构风格">¶</a>6.4.4 自适应系统的架构风格</h3><h3 id="6-4-5-其他架构风格"><a class="header-anchor" href="#6-4-5-其他架构风格">¶</a>6.4.5 其他架构风格</h3><h2 id="6-5-设计模式"><a class="header-anchor" href="#6-5-设计模式">¶</a>6.5 设计模式</h2><p>设计模式有如下分类：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210107215007.png" alt=""></p><h3 id="6-5-1-创建型设计模式"><a class="header-anchor" href="#6-5-1-创建型设计模式">¶</a>6.5.1 创建型设计模式</h3><h3 id="6-5-2-结构性设计模式"><a class="header-anchor" href="#6-5-2-结构性设计模式">¶</a>6.5.2 结构性设计模式</h3><h3 id="6-5-3-行为型设计模式"><a class="header-anchor" href="#6-5-3-行为型设计模式">¶</a>6.5.3 行为型设计模式</h3><h2 id="6-6-人机界面设计"><a class="header-anchor" href="#6-6-人机界面设计">¶</a>6.6 人机界面设计</h2><h3 id="6-6-1-界面设计原则"><a class="header-anchor" href="#6-6-1-界面设计原则">¶</a>6.6.1 界面设计原则</h3><h3 id="6-6-2-人机交互方式"><a class="header-anchor" href="#6-6-2-人机交互方式">¶</a>6.6.2 人机交互方式</h3><h3 id="6-6-3-界面设计过程"><a class="header-anchor" href="#6-6-3-界面设计过程">¶</a>6.6.3 界面设计过程</h3><h3 id="6-6-4-界面设计问题"><a class="header-anchor" href="#6-6-4-界面设计问题">¶</a>6.6.4 界面设计问题</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件工程原理》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter5 面向对象的分析建模</title>
      <link href="2020/12/31/Chapter5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90%E5%BB%BA%E6%A8%A1/"/>
      <url>2020/12/31/Chapter5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<p>这章好重要！有UML（Unified Modeling Language，统一建模语言）！</p><h2 id="5-1-面向对象的分析模型UML"><a class="header-anchor" href="#5-1-面向对象的分析模型UML">¶</a>5.1 面向对象的分析模型UML</h2><p>先说一下学到这里了，感受到的关于“分析”和“设计”的一些知识：</p><ul><li>分析解决的是What的问题，产生的分析模型是平台无关模型</li><li>设计解决的是How的问题，产生的设计模型是平台相关模型</li></ul><p>面向对象的分析模型是包括许多图的，这些图从不同的角度来描述软件系统要解决的问题</p><h3 id="5-1-1-用例图"><a class="header-anchor" href="#5-1-1-用例图">¶</a>5.1.1 用例图</h3><h4 id="（1）作用"><a class="header-anchor" href="#（1）作用">¶</a>（1）作用</h4><p>描述系统的功能以及交互情况</p><h4 id="（2）示例"><a class="header-anchor" href="#（2）示例">¶</a>（2）示例</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE256.png" alt=""></p><h3 id="5-1-2-活动图"><a class="header-anchor" href="#5-1-2-活动图">¶</a>5.1.2 活动图</h3><h4 id="（1）作用-v2"><a class="header-anchor" href="#（1）作用-v2">¶</a>（1）作用</h4><ul><li>描述一个系统/子系统的工作流程</li><li>描述用例内部数据流</li></ul><h4 id="（2）示例-v2"><a class="header-anchor" href="#（2）示例-v2">¶</a>（2）示例</h4><p>感觉长的好像流程图：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103000434.png" alt=""></p><h4 id="（3）活动图元素分组"><a class="header-anchor" href="#（3）活动图元素分组">¶</a>（3）活动图元素分组</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103000550.png" alt=""></p><h3 id="5-1-3-类图"><a class="header-anchor" href="#5-1-3-类图">¶</a>5.1.3 类图</h3><p>先介绍类，再介绍其各种关系</p><h4 id="（1）类"><a class="header-anchor" href="#（1）类">¶</a>（1）类</h4><p>UML定义了4种类型的可见性：</p><ul><li>public</li><li>protected</li><li>private</li><li>package</li></ul><h4 id="（2）继承-泛化"><a class="header-anchor" href="#（2）继承-泛化">¶</a>（2）继承/泛化</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103002839.png" alt=""></p><p>李氏替换准则：在继承时，子类应该能够替换父类</p><h4 id="（3）关联"><a class="header-anchor" href="#（3）关联">¶</a>（3）关联</h4><p>A类的实例与B类的实例中的特例有固定关系的话，这就叫关联关系<br>就好像圆这个类和点这个类的关系一样</p><p>分析阶段其实不是很在乎关联具体是单向还是双向，设计阶段才需要细化；另外还有一些特殊的关联如聚合、组合</p><h4 id="（4）依赖"><a class="header-anchor" href="#（4）依赖">¶</a>（4）依赖</h4><p>依赖的定义其实比较大，是指两个模型元素之间存在的一种语义关系，被依赖者的某些变化会要求或指示依赖者随之发生变化。其实泛化和依赖都是依赖关系，但是是比较特别的依赖关系</p><p>UML模型中的依赖关系有如下这些：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210106193042.png" alt=""></p><p>要画图的时候就是在箭头上的尖括号里面写上关键词：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210106193147.png" alt=""></p><p>依赖关系与关系关系的不同：</p><ul><li>前者是临时的非结构型的关系</li><li>后者是永久的结构型的关系</li></ul><p>其实依赖关系在分析阶段比较少用</p><h4 id="（5）接口和实现"><a class="header-anchor" href="#（5）接口和实现">¶</a>（5）接口和实现</h4><p>注意：要关注线和箭头的样式，不是乱画的</p><p>有两种表示方法：</p><ul><li>实现关系：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210106193748.png" alt=""></li><li>棒棒糖表示法：<ul><li>需要接口：使用了这个接口提供的服务</li><li>提供接口：完全就是用这个定义的数据结构/行为<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210106193854.png" alt=""></li></ul></li></ul><h3 id="5-1-4-时序图"><a class="header-anchor" href="#5-1-4-时序图">¶</a>5.1.4 时序图</h3><p>系统当然还有动态的性质，从两个角度刻画：</p><ul><li>对象内部：状态机图</li><li>对象之间：时序图、通信图</li></ul><h4 id="（1）时序图定义"><a class="header-anchor" href="#（1）时序图定义">¶</a>（1）时序图定义</h4><p>描述了多个对象之间发送消息的时间顺序，图中的每条消息可以是：</p><ul><li>类的操作</li><li>状态机图中引起状态转换的触发事件</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE255.png" alt=""></p><p>其中详解一下序列片段，有四种：</p><ul><li>交互使用（ref标签）：复用已定义的交互场景</li><li>循环（loop标签）：用[get next item]来控制执行</li><li>条件（alt标签）：</li><li>并发（par标签）：</li></ul><h3 id="5-1-5-通信图"><a class="header-anchor" href="#5-1-5-通信图">¶</a>5.1.5 通信图</h3><p>其实可以和时序图互相转换，强调的是发送和接收消息的对象之间的组织结构；而时序图强调的是时间顺序，实际中可以利用两者优势……</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210107001406.png" alt=""></p><h3 id="5-1-6-包图"><a class="header-anchor" href="#5-1-6-包图">¶</a>5.1.6 包图</h3><p>包就像文件夹，可以更好地管理大型项目</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210107001505.png" alt=""></p><h2 id="5-2-分析建模的步骤"><a class="header-anchor" href="#5-2-分析建模的步骤">¶</a>5.2 分析建模的步骤</h2><p>什么是用例（？）</p><p>分析建模的步骤如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE254.png" alt=""></p><h2 id="5-3-用例建模"><a class="header-anchor" href="#5-3-用例建模">¶</a>5.3 用例建模</h2><p>一般步骤：</p><ul><li>分析项目干系人需求</li><li>识别出执行者和用例</li><li>画用例图</li><li>为每个用例写用例规约</li></ul><h3 id="5-3-1-执行者的识别"><a class="header-anchor" href="#5-3-1-执行者的识别">¶</a>5.3.1 执行者的识别</h3><p>有些帮助识别执行者的方法</p><h3 id="5-3-2-用例的识别"><a class="header-anchor" href="#5-3-2-用例的识别">¶</a>5.3.2 用例的识别</h3><h4 id="（1）用例的定义"><a class="header-anchor" href="#（1）用例的定义">¶</a>（1）用例的定义</h4><p>系统执行的一个动作序列，可以为某个执行者产生可观测的、有价值的结果</p><h4 id="（2）有助于寻找用例的问题"><a class="header-anchor" href="#（2）有助于寻找用例的问题">¶</a>（2）有助于寻找用例的问题</h4><h4 id="（3）识别用例中的一些误区"><a class="header-anchor" href="#（3）识别用例中的一些误区">¶</a>（3）识别用例中的一些误区</h4><ul><li>粒度太小</li><li>以低层次数据来命名</li></ul><h3 id="5-3-3-用例图的构建"><a class="header-anchor" href="#5-3-3-用例图的构建">¶</a>5.3.3 用例图的构建</h3><p>当系统规模变大时，可以用包来管理用例，将它们分组，分组依据有多种<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE253.png" alt=""></p><p>执行者也可以分类<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE252.png" alt=""></p><h3 id="5-3-4-用例规约撰写"><a class="header-anchor" href="#5-3-4-用例规约撰写">¶</a>5.3.4 用例规约撰写</h3><h4 id="（1）用例规约作用"><a class="header-anchor" href="#（1）用例规约作用">¶</a>（1）用例规约作用</h4><p>用文字辅以图形，向外部人员描述一个用例的行为</p><h4 id="（2）用例规约的核心内容——事件流"><a class="header-anchor" href="#（2）用例规约的核心内容——事件流">¶</a>（2）用例规约的核心内容——事件流</h4><p>用例其实是一系列动作组成的，这些动作系列就构成了事件流</p><h4 id="（3）用例规约的可选字段"><a class="header-anchor" href="#（3）用例规约的可选字段">¶</a>（3）用例规约的可选字段</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE251.png" alt=""></p><h4 id="（4）活动图"><a class="header-anchor" href="#（4）活动图">¶</a>（4）活动图</h4><p>如果事件流比较复杂，我们可以考虑用活动图和时序图对它建模，比如活动图可以这样（值得关注的是，这些可以和之前写的用例规约对上号）：</p><h4 id="（5）用例规约的细化"><a class="header-anchor" href="#（5）用例规约的细化">¶</a>（5）用例规约的细化</h4><h3 id="5-3-5-用例模型的优化"><a class="header-anchor" href="#5-3-5-用例模型的优化">¶</a>5.3.5 用例模型的优化</h3><p>可以用包含、扩展和泛化三种关系来优化用例模型</p><h4 id="（1）包含"><a class="header-anchor" href="#（1）包含">¶</a>（1）包含</h4><h4 id="（2）扩展"><a class="header-anchor" href="#（2）扩展">¶</a>（2）扩展</h4><h4 id="（3）泛化"><a class="header-anchor" href="#（3）泛化">¶</a>（3）泛化</h4><h2 id="5-4-建立概念模型"><a class="header-anchor" href="#5-4-建立概念模型">¶</a>5.4 建立概念模型</h2><p>这一步就是让我们确定概念类，画出类图，建立概念模型</p><p>识别概念类的方法：</p><p>识别出概念类后，需要定义这些类之间存在的继承关系或关联关系</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE250.png" alt=""></p><h2 id="5-5-用例实现的识别"><a class="header-anchor" href="#5-5-用例实现的识别">¶</a>5.5 用例实现的识别</h2><p>“用例实现”充当了桥梁：从以需求为中心的活动——&gt;以设计为中心的活动；“用例”与“用例实现”之间的存在&lt;&lt;实现&gt;&gt;的依赖关系</p><h2 id="5-6-分析类的识别"><a class="header-anchor" href="#5-6-分析类的识别">¶</a>5.6 分析类的识别</h2><p>书上的概念也太抽象了……分析类到底是啥？（？）</p><h3 id="5-6-1-3种分析类"><a class="header-anchor" href="#5-6-1-3种分析类">¶</a>5.6.1 3种分析类</h3><p>衍型是什么（？）<br>感觉如果在类上面加一个衍型，好像就是说它具有这个衍型对应的性质</p><p>分析类有三种分类：</p><ul><li>系统边界View：用衍型&lt;<boundary>&gt;表示</boundary></li><li>系统要记录和维护的信息Model：&lt;<entity>&gt;</entity></li><li>系统的控制逻辑Control：&lt;<control>&gt;</control></li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210107204819.png" alt=""></p><h3 id="5-6-2-识别边界类"><a class="header-anchor" href="#5-6-2-识别边界类">¶</a>5.6.2 识别边界类</h3><h4 id="（1）什么是控制类？"><a class="header-anchor" href="#（1）什么是控制类？">¶</a>（1）什么是控制类？</h4><p>边界类就是和外界有交互的那些</p><h4 id="（2）边界类分类"><a class="header-anchor" href="#（2）边界类分类">¶</a>（2）边界类分类</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE249.png" alt=""></p><h3 id="5-6-3-识别控制类"><a class="header-anchor" href="#5-6-3-识别控制类">¶</a>5.6.3 识别控制类</h3><p>控制类一般自己不做事，只是协调其他对象实现用例的功能，比如“事务管理器”、“资源协调器”等等</p><h3 id="5-6-4-识别实体类"><a class="header-anchor" href="#5-6-4-识别实体类">¶</a>5.6.4 识别实体类</h3><p>描述系统必须存储的信息和相关行为</p><p>综上所述，某“用例实现”的分析类可以表示如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210107205925.png" alt=""></p><h2 id="5-7-用例分析"><a class="header-anchor" href="#5-7-用例分析">¶</a>5.7 用例分析</h2><p>好晕QWQ这么多图的顺序到底是什么</p><h3 id="5-7-1-职责分配通用原则"><a class="header-anchor" href="#5-7-1-职责分配通用原则">¶</a>5.7.1 职责分配通用原则</h3><h3 id="5-7-2-时序图和通信图的构建"><a class="header-anchor" href="#5-7-2-时序图和通信图的构建">¶</a>5.7.2 时序图和通信图的构建</h3><h3 id="5-7-3-类图的构建"><a class="header-anchor" href="#5-7-3-类图的构建">¶</a>5.7.3 类图的构建</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件工程原理》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter4 需求工程</title>
      <link href="2020/12/31/Chapter4-%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/"/>
      <url>2020/12/31/Chapter4-%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-软件需求面临的挑战"><a class="header-anchor" href="#4-1-软件需求面临的挑战">¶</a>4.1 软件需求面临的挑战</h2><p>见书P96</p><h2 id="4-2-需求工程的概念"><a class="header-anchor" href="#4-2-需求工程的概念">¶</a>4.2 需求工程的概念</h2><h3 id="4-2-1-软件需求"><a class="header-anchor" href="#4-2-1-软件需求">¶</a>4.2.1 软件需求</h3><p>需求=系统要有的条件+能力</p><p>我们常用FURPS+模型定义软件需求：</p><ul><li>F——Functionality：功能、安全性</li><li>U——Usability：实现“用户友好”的因素</li><li>R——Reliability：保证软件可以无故障运行一段时间</li><li>P——Performance：效率、吞吐量等衡量标准</li><li>S——Supportability：（这个我懂得比较少诶）表明进行系统测试、安装、移植等工作量的大小</li><li>+——一些补充的需求：见书P98</li></ul><p>F为功能性需求，URPS为非功能性需求，+为补充需求</p><h3 id="4-2-2-需求的层次"><a class="header-anchor" href="#4-2-2-需求的层次">¶</a>4.2.2 需求的层次</h3><p>软件需求三个层次：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231205244.png" alt=""></p><h3 id="4-2-3-优秀需求应具有的特性"><a class="header-anchor" href="#4-2-3-优秀需求应具有的特性">¶</a>4.2.3 优秀需求应具有的特性</h3><h4 id="（1）单个需求"><a class="header-anchor" href="#（1）单个需求">¶</a>（1）单个需求</h4><h4 id="（2）多个需求"><a class="header-anchor" href="#（2）多个需求">¶</a>（2）多个需求</h4><h3 id="4-2-4-软件需求工程"><a class="header-anchor" href="#4-2-4-软件需求工程">¶</a>4.2.4 软件需求工程</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231205809.png" alt=""></p><h2 id="4-3-需求获取"><a class="header-anchor" href="#4-3-需求获取">¶</a>4.3 需求获取</h2><h3 id="4-3-1-需求来源"><a class="header-anchor" href="#4-3-1-需求来源">¶</a>4.3.1 需求来源</h3><ul><li>项目干系人</li><li>竞品信息</li><li>（以往版本经验）</li><li>……</li></ul><h3 id="4-3-2-需求获取技术"><a class="header-anchor" href="#4-3-2-需求获取技术">¶</a>4.3.2 需求获取技术</h3><h2 id="4-4-需求分析建模"><a class="header-anchor" href="#4-4-需求分析建模">¶</a>4.4 需求分析建模</h2><h3 id="4-4-1-分析模型"><a class="header-anchor" href="#4-4-1-分析模型">¶</a>4.4.1 分析模型</h3><h4 id="（1）分析模型定义"><a class="header-anchor" href="#（1）分析模型定义">¶</a>（1）分析模型定义</h4><p>问题本质的抽象，What而非How，是平台无关模型（PIM）</p><h4 id="（2）分析模型的元素"><a class="header-anchor" href="#（2）分析模型的元素">¶</a>（2）分析模型的元素</h4><ul><li>结构化分析模型<br>数据字典那个</li><li>面向对象分析模型<br>UML等</li></ul><h3 id="4-4-2-分析建模的准则"><a class="header-anchor" href="#4-4-2-分析建模的准则">¶</a>4.4.2 分析建模的准则</h3><p>5条原则</p><h2 id="4-5-需求定义和验证"><a class="header-anchor" href="#4-5-需求定义和验证">¶</a>4.5 需求定义和验证</h2><h3 id="4-5-1-软件前景文档"><a class="header-anchor" href="#4-5-1-软件前景文档">¶</a>4.5.1 软件前景文档</h3><p>书上有模板</p><h3 id="4-5-2-软件需求归约SRS"><a class="header-anchor" href="#4-5-2-软件需求归约SRS">¶</a>4.5.2 软件需求归约SRS</h3><p>也就是正式的详细的软件需求<br>也有模板</p><h3 id="4-5-3-用户界面原型"><a class="header-anchor" href="#4-5-3-用户界面原型">¶</a>4.5.3 用户界面原型</h3><p>用户界面原型拿给用户看，可以更好地细化需求<br>一般流程：</p><ul><li>设计用户界面原型</li><li>开发……</li><li>获得有关用户界面原型的反馈</li></ul><h3 id="4-5-4-软件需求验证"><a class="header-anchor" href="#4-5-4-软件需求验证">¶</a>4.5.4 软件需求验证</h3><h4 id="（1）需求评审"><a class="header-anchor" href="#（1）需求评审">¶</a>（1）需求评审</h4><p>早期控制和防范风险的有效手段，评审过程：</p><ul><li>准备计划阶段：确定评审人员、评审方法等</li><li>实施阶段</li><li>检查在实施阶段</li><li>总结阶段：定稿需求</li></ul><h4 id="（2）原型确认"><a class="header-anchor" href="#（2）原型确认">¶</a>（2）原型确认</h4><p>因为需求一般复杂、不确定等等，所以原型确认作为需求评审的补充，作用也是早期控制和防范风险</p><p>原型确认分类：</p><p>根据不同目的：</p><table><thead><tr><th>水平原型确认</th><th>垂直原型确认</th></tr></thead><tbody><tr><td>例如用户界面模型</td><td>更多被用于验证设计</td></tr></tbody></table><p>根据不同用途</p><table><thead><tr><th>抛弃型原型确认</th><th>演进型原型确认</th></tr></thead><tbody><tr><td>一次性的</td><td>经过精化作为产品的一部分了</td></tr></tbody></table><h2 id="4-6-需求管理"><a class="header-anchor" href="#4-6-需求管理">¶</a>4.6 需求管理</h2><p>下面介绍需求管理的主要3个活动：</p><h3 id="4-6-1-定义需求基线"><a class="header-anchor" href="#4-6-1-定义需求基线">¶</a>4.6.1 定义需求基线</h3><p>明确需求，定义优先级</p><h3 id="4-6-2-需求变更控制和版本控制"><a class="header-anchor" href="#4-6-2-需求变更控制和版本控制">¶</a>4.6.2 需求变更控制和版本控制</h3><p>6条有效的需求变更控制策略：</p><p>如何使项目反映最新的或变更过的需求：</p><h3 id="4-6-3-需求跟踪"><a class="header-anchor" href="#4-6-3-需求跟踪">¶</a>4.6.3 需求跟踪</h3><p>了解各种情况</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件工程原理》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Modelling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter3 软件建模</title>
      <link href="2020/12/29/Chapter3-%E8%BD%AF%E4%BB%B6%E5%BB%BA%E6%A8%A1/"/>
      <url>2020/12/29/Chapter3-%E8%BD%AF%E4%BB%B6%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-模型和建模"><a class="header-anchor" href="#3-1-模型和建模">¶</a>3.1 模型和建模</h2><h3 id="3-1-1-模型"><a class="header-anchor" href="#3-1-1-模型">¶</a>3.1.1 模型</h3><p>模型可以帮助我们抓住问题本质，按需取用不同的语言来描述，一般有如下作用：</p><ul><li>降低风险</li><li>比较不同方案</li><li>用于交流</li><li>指导工程</li></ul><h3 id="3-1-2-软件模型的3个层次：CIM、PIM和PSM"><a class="header-anchor" href="#3-1-2-软件模型的3个层次：CIM、PIM和PSM">¶</a>3.1.2 软件模型的3个层次：CIM、PIM和PSM</h3><p>它们的关系可以用下图描述：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229150729.png" alt=""></p><h3 id="3-1-3-软件建模方法"><a class="header-anchor" href="#3-1-3-软件建模方法">¶</a>3.1.3 软件建模方法</h3><p>软件越来越大，单打独斗不现实了，我们需要理论和方法论支撑。接下来将分别介绍：</p><ul><li>结构化方法</li><li>面向对象方法</li><li>基于构件的开发方法</li><li>面向服务方法</li><li>模型驱动开发方法</li><li>形式化方法</li><li>敏捷建模方法</li></ul><h2 id="3-2-结构化方法"><a class="header-anchor" href="#3-2-结构化方法">¶</a>3.2 结构化方法</h2><p>结构化方法的核心思想：模块化+“自顶向下，逐步求精”</p><p>其实这是一套方法，包括：</p><ul><li>建模技术<ul><li>结构化分析</li><li>结构化设计</li></ul></li><li>编程技术<ul><li>结构化编程</li></ul></li></ul><h3 id="3-2-1-结构化分析"><a class="header-anchor" href="#3-2-1-结构化分析">¶</a>3.2.1 结构化分析</h3><p>结构化分析可以得到这样的模型：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229154400.png" alt=""></p><h4 id="（1）怎么画分层DFD"><a class="header-anchor" href="#（1）怎么画分层DFD">¶</a>（1）怎么画分层DFD</h4><p>步骤：</p><ul><li>顶层图：以系统为中心，画出所有数据源和目的地，以及之间的数据流向</li><li>0层图：把系统分解一次</li><li>1层图：把上面的再分解</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229160046.png" alt=""></p><p>直到每个加工都足够简单，就可以结束</p><p>分层DFD应该遵循如下原则：</p><ul><li>父图与子图平衡：对应数据流保持一致</li><li>数据守恒：<ul><li>输出的数据流必然来自输入数据流的原样/加工</li><li>没有多余数据流，都是用了的</li></ul></li><li>完整性：<ul><li>每个加工过程至少有一个输入、一个输出数据流</li><li>对于文件，至少有一个加工读它、一个加工写它</li><li>数据流和文件都必须命名，并保持与数据字典一致</li><li>不可再分解的加工过程应该有加工说明（后面有写）</li></ul></li></ul><h4 id="（2）怎么定义数据字典DD"><a class="header-anchor" href="#（2）怎么定义数据字典DD">¶</a>（2）怎么定义数据字典DD</h4><p>有了DFD以后，我们从最低一层看，把所有的数据流（箭头上的）和数据文件（双杠）拎出来，写出其组成，一般都是等式右边用加号连接的形式，如下图：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229161237.png" alt=""></p><p>值得注意的是，这里写出来的组成并不依赖于DFD，并不是从图里读出来的；其中使用到的表达方式如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229161424.png" alt=""></p><p>写出数据组成以后，配合DFD信息，配合其他信息，我们可以为每一项数据流/文件写出如下数据字典：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229161817.png" alt=""></p><h4 id="（3）定义加工说明"><a class="header-anchor" href="#（3）定义加工说明">¶</a>（3）定义加工说明</h4><p>加工说明包括：经典IPO<br>这个P不用太详细，写清楚“What”而不是“How”</p><p>加工说明可以有多种表达方式，下面一一介绍：</p><ul><li><p>结构化语言：感觉有点像伪代码的味道<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229162801.png" alt=""></p></li><li><p>判定表/判定树：都适用于比较复杂的逻辑<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229164224.png" alt=""></p></li></ul><h4 id="（4）画实体-关系图"><a class="header-anchor" href="#（4）画实体-关系图">¶</a>（4）画实体-关系图</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229170652.png" alt=""></p><p>（？）0:m和0:1什么意思？</p><h3 id="3-2-2-结构化设计"><a class="header-anchor" href="#3-2-2-结构化设计">¶</a>3.2.2 结构化设计</h3><p><strong>目的：DFD表示的分析模型——&gt;结构图SC表示的设计模型</strong></p><h4 id="（1）鉴别DFD的类别"><a class="header-anchor" href="#（1）鉴别DFD的类别">¶</a>（1）鉴别DFD的类别</h4><ul><li>变换型结构：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229171907.png" alt=""></li><li>事务型结构：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229201517.png" alt=""></li></ul><h4 id="（2）把DFD映射到SC"><a class="header-anchor" href="#（2）把DFD映射到SC">¶</a>（2）把DFD映射到SC</h4><p>先简单介绍一下SC：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229202147.png" alt=""></p><p>对于上面两种结构，分别有对应的映射方法：<br>（？）有点疑问</p><ul><li><p>变换映射：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE77.png" alt=""></p></li><li><p>事务映射：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE98.png" alt=""></p></li></ul><h4 id="（3）优化结构设计"><a class="header-anchor" href="#（3）优化结构设计">¶</a>（3）优化结构设计</h4><ul><li>降低耦合度，提高内聚度</li><li>低扇出，高扇入</li><li>模块的作用域限制在该模块的控制域范围内</li></ul><h4 id="（4）详细设计"><a class="header-anchor" href="#（4）详细设计">¶</a>（4）详细设计</h4><p>对于SC中的每个模块给出足够详细的过程性描述，表达工具包括：</p><ul><li>程序流程图</li><li>PAD图</li><li>N-S图</li><li>伪代码</li></ul><h2 id="3-3-面向对象方法"><a class="header-anchor" href="#3-3-面向对象方法">¶</a>3.3 面向对象方法</h2><h3 id="3-3-1-面向对象的基本概念"><a class="header-anchor" href="#3-3-1-面向对象的基本概念">¶</a>3.3.1 面向对象的基本概念</h3><ul><li>对象</li><li>类</li><li>继承</li><li>消息：对象预期外界世界相关联的唯一途径</li></ul><h3 id="3-3-2-面向对象的基本原则"><a class="header-anchor" href="#3-3-2-面向对象的基本原则">¶</a>3.3.2 面向对象的基本原则</h3><ul><li>抽象</li><li>封装：将对象特征的实现方式隐藏在一个公共接口之后的黑盒中</li><li>模块化</li><li>层次原则：不同级别的抽象组成树形结构</li></ul><h3 id="3-3-3-面向对象的分析和设计"><a class="header-anchor" href="#3-3-3-面向对象的分析和设计">¶</a>3.3.3 面向对象的分析和设计</h3><p>突然觉得分析=说清楚我们要解决什么问题；设计=基于分析的结果，确定我们要怎么解决问题</p><h4 id="（1）面向对象的分析OOA"><a class="header-anchor" href="#（1）面向对象的分析OOA">¶</a>（1）面向对象的分析OOA</h4><p>OOA方法的基本步骤：</p><ul><li>用例建模</li><li>识别出关键抽象（概念类），采用类图建立概念模型</li><li>类图和交互图</li></ul><h4 id="（2）面向对象的设计OOD"><a class="header-anchor" href="#（2）面向对象的设计OOD">¶</a>（2）面向对象的设计OOD</h4><p>令人开心的一点是，OOD和OOA采用相同的表示法和模型结构，所以从OOA——&gt;OOD不需要太多转换，只要稍作修改即可</p><p>OOD的基本步骤：</p><ul><li>从多个视图设计软件的架构</li><li>确定子系统之间的接口+子系统内部的设计</li><li>类的设计和优化</li></ul><h4 id="（3）面向对象的模型"><a class="header-anchor" href="#（3）面向对象的模型">¶</a>（3）面向对象的模型</h4><p>有14种图，超级全面，不过开发的时候不一定都会用到</p><h3 id="3-3-4-结构化方法和面向对象方法的比较"><a class="header-anchor" href="#3-3-4-结构化方法和面向对象方法的比较">¶</a>3.3.4 结构化方法和面向对象方法的比较</h3><p>见书P66-67</p><h2 id="3-4-基于构件的开发方法"><a class="header-anchor" href="#3-4-基于构件的开发方法">¶</a>3.4 基于构件的开发方法</h2><h2 id="3-5-面向服务方法"><a class="header-anchor" href="#3-5-面向服务方法">¶</a>3.5 面向服务方法</h2><h2 id="3-6-模型驱动开发方法"><a class="header-anchor" href="#3-6-模型驱动开发方法">¶</a>3.6 模型驱动开发方法</h2><h2 id="3-7-形式化方法"><a class="header-anchor" href="#3-7-形式化方法">¶</a>3.7 形式化方法</h2><h2 id="3-8-敏捷建模方法"><a class="header-anchor" href="#3-8-敏捷建模方法">¶</a>3.8 敏捷建模方法</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件工程原理》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Modelling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter2 知识表示</title>
      <link href="2020/12/28/Chapter2-%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/"/>
      <url>2020/12/28/Chapter2-%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1>问题归约</h1><h2 id="描述"><a class="header-anchor" href="#描述">¶</a>描述</h2><p>三元组（G,O,P）</p><ul><li>G：初始问题描述</li><li>O：把问题分解为子问题的操作符</li><li>P：本原问题描述</li></ul><p><strong>问题归约法是更通用、更一般化的状态空间表示方法。</strong>（？？？）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter6 传输层安全</title>
      <link href="2020/12/28/Chapter6-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8/"/>
      <url>2020/12/28/Chapter6-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>本节将讨论到关注于传输层安全的三种标准模式：SSL/TLS、HTTPS、SSH</p><h2 id="6-1-Web安全需求"><a class="header-anchor" href="#6-1-Web安全需求">¶</a>6.1 Web安全需求</h2><p>万维网WWW，其实可以看做是运行在互联网上，并基于TCP/IP的C/S模式的应用系统。相关的安全问题就可以被称为<strong>Web安全问题</strong>。</p><p>Web安全有如下挑战：</p><ul><li>互联网的发布环境是双向的</li><li>Web成为企业商业平台，遭攻击会信誉受损</li><li>Web底层软件复杂，可能隐藏安全缺陷</li><li>Web作为公司核心，一旦出问题容易瘫一整片</li><li>Web用户由于缺乏安全意识……</li></ul><h3 id="6-1-1-Web安全威胁"><a class="header-anchor" href="#6-1-1-Web安全威胁">¶</a>6.1.1 Web安全威胁</h3><h4 id="（1）Web安全威胁分类"><a class="header-anchor" href="#（1）Web安全威胁分类">¶</a>（1）Web安全威胁分类</h4><ul><li>按主被动分类<ul><li>主动攻击</li><li>被动攻击</li></ul></li><li>按威胁发生的位置分类<ul><li>在Web服务器</li><li>浏览器</li><li>浏览器与服务器之间的网络通信</li></ul></li></ul><h4 id="（2）各类Web安全威胁的比较"><a class="header-anchor" href="#（2）各类Web安全威胁的比较">¶</a>（2）各类Web安全威胁的比较</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201227225334.png" alt=""></p><h3 id="6-1-2-Web流量安全方法"><a class="header-anchor" href="#6-1-2-Web流量安全方法">¶</a>6.1.2 Web流量安全方法</h3><p>按照安全设施的实现位置不同，可以分成以下三种：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201227225804.png" alt=""></p><ul><li>网络层：可以用IPSec，之后作详细介绍</li><li>传输层：SSL或TLS</li><li>应用层：有些特定的应用有特定的安全服务</li></ul><h2 id="6-2-安全套接字层SSL和传输层安全TLS"><a class="header-anchor" href="#6-2-安全套接字层SSL和传输层安全TLS">¶</a>6.2 安全套接字层SSL和传输层安全TLS</h2><h3 id="6-2-1-SSL体系结构"><a class="header-anchor" href="#6-2-1-SSL体系结构">¶</a>6.2.1 SSL体系结构</h3><h4 id="（1）SSL协议组成"><a class="header-anchor" href="#（1）SSL协议组成">¶</a>（1）SSL协议组成</h4><p>SSL是用TCP提供的端到端的安全服务，由两层协议组成：</p><h4 id="（2）SSL协议两个重要概念"><a class="header-anchor" href="#（2）SSL协议两个重要概念">¶</a>（2）SSL协议两个重要概念</h4><ul><li>连接：一种提供合适服务类型的传输，每个连接与一个会话关联</li><li>会话：通过握手协议来创建会话</li></ul><p>每个会话有若干个状态</p><p>SSL协议：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE31.png" alt=""></p><h2 id="6-3-传输层安全TLS"><a class="header-anchor" href="#6-3-传输层安全TLS">¶</a>6.3 传输层安全TLS</h2><p>TLS目标是编写SSL的互联网标准版本，RFC 5246中定义的TLS非常接近于SSLv3，这里着重介绍区别</p><h3 id="6-3-1-版本号"><a class="header-anchor" href="#6-3-1-版本号">¶</a>6.3.1 版本号</h3><p>TLS记录格式与SSL记录格式完全相同</p><h3 id="6-3-2-消息认证码"><a class="header-anchor" href="#6-3-2-消息认证码">¶</a>6.3.2 消息认证码</h3><p>SSL和TLS的MAC方案不同在于：</p><ul><li>使用的算法</li><li>MAC值的计算范围</li></ul><h3 id="6-3-3-伪随机函数"><a class="header-anchor" href="#6-3-3-伪随机函数">¶</a>6.3.3 伪随机函数</h3><p>（？）<br>TLS使用伪随机函数的目的：使用相对较小的共享密钥值，生成较长的数据块</p><h3 id="6-3-4-警报码"><a class="header-anchor" href="#6-3-4-警报码">¶</a>6.3.4 警报码</h3><p>TLS支持一些SSLv3以外的警报码</p><h3 id="6-3-5-密码套件"><a class="header-anchor" href="#6-3-5-密码套件">¶</a>6.3.5 密码套件</h3><p>可用的密码套件之间有些小区别</p><h3 id="6-3-6-客户端证书类型"><a class="header-anchor" href="#6-3-6-客户端证书类型">¶</a>6.3.6 客户端证书类型</h3><p>客户端可请求的证书有区别</p><h3 id="6-3-7-certificate-verify和finished消息"><a class="header-anchor" href="#6-3-7-certificate-verify和finished消息">¶</a>6.3.7 certificate_verify和finished消息</h3><h3 id="6-3-8-密码计算"><a class="header-anchor" href="#6-3-8-密码计算">¶</a>6.3.8 密码计算</h3><p>预备主密码的计算</p><h3 id="6-3-9-填充"><a class="header-anchor" href="#6-3-9-填充">¶</a>6.3.9 填充</h3><h2 id="6-4-HTTPS"><a class="header-anchor" href="#6-4-HTTPS">¶</a>6.4 HTTPS</h2><p>HTTPS=HTTP+SSL/TLS，以实现浏览器和服务器之间的安全通信</p><p>HTTPS协议中需要被加密的元素：</p><ul><li>URL</li><li>请求的文件内容</li><li>浏览器表单内容</li><li>（双向）cookie</li><li>HTTP报头内容</li></ul><h3 id="6-4-1-连接初始化"><a class="header-anchor" href="#6-4-1-连接初始化">¶</a>6.4.1 连接初始化</h3><p>HTTPS连接初始化过程：</p><ul><li>用户向服务器请求连接</li><li>交换TLS信息</li><li>发起第一次HTTP请求，是以TLS应用数据的形式发送的</li><li>HTTP的传统操作仍然保持</li></ul><p>HTTPS连接中的三层不同意思：</p><ul><li>对于HTTP的部分来说，它觉得自己是向下一层发送了一个连接请求，下一层帮它连接到服务器了；对HTTP，下层是TCP，对HTTPS，下层是SSL/TLS</li><li>对于SSL/TLS的部分来说，它觉得自己是在TLS用户和TLS服务器之间建立了会话；建立一个SSL/TLS连接=建立了一个TCP连接</li></ul><h3 id="6-4-2-连接关闭"><a class="header-anchor" href="#6-4-2-连接关闭">¶</a>6.4.2 连接关闭</h3><p>HTTPS要求关闭TLS——&gt;关闭TLS要求关闭TCP连接</p><h2 id="6-5-SSH（Secure-Shell）"><a class="header-anchor" href="#6-5-SSH（Secure-Shell）">¶</a>6.5 SSH（Secure Shell）</h2><p>SSH是个简单又安全的通信协议，用于远程登录、隧道等</p><p>SSH协议栈：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210101142842.png" alt=""></p><p>接下来分别介绍SSH传输层协议、SSH用户认证协议、SSH连接协议</p><h3 id="6-5-1-传输层协议"><a class="header-anchor" href="#6-5-1-传输层协议">¶</a>6.5.1 传输层协议</h3><h4 id="（1）主机密钥"><a class="header-anchor" href="#（1）主机密钥">¶</a>（1）主机密钥</h4><p>主机密钥用于服务器认证，也就是让用户在密钥交换后可以确认这个服务器身份的意思<br>那用户拿到服务器讼案例的主机密钥之后又怎么验证呢？两种方式：</p><ul><li>用户有个数据库，存了服务器和主机密钥的映射关系</li><li>用户到CA去认证，那里存了主机名和密钥对</li></ul><h4 id="（2）分组交换"><a class="header-anchor" href="#（2）分组交换">¶</a>（2）分组交换</h4><h4 id="（3）SSH传输层协议流程"><a class="header-anchor" href="#（3）SSH传输层协议流程">¶</a>（3）SSH传输层协议流程</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE77.png" alt=""></p><h3 id="6-5-2-用户身份认证协议"><a class="header-anchor" href="#6-5-2-用户身份认证协议">¶</a>6.5.2 用户身份认证协议</h3><p>是用户向服务器证明自己的身份</p><h4 id="（1）消息类型和格式"><a class="header-anchor" href="#（1）消息类型和格式">¶</a>（1）消息类型和格式</h4><ul><li>用户请求服务器帮自己做个认证的格式</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byte SSH_MSG_USERAUTH_REQUEST (50)</span><br><span class="line">string user name</span><br><span class="line">string server name</span><br><span class="line">string method name</span><br><span class="line">... method specific fields</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>服务器拒绝帮用户做认证或者需要它提供更多信息的话，会发这种格式的</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte SSH_MSG_USERAUTH_FAILURE (51)</span><br><span class="line">name-list authentications that can continue</span><br><span class="line">boolean partial success</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>服务器同意帮你认证</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte SSH_MSG_USERAUTH_SUCEESS（52）</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="（2）消息交换"><a class="header-anchor" href="#（2）消息交换">¶</a>（2）消息交换</h4><p>流程如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210101154055.png" alt=""></p><h4 id="（3）身份认证方式"><a class="header-anchor" href="#（3）身份认证方式">¶</a>（3）身份认证方式</h4><p>说的是上图中认证方法列表的内容？</p><h3 id="6-5-3-连接协议"><a class="header-anchor" href="#6-5-3-连接协议">¶</a>6.5.3 连接协议</h3><p>这里顺带一提：SSH协议栈的三个协议，用法大概是——先做SSH用户身份验证协议，再做SSH连接协议，这两个都是基于SSH传输协议的</p><p>有个前提假设是：使用了安全的认证连接</p><blockquote><p>安全的认证连接：连接协议用一个通道虚拟出多条逻辑通道</p></blockquote><h4 id="（1）信道机制"><a class="header-anchor" href="#（1）信道机制">¶</a>（1）信道机制</h4><p>通过窗口机制进行流控，信道的生命周期有3个阶段：</p><ul><li><p>开启信道：</p><ul><li>某一方想开了，给信道分配一个本地序列号，发这种消息：</li></ul>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">byte SSH_MSG_CHANNEL_OPEN</span><br><span class="line">string channel type</span><br><span class="line">uint32 sender channel</span><br><span class="line">uint32 initial window size</span><br><span class="line">uint32 maximum packet size</span><br><span class="line">... channel type specific data follows</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>另一方同意或不同意，如果同意则开启信道</li></ul></li><li><p>关闭信道：</p><ul><li>任意一方想关闭信道，发消息</li></ul></li></ul><p>过程如下图：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210101161117.png" alt=""></p><h4 id="（2）信道类型"><a class="header-anchor" href="#（2）信道类型">¶</a>（2）信道类型</h4><p>4种</p><h4 id="（3）端口转发（即SSH隧道）"><a class="header-anchor" href="#（3）端口转发（即SSH隧道）">¶</a>（3）端口转发（即SSH隧道）</h4><p>可以将不安全的TCP连接转换为安全的SSH连接，转发可以分为本地的和远程的</p><p>没看懂（？）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Transport Layer Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter2 软件过程</title>
      <link href="2020/12/25/Chapter2-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B/"/>
      <url>2020/12/25/Chapter2-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-软件过程的概念"><a class="header-anchor" href="#2-1-软件过程的概念">¶</a>2.1 软件过程的概念</h2><p>软件（生存周期）过程：</p><blockquote><p>过程=活动的集合<br>活动=任务的集合<br>任务=input-&gt;process-&gt;output</p></blockquote><h3 id="2-1-2-软件过程的分类"><a class="header-anchor" href="#2-1-2-软件过程的分类">¶</a>2.1.2 软件过程的分类</h3><p>软件与系统有很多关系，这里分别阐述“系统过程”和“软件过程”。左三列是系统过程，右两列是软件过程</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%B3%BB%E7%BB%9F%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B.png" alt=""></p><h3 id="2-1-3-软件过程的核心元素"><a class="header-anchor" href="#2-1-3-软件过程的核心元素">¶</a>2.1.3 软件过程的核心元素</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201225171541.png" alt=""></p><h2 id="2-2-软件生命周期模型（软件开发模型）"><a class="header-anchor" href="#2-2-软件生命周期模型（软件开发模型）">¶</a>2.2 软件生命周期模型（软件开发模型）</h2><p>规定了软件<br>开发+运作+维护<br>所需的主要活动和任务</p><h3 id="2-2-1-瀑布模型"><a class="header-anchor" href="#2-2-1-瀑布模型">¶</a>2.2.1 瀑布模型</h3><h4 id="（1）介绍"><a class="header-anchor" href="#（1）介绍">¶</a>（1）介绍</h4><p>著名的<strong>线性顺序模型</strong><br>一路往下滚，对前一阶段只评审，不在实践中检验</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201225172109.png" alt=""></p><h4 id="（2）优点"><a class="header-anchor" href="#（2）优点">¶</a>（2）优点</h4><ul><li>解决复杂问题很有作用</li><li>有效保证软件质量</li></ul><h4 id="（3）缺点"><a class="header-anchor" href="#（3）缺点">¶</a>（3）缺点</h4><ul><li>没在实践中验证</li></ul><h4 id="（4）不适用场景"><a class="header-anchor" href="#（4）不适用场景">¶</a>（4）不适用场景</h4><p>见书</p><h3 id="2-2-2-增量模型"><a class="header-anchor" href="#2-2-2-增量模型">¶</a>2.2.2 增量模型</h3><h4 id="（1）介绍-v2"><a class="header-anchor" href="#（1）介绍-v2">¶</a>（1）介绍</h4><p>版本后推，每次多加一些需求进去</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201225173117.png" alt=""></p><h4 id="（2）优点-v2"><a class="header-anchor" href="#（2）优点-v2">¶</a>（2）优点</h4><ul><li>多个版本可以并行开发</li><li>每个版本都可以独立运行</li><li>可以将功能有计划地分为若干增量来逐步实现</li></ul><h4 id="（3）缺点-v2"><a class="header-anchor" href="#（3）缺点-v2">¶</a>（3）缺点</h4><p>需求不明确的时候，可能影响不止一个版本</p><h4 id="（4）不适用的场景"><a class="header-anchor" href="#（4）不适用的场景">¶</a>（4）不适用的场景</h4><p>见书</p><h4 id="（5）适用的场景"><a class="header-anchor" href="#（5）适用的场景">¶</a>（5）适用的场景</h4><p>见书</p><h3 id="2-2-3-演化模型"><a class="header-anchor" href="#2-2-3-演化模型">¶</a>2.2.3 演化模型</h3><h4 id="（1）介绍-v3"><a class="header-anchor" href="#（1）介绍-v3">¶</a>（1）介绍</h4><ul><li>能很好地适应随时间演化的产品的开发</li><li>是迭代的过程模型</li><li>也支持并行开发</li><li>目前采用最广泛的模型</li><li>用于统一过程和许多敏捷过程</li></ul><p>我觉得演化模型和增量模型的区别在于：</p><ul><li>增量模型感觉是已经知道一些需求，然后有计划地主动地把它划分到不同开发轮次里面</li><li>演化模型，后来加入的需求并不是因为之前没把它排进去，而是因为这个需求是随市场变化而来的</li></ul><h4 id="（2）优点-v3"><a class="header-anchor" href="#（2）优点-v3">¶</a>（2）优点</h4><ul><li>可以先开发一部分已明确的需求</li><li>可以面对需求变更</li></ul><h4 id="（3）缺点-v3"><a class="header-anchor" href="#（3）缺点-v3">¶</a>（3）缺点</h4><ul><li>复杂，迭代的规划和控制是难点</li></ul><h4 id="（4）两种实例：原型模型和螺旋模型"><a class="header-anchor" href="#（4）两种实例：原型模型和螺旋模型">¶</a>（4）两种实例：原型模型和螺旋模型</h4><ul><li>原型模型<ul><li>定义：迭代次数为2的演化模型<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201226215738.png" alt=""></li><li>适用情境：用户说不出详细需求/开发者不能确定一些技术细节</li><li>目标：识别软件需求/分析技术风险</li><li>达到目标后对原型的处理：<ul><li>抛弃式原型</li><li>演化式原型：作为产品的一部分</li></ul></li><li>存在的问题：<ul><li>原型可能带给用户不切实际的期望</li><li>建立原型耗时太长</li><li>原型设计欠佳带坏整个软件开发方向</li></ul></li></ul></li><li>螺旋模型<ul><li>定义：迭代的特征+线性模型的特征+风险分析（每次迭代都有）<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201226224513.png" alt=""><br><em>看这个图，需要意识到，每次迭代其实完成的事情是不一样的，并不是说每一次的内部任务都一样。比如原型2是负责确认软件需求，原型3是负责软件产品设计等等</em></li><li>使用原型来降低风险，并且需要相应的风险评估的专门技术</li></ul></li></ul><p><em>小疑惑：什么是原型？</em>（？）<br>以下是维基百科的定义，虽然不是针对软件工程领域的，但是也能让人了解到一些：</p><blockquote><p>原型（英语：Prototype）是指某种新技术在投入量产之前的所作的模型，用以检测产品质素，保障正常运行。在电子技术、机械工程、车辆工程、航空工程及建筑工程等方面广泛运用，实验产品相应地被称为样机，样车等。广义上来讲，通过计算机模拟技术也可以实现这一目的。<br>一般来说，原型的创建与最终产品的创建有所不同，一些基本的分别方式：</p></blockquote><ul><li>材料：最终产品使用的材料可能是昂贵的或不易制造的，因此，用不同于最终产品的材料来制做原型。有时候甚至最终产品的材料都还在开发中，还没办法用在原型。</li><li>过程：批量生产不适合制造少量零件。因此，原型可能使用与最终产品不同的制程来制作。例如，通过塑料射出成型制成的最终产品，需要昂贵的成型模具。因此，为节省费用，可以通过机械加工或3D打印来制造原型。</li><li>验证：最终产品可能需要进行多项品质测试，以验证是否符合设计或规格。通常假设一些调整或返工，为制造过程的一部分。原型也可以免除适用于最终产品的一些要求。</li></ul><blockquote><p>工程师和原型专家试图尽量减少这些差异对原型的影响。例如，如果视觉原型不能使用与最终产品相同的材料，他们将尝试使用具能模拟最终材料的替代材料。</p></blockquote><h3 id="2-2-4-迭代过程"><a class="header-anchor" href="#2-2-4-迭代过程">¶</a>2.2.4 迭代过程</h3><p>迭代式处理不确定的复杂问题的有效手段<br>后一次迭代受益于前一次的经验</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201226214642.png" alt=""></p><h4 id="（1）原则一"><a class="header-anchor" href="#（1）原则一">¶</a>（1）原则一</h4><blockquote><p>每次迭代都要产生一个可执行软件版本<br>每次迭代=计划+建模+需求+分析+设计+实现+测试+评估</p></blockquote><p>从此原则，我们可以知道迭代过程中的内部某一次，其实和瀑布模型有一定的相似之处；区别在于迭代中的各任务可以并行进行</p><h4 id="（2）原则二"><a class="header-anchor" href="#（2）原则二">¶</a>（2）原则二</h4><blockquote><p>要有计划地迭代</p></blockquote><p>迭代化开发，要求在最开始就确定迭代次数、每次迭代的时间……这样才不会使迭代由于无计划而失控</p><h2 id="2-3-统一软件过程UP"><a class="header-anchor" href="#2-3-统一软件过程UP">¶</a>2.3 统一软件过程UP</h2><p>是目前最广泛接受的<strong>软件过程</strong></p><p>包括三大组成部分：</p><ul><li>开发软件原理+实践</li><li>过程模型+模板库（？）</li><li>过程定义工具</li></ul><p>整体框架如下图所示：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201226225323.png" alt=""></p><ul><li>横着看，是以时间为变量的，软件生命周期</li><li>竖着看，是一个阶段里的过程</li></ul><h3 id="2-3-1-阶段"><a class="header-anchor" href="#2-3-1-阶段">¶</a>2.3.1 阶段</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201226233019.png" alt=""></p><p>由上图可知，UP把软件生命周期分为四个阶段：</p><ul><li>先启：目标里程碑，对项目目标达成共识，以规避某些风险（如需求风险）</li><li>精化：架构里程碑，建立软件架构的基线</li><li>构建：软件初始能力里程碑，基于架构进行开发</li><li>产品化：软件产品发布里程碑，做点小事情以确保用户可用（比如安装、配置等）</li></ul><h3 id="2-3-2-迭代"><a class="header-anchor" href="#2-3-2-迭代">¶</a>2.3.2 迭代</h3><p>UP的每个阶段都可以用多次迭代来实现，迭代有如下策略：</p><ul><li>增量式<ul><li>适用于：项目架构风险较小</li><li>精化1次迭代+构建多次迭代（每次加一部分功能，和增量模型很像）</li></ul></li><li>演进式<ul><li>适用于：项目架构的风险较大</li><li>精化多次+构建1次</li></ul></li><li>增量提交<ul><li>适用于：项目不难，但需求不断变化</li><li>后一次迭代使用前一次迭代+用户反馈来改进</li><li>适应需求变化要求架构稳定，而架构的稳定性可以通过多个原型来评估验证（？）</li></ul></li><li>单次迭代<ul><li>只有一次迭代，即<strong>退化为</strong>瀑布模型</li></ul></li></ul><h3 id="2-3-3-过程规范"><a class="header-anchor" href="#2-3-3-过程规范">¶</a>2.3.3 过程规范</h3><p>UP把软件生命周期分为6个核心规范和3个支持规范：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229085723.png" alt=""></p><h2 id="2-4-敏捷过程"><a class="header-anchor" href="#2-4-敏捷过程">¶</a>2.4 敏捷过程</h2><blockquote><p>敏捷过程=<br>以人为本（？）+<br>快速响应需求和变化+<br>注意力集中到项目的主要目标——做出可用软件+<br>文档、度量适度（前提是保证质量）</p></blockquote><p>敏捷过程比较注重人的沟通，发挥人的能动性和创造性，而不是机械地做事；所以这种软件过程适合如下场景：</p><ul><li>需求不确定、易挥发</li><li>有责任感和积极向上的开发人员</li><li>用户容易沟通并能参与（？）</li><li>团队人数&lt;10</li></ul><h3 id="2-4-1-敏捷过程的价值观和原则"><a class="header-anchor" href="#2-4-1-敏捷过程的价值观和原则">¶</a>2.4.1 敏捷过程的价值观和原则</h3><p>敏捷过程的框架分为四个层次：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229093511.png" alt=""></p><p>下面介绍三种具体的敏捷过程：</p><table><thead><tr><th>XP</th><th>Scrum</th><th>MSF</th></tr></thead><tbody><tr><td>敏捷开发技术</td><td>敏捷开发管理</td><td>敏捷开发过程框架</td></tr></tbody></table><h3 id="2-4-2-极限编程XP"><a class="header-anchor" href="#2-4-2-极限编程XP">¶</a>2.4.2 极限编程XP</h3><p>是一种敏捷过程方法</p><h4 id="（1）4个价值目标"><a class="header-anchor" href="#（1）4个价值目标">¶</a>（1）4个价值目标</h4><ul><li>沟通</li><li>简化</li><li>反馈</li><li>勇气</li></ul><h4 id="（2）XP项目状态变迁图"><a class="header-anchor" href="#（2）XP项目状态变迁图">¶</a>（2）XP项目状态变迁图</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229122726.png" alt=""></p><p>XP项目的大概开发流程是：</p><ul><li>首先探索出架构</li><li>根据用户需求发布规划，并且发布的规划可以根据用户新需求的加入来迭代</li><li>根据规划做软件，做出的软件根据测试结果打回去迭代；测试的场景可以来自用户</li><li>测试完了可以交给用户验收，可以的话就进行小型发布</li></ul><h4 id="（3）XP的一些核心思想"><a class="header-anchor" href="#（3）XP的一些核心思想">¶</a>（3）XP的一些核心思想</h4><ul><li>先开发最重要的特性，只关注当下</li><li>其它新需求和变化靠重构来实现</li><li>不对未来投入过多</li></ul><p>代码重构部分可以用下图表示：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229124026.png" alt=""></p><h4 id="（4）XP的使用条件"><a class="header-anchor" href="#（4）XP的使用条件">¶</a>（4）XP的使用条件</h4><p>根据XP的特点我们可以知道，假如重构比事先充分设计的开销要大，那就不值得用XP了</p><h4 id="（5）XP的核心内容（12条实践做法）"><a class="header-anchor" href="#（5）XP的核心内容（12条实践做法）">¶</a>（5）XP的核心内容（12条实践做法）</h4><p>前面说了XP的一些理论层面的内容，接下来谈谈这些理论在实践中表现为什么。以下是12条准则，<strong>不过并非XP特有</strong>：</p><ul><li>计划博弈：做简短的计划，快速确定下次迭代的发布范围</li><li>小型发布：small releases先投入使用，之后再改</li><li>系统隐喻：（？）太抽象了吧</li><li>简化设计：到恰好满足需求的程度</li><li>测试驱动：<strong>XP要求“先写测试，后编码”，用失败的测试驱动编码（？）</strong></li><li>重构：重构以简化系统</li><li>结对编程：两人一起，一人写一人看——<strong>同级评审</strong></li><li>代码全体拥有：大家都能改</li><li>持续集成：每当完成一个任务，都集成一次成品；可能一天有好几次，并不断回归测试</li><li>每周40小时工作制</li><li>现场客户：加入开发环节</li><li>代码规范：为了减少文档</li></ul><h3 id="2-4-3-Scrum"><a class="header-anchor" href="#2-4-3-Scrum">¶</a>2.4.3 Scrum</h3><h4 id="（1）Scrum特点"><a class="header-anchor" href="#（1）Scrum特点">¶</a>（1）Scrum特点</h4><p>类比于橄榄球争球：</p><ul><li>迅速</li><li>适应性</li><li>自组织</li></ul><h4 id="（2）Scrum核心思想"><a class="header-anchor" href="#（2）Scrum核心思想">¶</a>（2）Scrum核心思想</h4><p>Scrum认为软件更多地是<strong>经验性的过程</strong>，而非确定性的过程</p><ul><li>经验性：中间是黑箱，只定两头输入输出，然后根据经验调控黑箱（黑箱里面是分析、设计、实现这些步骤）</li><li>确定性：如一个具体的软件过程模型</li></ul><p>所以Scrum更有适应性和创造力，没有卡得那么死</p><h4 id="（3）Scrum核心准则"><a class="header-anchor" href="#（3）Scrum核心准则">¶</a>（3）Scrum核心准则</h4><ul><li>自我管理：每个Scrum团队都有3种角色，没有中心，可以自组织，跨职能；十分灵活</li><li>迭代开发：<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229143834.png" alt=""></li></ul><h4 id="4-Scrum的一系列规则"><a class="header-anchor" href="#4-Scrum的一系列规则">¶</a>(4) Scrum的一系列规则</h4><p>书P36-37</p><h3 id="2-4-4-微软解决方案框架MSF-（？）"><a class="header-anchor" href="#2-4-4-微软解决方案框架MSF-（？）">¶</a>2.4.4 微软解决方案框架MSF （？）</h3><p>包括两个过程：</p><ul><li>MSF敏捷开发过程</li><li>MSF for CMMI过程</li></ul><h2 id="2-5-软件过程的选择、裁剪、评估和改进"><a class="header-anchor" href="#2-5-软件过程的选择、裁剪、评估和改进">¶</a>2.5 软件过程的选择、裁剪、评估和改进</h2><h3 id="2-5-1-软件过程的选择和裁剪"><a class="header-anchor" href="#2-5-1-软件过程的选择和裁剪">¶</a>2.5.1 软件过程的选择和裁剪</h3><p><strong>其实可以不止使用一个软件过程，可以融合</strong></p><h4 id="（1）选择"><a class="header-anchor" href="#（1）选择">¶</a>（1）选择</h4><p>书P38，3条考虑</p><h4 id="（2）裁剪"><a class="header-anchor" href="#（2）裁剪">¶</a>（2）裁剪</h4><p>书P38-39，3条考虑</p><h3 id="2-5-2-软件过程的评估"><a class="header-anchor" href="#2-5-2-软件过程的评估">¶</a>2.5.2 软件过程的评估</h3><p>用来考察以下问题：</p><ul><li>用的软件过程适合本团队吗？</li><li>过程绩效如何？</li><li>软件过程能力成熟度为几级？</li><li>做的好与不好之处？</li></ul><h4 id="（1）参考模型"><a class="header-anchor" href="#（1）参考模型">¶</a>（1）参考模型</h4><ul><li>CMM/CMMI</li><li>ISO/IEC 15504</li><li>ISO/IEC 20000</li></ul><h4 id="（2）评估方法"><a class="header-anchor" href="#（2）评估方法">¶</a>（2）评估方法</h4><p>以上模型还提供了配套的评估方法</p><h3 id="2-5-3-软件过程的改进"><a class="header-anchor" href="#2-5-3-软件过程的改进">¶</a>2.5.3 软件过程的改进</h3><p>惊讶的是，软件工程的知识完备到，连软件过程的改进也有一些生命周期模型<br>一般切入点是找要素，比如人、技术、方法等等；<br>软件过程、过程评估、过程改进三者关系如下：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229145317.png" alt=""></p><h4 id="（1）PDCA循环"><a class="header-anchor" href="#（1）PDCA循环">¶</a>（1）PDCA循环</h4><h4 id="（2）IDEAL模型"><a class="header-anchor" href="#（2）IDEAL模型">¶</a>（2）IDEAL模型</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件工程原理》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Reading Report for Adversarial Roubustness vs. Model Compression, or Both?</title>
      <link href="2020/12/25/Reading-Report-for-Adversarial-Roubustness-vs-Model-Compression-or-Both/"/>
      <url>2020/12/25/Reading-Report-for-Adversarial-Roubustness-vs-Model-Compression-or-Both/</url>
      
        <content type="html"><![CDATA[<h2 id="0-Abstract"><a class="header-anchor" href="#0-Abstract">¶</a>0. Abstract</h2><ul><li>DNN is vulnerable to adversarial attacks</li><li>adversarial robustness requires larger capacity of the network than normal</li><li>This paper proposed a training framework to achieve both model compression and adversarial attacks</li><li>This paper studied 2 hypotheses:<ul><li>under adversarial setting, weight pruning is essential for reducing the model size</li><li>train a small model from scratch cannot achieve neither compression and adversarial robustness</li></ul></li></ul><h2 id="1-Introduction"><a class="header-anchor" href="#1-Introduction">¶</a>1. Introduction</h2><h3 id="1-1-Background"><a class="header-anchor" href="#1-1-Background">¶</a>1.1 Background</h3><ul><li>Listing several bad results brought by DNN’s vulnerability</li><li>brief introduction of adversarial attack and 2 types of it (black and white box)</li></ul><h3 id="1-2-Existing-conclusions"><a class="header-anchor" href="#1-2-Existing-conclusions">¶</a>1.2 Existing conclusions</h3><ul><li>So there are many denfense mechanisms, such as adversarial training using min-max robust optimization</li><li>Increase the capacity of a network may provide a better trade off between  standard accuracy of an adversarially trained model and its adversarial robustness</li><li>But large network capacity required in adversarial training may limit its use in resource constrained application systems.</li><li>Some studies work on the relationship between adversarial robustness and weight sparsity, one of them concludes that moderate spasity can help with adversarial robustness, still vulnerable though.</li></ul><h3 id="1-3-Our-contribution"><a class="header-anchor" href="#1-3-Our-contribution">¶</a>1.3 Our contribution</h3><ul><li>This paper investigated whether and how weight sparsity can facilitate an active defense technique. And got following observations:<ul><li>smaller model size leads to both lower accuarcy and robustness<ul><li>so pre-pruning before training isn’t useful</li></ul></li><li>adversarially trained model is less sparse<ul><li>harder to prune an adversarially trained network</li></ul></li></ul></li><li>Based on above observations, this paper tries to enable <strong>security-critical applications in resource constrained systems</strong> by integrating weight pruning with the adversarial robustness and model compression together.</li><li>We studied 2 hypotheses (mentioned above)</li><li>We build a framework to achieve both, for details:<ul><li>ADMM based pruning (because it’s compatible with adversarial training)</li><li>can switch between different pruning schemes</li></ul></li><li>We find that the irregular pruning is best for achieving both</li></ul><h2 id="2-Related-Work"><a class="header-anchor" href="#2-Related-Work">¶</a>2. Related Work</h2><h3 id="2-1-Adversarial-Trainning"><a class="header-anchor" href="#2-1-Adversarial-Trainning">¶</a>2.1 Adversarial Trainning</h3><h3 id="2-2-Weight-Pruning"><a class="header-anchor" href="#2-2-Weight-Pruning">¶</a>2.2 Weight Pruning</h3><h2 id="3-Concurrent-Adversarial-Training-and-Weight-Pruning"><a class="header-anchor" href="#3-Concurrent-Adversarial-Training-and-Weight-Pruning">¶</a>3. Concurrent Adversarial Training and Weight Pruning</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research Group </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Model Compression </tag>
            
            <tag> Adversarial Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter1 软件工程绪论</title>
      <link href="2020/12/25/Chapter1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%BB%AA%E8%AE%BA/"/>
      <url>2020/12/25/Chapter1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>本章将从软件和工程两个方面来探讨软件工程的<strong>本质</strong>和<strong>基本原理</strong></p><h2 id="1-1-软件"><a class="header-anchor" href="#1-1-软件">¶</a>1.1 软件</h2><h3 id="1-1-1-软件的作用和特性"><a class="header-anchor" href="#1-1-1-软件的作用和特性">¶</a>1.1.1 软件的作用和特性</h3><h4 id="（1）软件定义："><a class="header-anchor" href="#（1）软件定义：">¶</a>（1）软件定义：</h4><blockquote><p>软件是计算机系统中与硬件相互依存的另一部分<br>软件=程序+相关数据+说明文档</p></blockquote><h4 id="（2）软件和硬件区别："><a class="header-anchor" href="#（2）软件和硬件区别：">¶</a>（2）软件和硬件区别：</h4><ul><li>软件开发不同于硬件设计</li><li>软件生产不同于硬件制造</li><li>软件维护不同于硬件维修</li></ul><h3 id="1-1-2-软件的发展和面临的新挑战"><a class="header-anchor" href="#1-1-2-软件的发展和面临的新挑战">¶</a>1.1.2 软件的发展和面临的新挑战</h3><p>挑战：</p><ul><li>软件复杂性增加</li><li>软件规模的扩大</li><li>软件环境的变化</li><li>遗留系统的集成和复用</li><li>软件开发的高质量和敏捷性要求</li><li>分散的开发团队的协同</li></ul><h3 id="1-1-3-软件危机"><a class="header-anchor" href="#1-1-3-软件危机">¶</a>1.1.3 软件危机</h3><h4 id="（1）软件危机定义"><a class="header-anchor" href="#（1）软件危机定义">¶</a>（1）软件危机定义</h4><p>指的是软件开发过程中面临的一系列问题：</p><ul><li>不符合需求</li><li>出错</li><li>鲁棒性差</li><li>使用不方便</li><li>工期超时</li><li>成本超预算</li></ul><h4 id="（2）软件开发不成熟的原因"><a class="header-anchor" href="#（2）软件开发不成熟的原因">¶</a>（2）软件开发不成熟的原因</h4><ul><li>软件本身复杂</li><li>软件开发维护的方法、工具等等不恰当</li></ul><h2 id="1-2-工程"><a class="header-anchor" href="#1-2-工程">¶</a>1.2 工程</h2><h3 id="1-2-1-软件开发与艺术、科学和工程的关系"><a class="header-anchor" href="#1-2-1-软件开发与艺术、科学和工程的关系">¶</a>1.2.1 软件开发与艺术、科学和工程的关系</h3><p>科学（真）、工程（善）、艺术（美），软件开发三者兼备</p><h3 id="1-2-2-工程的定义和特性"><a class="header-anchor" href="#1-2-2-工程的定义和特性">¶</a>1.2.2 工程的定义和特性</h3><h4 id="（1）定义"><a class="header-anchor" href="#（1）定义">¶</a>（1）定义</h4><p><strong>组织</strong>良好+<strong>管理</strong>严密+各类人员协同配合<strong>共同</strong>完成工作<br>的学科</p><h4 id="（2）特性"><a class="header-anchor" href="#（2）特性">¶</a>（2）特性</h4><ul><li>以价值为目标</li><li>高度的组织管理性</li><li>多种学科的综合</li><li>高度的实践性。工程实践一般包括如下步骤：<ul><li>理解问题——需求分析</li><li>规划方案——设计</li><li>实施计划——编码</li><li>验证结果的准确性——测试和质量保证</li></ul></li></ul><h3 id="1-2-3-工程的准则"><a class="header-anchor" href="#1-2-3-工程的准则">¶</a>1.2.3 工程的准则</h3><p>见书</p><h2 id="1-3-软件工程"><a class="header-anchor" href="#1-3-软件工程">¶</a>1.3 软件工程</h2><p>即把工程的方法应用于软件开发<br>是工程师解决“软件危机”的探索</p><h3 id="1-3-1-软件工程的概念和知识域"><a class="header-anchor" href="#1-3-1-软件工程的概念和知识域">¶</a>1.3.1 软件工程的概念和知识域</h3><h4 id="（1）概念"><a class="header-anchor" href="#（1）概念">¶</a>（1）概念</h4><p>为了<strong>经济地</strong>获得<strong>可靠的</strong>且能在实际机器上<strong>高效运行</strong>的软件<br>而建立和使用的<br>工程原理</p><h4 id="（2）软件工程知识域"><a class="header-anchor" href="#（2）软件工程知识域">¶</a>（2）软件工程知识域</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201225144907.png" alt=""></p><h3 id="1-3-2-软件工程的金三角"><a class="header-anchor" href="#1-3-2-软件工程的金三角">¶</a>1.3.2 软件工程的金三角</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201225145134.png" alt=""></p><ul><li>人：软件开发和维护的主体，最重要的因素</li><li>技术：解决“如何做”的问题<br>软件工程核心技术环节：<ul><li>系统工程：了解软件所处系统的方法</li><li>软件需求：确定软件的目标和范围</li><li>软件设计：从需求到代码的桥梁</li><li>软件构造/编码：就是写代码啦</li><li>软件测试：</li><li>软件维护<br>记住上面这个顺序……这个思路很常见</li></ul></li><li>管理：我国大企业不多</li><li>过程：=人+技术+管理</li></ul><h3 id="1-3-3-控制软件开发的复杂性"><a class="header-anchor" href="#1-3-3-控制软件开发的复杂性">¶</a>1.3.3 控制软件开发的复杂性</h3><h4 id="（1）软件复杂在哪？"><a class="header-anchor" href="#（1）软件复杂在哪？">¶</a>（1）软件复杂在哪？</h4><ul><li>技术复杂</li><li>需求复杂</li><li>人复杂</li></ul><h4 id="（2）控制复杂性的方法"><a class="header-anchor" href="#（2）控制复杂性的方法">¶</a>（2）控制复杂性的方法</h4><p>把复杂的问题转变为计算机能处理的简单问题</p><ul><li>抽象：含义你懂的，程序设计中主要用到两种：<ul><li>过程抽象：i.e.类的方法</li><li>数据抽象：i.e.类的属性</li></ul></li><li>分解：复杂问题——&gt;简单子问题</li><li>迭代：比如多次试验以获取足够多的经验</li></ul><h3 id="1-3-4-软件工程经济学"><a class="header-anchor" href="#1-3-4-软件工程经济学">¶</a>1.3.4 软件工程经济学</h3><p>研究软件价值及提高的方法</p><h2 id="1-4-案例概述"><a class="header-anchor" href="#1-4-案例概述">¶</a>1.4 案例概述</h2><p>4S店与软件工程比对</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件工程原理》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter1 人工智能绪论</title>
      <link href="2020/12/24/Chapter1-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%BB%AA%E8%AE%BA/"/>
      <url>2020/12/24/Chapter1-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《人工智能及其应用》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter7 机器学习</title>
      <link href="2020/12/24/Chapter7-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/12/24/Chapter7-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="7-1-机器学习的定义和发展历史"><a class="header-anchor" href="#7-1-机器学习的定义和发展历史">¶</a>7.1 机器学习的定义和发展历史</h2><h3 id="7-1-1-机器学习的定义"><a class="header-anchor" href="#7-1-1-机器学习的定义">¶</a>7.1.1 机器学习的定义</h3><p>书上首先介绍了很多很多大师的定义，最后提出了一个为了便于学科研究的定义：</p><blockquote><p>机器学习是研究机器<strong>模拟人类</strong>的学习活动、<strong>获取知识和技能</strong>的理论和方法，以<strong>改善系统性能</strong>的学科</p></blockquote><h3 id="7-1-2-机器学习的发展史"><a class="header-anchor" href="#7-1-2-机器学习的发展史">¶</a>7.1.2 机器学习的发展史</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201224142728.png" alt=""></p><p>另外书中还提到机器学习进入新阶段的重要表现（6条）</p><h2 id="7-2-机器学习的主要策略与基本结构"><a class="header-anchor" href="#7-2-机器学习的主要策略与基本结构">¶</a>7.2 机器学习的主要策略与基本结构</h2><h3 id="7-2-1-机器学习的主要策略"><a class="header-anchor" href="#7-2-1-机器学习的主要策略">¶</a>7.2.1 机器学习的主要策略</h3><p>分为四种，所需要的推理能力从低到高：</p><ul><li>机械学习：即记忆，外界知识表示方式与系统内部表示方式完全一致，不需要任何处理与转换</li><li>示教学习：表达方式不完全一致，需要一定的推理、翻译和转化工作</li><li>类比学习：去发现已知任务和当前任务的相似之处，由此为当前任务制定解决方案</li><li>示例学习：对具体的工作例子及工作经验进行分析总结和推广，得到完成任务的一般性规律</li></ul><h3 id="7-2-2-机器学习系统的基本结构"><a class="header-anchor" href="#7-2-2-机器学习系统的基本结构">¶</a>7.2.2 机器学习系统的基本结构</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/0E13DC29D62D538FC2881F61451D6AD0.png" alt=""></p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/0E13DC29D62D538FC2881F61451D6AD0.png"><p>注意到知识库中知识的表示多种多样，所以书中提到了四条选择原则：</p><ol><li>表达能力强</li><li>易于推理：学习系统计算代价较低</li><li>容易修改知识库：难点在于——修改某一知识的时候，可能关联到其他的知识，需要全面检查</li><li>知识表示易于扩展：发展以来，一个系统可能变得需要多种知识表示方式</li></ol><h2 id="7-3-归纳学习"><a class="header-anchor" href="#7-3-归纳学习">¶</a>7.3 归纳学习</h2><p>归纳学习定义：</p><blockquote><p>是应用<strong>归纳推理</strong>进行学习的一种方法</p></blockquote><p>分类（根据有无教师指导）：</p><ul><li>示例学习：有师学习</li><li>观察与发现学习：无师学习</li></ul><h3 id="7-3-1-归纳学习的模式和规则"><a class="header-anchor" href="#7-3-1-归纳学习的模式和规则">¶</a>7.3.1 归纳学习的模式和规则</h3><p>归纳学习的一些特点：<br>这里把归纳学习分成有穷归纳、数学归纳和一般归纳<br>除去前两者以外，一般归纳其实推理结论只**“保假”**</p><blockquote><p>保假的意思：当归纳前提是错误时，我们可以肯定地说结论也是错的；但是前提是正确的时候就不一定了</p></blockquote><p>其实人类的知识也是存在很强的<strong>可证伪性</strong></p><h4 id="1-归纳学习的模式"><a class="header-anchor" href="#1-归纳学习的模式">¶</a>1. 归纳学习的模式</h4><p>（从这里开始不讲人话了）</p><h4 id="2-归纳概括规则"><a class="header-anchor" href="#2-归纳概括规则">¶</a>2. 归纳概括规则</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《人工智能及其应用》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter8 恶意代码检测与分析</title>
      <link href="2020/12/21/Chapter8-%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>2020/12/21/Chapter8-%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="8-1-恶意代码分析基础"><a class="header-anchor" href="#8-1-恶意代码分析基础">¶</a>8.1 恶意代码分析基础</h2><h3 id="8-1-1-恶意代码分类"><a class="header-anchor" href="#8-1-1-恶意代码分类">¶</a>8.1.1 恶意代码分类</h3><p>恶意代码分析过程总结</p><ol><li>将exe文件上传至</li></ol><h2 id="8-3-动态分析"><a class="header-anchor" href="#8-3-动态分析">¶</a>8.3 动态分析</h2><p>有效的简单动态分析步骤：</p><ul><li>准备：有效的目标+安全的运行环境+尽量真实的网络环境配置</li><li>运行恶意代码</li><li>使用监视工具</li><li>综合分析</li></ul><h3 id="8-3-1-动态分析环境构建"><a class="header-anchor" href="#8-3-1-动态分析环境构建">¶</a>8.3.1 动态分析环境构建</h3><h4 id="（1）环境构建要考虑的重点问题"><a class="header-anchor" href="#（1）环境构建要考虑的重点问题">¶</a>（1）环境构建要考虑的重点问题</h4><p>不破坏/影响外部环境</p><h4 id="（2）做法"><a class="header-anchor" href="#（2）做法">¶</a>（2）做法</h4><p>在受控的隔离环境里面进行动态分析，可以做到：</p><ul><li>影响限制到一定范围内</li><li>可以快速恢复环境而不影响后续分析</li></ul><h4 id="（3）构建环境的工具"><a class="header-anchor" href="#（3）构建环境的工具">¶</a>（3）构建环境的工具</h4><p>按采用的技术方法的不同，做如下分类:</p><ul><li><p>沙箱程序：</p><ul><li>作用：比如可以按照用户指定的安全策略来限制程序行为等，是一种可以运行在</li><li></li></ul></li><li><p>虚拟化软件（如VMware/VirtualBox）：</p></li><li><p>硬件模拟器：</p></li></ul><h3 id="8-3-2-动态行为分析"><a class="header-anchor" href="#8-3-2-动态行为分析">¶</a>8.3.2 动态行为分析</h3><h3 id="8-3-3-动态调试分析"><a class="header-anchor" href="#8-3-3-动态调试分析">¶</a>8.3.3 动态调试分析</h3><h3 id="8-3-4-反虚拟化分析对抗"><a class="header-anchor" href="#8-3-4-反虚拟化分析对抗">¶</a>8.3.4 反虚拟化分析对抗</h3><h3 id="8-3-5-反自动化分析对抗"><a class="header-anchor" href="#8-3-5-反自动化分析对抗">¶</a>8.3.5 反自动化分析对抗</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件安全分析与应用》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter7 污点传播分析</title>
      <link href="2020/12/21/Chapter7-%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E5%88%86%E6%9E%90/"/>
      <url>2020/12/21/Chapter7-%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>污点分析是属于<strong>数据流分析方法</strong>的一种。<br><strong>主要思想</strong>是：标记程序中的数据为污点，跟踪它的去向，看它是不是到了什么敏感的地方（重要的控制决策变量之类的）等等。<br><strong>应用领域</strong>：恶意代码检测、软件漏洞挖掘、用户隐私保护</p><h2 id="7-1-概述"><a class="header-anchor" href="#7-1-概述">¶</a>7.1 概述</h2><h3 id="7-1-1-发展简史"><a class="header-anchor" href="#7-1-1-发展简史">¶</a>7.1.1 发展简史</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201221152906.png" alt=""></p><h3 id="7-1-2-应用领域"><a class="header-anchor" href="#7-1-2-应用领域">¶</a>7.1.2 应用领域</h3><h4 id="1-恶意代码检测"><a class="header-anchor" href="#1-恶意代码检测">¶</a>1. 恶意代码检测</h4><h4 id="2-软件漏洞挖掘"><a class="header-anchor" href="#2-软件漏洞挖掘">¶</a>2. 软件漏洞挖掘</h4><h4 id="3-敏感数据泄露分析方面"><a class="header-anchor" href="#3-敏感数据泄露分析方面">¶</a>3. 敏感数据泄露分析方面</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件安全分析与应用》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter2 基础知识</title>
      <link href="2020/12/21/Chapter2-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>2020/12/21/Chapter2-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>本章的基础知识是指：在恶意代码分析、软件漏洞分析中需要的基础知识</p><h2 id="2-1-处理器硬件架构基础"><a class="header-anchor" href="#2-1-处理器硬件架构基础">¶</a>2.1 处理器硬件架构基础</h2><p>了解硬件知识有利于了解操作系统原理和软件漏洞</p><h3 id="2-1-1-CPU结构介绍"><a class="header-anchor" href="#2-1-1-CPU结构介绍">¶</a>2.1.1 CPU结构介绍</h3><h4 id="（1）CPU结构示意图"><a class="header-anchor" href="#（1）CPU结构示意图">¶</a>（1）CPU结构示意图</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201228142159.png" alt=""></p><p>包括：寄存器+算术逻辑单元ALU+控制器+内部总线</p><ul><li>寄存器：暂存运算数据与结果</li><li>ALU：多种运算功能</li><li>控制器：取指、译码、执行</li><li>内部总线：连接各部分，提供通信</li></ul><p><strong>由于寄存器记录了操作系统关键数据结构的入口，所以我们重点关注它</strong></p><h4 id="（2）CPU寄存器详解"><a class="header-anchor" href="#（2）CPU寄存器详解">¶</a>（2）CPU寄存器详解</h4><p>以32位系统为例：</p><ul><li>指令指针寄存器EIP：存储当前执行指令的地址；操作系统从根据EIP内容寻址，然后取指、译码、执行</li><li>通用数据寄存器EAX/ECX/EDX/EBX：各自有一些常见用法；16位的表示为AX/CX/DX/BX，8位的表示为AL/CL/DL/BL<ul><li>ECX：存储循环次数</li><li>EAX/EDX：乘除法的隐含操作数</li></ul></li><li>地址指针寄存器ESP/EBP：<ul><li>ESP：当前函数栈顶</li><li>EBP：当前函数栈底</li></ul></li><li>变址指针寄存器ESI/EDI：<ul><li>ESI：操作数源地址</li><li>EDI：操作数目的地址</li></ul></li><li>标志位寄存器EFLAGS，具体见书：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103143555.png" alt=""></li><li>段寄存器：CS/DS/SS/ES/FS/GS</li><li>控制寄存器:CR0/CR1/CR2/CR3/CR4</li></ul><h3 id="2-1-2-保护模式"><a class="header-anchor" href="#2-1-2-保护模式">¶</a>2.1.2 保护模式</h3><h4 id="（1）实模式与保护模式区别"><a class="header-anchor" href="#（1）实模式与保护模式区别">¶</a>（1）实模式与保护模式区别</h4><table><thead><tr><th>实模式</th><th>保护模式</th></tr></thead><tbody><tr><td>不支持多线程；不实现权限分级</td><td>可以多线程、多任务；实现内存分页/分段和权限分级</td></tr></tbody></table><h4 id="（2）分页与分段"><a class="header-anchor" href="#（2）分页与分段">¶</a>（2）分页与分段</h4><ul><li>分页由CR3寄存器支持</li><li>分段由内存管理寄存器支持（GDTR/IDTR/LDTR/TR）</li></ul><h3 id="2-1-3-特权级"><a class="header-anchor" href="#2-1-3-特权级">¶</a>2.1.3 特权级</h3><p>4个特权级：Ring0/1/2/3</p><p>校验代码段、数据段的特权级，需要三种类型的特权级支持：</p><ul><li>当前特权级CPL</li><li>描述符特权级DPL</li><li>请求特权级RPL</li></ul><p>常用特权级指令（只能运行在Ring0）：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103144440.png" alt=""></p><h3 id="2-1-4-中断和异常处理"><a class="header-anchor" href="#2-1-4-中断和异常处理">¶</a>2.1.4 中断和异常处理</h3><ul><li>中断是在程序执行期间发生的，分为<ul><li>硬件中断</li><li>软件中断</li></ul></li><li>异常是在处理器执行指令过程中发生错误了<ul><li>程序错误异常</li><li>软件产生异常</li><li>机器检测异常</li></ul></li></ul><p>异常和中断都有唯一的识别码——中断向量</p><h3 id="2-1-5-调试支持"><a class="header-anchor" href="#2-1-5-调试支持">¶</a>2.1.5 调试支持</h3><p>EFLAGS中的IF、TF用于调试模式的开启</p><p>8个调试寄存器DR0-DR7</p><h3 id="2-1-6-虚拟化支持"><a class="header-anchor" href="#2-1-6-虚拟化支持">¶</a>2.1.6 虚拟化支持</h3><h2 id="2-2-反汇编及对抗技术"><a class="header-anchor" href="#2-2-反汇编及对抗技术">¶</a>2.2 反汇编及对抗技术</h2><h3 id="2-2-1-汇编语言"><a class="header-anchor" href="#2-2-1-汇编语言">¶</a>2.2.1 汇编语言</h3><h4 id="（1）寻址方式"><a class="header-anchor" href="#（1）寻址方式">¶</a>（1）寻址方式</h4><h4 id="（2）常用的汇编指令"><a class="header-anchor" href="#（2）常用的汇编指令">¶</a>（2）常用的汇编指令</h4><h3 id="2-2-2-反汇编"><a class="header-anchor" href="#2-2-2-反汇编">¶</a>2.2.2 反汇编</h3><h4 id="（1）反汇编流程"><a class="header-anchor" href="#（1）反汇编流程">¶</a>（1）反汇编流程</h4><p>基本的反汇编包括4个步骤：</p><ul><li>区分出程序的代码段、数据段</li><li>确定程序的代码入口，解码出所有操作数</li><li>反汇编</li><li>重复上述</li></ul><h4 id="（2）线性扫描算法"><a class="header-anchor" href="#（2）线性扫描算法">¶</a>（2）线性扫描算法</h4><h4 id="（3）递归下降扫描算法"><a class="header-anchor" href="#（3）递归下降扫描算法">¶</a>（3）递归下降扫描算法</h4><h3 id="2-2-3-代码混淆"><a class="header-anchor" href="#2-2-3-代码混淆">¶</a>2.2.3 代码混淆</h3><p>代码混淆是将计算机程序转换成更难读懂的变形</p><p>分类：</p><ul><li>程序源代码混淆</li><li>二进制代码混淆<ul><li>反反汇编的混淆<ul><li>对抗静态反汇编：如混淆和加壳</li><li>对抗动态反汇编</li></ul></li><li>指令控制流混淆</li></ul></li></ul><h3 id="2-2-4-反调试"><a class="header-anchor" href="#2-2-4-反调试">¶</a>2.2.4 反调试</h3><p>由于程序逆向分析行业中有动态调试方法，所以对抗地有了反调试技术</p><h4 id="（1）基于调试特征检测的反调试"><a class="header-anchor" href="#（1）基于调试特征检测的反调试">¶</a>（1）基于调试特征检测的反调试</h4><h4 id="（2）基于调试特征隐藏代码"><a class="header-anchor" href="#（2）基于调试特征隐藏代码">¶</a>（2）基于调试特征隐藏代码</h4><h2 id="2-3-Windows操作系统基础"><a class="header-anchor" href="#2-3-Windows操作系统基础">¶</a>2.3 Windows操作系统基础</h2><h3 id="2-3-1-PE文件结构"><a class="header-anchor" href="#2-3-1-PE文件结构">¶</a>2.3.1 PE文件结构</h3><p>可以把博客打印出来看<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE298.png" alt=""></p><h3 id="2-3-2-进程管理"><a class="header-anchor" href="#2-3-2-进程管理">¶</a>2.3.2 进程管理</h3><p>Windows的进程由一个EPROCESS块来表示，包含了PCB、PEB的<strong>指针</strong>等等<br>EPROCESS位于系统内核空间中，<strong>PEB位于进程地址空间中</strong>，其中有一些需要<strong>用户模式</strong>的代码修改的信息</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE297.png" alt=""></p><h3 id="2-3-3-线程管理"><a class="header-anchor" href="#2-3-3-线程管理">¶</a>2.3.3 线程管理</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE296.png" alt=""></p><h3 id="2-3-4-内存管理"><a class="header-anchor" href="#2-3-4-内存管理">¶</a>2.3.4 内存管理</h3><p>内存分为系统态的和用户态的</p><p>Windows内存管理器对内存进行管理，主要有两个功能：</p><ul><li>虚存地址转实存地址：分页寻址，找页表地址——&gt;找页地址——&gt;取数据</li><li>内存不足时将数据换页到物理磁盘：按需换页，等页错误时，挑一种方法来换页</li></ul><h3 id="2-3-5-对象与句柄管理"><a class="header-anchor" href="#2-3-5-对象与句柄管理">¶</a>2.3.5 对象与句柄管理</h3><h3 id="2-3-6-文件系统"><a class="header-anchor" href="#2-3-6-文件系统">¶</a>2.3.6 文件系统</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件安全分析与应用》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Scraps of Study or Life Skills</title>
      <link href="2020/12/15/Scraps-of-Study-or-Life-Skills/"/>
      <url>2020/12/15/Scraps-of-Study-or-Life-Skills/</url>
      
        <content type="html"><![CDATA[<h1>Convert ppt to pdf automatically</h1><p><a href="https://sspai.com/post/44122">一键批量将PPT/Word文档转为PDF</a></p><h1>你需要来自xxx的权限才能更改……</h1><p><a href="https://blog.csdn.net/lanluyug/article/details/76559748">你需要来自XXX的权限才能对此文件夹进行更改 win10</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Tiny Skills </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter4 程序切片</title>
      <link href="2020/12/14/Chapter-4-%E7%A8%8B%E5%BA%8F%E5%88%87%E7%89%87/"/>
      <url>2020/12/14/Chapter-4-%E7%A8%8B%E5%BA%8F%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-概述"><a class="header-anchor" href="#4-1-概述">¶</a>4.1 概述</h2><h4 id="（1）程序切片定义"><a class="header-anchor" href="#（1）程序切片定义">¶</a>（1）程序切片定义</h4><ul><li>一种重要的程序分解技术</li><li>从程序中提取</li></ul><h4 id="（2）“分解”在软工中的运用"><a class="header-anchor" href="#（2）“分解”在软工中的运用">¶</a>（2）“分解”在软工中的运用</h4><p>见书P99-100</p><h2 id="4-2-程序切片初探"><a class="header-anchor" href="#4-2-程序切片初探">¶</a>4.2 程序切片初探</h2><h3 id="4-2-1-切片相关基础知识"><a class="header-anchor" href="#4-2-1-切片相关基础知识">¶</a>4.2.1 切片相关基础知识</h3><h4 id="（1）控制流"><a class="header-anchor" href="#（1）控制流">¶</a>（1）控制流</h4><p>程序中一系列指令（语句、函数调用）执行的顺序<br>程序指令分类：</p><ul><li>具备一定独立性的<strong>功能性指令</strong></li><li>对指令执行顺序进行<strong>控制的指令</strong>——&gt;形成特定的控制结构</li></ul><h4 id="（2）控制结构"><a class="header-anchor" href="#（2）控制结构">¶</a>（2）控制结构</h4><p>三种基本结构：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201214144554.png" alt=""></p><h4 id="（3）数据流"><a class="header-anchor" href="#（3）数据流">¶</a>（3）数据流</h4><p>数据在指令间变化（产生、传递、复制和消失）的过程</p><h4 id="1-控制流分析"><a class="header-anchor" href="#1-控制流分析">¶</a>1. 控制流分析</h4><h4 id="（1）基本块的定义"><a class="header-anchor" href="#（1）基本块的定义">¶</a>（1）基本块的定义</h4><ul><li>程序只能从第一条指令进入该基本块</li><li>离开该基本块前的最后一条指令必须是基本块的最后一条指令</li></ul><h4 id="（2）基本块的计算方法"><a class="header-anchor" href="#（2）基本块的计算方法">¶</a>（2）基本块的计算方法</h4><ul><li>遍历所有指令，如果指令是：整个程序的入口指令/函数入口指令/跳转指令的目的指令，则纳入“入口指令集合”</li><li>遍历所有指令，如果该指令是：<ul><li>入口指令：为它初始化一个基本块，往后收指令直到遇到的指令是入口指令</li><li>其他指令：纳入当前在扩展的基本块</li></ul></li></ul><h4 id="（3）控制流图CFG构造算法"><a class="header-anchor" href="#（3）控制流图CFG构造算法">¶</a>（3）控制流图CFG构造算法</h4><p>对于每个基本块：</p><ul><li>找到最后一条指令，如果它是：<ul><li>跳转指令：则在此指令所在基本块和它跳往的基本块之间添加边</li><li>非跳转指令：则在此指令所在基本块和它后继的基本块之间添加边</li></ul></li></ul><p>另外说下CFG中几个概念：</p><ul><li>直接前驱/直接后继：有边相连的</li><li>如果从entry到b的所有路径都经过a，那么a支配b，且a为b的前必经结点，若a!=b，还可以说是严格前必经结点……</li><li>后必经结点：</li></ul><h4 id="2-数据流分析"><a class="header-anchor" href="#2-数据流分析">¶</a>2.数据流分析</h4><p>对于一条语句，有两种分析：</p><ul><li>可到达定义分析：该语句中引用的变量是哪些语句定义的</li><li>变量活性定义：该语句定义的变量在后续哪些语句被重新定义/引用</li></ul><h4 id="3-可到达定义"><a class="header-anchor" href="#3-可到达定义">¶</a>3.可到达定义</h4><h4 id="（1）路径的定义"><a class="header-anchor" href="#（1）路径的定义">¶</a>（1）路径的定义</h4><p>给每条语句的前后都标号，直白点说，就是插在各语句之间，然后用P来描述路径<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103185730.png" alt=""></p><h4 id="（2）可到达定义的概念"><a class="header-anchor" href="#（2）可到达定义的概念">¶</a>（2）可到达定义的概念</h4><p>见书</p><h4 id="（3）可到达定义的计算方法"><a class="header-anchor" href="#（3）可到达定义的计算方法">¶</a>（3）可到达定义的计算方法</h4><p>首先，对于语句s，我们有四个概念需要知道，这些集合的元素都是语句：</p><ul><li>Gen(s)：s给出变量定义</li><li>Kill(s)：覆盖了某某语句对某变量的定义，这个某某语句就是被消灭的</li><li>In(s)：在s语句前有效的定义语句集合</li><li>Out(s)：Out(s)=In(s)+s产生的语句-s消灭的语句</li></ul><p>算法：</p><ul><li>遍历所有基本块：In设为空集，Out=Gen</li><li>设置变量Change为true</li><li>while Change：<ul><li>遍历所有基本块，对于b：<ul><li>In(b)=b的前驱基本块的Out集的并集</li><li>记录OldOut=Out(b),OldIn=In(b)</li><li>Out(b)=Gen(b)∪(In(b)-Kill(b))</li><li>如果现在的Out和In与OldOut和OldIn都完全相同<ul><li>设置Change=false //也就是收敛了</li></ul></li><li>否则<ul><li>设置Change=true</li></ul></li></ul></li></ul></li></ul><p>以上流程可以执行很多次，值得注意的是，只有In和Out在变：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103193925.png" alt=""></p><p>注意两个要点：</p><ul><li>计算时用的In、Out都是最新的</li><li>Kill的计算有点迷惑（？）</li></ul><h4 id="4-活性分析"><a class="header-anchor" href="#4-活性分析">¶</a>4.活性分析</h4><h4 id="（1）变量是否活跃"><a class="header-anchor" href="#（1）变量是否活跃">¶</a>（1）变量是否活跃</h4><p>对于语句p中的变量x，如果p所在的路径上的语句有某一条<strong>用</strong>了x，x在p上是活的</p><h4 id="（2）变量在哪个范围内保持活跃——活性范围"><a class="header-anchor" href="#（2）变量在哪个范围内保持活跃——活性范围">¶</a>（2）变量在哪个范围内保持活跃——活性范围</h4><p>不太懂（？）</p><h4 id="5-程序依赖图"><a class="header-anchor" href="#5-程序依赖图">¶</a>5.程序依赖图</h4><p>在介绍之前，我们来辨析一下各种“关系”：</p><ul><li>两个语句之间的依赖关系：控制流分析和数据流分析</li><li>基本块（或者语句）之间的关系：控制依赖关系和数据依赖关系</li></ul><h4 id="（1）控制依赖关系"><a class="header-anchor" href="#（1）控制依赖关系">¶</a>（1）控制依赖关系</h4><h4 id="（2）数据依赖关系"><a class="header-anchor" href="#（2）数据依赖关系">¶</a>（2）数据依赖关系</h4><h2 id="4-2-2-切片的基本原理"><a class="header-anchor" href="#4-2-2-切片的基本原理">¶</a>4.2.2 切片的基本原理</h2><h2 id="切片作用之一"><a class="header-anchor" href="#切片作用之一">¶</a>切片作用之一</h2><p>调试的时候，为了排除不相干的代码的影响，我们需要有一些条件来过滤出我们感兴趣的代码<br>这个条件就叫“切片准则”</p><h3 id="切片准则"><a class="header-anchor" href="#切片准则">¶</a>切片准则</h3><ul><li>切片准则包含两个要素：目标变量和开始切片的代码位置</li><li>所以切片准则用形式化定义可以表示为一个二元组：&lt;n,V&gt;</li><li>针对动态切片，可以是三元组：&lt;n,V,p&gt;；其中p为一个输入序列</li></ul><h3 id="程序切片技术的发展历程"><a class="header-anchor" href="#程序切片技术的发展历程">¶</a>程序切片技术的发展历程</h3><p>见书P100</p><h3 id="程序切片的步骤与细分类"><a class="header-anchor" href="#程序切片的步骤与细分类">¶</a>程序切片的步骤与细分类</h3><ol><li>程序依赖关系提取：考察控制流和数据流信息</li><li>切片规则制定</li><li>切片生成</li></ol><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201214142921.png" alt=""></p><h3 id="程序切片的应用"><a class="header-anchor" href="#程序切片的应用">¶</a>程序切片的应用</h3><h3 id="符号执行"><a class="header-anchor" href="#符号执行">¶</a>符号执行</h3><p>核心思想：用符号指来表示程序的输入数据，并将程序的运算过程逐指令或逐语句地转换为数学表达式；在CFG的基础上构建<strong>符号执行树</strong></p><h3 id="动态污点标记和非法操作检测"><a class="header-anchor" href="#动态污点标记和非法操作检测">¶</a>动态污点标记和非法操作检测</h3><h2 id="4-3-静态程序切片"><a class="header-anchor" href="#4-3-静态程序切片">¶</a>4.3 静态程序切片</h2><p>以下是静态程序切片的主要两种方法：</p><h3 id="4-3-1-基于数据流方程的切片方法"><a class="header-anchor" href="#4-3-1-基于数据流方程的切片方法">¶</a>4.3.1 基于数据流方程的切片方法</h3><h4 id="Mark-Weiser数据流切片算法"><a class="header-anchor" href="#Mark-Weiser数据流切片算法">¶</a><strong>Mark Weiser数据流切片算法</strong></h4><h3 id="4-3-2-基于图可达性算法的切片方法"><a class="header-anchor" href="#4-3-2-基于图可达性算法的切片方法">¶</a>4.3.2 基于图可达性算法的切片方法</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件安全分析与应用》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序切片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning about Caffe</title>
      <link href="2020/12/14/Learning-about-Caffe/"/>
      <url>2020/12/14/Learning-about-Caffe/</url>
      
        <content type="html"><![CDATA[<h1>Learning References</h1><p><a href="https://www.zhihu.com/question/27982282">深度学习caffe的代码怎么读？</a></p><h1>Setup Caffe</h1><p><a href="https://alberthg.github.io/2018/04/12/Caffe-Windows-%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/">Caffe Windows 配置</a></p><p><a href="https://software.intel.com/content/www/cn/zh/develop/articles/installation-and-configuration-of-bvlc-caffe-under-windows-the-caffe-learning-notes-part1.html">里面有各个版本caffe介绍</a></p><p><a href="https://blog.csdn.net/zb1165048017/article/details/51355143?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-5.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-5.control">【caffe-Windows】caffe+VS2013+Windows无GPU快速配置教程</a></p><h1>Several Questions</h1><h2 id="What-is-CUDA"><a class="header-anchor" href="#What-is-CUDA">¶</a>What is CUDA?</h2><blockquote><p>CUDA（Compute Unified Device Architecture），是显卡厂商NVIDIA推出的运算平台。 CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。 它包含了CUDA指令集架构（ISA）以及GPU内部的并行计算引擎。 开发人员可以使用C语言来为CUDA™架构编写程序，C语言是应用最广泛的一种高级编程语言。所编写出的程序可以在支持CUDA™的处理器上以超高性能运行。CUDA3.0已经开始支持C++和FORTRAN。</p></blockquote><p>哦……原来是让GPU解决问题的啊……我这台没有GPU的电脑难怪在安装CUDA的时候会出错了……</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research Group </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Caffe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gradually Build up my own Blog</title>
      <link href="2020/12/14/Gradually-Build-up-my-own-Blog/"/>
      <url>2020/12/14/Gradually-Build-up-my-own-Blog/</url>
      
        <content type="html"><![CDATA[<h1>Turn off the Auto-created Folder</h1><ul><li>find “_config.yml”</li><li>in the file, find “post_asset…”</li><li>set it to be “false”</li></ul><h1>Turn off auto-number</h1><ul><li>find “_config.yml” in /themes/next</li><li>find “number”</li><li>set it to be “false”</li></ul><h2 id="References"><a class="header-anchor" href="#References">¶</a>References</h2><p><a href="https://io-oi.me/tech/hexo-next-optimization/">打造个性超赞博客 Hexo + NexT + GitHub Pages 的超深度优化</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Tiny Skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog Settings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning about ResNet</title>
      <link href="2020/12/14/Learning-about-ResNet/"/>
      <url>2020/12/14/Learning-about-ResNet/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Fix My Long-broken Python Environment</title>
      <link href="2020/12/14/Fix-My-Long-broken-Python-Environment/"/>
      <url>2020/12/14/Fix-My-Long-broken-Python-Environment/</url>
      
        <content type="html"><![CDATA[<h1>Use Anaconda to Manage Python Environments</h1><p><a href="https://blog.csdn.net/u014628771/article/details/80066624">Anaconda 查看、创建、管理和使用python环境</a></p><p>If <code>conda activate your-env-name</code> won’t work, we can use <code>activate your-env-name</code></p><h1>Pip install time-out</h1><p><a href="https://blog.csdn.net/sxf1061926959/article/details/54091748">pip和conda安装源更改</a></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pandas</span><br></pre></td></tr></tbody></table></figure><h1>Unable to pip install pickle</h1><p><a href="https://stackoverflow.com/questions/48477949/not-able-to-pip-install-pickle-in-python-3-6/48477988">Not able to pip install pickle in python 3.6</a></p><p>try to add <code>D:\anaconda3\envs\python38</code> to <code>Path</code>.</p><h1>PyCharm远程连接到服务器</h1><p><a href="https://blog.csdn.net/yeler082/article/details/83818771?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-7.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-7.control">https://blog.csdn.net/yeler082/article/details/83818771?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-7.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-7.control</a></p><h1>PyTorch中指定使用的GPU</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.environ["CUDA_VISIBLE_DEVICES"] = "2"</span><br></pre></td></tr></tbody></table></figure><h1>调用另一个python文件中的代码</h1><p><a href="https://blog.csdn.net/u010412719/article/details/47089883">如何调用另一个python文件中的代码</a></p><p><a href="https://blog.csdn.net/weixin_42159393/article/details/107188710">暴力解</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research Group </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Env Setup </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HongYi Lee: Model Compression Lecture</title>
      <link href="2020/11/08/HongYi-Lee-Model-Compression-Lecture/"/>
      <url>2020/11/08/HongYi-Lee-Model-Compression-Lecture/</url>
      
        <content type="html"><![CDATA[<h2 id="Network-Pruning"><a class="header-anchor" href="#Network-Pruning">¶</a>Network Pruning</h2><h5 id="What’s-it-for"><a class="header-anchor" href="#What’s-it-for">¶</a>What’s it for?</h5><p>Deleting some neurons or weights to make the model smaller.</p><h5 id="Why-can-we-do-that-without-affecting-the-accuracy"><a class="header-anchor" href="#Why-can-we-do-that-without-affecting-the-accuracy">¶</a>Why can we do that(without affecting the accuracy)?</h5><p>We usually believe the network is over-parameterized,<br>That is to say, many neurons’ outputs often turn out to be zero.</p><h5 id="How-about-simply-train-a-smaller-network-at-the-beginning"><a class="header-anchor" href="#How-about-simply-train-a-smaller-network-at-the-beginning">¶</a>How about simply train a smaller network at the beginning?</h5><ul><li>It’s proved that larger network is easier to be optimized.(the problem of local minimum and saddle point become less severe)</li><li>Lottery Ticket Hypothesis<br>When we follow these steps, we’ll get a parameterized pruned network.<br>If we want to train it futher, we shouldn’t give it a random initialization, instead, we should copy the weight from the original initialization of the larger network.And start from this.(Because this initialization is proved to be trainable, so we should still use it.)<br>(Though this seems to be reasonable, another paper put forward a contrast idea.)</li></ul><h5 id="To-drop-neuron-or-drop-weight"><a class="header-anchor" href="#To-drop-neuron-or-drop-weight">¶</a>To drop neuron or drop weight?</h5><h6 id="Weight-pruning"><a class="header-anchor" href="#Weight-pruning">¶</a>Weight pruning</h6><p>We may get an irregular network:</p><ul><li>hard to implement</li><li>hard to speedup(Because GPU’s speedup is based on  matrix manipulation.)</li></ul><p>To solve “irregular”, we may remain those weights and set them to be zero rather than drop them out. But this is meaningless from the perspective of storage.</p><h6 id="Neuron-pruning"><a class="header-anchor" href="#Neuron-pruning">¶</a>Neuron pruning</h6><ul><li>regular</li><li>easy to implement</li><li>easy to speedup</li></ul><h2 id="Knowledge-Distillation"><a class="header-anchor" href="#Knowledge-Distillation">¶</a>Knowledge Distillation</h2><h5 id="How-to-do"><a class="header-anchor" href="#How-to-do">¶</a>How to do?</h5><p>Let a student model learn from a teacher model.<br>Note that the student model doesn’t learn from real data, it learns from outputs of the teacher model which may be wrong.</p><h5 id="Why-is-it-useful"><a class="header-anchor" href="#Why-is-it-useful">¶</a>Why is it useful?</h5><p>Because data from the teacher model may be richer than labels, the student model may be able to classify the piture which it has never seen.</p><h5 id="One-application-for-knowledge-distillation"><a class="header-anchor" href="#One-application-for-knowledge-distillation">¶</a>One application for knowledge distillation</h5><p>Sometimes we use ensemble models to get better performance, but the model maybe too large to be deployed on mobile device.<br>So we can use the average of models’ output as a teacher model 's output to train our student network</p><h2 id="Parameter-Quantization"><a class="header-anchor" href="#Parameter-Quantization">¶</a>Parameter Quantization</h2><h5 id="Ways-to-quantize-weights"><a class="header-anchor" href="#Ways-to-quantize-weights">¶</a>Ways to quantize weights</h5><ul><li>using less bits to represnt a value</li><li>Weight clustering<br>divide weights into groups, for each group, we use the average value to represent members.</li><li>Huffman encoding</li></ul><h5 id="Binary-Weights"><a class="header-anchor" href="#Binary-Weights">¶</a>Binary Weights</h5><ul><li>First of all, we have a network with real value weights and a network with binary weights.</li><li>We randomly initialize “real network”</li><li>Choose the closest binary weight, do gradient descent, follow the direction to update our real weight(to another real weight)</li><li>iterative</li><li>finally arrive at a real weight and we’ll choose the closest binary weight as our result.</li></ul><h2 id="Architecture-Design"><a class="header-anchor" href="#Architecture-Design">¶</a>Architecture Design</h2><h5 id="Low-rank-approximation"><a class="header-anchor" href="#Low-rank-approximation">¶</a>Low rank approximation</h5><p>insert a hidden linear layer with K neuron<br>if well-designed, weights will be less<br>（Not so intuitive，we need some computation to prove that）</p><h5 id="Depthwise-Separable-Convolution"><a class="header-anchor" href="#Depthwise-Separable-Convolution">¶</a>Depthwise Separable Convolution</h5><p>Divide convolution into two steps:</p><ol><li><p>Depthwise Convolution<br>——the number of filters=the number of channels<br>——filters is not three-dimensional<br>——each filter considers one channel</p></li><li><p>Pointwise Convolution<br>——just like the normal convolution<br>——filter is 1*1<br>——the height of the filter=the number of channels</p></li></ol><h5 id="The-connections-between-normal-convolution-and-Depthwise-Separable-Convolution"><a class="header-anchor" href="#The-connections-between-normal-convolution-and-Depthwise-Separable-Convolution">¶</a>The connections between normal convolution and Depthwise Separable Convolution</h5><ul><li>Depthwise Separable Convolution has common ground with inserting a hidden linear layer</li><li>After analyzing the origin of each output, we may discover that the first step of DSC has “weights sharing”.(keep the same performance with less parameters)</li></ul><h2 id="Dynamic-Computation"><a class="header-anchor" href="#Dynamic-Computation">¶</a>Dynamic Computation</h2><p>Possible Solutions:</p><ul><li>Train multiple classifiers:<br>from small to large, and choose the suitable one according to the computational power of the device</li><li>Classifiers at the intermedia layer:<br>Instead of using the final output, we use the output at the intermedia layer.(But the performance is not good always &amp;&amp; classifiers near the input layer will decrease the perfomance(it forces layers to learn more complicate features than before))</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research Group </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Model Compression </tag>
            
            <tag> HongYi Lee </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter9 IP安全</title>
      <link href="2020/10/12/Chapter9-IP%E5%AE%89%E5%85%A8/"/>
      <url>2020/10/12/Chapter9-IP%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>防重放攻击，一般通过序列号或者时间戳</p><h2 id="9-1-IP安全概述"><a class="header-anchor" href="#9-1-IP安全概述">¶</a>9.1 IP安全概述</h2><p>之前学的Kerberos、TLS/SSL、S/MIME、PGP，都是用来保护应用安全的，其实协议安全也很重要<br>在IP中加入认证和加密机制来保障终端用户安全，这样的话，即便上层没有安全机制也可以保证安全</p><p>IP层安全包括：</p><ul><li>认证</li><li>保密</li><li>密钥管理机制：保证密钥交换安全</li></ul><h3 id="9-1-1-IPSec的应用"><a class="header-anchor" href="#9-1-1-IPSec的应用">¶</a>9.1.1 IPSec的应用</h3><h4 id="（1）IPSec适用范围"><a class="header-anchor" href="#（1）IPSec适用范围">¶</a>（1）IPSec适用范围</h4><p>LAN、专用和公用WAN、互联网</p><h4 id="（2）用途"><a class="header-anchor" href="#（2）用途">¶</a>（2）用途</h4><ul><li>通过互联网安全分支机构接入：</li><li>通过互联网进行安全远程访问：</li><li>与合作者建立企业间联网和企业内联网接入：</li><li>加强电子商务安全性：</li></ul><h4 id="（3）IPSec典型方案"><a class="header-anchor" href="#（3）IPSec典型方案">¶</a>（3）IPSec典型方案</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210102220557.png" alt=""></p><h3 id="9-1-2-IPSec的好处"><a class="header-anchor" href="#9-1-2-IPSec的好处">¶</a>9.1.2 IPSec的好处</h3><h3 id="9-1-3-路由应用"><a class="header-anchor" href="#9-1-3-路由应用">¶</a>9.1.3 路由应用</h3><p>IPSec其实在互联网的路由结构中也有很重要的作用，例如它可以确保：</p><ul><li>路由器广播来自授权的路由器</li><li>邻居广播来自授权的路由器</li><li>重定向报文</li><li>路由更新未被伪造</li></ul><h3 id="9-1-4-IPSec文档"><a class="header-anchor" href="#9-1-4-IPSec文档">¶</a>9.1.4 IPSec文档</h3><h3 id="9-1-5-IPSec服务"><a class="header-anchor" href="#9-1-5-IPSec服务">¶</a>9.1.5 IPSec服务</h3><p>IPSec提供以下服务：</p><ul><li>访问控制</li><li>无连接完整性</li><li>数据源认证</li><li>拒绝重放包</li><li>保密性</li><li>受限制的流量保密性</li></ul><p>有两种协议可以提供安全性：</p><ul><li>AH：用于提供消息认证的扩展头</li><li>ESP：加密与认证结合的协议</li></ul><h3 id="9-1-6-传输模式和隧道模式"><a class="header-anchor" href="#9-1-6-传输模式和隧道模式">¶</a>9.1.6 传输模式和隧道模式</h3><p>AH和ESP都用两种模式，这里做个简介：</p><ul><li>传输模式：为上层协议提供保护，也就是对IP数据包的载荷进行保护<ul><li>AH：认证IP载荷+IP报头选中的部分</li><li>ESP：加密和认证IP载荷</li></ul></li><li>隧道模式：对整个IP包提供保护，把原来的包+安全域，一起作为载荷套在新的IP包内<ul><li>AH：认证整个内部IP包+外部IP报头被选中的部分</li><li>ESP：加密和认证整个内部IP包</li></ul></li></ul><h2 id="9-2-IP安全策略"><a class="header-anchor" href="#9-2-IP安全策略">¶</a>9.2 IP安全策略</h2><h3 id="9-2-1-安全关联"><a class="header-anchor" href="#9-2-1-安全关联">¶</a>9.2.1 安全关联</h3><p>IPSec安全策略实际上由两个交互的数据库确定：安全关联数据库SAD和安全策略数据库SPD</p><p>那个图看不太懂（？）</p><p>安全关联SA：发送端与接收端之间用于对它们之间传递的<strong>数据流提供安全服务</strong>的一个单向逻辑连接，如果要双向，就要两个SA<br>SA提供的安全服务取决于使用的安全协议AH/ESP</p><p>一个SA由三个参数确定：</p><ul><li>安全参数索引SPI：</li><li>IP目的地址：目的端点地址</li><li>安全协议标识：AH/ESP</li></ul><p>IPSec使用SA协商的参数（密码算法，相关的参数等等），有一部分在ESP数据包中传送，IPSec感觉定义的是一种“工作流程”？</p><h3 id="9-2-2-安全关联数据库SAD"><a class="header-anchor" href="#9-2-2-安全关联数据库SAD">¶</a>9.2.2 安全关联数据库SAD</h3><p>每个IPSec的实现中都有一个名义的SAD，所谓名义，是说：<br>SAD说明IPSec需要具备的功能，不负责定义具体实现，这个由IPSec自己决定</p><p>SAD中的SA用以下参数定义：</p><p>不同SA的不同组合可以使用户获得自己理想的配置</p><h3 id="9-2-3-安全策略数据库SPD"><a class="header-anchor" href="#9-2-3-安全策略数据库SPD">¶</a>9.2.3 安全策略数据库SPD</h3><p>（突然感觉这个好像防火墙啊！）（？）</p><p>SPD中说明了IP流量与什么SA相关联</p><p>如何用SPD处理IP数据包？</p><ul><li>取IP数据包中的信息（字段值）判断，看符合哪个SPD入口</li><li>如果该数据包存在SA，那就根据对应的入口确定SA</li><li>执行所需的IPSec处理（AH或ESP处理）</li></ul><p>判断字段值可以用选择器，一般依据是IP地址、下层协议等等</p><p>某主机上SPD的一个例子：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103125634.png" alt=""></p><h3 id="9-2-4-IP通信进程"><a class="header-anchor" href="#9-2-4-IP通信进程">¶</a>9.2.4 IP通信进程</h3><h4 id="（1）IPSec作用位置"><a class="header-anchor" href="#（1）IPSec作用位置">¶</a>（1）IPSec作用位置</h4><p>IPSec的作用单位：IP包，如果是往外面发的，则发之前要IPSec处理；如果是收进来的，往上层传的时候要处理</p><h4 id="（2）出站报文"><a class="header-anchor" href="#（2）出站报文">¶</a>（2）出站报文</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE278.png" alt=""></p><h4 id="（3）入站报文"><a class="header-anchor" href="#（3）入站报文">¶</a>（3）入站报文</h4><p>和出站报文的处理不太一样，这里是SAD和SPD二者选其一的</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE277.png" alt=""></p><h2 id="9-3-封装安全载荷ESP"><a class="header-anchor" href="#9-3-封装安全载荷ESP">¶</a>9.3 封装安全载荷ESP</h2><p>这章是对ESP的详解</p><p>ESP可以提供的服务包括：</p><ul><li>机密性</li><li>数据源认证</li><li>中断连接后的完整性</li><li>一次抗重放攻击服务</li><li>流量机密性</li></ul><p>具体提供哪些要看SA的选择</p><h3 id="9-3-1-ESP格式"><a class="header-anchor" href="#9-3-1-ESP格式">¶</a>9.3.1 ESP格式</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE276.png" alt=""></p><h3 id="9-3-2-加密和认证算法"><a class="header-anchor" href="#9-3-2-加密和认证算法">¶</a>9.3.2 加密和认证算法</h3><p>IV</p><p>ICV</p><h3 id="9-3-3-填充"><a class="header-anchor" href="#9-3-3-填充">¶</a>9.3.3 填充</h3><p>填充域有如下几个作用：</p><h3 id="9-3-4-防止重放服务"><a class="header-anchor" href="#9-3-4-防止重放服务">¶</a>9.3.4 防止重放服务</h3><p>IPSec规定了一种窗口模式</p><h3 id="9-3-5-传输模式和隧道模式"><a class="header-anchor" href="#9-3-5-传输模式和隧道模式">¶</a>9.3.5 传输模式和隧道模式</h3><h4 id="（1）两种模式的比较"><a class="header-anchor" href="#（1）两种模式的比较">¶</a>（1）两种模式的比较</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103195235.png" alt=""></p><h4 id="（2）传输模式ESP"><a class="header-anchor" href="#（2）传输模式ESP">¶</a>（2）传输模式ESP</h4><p>传输模式操作流程：</p><ul><li>先加密后认证（认证可选）</li><li>数据包路由到目的地，不需要检查密文部分</li><li>目的节点经检查ESP报头中的SPI，解密数据包</li></ul><h4 id="（3）隧道模式ESP"><a class="header-anchor" href="#（3）隧道模式ESP">¶</a>（3）隧道模式ESP</h4><p>新的IP报头中的信息，可以为路由提供足够信息，但不为流量分析提供信息</p><p>隧道模式操作流程：</p><ul><li>对以ESP为前缀的原IP包，进行加密、认证，封装新的IP报头</li><li>将外部IP包路由，中间路由器和防火墙只检查外部的</li><li>目的地节点解密，把明文数据包在内网中传送，送到目的地主机</li></ul><p>总结一下这两种模式：</p><ul><li>传输模式适合保护（支持ESP特性的）主机之间的连接</li><li>隧道模式在含有防火墙的情况下，可以用来让可信数据包穿过防火墙</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE275.png" alt=""></p><h2 id="9-4-安全关联组合"><a class="header-anchor" href="#9-4-安全关联组合">¶</a>9.4 安全关联组合</h2><p>同一个流量，可能要多个SA组合才能得到想要的IPSec服务，这些SA就叫安全关联束</p><p>SA之间怎么组合成安全关联束呢？</p><ul><li>传输邻接：（？）</li><li>隧道迭代：多层嵌套</li></ul><h3 id="9-4-1-认证和加密"><a class="header-anchor" href="#9-4-1-认证和加密">¶</a>9.4.1 认证和加密</h3><p>下面讨论一下几种实现认证加保密的方法：</p><h4 id="（1）带认证选项的ESP"><a class="header-anchor" href="#（1）带认证选项的ESP">¶</a>（1）带认证选项的ESP</h4><p>先用ESP，然后认证</p><p>（？）IPSec、AH、ESP、SAD、SPD之间的关系是什么？</p><p>认证的是密文而不是明文</p><h4 id="（2）传输邻接"><a class="header-anchor" href="#（2）传输邻接">¶</a>（2）传输邻接</h4><p>加密之后，添加两个报头，内部是ESP，外部是AH</p><h4 id="（3）传输-隧道束"><a class="header-anchor" href="#（3）传输-隧道束">¶</a>（3）传输-隧道束</h4><p>加密之后，添加两个报头，内部是AH，外部是ESP</p><h3 id="9-4-2-安全关联的基本组合"><a class="header-anchor" href="#9-4-2-安全关联的基本组合">¶</a>9.4.2 安全关联的基本组合</h3><p>介绍了IPSec文档中要求的主机必须有的4种SA组合</p><h2 id="9-5-因特网密钥交换"><a class="header-anchor" href="#9-5-因特网密钥交换">¶</a>9.5 因特网密钥交换</h2><p>一个典型的要求：4个密钥——发送者公钥私钥+接收者公钥私钥</p><p>IPSec文档要求支持的密钥管理类型：</p><ul><li>手动类型</li><li>自动类型</li></ul><p>IKE是什么——因特网密钥交换协议</p><p>自动类型的密钥管理默认有：</p><ul><li>Oakley协议</li><li>ISAKMP协议</li></ul><h3 id="9-5-1-密钥确定协议"><a class="header-anchor" href="#9-5-1-密钥确定协议">¶</a>9.5.1 密钥确定协议</h3><p>IKE密钥确定是DH密钥交换算法的细化</p><h4 id="（1）DH算法流程"><a class="header-anchor" href="#（1）DH算法流程">¶</a>（1）DH算法流程</h4><ul><li>选定两个全局参数</li><li>A选一个x，传一个y；B也一样</li><li>每一方都可以算出同一个值</li></ul><h4 id="（2）DH算法优点"><a class="header-anchor" href="#（2）DH算法优点">¶</a>（2）DH算法优点</h4><ul><li>仅在需要时生成密钥</li><li>仅需要全局参数一致</li></ul><h4 id="（3）DH算法弱点"><a class="header-anchor" href="#（3）DH算法弱点">¶</a>（3）DH算法弱点</h4><ul><li>没有认证双方</li><li>易受中间人攻击</li><li>密集型计算易受拥塞攻击</li></ul><h4 id="（4）IKE密钥确定"><a class="header-anchor" href="#（4）IKE密钥确定">¶</a>（4）IKE密钥确定</h4><p>有5点特性：</p><p>2点是原来DH的性质：</p><ul><li>双方协商得到一个组</li><li>双方交换公钥</li></ul><p>3点是防攻击：</p><ul><li>Cookie防拥塞</li><li>随机数防重放</li><li>认证，从而阻止中间人攻击</li></ul><p>接下来是一些细节</p><h4 id="（5）IKEv2密钥交换"><a class="header-anchor" href="#（5）IKEv2密钥交换">¶</a>（5）IKEv2密钥交换</h4><p>感觉是先做密钥交换，再开始交换信息</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103232118.png" alt=""></p><h3 id="9-5-2-报头和载荷格式"><a class="header-anchor" href="#9-5-2-报头和载荷格式">¶</a>9.5.2 报头和载荷格式</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE274.png" alt=""></p><h2 id="9-6-密码套件"><a class="header-anchor" href="#9-6-密码套件">¶</a>9.6 密码套件</h2><p>IPSec和IKE依赖多种密码算法，而且每个算法的参数又多</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter5 网络访问控制和云安全</title>
      <link href="2020/10/12/Chapter5-%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E4%BA%91%E5%AE%89%E5%85%A8/"/>
      <url>2020/10/12/Chapter5-%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E4%BA%91%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-网络访问控制"><a class="header-anchor" href="#5-1-网络访问控制">¶</a>5.1 网络访问控制</h2><p>简称NAC，大概包括：登录认证+决定用户可以访问哪些数据+执行哪些操作+检查用户端设备的安全程度</p><h3 id="5-1-1-网络访问控制系统的组成元素"><a class="header-anchor" href="#5-1-1-网络访问控制系统的组成元素">¶</a>5.1.1 网络访问控制系统的组成元素</h3><h4 id="（1）组成成分"><a class="header-anchor" href="#（1）组成成分">¶</a>（1）组成成分</h4><ul><li>访问请求者AR</li><li>策略服务器</li><li>网络访问服务器NAS</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231195151.png" alt=""></p><h3 id="5-1-2-网络访问强制措施"><a class="header-anchor" href="#5-1-2-网络访问强制措施">¶</a>5.1.2 网络访问强制措施</h3><p>可以对AR使用一种或多种强制措施，以管理其访问</p><p>常用的NAC强制措施见书P114</p><h2 id="5-2-可扩展认证协议EAP"><a class="header-anchor" href="#5-2-可扩展认证协议EAP">¶</a>5.2 可扩展认证协议EAP</h2><p>EAP是网络访问、认证协议的框架，封装了许多认证方法</p><h3 id="5-2-1-认证方法"><a class="header-anchor" href="#5-2-1-认证方法">¶</a>5.2.1 认证方法</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231195844.png" alt=""></p><h3 id="5-2-2-EAP交换协议"><a class="header-anchor" href="#5-2-2-EAP交换协议">¶</a>5.2.2 EAP交换协议</h3><h4 id="（1）EAP目标"><a class="header-anchor" href="#（1）EAP目标">¶</a>（1）EAP目标</h4><p>EAP目标：成功认证</p><p>认证成功标志：EAP信息进行交换，认证者允许被认证者的访问，被认证者同意使用此次访问</p><h4 id="（2）EAP典型布局"><a class="header-anchor" href="#（2）EAP典型布局">¶</a>（2）EAP典型布局</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231201250.png" alt=""></p><h2 id="5-3-IEEE-802-1X基于端口的网络访问控制"><a class="header-anchor" href="#5-3-IEEE-802-1X基于端口的网络访问控制">¶</a>5.3 IEEE 802.1X基于端口的网络访问控制</h2><p>这是为局域网提供访问控制功能的</p><h3 id="5-3-1-802-1X访问控制"><a class="header-anchor" href="#5-3-1-802-1X访问控制">¶</a>5.3.1 802.1X访问控制</h3><h3 id="5-3-2-EAPOL包"><a class="header-anchor" href="#5-3-2-EAPOL包">¶</a>5.3.2 EAPOL包</h3><h2 id="5-4-云计算"><a class="header-anchor" href="#5-4-云计算">¶</a>5.4 云计算</h2><p>将信息技术操作移到联网的基础设施上</p><h3 id="5-4-1-云计算组成元素"><a class="header-anchor" href="#5-4-1-云计算组成元素">¶</a>5.4.1 云计算组成元素</h3><h4 id="（1）云计算定义与组成"><a class="header-anchor" href="#（1）云计算定义与组成">¶</a>（1）云计算定义与组成</h4><h4 id="（2）云计算主要特征"><a class="header-anchor" href="#（2）云计算主要特征">¶</a>（2）云计算主要特征</h4><h4 id="（3）NIST定义的3种服务模型"><a class="header-anchor" href="#（3）NIST定义的3种服务模型">¶</a>（3）NIST定义的3种服务模型</h4><h4 id="（4）NIST定义的4种部署模型"><a class="header-anchor" href="#（4）NIST定义的4种部署模型">¶</a>（4）NIST定义的4种部署模型</h4><h3 id="5-4-2-云计算参考架构"><a class="header-anchor" href="#5-4-2-云计算参考架构">¶</a>5.4.2 云计算参考架构</h3><h2 id="5-5-云安全风险和对策"><a class="header-anchor" href="#5-5-云安全风险和对策">¶</a>5.5 云安全风险和对策</h2><h2 id="5-6-云端数据保护"><a class="header-anchor" href="#5-6-云端数据保护">¶</a>5.6 云端数据保护</h2><h2 id="5-7-云安全即服务"><a class="header-anchor" href="#5-7-云安全即服务">¶</a>5.7 云安全即服务</h2><p>SecaaS——安全服务商提供服务（以前是企业提供）</p><h3 id="5-7-1-SecaaS服务类型"><a class="header-anchor" href="#5-7-1-SecaaS服务类型">¶</a>5.7.1 SecaaS服务类型</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud Securtiy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse Linked List</title>
      <link href="2020/10/09/Reverse-Linked-List/"/>
      <url>2020/10/09/Reverse-Linked-List/</url>
      
        <content type="html"><![CDATA[<h1>Description</h1><p>Reverse a singly linked list.</p><h1>Input&amp;Output</h1><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h1>Analysis</h1><p>感觉二叉树经常会用递归，我们应该一直走到底，将两个叶节点交换，然后再一路往上……<br>妙啊，越写越快了！</p><h1>Code</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() {}</span><br><span class="line"> *     ListNode(int val) { this.val = val; }</span><br><span class="line"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span><br><span class="line"> * }</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">    public ListNode reverseList(ListNode head) {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leetcode Top 100 Liked Questions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Invert Binary Tree</title>
      <link href="2020/09/30/Invert-Binary-Tree/"/>
      <url>2020/09/30/Invert-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h1>Description</h1><p>Invert a binary tree.</p><h1>Input&amp;Output</h1><p><img src="%5CInvert-Binary-Tree%5CIO.png" alt=""></p><h1>Analysis</h1><p>感觉二叉树经常会用递归，我们应该一直走到底，将两个叶节点交换，然后再一路往上……<br>妙啊，越写越快了！</p><h1>Code</h1><pre><code>/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */class Solution {    public TreeNode invertTree(TreeNode root) {        if(root==null){            return null;        }else{            if(root.left==null&amp;&amp;root.right==null){                return root;            }            root.left=invertTree(root.left);            root.right=invertTree(root.right);            TreeNode temp=new TreeNode();            temp=root.left;            root.left=root.right;            root.right=temp;                    return root;        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leetcode Top 100 Liked Questions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Single Number</title>
      <link href="2020/09/30/Single-Number/"/>
      <url>2020/09/30/Single-Number/</url>
      
        <content type="html"><![CDATA[<h1>Description</h1><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p><p><em>NOTE：Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</em></p><h1>Input&amp;Output</h1><p><img src="/2020/09/30/Single-Number/%5CSingle-Number%5CIO.png" alt=""></p><h1>Code</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution {</span><br><span class="line">    public int singleNumber(int[] nums) {</span><br><span class="line">        int i=1;</span><br><span class="line">        </span><br><span class="line">        java.util.Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        if(nums.length==1){</span><br><span class="line">            return nums[0];</span><br><span class="line">        }else if(nums[0]!=nums[1]){</span><br><span class="line">            return nums[0];</span><br><span class="line">        }else if(nums[nums.length-1]!=nums[nums.length-1]){</span><br><span class="line">            return nums[nums.length-1];</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        for(;i&lt;nums.length-1;i++){</span><br><span class="line">            if(nums[i]==nums[i-1]||nums[i]==nums[i+1]){</span><br><span class="line">                continue;</span><br><span class="line">            }else{</span><br><span class="line">                break;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        return nums[i];</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leetcode Top 100 Liked Questions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Depth of Binary Tree</title>
      <link href="2020/09/30/Maximum-Depth-of-Binary-Tree/"/>
      <url>2020/09/30/Maximum-Depth-of-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h1>Description</h1><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><h1>Input&amp;Output</h1><p><img src="/2020/09/30/Maximum-Depth-of-Binary-Tree/%5CMaximum-Depth-of-Binary-Tree%5CIO.png" alt=""></p><h1>Analysis</h1><p>大致的思路是，一直往下，过程中有计数器，到底了就返回数字啥的</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() {}</span><br><span class="line"> *     TreeNode(int val) { this.val = val; }</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     }</span><br><span class="line"> * }</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">    int depth=0;</span><br><span class="line">    </span><br><span class="line">    public int maxDepth(TreeNode root) {</span><br><span class="line">        if(root!=null){</span><br><span class="line">            depth++;</span><br><span class="line">            if(root.left==null&amp;&amp;root.right==null){</span><br><span class="line">                return depth;</span><br><span class="line">            }</span><br><span class="line">            if(root.left!=null&amp;&amp;root.right==null){</span><br><span class="line">                depth=maxDepth(root.left);</span><br><span class="line">            }       </span><br><span class="line">            if(root.left==null&amp;&amp;root.right!=null){</span><br><span class="line">                depth=maxDepth(root.right);</span><br><span class="line">            }</span><br><span class="line">            if(root.left!=null&amp;&amp;root.right!=null){</span><br><span class="line">                int depthTemp=depth;</span><br><span class="line">                int depthLeft=maxDepth(root.left);</span><br><span class="line">                depth=depthTemp;</span><br><span class="line">                int depthRight=maxDepth(root.right);</span><br><span class="line">                depth=depthLeft&gt;depthRight?depthLeft:depthRight;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        return depth;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leetcode Top 100 Liked Questions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter1 Linux操作系统概述</title>
      <link href="2020/09/23/Chapter1-%E6%A6%82%E8%BF%B0/"/>
      <url>2020/09/23/Chapter1-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-认识操作系统"><a class="header-anchor" href="#1-1-认识操作系统">¶</a>1.1 认识操作系统</h2><h3 id="1-1-1-从使用者角度看"><a class="header-anchor" href="#1-1-1-从使用者角度看">¶</a>1.1.1 从使用者角度看</h3><p>不用关心具体实现</p><h3 id="1-1-2-从程序开发者的角度看"><a class="header-anchor" href="#1-1-2-从程序开发者的角度看">¶</a>1.1.2 从程序开发者的角度看</h3><p>不用关心在内存的哪里存放变量，并不需要自己指定</p><h3 id="1-1-3-从操作系统在整个计算机系统所处的位置看"><a class="header-anchor" href="#1-1-3-从操作系统在整个计算机系统所处的位置看">¶</a>1.1.3 从操作系统在整个计算机系统所处的位置看</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE174.png" alt=""></p><h3 id="1-1-4-从操作系统设计者的角度看"><a class="header-anchor" href="#1-1-4-从操作系统设计者的角度看">¶</a>1.1.4 从操作系统设计者的角度看</h3><p>操作系统设计有两个目标：</p><ul><li>方便用户</li><li>资源高效运转</li></ul><p>操作系统必须包含的部分：</p><ul><li>操作系统接口</li><li>CPU管理</li><li>内存管理</li><li>设备管理</li><li>文件管理</li></ul><h3 id="1-1-5-操作系统组成"><a class="header-anchor" href="#1-1-5-操作系统组成">¶</a>1.1.5 操作系统组成</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE173.png" alt=""></p><h2 id="1-2-开放源代码的UNIX-Linux操作系统"><a class="header-anchor" href="#1-2-开放源代码的UNIX-Linux操作系统">¶</a>1.2 开放源代码的UNIX/Linux操作系统</h2><h3 id="1-2-1-UNIX诞生和发展"><a class="header-anchor" href="#1-2-1-UNIX诞生和发展">¶</a>1.2.1 UNIX诞生和发展</h3><h3 id="1-2-2-Linux诞生"><a class="header-anchor" href="#1-2-2-Linux诞生">¶</a>1.2.2 Linux诞生</h3><h3 id="1-2-3-操作系统标准POSIX"><a class="header-anchor" href="#1-2-3-操作系统标准POSIX">¶</a>1.2.3 操作系统标准POSIX</h3><h3 id="1-2-4-GNU和Linux"><a class="header-anchor" href="#1-2-4-GNU和Linux">¶</a>1.2.4 GNU和Linux</h3><h3 id="1-2-5-Linux的开发模式"><a class="header-anchor" href="#1-2-5-Linux的开发模式">¶</a>1.2.5 Linux的开发模式</h3><h2 id="1-3-Linux内核"><a class="header-anchor" href="#1-3-Linux内核">¶</a>1.3 Linux内核</h2><h3 id="1-3-1-Linux内核的技术特点"><a class="header-anchor" href="#1-3-1-Linux内核的技术特点">¶</a>1.3.1 Linux内核的技术特点</h3><h3 id="1-3-2-Linux内核的位置"><a class="header-anchor" href="#1-3-2-Linux内核的位置">¶</a>1.3.2 Linux内核的位置</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210102150309.png" alt=""></p><h3 id="1-3-3-Linux内核体系结构"><a class="header-anchor" href="#1-3-3-Linux内核体系结构">¶</a>1.3.3 Linux内核体系结构</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE172.png" alt=""></p><h2 id="1-4-Linux内核源代码"><a class="header-anchor" href="#1-4-Linux内核源代码">¶</a>1.4 Linux内核源代码</h2><h3 id="1-3-1-Linux内核版本"><a class="header-anchor" href="#1-3-1-Linux内核版本">¶</a>1.3.1 Linux内核版本</h3><h3 id="1-3-2-Linux内核源代码的结构"><a class="header-anchor" href="#1-3-2-Linux内核源代码的结构">¶</a>1.3.2 Linux内核源代码的结构</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210102151334.png" alt=""></p><h3 id="1-3-3-Linux内核源代码分析工具"><a class="header-anchor" href="#1-3-3-Linux内核源代码分析工具">¶</a>1.3.3 Linux内核源代码分析工具</h3><h2 id="1-5-Linux内核模块编程入门"><a class="header-anchor" href="#1-5-Linux内核模块编程入门">¶</a>1.5 Linux内核模块编程入门</h2><p>内核模块=模块=动态可加载内核模块LKM</p><p>模块机制是一个插口，实现可扩展性，弥补单内核的缺陷</p><h3 id="1-5-1-模块的定义"><a class="header-anchor" href="#1-5-1-模块的定义">¶</a>1.5.1 模块的定义</h3><p>模块可以被单独编译，但是不能单独运行，运行时被链接到内核作为内核的一部分在<strong>内核空间</strong>运行</p><h3 id="1-5-2-编写一个简单的模块"><a class="header-anchor" href="#1-5-2-编写一个简单的模块">¶</a>1.5.2 编写一个简单的模块</h3><h4 id="（1）程序举例"><a class="header-anchor" href="#（1）程序举例">¶</a>（1）程序举例</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE171.png" alt=""></p><h4 id="（2）编译"><a class="header-anchor" href="#（2）编译">¶</a>（2）编译</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#Makefile2.6</span><br><span class="line">obj-m : = hellomod.o #产生hellomod模块的目标文件</span><br><span class="line">CURRENT_PATH : = $ (shell pwd) #模块所在的当前路径，这里直接用shell命令获取</span><br><span class="line">LINUX_KERNEL : = $(shell uname - r) #Linux内核源代码的当前版本</span><br><span class="line">LINUX_KERNEL_PATH : = /usr/src/linux - headers - $ (LINUX_KERNEL)  #Linux内核源代码的绝对路径</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">make -c $ (LINUX_KERNEL_PATH)M = $ ( CURRENT_PATH) modules   #编译模块</span><br><span class="line">clean:</span><br><span class="line">make -c $ (LINUX_KERNEL_PATH)M= $ ( CURRENT_PATH) clean    #井清理</span><br></pre></td></tr></tbody></table></figure><h4 id="（3）运行"><a class="header-anchor" href="#（3）运行">¶</a>（3）运行</h4><p>插入和移除就不说了，说下printk</p><p>可以用tail /var/log/message查看日志</p><h3 id="1-5-3-应用程序与内核模块的比较"><a class="header-anchor" href="#1-5-3-应用程序与内核模块的比较">¶</a>1.5.3 应用程序与内核模块的比较</h3><h2 id="1-6-Linux内核中链表的实现及应用"><a class="header-anchor" href="#1-6-Linux内核中链表的实现及应用">¶</a>1.6 Linux内核中链表的实现及应用</h2><p>链表是Linux内核中最简单、最常用的一种数据结构</p><p><strong>值得注意的是，它们的内存无需占用连续的单元</strong></p><h3 id="1-6-1-链表的演化"><a class="header-anchor" href="#1-6-1-链表的演化">¶</a>1.6.1 链表的演化</h3><h3 id="1-6-2-链表的定义和操作"><a class="header-anchor" href="#1-6-2-链表的定义和操作">¶</a>1.6.2 链表的定义和操作</h3><h3 id="1-6-3-链表的应用"><a class="header-anchor" href="#1-6-3-链表的应用">¶</a>1.6.3 链表的应用</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《Linux操作系统原理与应用(E2)》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter3 公钥密码和消息认证</title>
      <link href="2020/09/23/Chapter3-%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%92%8C%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81/"/>
      <url>2020/09/23/Chapter3-%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%92%8C%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-消息认证方法"><a class="header-anchor" href="#3-1-消息认证方法">¶</a>3.1 消息认证方法</h2><h3 id="3-1-0-引言"><a class="header-anchor" href="#3-1-0-引言">¶</a>3.1.0 引言</h3><p>加密这个手段，自然的就可以防止被动攻击了；不过我们还需要满足防止主动攻击（伪造数据和业务）的需求————对应的办法就是消息认证。<br>首先，什么是可信？<br>可信就是，数据真实且来自合法来源，消息认证就是认证数据可不可信的。<br>对应着可信的两方面定义，认证要做的就是判断消息被篡改与否+来源合法与否，此外还有可能要验证数据时效性、消息流顺序等等</p><h3 id="3-1-1-利用常规加密的消息认证"><a class="header-anchor" href="#3-1-1-利用常规加密的消息认证">¶</a>3.1.1 利用常规加密的消息认证</h3><p>常规就是说简单的对称加密这样子，但是对于分组对称加密会出现问题。<br>假如攻击者想换动消息流之间的顺序，那么由于是分组的，所以B还是能每组都正常解密……<br>但通常情况下，分组的重排其实还是能算是一种威胁</p><h3 id="3-1-2-非加密的消息认证"><a class="header-anchor" href="#3-1-2-非加密的消息认证">¶</a>3.1.2 非加密的消息认证</h3><h4 id="（1）认证与加密"><a class="header-anchor" href="#（1）认证与加密">¶</a>（1）认证与加密</h4><p>把这两个词放一起的时候，我常常感觉……很迷糊，现在理一理：<br>一般来说认证和加密是两个功能，说一句话可能会让关系更明白：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如我们有一个对消息作处理的算法，这里面可以包含两步操作：先对消息加密，再打上认证标签；这样我们就可以说：把消息的认证和保密结合起来了</span><br></pre></td></tr></tbody></table></figure><p>在满足安全需求这件事上，认证和加密是各有应用场景的</p><h4 id="（2）什么时候可以不加密只认证呢？"><a class="header-anchor" href="#（2）什么时候可以不加密只认证呢？">¶</a>（2）什么时候可以不加密只认证呢？</h4><ol><li>相同消息广播时，只由一端负责监控的系统执行认证（不是很理解，直观是什么样的？）</li><li>交换信息时，某一端负载太大不能全部解密，就会随机抽一些进行认证</li><li>程序可以用明文+认证标签，节省处理器解密的消耗</li></ol><h4 id="（3）消息认证码MAC"><a class="header-anchor" href="#（3）消息认证码MAC">¶</a>（3）消息认证码MAC</h4><p>定义：用私钥产生一小块数据，它可以作为MAC<br>工作流程：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/MAC.png" alt=""></p><ul><li>A和B共享一个密钥K</li><li>A给B发消息的时候，A用(消息+K)生成MAC，再把消息和MAC一起发给B</li><li>B收到以后，算一算MAC对不对</li></ul><p><em>值得注意的是，认证算法不需要可逆，因为B验证的时候和A是一样的操作（与加密相比更不容易被破）</em></p><h4 id="（4）单向散列函数"><a class="header-anchor" href="#（4）单向散列函数">¶</a>（4）单向散列函数</h4><p>这是MAC的一种替代品，不同之处在于：<strong>MAC需要密钥而单向散列不需要</strong>，它只是输入M得到H(M)而已。</p><p>H函数可以有以下三种形式：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/HASH.png" alt=""></p><ul><li>传统加密：先hash再加密</li><li>公钥加密：先hash再用公钥加密</li><li>秘密值加密：原消息与秘密值Secret一起hash，结果和原消息拼接</li></ul><p>（详细见P50-51）</p><h2 id="3-2-安全散列函数"><a class="header-anchor" href="#3-2-安全散列函数">¶</a>3.2 安全散列函数</h2><h3 id="3-2-1-散列函数的要求"><a class="header-anchor" href="#3-2-1-散列函数的要求">¶</a>3.2.1 散列函数的要求</h3><ol><li>输入长度不受限制</li><li>输出长度固定</li><li>从x——&gt;H(x)容易计算</li><li>单向性/抗原像攻击性：从H(x)——&gt;x计算上不可行</li><li>抗弱碰撞攻击性/抗第二原像攻击性：对于x，找一个和它哈希值相同的y从计算上不可行</li><li>抗碰撞性/抗强碰撞性：找到任意一对哈希值相同的x，y计算上不可行（可以防止生日攻击）</li></ol><h3 id="3-2-2-散列函数的安全性"><a class="header-anchor" href="#3-2-2-散列函数的安全性">¶</a>3.2.2 散列函数的安全性</h3><p>攻击方法：密码分析法+蛮力攻击法<br>前者利用密码算法的缺陷，后者是要付出指数级代价的（不过2004年王小云教授破了MD5！）</p><h3 id="3-2-3-简单散列函数"><a class="header-anchor" href="#3-2-3-简单散列函数">¶</a>3.2.3 简单散列函数</h3><h4 id="（1）散列函数基本原理"><a class="header-anchor" href="#（1）散列函数基本原理">¶</a>（1）散列函数基本原理</h4><p>把消息按照n比特每块划分，迭代地每次处理一块，最后生成n比特的散列函数</p><h4 id="（2）一种最简单的散列函数"><a class="header-anchor" href="#（2）一种最简单的散列函数">¶</a>（2）一种最简单的散列函数</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230095511.png" alt=""></p><p>对于随机数据的完整性校验很有效，书上有一些数学推导和改进；但是这些改进并不是很有效……</p><p>举个例子，如果我们想替换一个假消息上去，为了让散列函数不变，我们可以根据需要附加一个n比特的数据块，想怎么调怎么调，非常容易生成相同的散列码……所以我们可以考虑散列码拼在消息后面以后，对整个进行加密</p><h3 id="3-2-4-SHA安全散列函数"><a class="header-anchor" href="#3-2-4-SHA安全散列函数">¶</a>3.2.4 SHA安全散列函数</h3><p>SHA-1有时候也叫加密散列码，码和函数貌似差不多，不要纠结<br>经过一段时间的发展，现在主要是用SHA-2：</p><blockquote><p>SHA-2，名称来自于安全散列算法2（英语：Secure Hash Algorithm 2）的缩写，一种密码散列函数算法标准，由美国国家安全局研发[3]，由美国国家标准与技术研究院（NIST）在2001年发布。属于SHA算法之一，是SHA-1的后继者。其下又可再分为六个不同的算法标准，包括了  ：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230104252.png" alt=""></p></blockquote><p>这里介绍一下SHA-512：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE2.png" alt=""></p><p>（？）M和K是干嘛的？</p><p>书上有些安全性的数学表达</p><h2 id="3-3-消息认证码MAC"><a class="header-anchor" href="#3-3-消息认证码MAC">¶</a>3.3 消息认证码MAC</h2><h3 id="3-3-1-HMAC"><a class="header-anchor" href="#3-3-1-HMAC">¶</a>3.3.1 HMAC</h3><h4 id="（1）为什么会有HMAC呢？"><a class="header-anchor" href="#（1）为什么会有HMAC呢？">¶</a>（1）为什么会有HMAC呢？</h4><p>首先，由于SHA-1软件实现速度快、有许多共享的Hash函数代码库等优点，人们逐渐将它用于MAC。但是为了<strong>把密钥合并到散列算法</strong>中（本身做散列函数是不需要密钥的），人们开发出了HMAC</p><h4 id="（2）HMAC的设计目标"><a class="header-anchor" href="#（2）HMAC的设计目标">¶</a>（2）HMAC的设计目标</h4><ul><li>不用大改散列函数</li><li>嵌入的散列函数可移植，便于二次开发</li><li>保持性能</li><li>使用、处理密钥简单</li><li>知散列函数强度——&gt;知HMAC强度</li></ul><p><strong>把散列函数模块化是个不错的做法</strong></p><h4 id="（3）HMAC的算法设计"><a class="header-anchor" href="#（3）HMAC的算法设计">¶</a>（3）HMAC的算法设计</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE12.png" alt=""></p><h3 id="3-3-2-基于分组密码的MAC"><a class="header-anchor" href="#3-3-2-基于分组密码的MAC">¶</a>3.3.2 基于分组密码的MAC</h3><h4 id="（1）基于密文的消息认证码CMAC"><a class="header-anchor" href="#（1）基于密文的消息认证码CMAC">¶</a>（1）基于密文的消息认证码CMAC</h4><p>适用于AES和3DES</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230125126.png" alt=""></p><h4 id="（2）具有密码块链式信息认证码的计数器CCM"><a class="header-anchor" href="#（2）具有密码块链式信息认证码的计数器CCM">¶</a>（2）具有密码块链式信息认证码的计数器CCM</h4><p>（？）好迷惑的名字</p><p>又叫认证加密模式<br>CCM=AES+CTR操作模式（2.5节提过）+CMAC认证算法</p><p>认证和加密一直是被设计成两种单独的服务的，前者保证可靠性（完整性），后者保证机密性</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230130735.png" alt=""></p><p>感觉有点改进后的散列算法的味道，最后送出的是加密的消息+加密的标签（由消息生成）</p><h2 id="3-4-公钥密码原理"><a class="header-anchor" href="#3-4-公钥密码原理">¶</a>3.4 公钥密码原理</h2><h3 id="3-4-1-公钥密码思想"><a class="header-anchor" href="#3-4-1-公钥密码思想">¶</a>3.4.1 公钥密码思想</h3><p>公钥密码基于数学函数，可以用于加密、消息认证、密钥分发</p><h4 id="（1）常见误解"><a class="header-anchor" href="#（1）常见误解">¶</a>（1）常见误解</h4><ul><li>公钥比对称密码更安全</li><li>公钥密码淘汰了传统密码</li><li>公钥密码实现的密钥分发比传统密码简单的多</li></ul><p>以上，都是错的</p><h4 id="（2）公钥密码的组成"><a class="header-anchor" href="#（2）公钥密码的组成">¶</a>（2）公钥密码的组成</h4><ul><li>明文、密文</li><li>公钥、私钥</li><li>加密算法、解密算法</li></ul><p>都是成双成对哒~</p><h4 id="（3）公钥密码算法基本流程"><a class="header-anchor" href="#（3）公钥密码算法基本流程">¶</a>（3）公钥密码算法基本流程</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230132126.png" alt=""></p><h3 id="3-4-2-公钥密码系统的应用"><a class="header-anchor" href="#3-4-2-公钥密码系统的应用">¶</a>3.4.2 公钥密码系统的应用</h3><p>发送者用什么，有三种情况：</p><ul><li>用自己私钥：数字签名1</li><li>用对方公钥：加密/解密2</li><li>两者都用</li></ul><p>3密钥交换：双方互换会话密钥</p><p>123是公钥密码的三种应用，不同的算法对这几种应用的支持也不同</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230132641.png" alt=""></p><h3 id="3-4-3-公钥密码的要求"><a class="header-anchor" href="#3-4-3-公钥密码的要求">¶</a>3.4.3 公钥密码的要求</h3><p>见书P63</p><h2 id="3-5-公钥密码算法"><a class="header-anchor" href="#3-5-公钥密码算法">¶</a>3.5 公钥密码算法</h2><p>本节重点介绍RSA+DH，简要介绍DSS+椭圆曲线</p><h3 id="3-5-1-RSA"><a class="header-anchor" href="#3-5-1-RSA">¶</a>3.5.1 RSA</h3><p>基于大数分解的困难</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230140625.png" alt=""></p><h3 id="3-5-2-Diffie-Hellman"><a class="header-anchor" href="#3-5-2-Diffie-Hellman">¶</a>3.5.2 Diffie-Hellman</h3><p>基于离散对数计算的困难</p><p>由于DH只有密钥交换的应用，所以通常被叫做DH密钥交换</p><h4 id="（1）算法"><a class="header-anchor" href="#（1）算法">¶</a>（1）算法</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230141939.png" alt=""></p><p>这种会受到中间人攻击，见（3）</p><h4 id="（2）使用DH的另外一个例子"><a class="header-anchor" href="#（2）使用DH的另外一个例子">¶</a>（2）使用DH的另外一个例子</h4><p>见书P68</p><h4 id="（3）DH的中间人攻击"><a class="header-anchor" href="#（3）DH的中间人攻击">¶</a>（3）DH的中间人攻击</h4><p>见书P68-69</p><h3 id="3-5-3-其他公钥密码算法"><a class="header-anchor" href="#3-5-3-其他公钥密码算法">¶</a>3.5.3 其他公钥密码算法</h3><h4 id="（1）ECC"><a class="header-anchor" href="#（1）ECC">¶</a>（1）ECC</h4><h4 id="（2）DSS"><a class="header-anchor" href="#（2）DSS">¶</a>（2）DSS</h4><h2 id="3-6-数字签名"><a class="header-anchor" href="#3-6-数字签名">¶</a>3.6 数字签名</h2><p>应用场景：Bob希望给Alice发送消息，消息保不保密不重要，但是需要Alice能确认这条消息确实来自于他；所以用Bob的私钥加密的消息就叫做数字签名</p><p>数字签名保证可靠性+完整性（没有Bob的私钥是不能篡改消息的）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Public-key cryptography </tag>
            
            <tag> Message authentication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter4 密钥分配和用户认证</title>
      <link href="2020/09/23/Chapter4-%E5%AF%86%E9%92%A5%E5%88%86%E9%85%8D%E5%92%8C%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/"/>
      <url>2020/09/23/Chapter4-%E5%AF%86%E9%92%A5%E5%88%86%E9%85%8D%E5%92%8C%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-基于对称加密的密钥分配"><a class="header-anchor" href="#4-1-基于对称加密的密钥分配">¶</a>4.1 基于对称加密的密钥分配</h2><p>在对称加密的情境下，双方需要共享同一个密钥，并且只能他两知道。A，B有这几种选择：</p><ol><li>A选密钥，物理方法传给B</li><li>第三方选密钥，物理方法传给A、B</li><li>（A、B不久前用过一个共同密钥）A/B把旧密钥加密的新密钥给B/A</li><li>（A、B各有到达第三方C的加密链路）C在加密链路上传给A、B</li></ol><p>主要讲讲第四种，其中需要两种密钥：</p><ul><li>会话密钥：一次性的，双方想说话的时候才有，用完就销毁</li><li>永久密钥：用于分发会话密钥（注意不是只有一个，是KDC与A之间有一个，KDC与B之间有一个的概念）</li></ul><p>其中提到的第三方C其实有个学名：密钥分发中心KDC，它有如下任务：</p><ul><li>决定哪些系统之间可以通信</li><li>可以的话，负责分发会话密钥</li></ul><p>KDC的操作过程：</p><ol><li>A想和B说话了</li><li>A用主密钥（？）（只有A和KDC共享），给KDC发请求包</li><li>KDC判断允不允许，允许的话则产生一次性会话密钥<ul><li>用永久密钥（KDC与A）加密会话密钥，发给A</li><li>用永久密钥（KDC与B）加密会话密钥，发给A</li></ul></li><li>A、B可以通话了！</li></ol><p>实现了上述操作过程的一种服务是Kerberos</p><h2 id="4-2-Kerberos"><a class="header-anchor" href="#4-2-Kerberos">¶</a>4.2 Kerberos</h2><h3 id="4-2-0-引言"><a class="header-anchor" href="#4-2-0-引言">¶</a>4.2.0 引言</h3><h4 id="（1）要解决的问题"><a class="header-anchor" href="#（1）要解决的问题">¶</a>（1）要解决的问题</h4><p>分布式环境中，控制访问权限，为用户<strong>提供认证服务</strong></p><h4 id="（2）三种威胁"><a class="header-anchor" href="#（2）三种威胁">¶</a>（2）三种威胁</h4><ol><li>用户可以伪装成其他用户</li><li>伪造网络地址发消息</li><li>监听消息/重放攻击</li></ol><p>Kerberos<strong>仅依赖于对称加密</strong>；此外，版本4逐渐被淘汰，现在常用版本5</p><h3 id="4-2-1-Kerberos版本4"><a class="header-anchor" href="#4-2-1-Kerberos版本4">¶</a>4.2.1 Kerberos版本4</h3><p>接下来逐步介绍到协议</p><h4 id="（1）一个简单的认证会话"><a class="header-anchor" href="#（1）一个简单的认证会话">¶</a>（1）一个简单的认证会话</h4><p>来看下面这个会话：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE60.png" alt=""></p><p>书上说明了第（3）步中消息每一部分的必要性</p><h4 id="（2）一个更安全的认证会话"><a class="header-anchor" href="#（2）一个更安全的认证会话">¶</a>（2）一个更安全的认证会话</h4><p>上述方式仍然存在问题：</p><ul><li>用户可能访问不同服务器，甚至多次访问同一服务器时，都要重新输入密码</li><li>消息（1）是明文传送口令的，被窃听了就完了QWQ</li></ul><p>为了解决上述问题，我们作如下改进：</p><ul><li>引入票据服务器TGS</li><li>提出避免明文传口令的方案</li></ul><p>具体流程如下：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230230940.png" alt=""></p><h4 id="（3）真正的Kerbores认证对话！"><a class="header-anchor" href="#（3）真正的Kerbores认证对话！">¶</a>（3）真正的Kerbores认证对话！</h4><p>没想到吧……上面的图已经那么完备了却还是存在缺陷……那么问题在哪呢？</p><ul><li>票据的有效期太长也不好，太短也不好；根本问题是，服务器要能判断持有票据的是正确的人</li><li>服务器也有被假冒的风险，所以它要向用户证明自己的身份</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE112.png" alt=""></p><h3 id="4-2-1-Kerberos版本5"><a class="header-anchor" href="#4-2-1-Kerberos版本5">¶</a>4.2.1 Kerberos版本5</h3><h4 id="（1）版本4与版本5的不同"><a class="header-anchor" href="#（1）版本4与版本5的不同">¶</a>（1）版本4与版本5的不同</h4><h4 id="（2）版本5的认证对话"><a class="header-anchor" href="#（2）版本5的认证对话">¶</a>（2）版本5的认证对话</h4><h2 id="4-3-基于非对称加密的密钥分配"><a class="header-anchor" href="#4-3-基于非对称加密的密钥分配">¶</a>4.3 基于非对称加密的密钥分配</h2><h3 id="4-3-0-引言"><a class="header-anchor" href="#4-3-0-引言">¶</a>4.3.0 引言</h3><p>公钥加密一个重要作用：处理密钥分发（公钥的分发+使用公钥加密分发私钥）</p><h3 id="4-3-1-公钥证书"><a class="header-anchor" href="#4-3-1-公钥证书">¶</a>4.3.1 公钥证书</h3><ul><li>为什么要有公钥证书？<br>就像邮箱、银行卡号这种公钥，它们是广而告之的；但是你怎么知道他说这是就是呢？万一伪造了呢？所以我们引入第三方、公钥证书这些来验证。</li><li>X.509标准是人们广泛接受的公钥证书格式</li></ul><h3 id="4-3-2-基于公钥密码的秘密密钥分发"><a class="header-anchor" href="#4-3-2-基于公钥密码的秘密密钥分发">¶</a>4.3.2 基于公钥密码的秘密密钥分发</h3><p>对称密钥中，任何一对通信者之间共享唯一密钥是前提，之后才能安全通信<br>我们会想到之前提过的DH密钥交换，但是这不能认证双方；所以这里提出“公钥证书”的概念<br>考虑如下操作步骤（当B想要发消息给A的时候）：</p><ul><li>使用一次性+传统的+会话密钥，加密消息</li><li>用A的公钥加密会话密钥（问题所在：B怎么得到A的公钥的？——&gt;通过A的公钥证书）</li><li>把加密后的会话密钥和加密后的消息放在一起送给A</li></ul><h2 id="4-4-X-509证书"><a class="header-anchor" href="#4-4-X-509证书">¶</a>4.4 X.509证书</h2><h3 id="4-4-0-引言"><a class="header-anchor" href="#4-4-0-引言">¶</a>4.4.0 引言</h3><p>X.500是一个系列推荐标准(?)，定义了一套目录服务：</p><blockquote><p>目录服务就是，有用于维护用户信息数据库的一个或一组分布式服务器。信息包括：用户名到网络地址的映射，以及用户其他信息</p></blockquote><p>X.509是X.500推荐标准系列中的一部分，定义了一个使用X.500目录向用户提供认证服务的框架，</p><ul><li>该目录就可以作为公钥证书存储库（公钥证书=用户的公钥+可信任的认证中心的私钥签名）</li><li>X.509还定义了一个基于公钥证书的认证协议</li></ul><p>下图表示了公钥证书的产生：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231110704.png" alt=""></p><h3 id="4-4-1-证书"><a class="header-anchor" href="#4-4-1-证书">¶</a>4.4.1 证书</h3><h4 id="（1）公钥证书使用步骤"><a class="header-anchor" href="#（1）公钥证书使用步骤">¶</a>（1）公钥证书使用步骤</h4><ul><li>可信任的认证中心CA为用户创建证书</li><li>CA/用户把证书放到目录服务器</li><li>目录服务器提供一个方便访问证书的场所</li></ul><h4 id="（2）X-509定义的公钥证书格式"><a class="header-anchor" href="#（2）X-509定义的公钥证书格式">¶</a>（2）X.509定义的公钥证书格式</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231130854.png" alt=""></p><p><strong>CA用自己的私钥对证书签名，用户知道CA的公钥的话，就可以解密，验证证书是否合法</strong></p><p>这其实是一个典型的数字签名过程，可以如下描述：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231130247.png" alt=""></p><h4 id="（3）CA生成的公钥证书的特征"><a class="header-anchor" href="#（3）CA生成的公钥证书的特征">¶</a>（3）CA生成的公钥证书的特征</h4><ul><li>用户可以用CA的公钥去解密证书，看里面的用户公钥，以验证</li><li>只有CA才可以修改用户证书；证书不可伪造，所以放到目录服务器里不需要采取额外保护措施</li></ul><h4 id="（4）证书链"><a class="header-anchor" href="#（4）证书链">¶</a>（4）证书链</h4><p>先来看一种情境，假如一个CA负责了很多用户的证书，那么它要给所有用户发一个自己的公钥的副本，以便他们可以用这个公钥去解密证书以验证其合法性。<br>那么如果，有一个假CA出来，用自己的私钥签了证书，并给用户自己的公钥；这个私钥和公钥仍然是匹配的，又由于用户只看能不能解密来证明其合法性……所以说，太多用户的时候，可以使用多个CA</p><p>多个CA会是什么情况呢？假如A从X1那里拿了证书，B从X2；然后A去看B的证书，能获取是能获取，但是拿到手上也没用，因为A没有X2的公钥，不能验证里面的签名，也就不能确定这个是B的证书……</p><p>一种解决方案是，X1和X2事先交换过公钥，然后就可以：</p><ol><li>A在目录中拿到X1签名的X2证书（X2的公钥证书，把X2当成一个普通用户的话）,即<code>X1&lt;&lt;X2&gt;&gt;</code></li><li>A有X1的公钥，所以A从<code>X1&lt;&lt;X2&gt;&gt;——&gt;X2</code>，也就是拿到了X2的公钥</li><li>A去拿由X2签名的B的证书，即<code>X2&lt;&lt;B&gt;&gt;</code>，解密拿到B，也就是知道了B的公钥</li></ol><p>A获取B的公钥的过程可以描述为：X1&lt;<x2>&gt;X2&lt;<b>&gt;<br>同理，B获取A的公钥的过程为：<code>X2&lt;&lt;X1&gt;&gt;X1&lt;&lt;A&gt;&gt;</code></b></x2></p><b><p>更普遍的过程可以描述为：</p><pre><code>X1&lt;&lt;X2&gt;&gt;X2&lt;&lt;X3&gt;&gt;...XN&lt;&lt;B&gt;&gt;</code></pre><p>相邻的两个X应该互相生成过证书，为了更明确这个关系，我们用下图来描述：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE138.png" alt=""></p><h4 id="（5）证书撤销"><a class="header-anchor" href="#（5）证书撤销">¶</a>（5）证书撤销</h4><p>一般都是自然过期，不过有以下情况需要提前撤销：<br>见书P98</p><p>用户从消息中取得证书的时候，需要确认它是否被取消</p><h3 id="4-4-2-X-509版本3"><a class="header-anchor" href="#4-4-2-X-509版本3">¶</a>4.4.2 X.509版本3</h3><h4 id="（1）X-509版本2没有满足的要求"><a class="header-anchor" href="#（1）X-509版本2没有满足的要求">¶</a>（1）X.509版本2没有满足的要求</h4><p>见书P98</p><h4 id="（2）X-509版本3的改变"><a class="header-anchor" href="#（2）X-509版本3的改变">¶</a>（2）X.509版本3的改变</h4><p>加入扩展部分，更加灵活</p><p>扩展=一个扩展标识+一个危险指示符+一个扩展值<br>危险指示符：标识一个扩展是否可以被安全地忽略，True则可</p><p>证书扩展可以分为三个主要类型：</p><ul><li>密钥和策略信息</li><li>主体和发放者属性</li><li>认证路径约束</li></ul><h4 id="（3）密钥和策略信息"><a class="header-anchor" href="#（3）密钥和策略信息">¶</a>（3）密钥和策略信息</h4><p>用处：指示证书对于（一个特定的具有相同安全需求的团体、应用类别）的适用性</p><p>域的内容见书P99</p><h4 id="（4）主体和发放者属性"><a class="header-anchor" href="#（4）主体和发放者属性">¶</a>（4）主体和发放者属性</h4><p>用处：附加一些属性，让别人更相信这个证书是某个人的</p><p>域的内容见书P99</p><h4 id="（5）认证路径约束"><a class="header-anchor" href="#（5）认证路径约束">¶</a>（5）认证路径约束</h4><p>用处：限制主体CA可以发放的证书类型，或限制在认证链中随后可以出现的证书类型</p><p>域的内容见书P99</p><h2 id="4-5-公钥基础设施KPI"><a class="header-anchor" href="#4-5-公钥基础设施KPI">¶</a>4.5 公钥基础设施KPI</h2><h3 id="4-5-0-引言"><a class="header-anchor" href="#4-5-0-引言">¶</a>4.5.0 引言</h3><ul><li>PKI是什么？<br>之所以叫基础设施：包含了硬件+软件+人员+策略+过程</li><li>那是干什么的基础设施？<br>公钥密码中，用于生成+管理+存储+分配+撤销数字证书</li><li>PKIX是什么？<br>基于X.509的PKI</li><li>所以具体来说，PKIX包括些什么呢？</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231152633.png" alt=""></p><h3 id="4-5-1-PKIX管理功能"><a class="header-anchor" href="#4-5-1-PKIX管理功能">¶</a>4.5.1 PKIX管理功能</h3><ul><li>注册：注册开始了一个PKI中的登记过程</li><li>初始化：客户端安装密钥资料</li><li>认证：CA发证书</li><li>密钥对恢复：</li><li>密钥对更新：</li><li>撤销申请：CA撤销</li><li>交叉认证：两个CA之间</li></ul><p>上图中粉红色部分</p><h3 id="4-5-2-PKIX管理协议"><a class="header-anchor" href="#4-5-2-PKIX管理协议">¶</a>4.5.2 PKIX管理协议</h3><p>用来支持上一节列出的管理功能</p><h2 id="4-6-联合身份管理"><a class="header-anchor" href="#4-6-联合身份管理">¶</a>4.6 联合身份管理</h2><h3 id="4-6-1-身份管理"><a class="header-anchor" href="#4-6-1-身份管理">¶</a>4.6.1 身份管理</h3><h4 id="（1）作用"><a class="header-anchor" href="#（1）作用">¶</a>（1）作用</h4><p>验证身份以后给对应的资源接口，基于单点登录SSO</p><h4 id="（2）基本要素"><a class="header-anchor" href="#（2）基本要素">¶</a>（2）基本要素</h4><p>见书P102</p><p>值得注意的是，Kerberos包含身份管理系统的许多要素</p><h4 id="（3）通用的身份管理系统"><a class="header-anchor" href="#（3）通用的身份管理系统">¶</a>（3）通用的身份管理系统</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231153605.png" alt=""></p><h3 id="4-6-2-身份联合"><a class="header-anchor" href="#4-6-2-身份联合">¶</a>4.6.2 身份联合</h3><p>身份联合就是将身份管理扩展到多个安全域，也就是说，多个域之间共享用户的数字身份，使得用户只要一次认证就可以接入多个域的应用及其资源</p><h4 id="（1）联合身份管理的作用"><a class="header-anchor" href="#（1）联合身份管理的作用">¶</a>（1）联合身份管理的作用</h4><ul><li>单点登录SSO</li><li>表示属性的标准方法：属性可以指口令、生物特征信息、文件所有权等等</li><li>身份映射：同一个用户在不同的域中身份和属性可能不同，身份映射可以将一个域的身份和属性映射到另一个域的要求</li></ul><h4 id="（2）联合身份管理的实体与数据流"><a class="header-anchor" href="#（2）联合身份管理的实体与数据流">¶</a>（2）联合身份管理的实体与数据流</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231193813.png" alt=""></p><h4 id="（3）标准"><a class="header-anchor" href="#（3）标准">¶</a>（3）标准</h4><p>联合身份管理使用了一些标准，作为系统的构件，实现在不同的域之间进行安全身份交换的要求：</p><ul><li>可扩展标记语言XML</li><li>简单对象访问协议SOAP</li><li>WS-安全</li><li>安全断言标记语言SAML：可以传递用户认证信息</li></ul><p>见书P103-104</p><h4 id="（4）例子"><a class="header-anchor" href="#（4）例子">¶</a>（4）例子</h4><p>见书P104-105</p></b><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter2 对称加密和消息机密性</title>
      <link href="2020/09/21/Chapter2-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E6%B6%88%E6%81%AF%E6%9C%BA%E5%AF%86%E6%80%A7/"/>
      <url>2020/09/21/Chapter2-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E6%B6%88%E6%81%AF%E6%9C%BA%E5%AF%86%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-对称加密原理"><a class="header-anchor" href="#2-1-对称加密原理">¶</a>2.1 对称加密原理</h2><h3 id="2-1-0-对称加密简介"><a class="header-anchor" href="#2-1-0-对称加密简介">¶</a>2.1.0 对称加密简介</h3><h4 id="（1）一个对称加密算法的组成"><a class="header-anchor" href="#（1）一个对称加密算法的组成">¶</a>（1）一个对称加密算法的组成</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/model.png" alt=""></p><h4 id="（2）对称加密算法的安全性"><a class="header-anchor" href="#（2）对称加密算法的安全性">¶</a>（2）对称加密算法的安全性</h4><p>需要达到以下两个要求：</p><ul><li>强加密算法：（一个很强的条件）攻击者知道算法且有很多密文+密文对应的明文，却不能破译密文，或者解出密钥</li><li>密钥安全：Alice和Bob的密钥收发仅两人可得。（因为如果别人得到了他们的密钥，所有使用此密钥的通信都可读）</li></ul><p><strong>注：对称加密的安全取决于密钥的保密性，算法可公开</strong></p><h3 id="2-1-1-密码体制"><a class="header-anchor" href="#2-1-1-密码体制">¶</a>2.1.1 密码体制</h3><p>密码体制有以下三个分类标准：</p><h4 id="1-明文转换成密文的操作类型"><a class="header-anchor" href="#1-明文转换成密文的操作类型">¶</a>1. 明文转换成密文的操作类型</h4><ul><li>替换：明文映射到……</li><li>换位：明文再排列</li></ul><p>（注：上述两种操作可以以比特、字母等等为单位）</p><h4 id="2-使用的密钥数"><a class="header-anchor" href="#2-使用的密钥数">¶</a>2. 使用的密钥数</h4><ul><li>AB同一密钥：对称/单钥/秘密密钥/传统加密</li><li>AB不同密钥：不对称/双钥/公钥加密</li></ul><h4 id="3-明文的处理方式"><a class="header-anchor" href="#3-明文的处理方式">¶</a>3. 明文的处理方式</h4><ul><li>一次处理一个分组：分组密码</li><li>明文输入过程中连续处理：流密码</li></ul><h3 id="2-1-2-密码分析"><a class="header-anchor" href="#2-1-2-密码分析">¶</a>2.1.2 密码分析</h3><p>密码分析或破译：找出明文或密钥</p><p>根据攻击者掌握的信息量，可将攻击类型分类如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/attack.png" alt=""></p><h4 id="1-惟密文攻击"><a class="header-anchor" href="#1-惟密文攻击">¶</a>1. 惟密文攻击</h4><p>或许只能穷举……但是也有一些小技巧，比如统计测试（前提是对明文的类型有一个大致的了解）</p><h4 id="2-已知明文攻击"><a class="header-anchor" href="#2-已知明文攻击">¶</a>2. 已知明文攻击</h4><p>比如某种文件可能有些固定的内容……<br><strong>一般密码算法会被设计成能抵挡已知明文攻击的程度</strong></p><h4 id="3-选择明文"><a class="header-anchor" href="#3-选择明文">¶</a>3. 选择明文</h4><p>攻击者能得到源系统，可以插入自己选定的消息（选定明文，查看密文）</p><h4 id="4-选择密文"><a class="header-anchor" href="#4-选择密文">¶</a>4. 选择密文</h4><p>是选择明文的反向，不过不太常见</p><h4 id="5-选择文本"><a class="header-anchor" href="#5-选择文本">¶</a>5. 选择文本</h4><p>选择明文+选择密文的能力，不过不太常见</p><p>计算安全的加密方案（妙啊！）：</p><ul><li>破解密文的代价&gt;明文的价值</li><li>破解密文的时间&gt;信息的有用寿命</li></ul><h3 id="2-1-3-Feistel密码结构"><a class="header-anchor" href="#2-1-3-Feistel密码结构">¶</a>2.1.3 Feistel密码结构</h3><h4 id="可以看做是对称密码算法的通用结构"><a class="header-anchor" href="#可以看做是对称密码算法的通用结构">¶</a>可以看做是对称密码算法的通用结构</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/Fiestel.png" alt=""></p><h4 id="其中有些可以调整的参数："><a class="header-anchor" href="#其中有些可以调整的参数：">¶</a>其中有些可以调整的参数：</h4><ul><li>分组大小：折中128bit一组比较常见</li><li>密钥大小：越长——越安全——加解密越慢</li><li>迭代轮数：典型16</li><li>子密钥产生算法：越复杂越安全</li><li>轮函数：同上</li></ul><h4 id="设计算法还需考虑"><a class="header-anchor" href="#设计算法还需考虑">¶</a>设计算法还需考虑</h4><ul><li>软件执行速度比较快</li><li>容易分析——容易找到弱点——随即加固</li></ul><p><strong>对称密码算法的加解密本质上是相同的过程，不需要实现两个不同的算法</strong></p><h2 id="2-2-对称分组加密算法"><a class="header-anchor" href="#2-2-对称分组加密算法">¶</a>2.2 对称分组加密算法</h2><h3 id="2-2-1-数据加密标准DES"><a class="header-anchor" href="#2-2-1-数据加密标准DES">¶</a>2.2.1 数据加密标准DES</h3><p>说实话，我总是不能把数据加密标准和DES联系在一起，这两个名字，一个像标准，一个像算法哈哈哈哈；但是仔细研究一下发现，其实我的直觉没错<br>DES准确来说是一种标准，数据加密标准；算法本身其实叫做DEA，略感陌生；一般都直接说DES了</p><h4 id="DEA算法描述"><a class="header-anchor" href="#DEA算法描述">¶</a>DEA算法描述</h4><p>基本沿用Fiestel结构，参数如下：</p><ul><li>分组大小：64</li><li>密钥大小：56</li><li>迭代轮数：典型16</li><li>子密钥产生算法：越复杂越安全</li><li>轮函数：同上</li></ul><h4 id="DES的强度"><a class="header-anchor" href="#DES的强度">¶</a>DES的强度</h4><ul><li>算法本身：至今还没人指出弱点</li><li>密钥长度：一定范围内，蛮力攻击还是可行的（所以后来有改进的算法来替代它，如3DES和AES）</li></ul><h3 id="2-2-2-三重DES"><a class="header-anchor" href="#2-2-2-三重DES">¶</a>2.2.2 三重DES</h3><h4 id="3DES流程"><a class="header-anchor" href="#3DES流程">¶</a>3DES流程</h4><p>使用三次DES，加密——解密——加密</p><h4 id="3DES优点"><a class="header-anchor" href="#3DES优点">¶</a>3DES优点</h4><ul><li>底层算法与DES相同，之前说过无弱点了</li><li>密钥长度168bit，解决了被穷举的问题</li></ul><h4 id="3DES缺点"><a class="header-anchor" href="#3DES缺点">¶</a>3DES缺点</h4><p>软件运行慢</p><h3 id="2-2-3-高级加密标准AES"><a class="header-anchor" href="#2-2-3-高级加密标准AES">¶</a>2.2.3 高级加密标准AES</h3><p>替代3DES，安全性&gt;=，效率&gt;=</p><h4 id="AES流程"><a class="header-anchor" href="#AES流程">¶</a>AES流程</h4><p>值得注意的是，它不是Feistel结构<br>（具体可见书30—31页）</p><h2 id="2-3-随机数和伪随机数"><a class="header-anchor" href="#2-3-随机数和伪随机数">¶</a>2.3 随机数和伪随机数</h2><h3 id="2-3-1-随机数的应用"><a class="header-anchor" href="#2-3-1-随机数的应用">¶</a>2.3.1 随机数的应用</h3><h4 id="（1）基于随机数的安全算法"><a class="header-anchor" href="#（1）基于随机数的安全算法">¶</a>（1）基于随机数的安全算法</h4><p>RSA、对称流密码的密钥流的生成、密钥分配方案……</p><h4 id="（2）应用对随机数的需求"><a class="header-anchor" href="#（2）应用对随机数的需求">¶</a>（2）应用对随机数的需求</h4><ol><li>随机性：有两个验证标准<br>（1）均匀分布：一串中，0与1出现概率大致相同<br>（2）独立：统一序列上，没有数字能影响别人</li><li>不可预测性</li></ol><h3 id="2-3-2-真随机数发生器TRNG、伪随机数生成器PRNG和伪随机函数PRF"><a class="header-anchor" href="#2-3-2-真随机数发生器TRNG、伪随机数生成器PRNG和伪随机函数PRF">¶</a>2.3.2 真随机数发生器TRNG、伪随机数生成器PRNG和伪随机函数PRF</h3><p>首先要明白，什么是统计上的随机性？（？）</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/random.png" alt=""></p><p>伪随机数发生器和伪随机函数的区别在于产生的比特数不同</p><h3 id="2-3-3-算法设计"><a class="header-anchor" href="#2-3-3-算法设计">¶</a>2.3.3 算法设计</h3><p>PRNG的算法可以分为两类：</p><h4 id="1-为特定目的构造的算法"><a class="header-anchor" href="#1-为特定目的构造的算法">¶</a>1. 为特定目的构造的算法</h4><ul><li>用于PRNG应用程序</li><li>有些算法专门被设计用在流密码中（如流密码）</li></ul><h4 id="2-基于现存密码算法的算法-、"><a class="header-anchor" href="#2-基于现存密码算法的算法-、">¶</a>2. 基于现存密码算法的算法          、</h4><p>有些密码算法可以嵌在PRNG应用中，作为其核心算法，比如：</p><ul><li>对称的分组密码</li><li>不对称的密码</li><li>散列函数和消息认证码</li></ul><h2 id="2-4-流密码和RC4"><a class="header-anchor" href="#2-4-流密码和RC4">¶</a>2.4 流密码和RC4</h2><p>分组密码更普遍，但对于特定应用还是要用流密码的。<br>流密码就是一次产生一个输出元素，我觉得和分组密码的区别就像：前者是python命令行一句句解释，后者是python IDE一整个程序给个解释<br>最对称的流密码可以说是RC4了哈哈哈哈</p><h3 id="2-4-1-流密码结构"><a class="header-anchor" href="#2-4-1-流密码结构">¶</a>2.4.1 流密码结构</h3><h4 id="（1）流密码结构示意图"><a class="header-anchor" href="#（1）流密码结构示意图">¶</a>（1）流密码结构示意图</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/flow.png" alt=""></p><p>解释一下：首先呢，你要先有个密钥K，把它投入伪随机字节生成器里面得到密钥流k；k和明文异或就得到密文字节流啦。由于是对称的，加密解密用同一个密钥</p><h4 id="2-设计流密码的考虑因素"><a class="header-anchor" href="#2-设计流密码的考虑因素">¶</a>(2)设计流密码的考虑因素</h4><ul><li>加密序列有个长周期：意思是，其实伪随机字节生成器生成的是周期性循环的确定字节流，如果周期太短容易被破</li><li>生成的密钥流最好能通过随机数检测那些</li><li>PRNG的输入要足够长以便不会被穷举</li></ul><h4 id="3-流密码优点"><a class="header-anchor" href="#3-流密码优点">¶</a>(3)流密码优点</h4><ul><li>比分组密码快，代码少</li></ul><h4 id="4-分组密码优点"><a class="header-anchor" href="#4-分组密码优点">¶</a>(4)分组密码优点</h4><ul><li>分组密码可以重复使用密钥，但是流密码的密钥最好不要重复用不然容易被破<br>若已知两个密文流，将它们进行异或，结果=对应两个明文流的异或</li></ul><h3 id="2-4-2-RC4算法"><a class="header-anchor" href="#2-4-2-RC4算法">¶</a>2.4.2 RC4算法</h3><h4 id="1-RC4算法"><a class="header-anchor" href="#1-RC4算法">¶</a>(1)RC4算法</h4><ul><li>初始化<ul><li>S是个状态向量，有256维，刚开始从0-255维依次设为0-255；</li><li>K为密钥（1-256字节可变）；</li><li>T为临时向量（256维），T的赋值即将K循环利用填充进去</li></ul></li><li>S的初始置换：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">j=0;</span><br><span class="line">for(i=0;i&lt;=255;i++){</span><br><span class="line">j=(j+S[i]+T[i])mod 256;</span><br><span class="line">swap(S[i],S[j]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>密钥流产生：感觉只有对S的置换操作，因为一旦完成S向量的初始置换，就不在需要输入密要了</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/a1.png" alt=""></p><h4 id="2-RC4强度"><a class="header-anchor" href="#2-RC4强度">¶</a>(2)RC4强度</h4><p>有些特定的攻击方法，但是当密钥长度&gt;128bit时，没有可以成功的。<br>另外有个有趣的点是：我们发现WEP协议易受攻击从而导致RC4易受攻击，这说明了一条安全系统设计的困难性所在：</p><blockquote><p>密码算法要安全还不够，密码函数所处的协议也要安全，比如考虑输入输出上下游的安全等等</p></blockquote><h2 id="2-5-分组密码工作模式"><a class="header-anchor" href="#2-5-分组密码工作模式">¶</a>2.5 分组密码工作模式</h2><p>NIST提出了五种工作模式，希望覆盖“用分组密码做加密”的所有应用场景，这里列出了以下四种：</p><h3 id="2-5-1-电子密码本ECB模式"><a class="header-anchor" href="#2-5-1-电子密码本ECB模式">¶</a>2.5.1 电子密码本ECB模式</h3><h4 id="1-原理"><a class="header-anchor" href="#1-原理">¶</a>(1)原理</h4><p>假设明文被分成b比特一组，每个分组都是同一密钥加密的。每个分组对于一个给定的密钥会有一个密文（唯一的结果），但是如果一段明文里有两个完全相同的分组……它们对应的密文也是相同的……</p><h4 id="2-不足"><a class="header-anchor" href="#2-不足">¶</a>(2)不足</h4><p>如果明文过长以至于出现两个分组重复，就不安全。所以我们希望有上述情况的话，它们会对应两个不同的密文。</p><h3 id="2-5-2-密码分组链接CBC模式"><a class="header-anchor" href="#2-5-2-密码分组链接CBC模式">¶</a>2.5.2 密码分组链接CBC模式</h3><h4 id="1-原理-v2"><a class="header-anchor" href="#1-原理-v2">¶</a>(1)原理</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/CBC.png" alt=""></p><ul><li>输入：每组明文和上一组密文的异或</li><li>处理：所有分组用同一密钥</li></ul><h4 id="2-数学推导说明的一些东西"><a class="header-anchor" href="#2-数学推导说明的一些东西">¶</a>(2)数学推导说明的一些东西</h4><p>见书P39，说明在接收者收数据准备解密之前，如果Attacker有机会改变初始向量IV，那么P1也会被改变，也就是接收者会解出错误的明文</p><h3 id="2-5-3-密码反馈CFB模式"><a class="header-anchor" href="#2-5-3-密码反馈CFB模式">¶</a>2.5.3 密码反馈CFB模式</h3><h4 id="（1）作用"><a class="header-anchor" href="#（1）作用">¶</a>（1）作用</h4><p>将任意分组密码转化为流密码，为什么要转换呢？是由于有些应用场景下比较适合用流密码：</p><ul><li>流密码不需要将消息填充为分组大小的整数倍</li><li>流密码可以实时操作，也就是说，如果传送字符流，流密码可以使我们及时加密并传送每个字符</li><li>流密码的密文长度=明文长度，由于传输能力是一个比较宝贵的资源，我们用分组密码可能导致密文比明文长，从而浪费传输能力</li></ul><h4 id="（2）原理"><a class="header-anchor" href="#（2）原理">¶</a>（2）原理</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201228130754.png" alt=""></p><h3 id="2-5-4-计数器模式CTR"><a class="header-anchor" href="#2-5-4-计数器模式CTR">¶</a>2.5.4 计数器模式CTR</h3><h4 id="（1）应用"><a class="header-anchor" href="#（1）应用">¶</a>（1）应用</h4><p>（？）</p><ul><li>异步传输模式的网络安全中</li><li>IPSec中</li></ul><h4 id="（2）原理-v2"><a class="header-anchor" href="#（2）原理-v2">¶</a>（2）原理</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201228130708.png" alt=""></p><h4 id="（3）CTR模式优点"><a class="header-anchor" href="#（3）CTR模式优点">¶</a>（3）CTR模式优点</h4><ul><li>硬件效率：各明文单元可以并行计算</li><li>软件效率：由于CTR允许并行计算，所以可以用一些有“并行特征”的指令</li><li>预处理：加密部分可以预处理</li><li>随机访问：对于只需要解密一部分密文的情况，CTR由于无链接，所以各块之间独立，想解密哪一块并不需要之前的信息</li><li>可证明的安全性</li><li>简单性：加解密算法完全相同</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter1 软件安全绪论</title>
      <link href="2020/09/19/Chapter1-%E7%BB%AA%E8%AE%BA-Reading-Notes/"/>
      <url>2020/09/19/Chapter1-%E7%BB%AA%E8%AE%BA-Reading-Notes/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-引言"><a class="header-anchor" href="#1-1-引言">¶</a>1.1 引言</h2><p>为什么会出现安全问题？</p><ul><li>软件变复杂，规模变大</li><li>软件承载的利益，让某些人利用软件安全问题来获取利益</li></ul><h2 id="1-2-典型安全问题"><a class="header-anchor" href="#1-2-典型安全问题">¶</a>1.2 典型安全问题</h2><p>为什么软件安全问题日渐复杂？</p><ul><li>随着科技发展、研究与分析的深入,我们注意到软件安全的问题非常多样化</li><li>试图利用软件安全问题获利的各类组织机构也在不断发展，针对软件安全问题的利用、破坏技术手段，造成软件安全问题日趋复杂</li></ul><h4 id="1-2-1-恶意软件"><a class="header-anchor" href="#1-2-1-恶意软件">¶</a>1.2.1 恶意软件</h4><h4 id="1-传统恶意软件"><a class="header-anchor" href="#1-传统恶意软件">¶</a>1. 传统恶意软件</h4><ul><li>传统的恶意软件包括：病毒、僵木蠕、间谍软件等</li><li>破坏：窃取信息、远程控制、实施破坏等</li><li>传统恶意软件需要发展的能力：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">渗透与扩散：突破防御+感染目标</span><br><span class="line">隐蔽能力：隐蔽特征避免被发现+被发现了能保护操纵者身份</span><br><span class="line">破坏能力：搜集信息+实施破坏</span><br></pre></td></tr></tbody></table></figure><h4 id="2-恶意软件发展历程"><a class="header-anchor" href="#2-恶意软件发展历程">¶</a>2. 恶意软件发展历程</h4><p>单机传播——网络传播——协同攻击<br>APT攻击（高可持续性威胁）：针对特定目标+高技术</p><h4 id="1-2-2-软件漏洞"><a class="header-anchor" href="#1-2-2-软件漏洞">¶</a>1.2.2 软件漏洞</h4><p>说的是程序设计错误导致的</p><h4 id="1-漏洞为什么越来越多？"><a class="header-anchor" href="#1-漏洞为什么越来越多？">¶</a>1. 漏洞为什么越来越多？</h4><ul><li>软件更复杂</li><li>漏洞多样化</li><li>软件开发周期变短</li></ul><h4 id="1-2-3-软件后门"><a class="header-anchor" href="#1-2-3-软件后门">¶</a>1.2.3 软件后门</h4><p>开发人员刻意设计，但对用户隐瞒的功能。为什么算在软件安全问题中呢？因为有的攻击者，开发软件的时候，会留下后门，将其设计为此软件的漏洞。<br>举个栗子：建城墙的人留了个暗道，工程交付以后，保护城墙的人不一定能找出来它，但是工人却一清二楚，可以通过暗道做些坏事。而且，工人更懂怎么利用城墙的设计藏好这个暗道。</p><h4 id="1-将软件后门设计为软件漏洞，此方法优势："><a class="header-anchor" href="#1-将软件后门设计为软件漏洞，此方法优势：">¶</a>1. 将软件后门设计为软件漏洞，此方法优势：</h4><ul><li>难发现</li><li>易利用</li><li>难取证：后门代码其实不在软件的产品代码中，而是攻击者利用漏洞动态加载的（被发现了说成设计错误就完事儿了，不是故意的哈哈哈）</li></ul><h2 id="1-3-软件安全性分析的目标"><a class="header-anchor" href="#1-3-软件安全性分析的目标">¶</a>1.3 软件安全性分析的目标</h2><h3 id="1-3-1-软件安全性分析要解决的问题"><a class="header-anchor" href="#1-3-1-软件安全性分析要解决的问题">¶</a>1.3.1 软件安全性分析要解决的问题</h3><ol><li><p>存在问题<br>“是否”的问题：有恶意功能/漏洞/后门吗？</p></li><li><p>机理问题<br>“为什么”的问题：分析下此问题出现的原因/原理/工作流程之类的，具体问题具体分析</p></li><li><p>对策问题<br>“怎么办”的问题：防御</p></li></ol><h3 id="1-3-2-无源码时对软件逆向分析的挑战"><a class="header-anchor" href="#1-3-2-无源码时对软件逆向分析的挑战">¶</a>1.3.2 无源码时对软件逆向分析的挑战</h3><ol><li><p>指令代码的理解<br>从可执行文件或指令执行序列等，理解到操作语义很困难</p></li><li><p>关联关系的抽取<br>操作之间的数据传递、计算，数据/指令之间的依赖关系，很难有直观的认识</p></li><li><p>对策问题<br>“怎么办”的问题：防御</p></li></ol><h2 id="1-4-主要方法与技术"><a class="header-anchor" href="#1-4-主要方法与技术">¶</a>1.4 主要方法与技术</h2><h3 id="1-4-0-软件逆向分析方法分类"><a class="header-anchor" href="#1-4-0-软件逆向分析方法分类">¶</a>1.4.0 软件逆向分析方法分类</h3><p>主要有两大类：静态分析和动态分析</p><h4 id="1-静态分析"><a class="header-anchor" href="#1-静态分析">¶</a>1. 静态分析</h4><p>感觉就像通过反汇编或反编译的手段，对软件的可执行代码进行分析<br>（1）优点：比较全面、整体<br>（2）缺点：一方面，软件代码规模大了或者复杂了就不好搞；另一方面，如果软件做了加壳保护那就不能反汇编等等</p><h4 id="2-动态分析"><a class="header-anchor" href="#2-动态分析">¶</a>2. 动态分析</h4><p>通过直接运行软件，监测软件运行过程进行分析。<br>（1）优点：分析过程中可根据软件的运行过程直接获得在各个指令执行后的结果数据，减少推理分析<br>（2）缺点：每次分析只能针对动态执行的一条路径执行，整体性较差（所以说，如何构造多条执行路径也是动态分析需要研究的一个重要问题）</p><p><strong>现在一般：动态为主，静态为辅</strong></p><h3 id="1-4-1-反汇编与反编译"><a class="header-anchor" href="#1-4-1-反汇编与反编译">¶</a>1.4.1 反汇编与反编译</h3><p>通常是逆向分析的第一步（静态动态都是）</p><h4 id="作用"><a class="header-anchor" href="#作用">¶</a>作用</h4><p>二进制exe文件（完全不可读）——&gt;汇编代码——&gt;其他高级语言代码（基本可读）<br>第一个箭头是反汇编，第二个是反编译；做到<strong>功能等价</strong>就行</p><h3 id="1-4-2-程序调试"><a class="header-anchor" href="#1-4-2-程序调试">¶</a>1.4.2 程序调试</h3><p>动态分析</p><h4 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h4><p>用一些工具，通过断点、单步执行等方式<br>内核代码的调试需要虚拟化技术+多台设备</p><h4 id="优缺点"><a class="header-anchor" href="#优缺点">¶</a>优缺点</h4><p>优缺点基本同“动态分析”中所写，此外，软件自保护技术可能阻碍调试，且数据量和复杂度都挺恐怖的</p><h3 id="1-4-3-程序切片"><a class="header-anchor" href="#1-4-3-程序切片">¶</a>1.4.3 程序切片</h3><h4 id="作用-v2"><a class="header-anchor" href="#作用-v2">¶</a>作用</h4><p>解决软件代码规模超大带来的理解困难，比如分析出了汇编代码，对汇编代码切片……</p><h4 id="基本思想"><a class="header-anchor" href="#基本思想">¶</a>基本思想</h4><p>分析指令的相关性，从而提取用户“感兴趣”的代码</p><p>主要用于静态分析，也可用于动态分析，有差异：<br>（1）静态分析：通过计算操作数<strong>可能的影响范围</strong>（要考虑各种可能的执行路径）来计算指令的关联关系<br>（2）动态分析：更有针对性，对某条路径某个操作数来分析指令关联</p><h4 id="缺点"><a class="header-anchor" href="#缺点">¶</a>缺点</h4><p>对局部代码还不错，但代码多了照样难受</p><h3 id="1-4-4-污点传播分析"><a class="header-anchor" href="#1-4-4-污点传播分析">¶</a>1.4.4 污点传播分析</h3><p>静态动态都有，<strong>数据流分析方法</strong></p><h4 id="基本思想-v2"><a class="header-anchor" href="#基本思想-v2">¶</a>基本思想</h4><p>将感兴趣的数据标记，根据每条指令的污点传播过程，分析数据的传递关系</p><h4 id="实现方式"><a class="header-anchor" href="#实现方式">¶</a>实现方式</h4><p>按照“如何获得后台执行过程中具体每一条指令和指令执行前后状态”，可以分为：<br>基于插桩/硬件/编译器扩展/硬件模拟器等等</p><h4 id="存在问题"><a class="header-anchor" href="#存在问题">¶</a>存在问题</h4><p>由于控制依赖、查表操作等引入的隐式污点传播无法简单地引入或去除</p><h3 id="1-4-5-符号执行"><a class="header-anchor" href="#1-4-5-符号执行">¶</a>1.4.5 符号执行</h3><p>静态动态都有</p><h3 id="1-4-6-模糊测试"><a class="header-anchor" href="#1-4-6-模糊测试">¶</a>1.4.6 模糊测试</h3><p>动态分析</p><h4 id="作用-v3"><a class="header-anchor" href="#作用-v3">¶</a>作用</h4><p>本来是构造许多奇怪数据来看软件鲁棒性的，但现在是为了触发不同的执行路径</p><h4 id="存在问题-v2"><a class="header-anchor" href="#存在问题-v2">¶</a>存在问题</h4><p>提高测试数据生成的针对性——&gt;提高模糊测试效率</p><h2 id="1-5-主要分析应用"><a class="header-anchor" href="#1-5-主要分析应用">¶</a>1.5 主要分析应用</h2><h3 id="1-5-1-恶意软件分析"><a class="header-anchor" href="#1-5-1-恶意软件分析">¶</a>1.5.1 恶意软件分析</h3><h5 id="对恶意软件的分析目标"><a class="header-anchor" href="#对恶意软件的分析目标">¶</a>对恶意软件的分析目标</h5><ul><li>分析出主要功能</li><li>提取代码或行为特征，更新防御配置</li><li>分析实现机理，研发清除手段</li></ul><h5 id="网络协议逆向分析"><a class="header-anchor" href="#网络协议逆向分析">¶</a>网络协议逆向分析</h5><p>方法：</p><ul><li>基于网络流量统计特征展开分析</li><li>直接通过逆向软件分析<br>优点：准确、分析能力强<br>基本思路：对代码静态+动态逆向分析，提取出协议中的数据包格式/关键字/协议状态机等</li></ul><h5 id="软件漏洞分析与利用"><a class="header-anchor" href="#软件漏洞分析与利用">¶</a>软件漏洞分析与利用</h5><p>如何发现软件漏洞？</p><ul><li>模糊测试工具</li><li>典型漏洞的代码特征</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件安全分析与应用》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Day1 - in_array函数缺陷//PHP Audit</title>
      <link href="2020/09/19/Day1-in-array%E5%87%BD%E6%95%B0%E7%BC%BA%E9%99%B7-PHP-Audit/"/>
      <url>2020/09/19/Day1-in-array%E5%87%BD%E6%95%B0%E7%BC%BA%E9%99%B7-PHP-Audit/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sqlmap Mannal</title>
      <link href="2020/09/19/Sqlmap-Mannal/"/>
      <url>2020/09/19/Sqlmap-Mannal/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>蚁剑 Mannal</title>
      <link href="2020/09/19/%E8%9A%81%E5%89%91-Mannal/"/>
      <url>2020/09/19/%E8%9A%81%E5%89%91-Mannal/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.fujieace.com/hacker/tools/antsword.html">中国蚁剑下载、安装、使用教程</a></p><p><a href="https://www.bilibili.com/video/av86179526/">https://www.bilibili.com/video/av86179526/</a></p><center><h1>Webshell</h1></center>理解 webshell 我们可以从字面上去理解，将其拆分成 web 和 shell 来分别进行理解，web 在百度百科的解释如下：<p>web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和 HTTP 的、全球性的、动态交互的、跨平台的分布式图形信息系统。<br>是建立在 Internet 上的一种网络服务，为浏览者在 Internet 上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将 Internet 上的信息节点组织成一个互为关联的网状结构。</p><p>web 对于我们来说都不陌生，是从事安全行业的同僚接触最多，也是入门必学的基础，为什么会是必学的基础呢？</p><p>因为这个在企业中是应用最广泛，也是最容易暴露在攻击者面前的东西，任何人都能找到任何企业暴露在外面可供入侵者攻击的应用，所以学习 web 安全没有错。</p><p>那么 shell 是什么呢？百度百科的解释如下：</p><p>在计算机科学中，Shell 俗称壳（用来区别于核），是指“提供使用者使用界面”的软件（命令解析器）。它类似于 DOS <a href="http://xn--command-nw3k6121a.com">下的command.com</a> 和后来的 cmd.exe。<br>它接收用户命令，然后调用相应的应用程序。</p><p>对于 shell 的理解，我们也可以理解为一个接口，用来管理某些应用程序。</p><p>webshell 就是两者的集合，合起来的意思可以理解为 web 应用管理工具，正常情况下，运维人员可以通过 webshell 针对 web 服务器进行日常的运维管理以及系统上线更新等，那么攻击者也可以通过 webshell 来管理 web 应用服务器。</p><p><strong>两者在使用上并没有太多区别，但是在叫法上可能就不大一样了，管理员使用可以叫服务器管理工具，而在攻击者手里就可以叫做后门程序了。</strong></p><center><h1>一句话木马</h1></center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php eval($_POST[&quot;kxc&quot;]);?&gt;</span><br></pre></td></tr></table></figure><p>php的eval()函数：eval($str)函数是把$str当做PHP代码执行。</p><p>这是php的一句话后门中最普遍的一种。它的工作原理是：<br>首先存在一个名为shell的变量，shell的取值为HTTP的POST方式。Web服务器对shell取值以后，然后通过eval()函数执行shell里面的内容。</p>]]></content>
      
      
      <categories>
          
          <category> Web Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蚁剑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wireshark Mannal</title>
      <link href="2020/09/19/Wireshark-Mannal/"/>
      <url>2020/09/19/Wireshark-Mannal/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Burpsuite Mannal</title>
      <link href="2020/09/19/Burpsuite-Mannal/"/>
      <url>2020/09/19/Burpsuite-Mannal/</url>
      
        <content type="html"><![CDATA[<h2 id="Proxy"><a class="header-anchor" href="#Proxy">¶</a>Proxy</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">forward：传输本次数据</span><br><span class="line">drop：丢弃本次数据</span><br><span class="line">Intercepton/off：拦截开启/关闭</span><br><span class="line">Action：提供功能选项</span><br></pre></td></tr></tbody></table></figure><p>当Burp Suite拦截的客户端和服务器交互之后，我们可以在Burp Suite的消息分析选项卡中查看这次请求的实体内容、消息头、请求参数等信息。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Raw：视图主要显示web请求的raw格式，包含请求地址、http协议版本、主机头、浏览器信息、Accept可接受的内容类型、字符集、编码方式、cookie等。我们可以通过手工修改这些信息，对服务器端进行渗透测试。</span><br><span class="line"></span><br><span class="line">params ：视图主要显示客户端请求的参数信息、包括GET或者POST请求的参数、Cookie参数。渗透人员可以通过修改这些请求参数来完成对服务器端的渗透测试。</span><br><span class="line"></span><br><span class="line">headers：视图显示的信息和Raw的信息类似，只不过在这个视图中，展示得更直观、友好。</span><br><span class="line"></span><br><span class="line">Hex ：视图显示Raw的二进制内容，你可以通过hex编辑器对请求的内容进行修改。</span><br></pre></td></tr></tbody></table></figure><p>Burpproxy所拦截的消息可在Fitter（过滤器）中根据需要进行修改</p><p>所有流经burpproxy的消息都会在 http history中记录下来，我们可以通过历史选项卡，查看传输的数据内容，对交互的数据进行测试和验证，同时，我们可以通过右击来弹出菜单，发送内容到burp的其他组件进行处理（类似于Action的功能）</p><p>comment：对拦截的消息添加备注，在一次渗透测试中，你通常会遇到一连串的请求消息，为了便于区分，在某个关键的请求消息上，你可以添加备注信息。</p><p>Highlight的功能与Comment功能有点类似，即对当前拦截的消息设置高亮，以便于其他的请求消息相区分。</p><p>可选项配置Options</p><p>从界面上看，主要有以下几大板块</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">▪客户端请求消息拦截（Interceptclient requests）</span><br><span class="line"></span><br><span class="line">▪服务器端返回消息拦截（intercept server responses）</span><br><span class="line"></span><br><span class="line">▪服务器返回消息修改（response modification）</span><br><span class="line"></span><br><span class="line">▪正则表达式配置（match and replace）</span><br><span class="line"></span><br><span class="line">▪其他配置项（miscellaneous）</span><br></pre></td></tr></tbody></table></figure><h2 id="Intruder"><a class="header-anchor" href="#Intruder">¶</a>Intruder</h2><p>工作原理：<br>Intruder在原始请求数据的基础上，通过修改各种请求参数，以获取不同的请求应答。每一次请求中，Intruder通常会携带一个或多个有效攻击载荷（Payload),在不同的位置进行攻击重放，通过应答数据的比对分析来获得需要的特征数据。<br>(在我的使用经验中，主要用于爆破)</p><p>应用场景：</p><ol><li>标识符枚举 Web应用程序经常使用标识符来引用用户、账户、资产等数据信息。例如，用户名，文件ID和账户号码。</li><li>提取有用的数据在某些场景下，而不是简单地识别有效标识符，你需要通过简单标识符提取一些其他的数据。比如说，你想通过用户的个人空间id，获取所有用户在个人空间标准的昵称和年龄。</li><li>模糊测试很多输入型的漏洞，如SQL注入，跨站点脚本和文件路径遍历可以通过请求参数提交各种测试字符串，并分析错误消息和其他异常情况，来对应用程序进行检测。由于的应用程序的大小和复杂性，手动执行这个测试是一个耗时且繁琐的过程。这样的场景，您可以设置Payload，通过Burp Intruder自动化地对Web应用程序进行模糊测试。</li></ol><p>测试步骤：</p><ol><li>确认Burp Suite安装正确并正常启动，且完成了浏览器的代理设置。</li><li>进入Burp Proxy选项卡，关闭代理拦截功能。</li><li>进行历史日志（History）子选项卡，查找可能存在问题的请求日志，并通过右击菜单，发送到Intruder。</li><li>进行Intruder选项卡，打开Target和Positions子选项卡。这时，你会看到上一步发送过来的请求消息。</li><li>因为我们了解到Burp Intruder攻击的基础是围绕刚刚发送过来的原始请求信息，在原始信息指定的位置上设置一定数量的攻击载荷Payload，通过Payload来发送请求获取应答消息。在默认情况下，所有的请求参数和cookie参数都会被设置为添加载荷<br>6.点击clear清除默认载荷（如果需要），圈定需要设置载荷的参数，点击add</li><li>当我们打开Payload子选项卡，选择Payload的生成或者选择策略，默认情况下选择“Simplelist",当然你也可以通过下拉选择其他Payload类型或者手工添加。</li><li>之后点击start attack发动攻击，此时burp 会自动打开一个新的界面，包含执行攻击的情况，http状态码、长度等信息的结果。我们还可以选择其中某一次通信消息，查看请求消息和应答消息的详细</li></ol><p>在很多时候，为了更好的标明应答消息中是否包含有我们需要的信息，通常在进行攻击前，会进行Options选项的相关配置，使用最多的为正则表达式匹配（Grep - Match）。</p><p>或者我们选择结果选项卡中的过滤器，对结果进行过滤筛选。同时，结果选项卡中所展示的列我们是可以进行指定的，我们可以在菜单columns进行设置。</p><p>最后选择我们需要的列，点击save按钮，对攻击结果进行保存。（也可以对保存对的内容进行设置</p><h2 id="Repeater"><a class="header-anchor" href="#Repeater">¶</a>Repeater</h2><p>Repeater是一个重放攻击器。<br>我们可以在这里对数据包的参数进行修改，以此来进行请求与响应的消息验证分析。<br><img src="https://img-blog.csdn.net/20170805164656913?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU1NDQzNzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web Sercurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Burpsuite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Understanding HTTP Deeply</title>
      <link href="2020/09/19/Understanding-HTTP-Deeply/"/>
      <url>2020/09/19/Understanding-HTTP-Deeply/</url>
      
        <content type="html"><![CDATA[<center><h1>简介</h1></center>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</p><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><p><img src="https://upload-images.jianshu.io/upload_images/2964446-5a35e17f298a48e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/551/format/webp" alt></p><center><h1>特点</h1></center>HTTP协议的主要特点可概括如下：1.支持客户/服务器模式。2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<center><h1>URL</h1></center>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息<p>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.aspxfans.com:8080&#x2F;news&#x2F;index.asp?boardID&#x3D;5&amp;ID&#x3D;24618&amp;page&#x3D;1#name</span><br></pre></td></tr></table></figure><p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p><ol><li><p>协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在&quot;HTTP&quot;后面的“//”为分隔符</p></li><li><p>域名部分：该URL的域名部分为“<a href="http://www.aspxfans.com">www.aspxfans.com</a>”。一个URL中，也可以使用IP地址作为域名使用</p></li><li><p>端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p></li><li><p>虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p></li><li><p>文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p></li><li><p>锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p></li><li><p>参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p></li></ol><center><h1>URI和URL的区别</h1></center><h2>URI</h2>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般由三部组成：①访问资源的命名机制②存放资源的主机名③资源自身的名称，由路径表示，着重强调于资源。<h2>URL</h2>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等<h2>URN</h2>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。<p>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。<br>在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。<br>相反的是，URL类可以打开一个到达资源的流。</p><center><h1>请求消息Request</h1></center>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：**请求行（request line）**、**请求头部（header）**、**空行**和**请求数据**四个部分。<p><img src="https://upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/466/format/webp" alt></p><h2>GET请求例子</h2><pre>GET /562f25980001b1b106000338.jpg HTTP/1.1Host    img.mukewang.comUser-Agent  Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept  image/webp,image/*,*/(为了让后面不要变成斜体，此处删去了一个星号);q=0.8Referer http://www.imooc.com/Accept-Encoding gzip, deflate, sdchAccept-Language zh-CN,zh;q=0.8</pre><h3>第一部分：请求行</h3>用来说明请求类型,要访问的资源以及所使用的HTTP版本.GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。<h3>第二部分：请求头部</h3>紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等<h3>第三部分：空行</h3>请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。(注意此例中是有空行的)<h3>第四部分：请求数据</h3>也叫主体，可以添加任意的其他数据。这个例子的请求数据为空。<h2>POST请求例子</h2><pre>POST / HTTP1.1Host:www.wrox.comUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type:application/x-www-form-urlencodedContent-Length:40Connection: Keep-Alivename=Professional%20Ajax&publisher=Wiley</pre><p>第一部分：请求行，第一行明了是post请求，以及http1.1版本。<br>第二部分：请求头部，第二行至第六行。<br>第三部分：空行，第七行的空行。<br>第四部分：请求数据，第八行。</p><center><h1>响应消息Response</h1></center>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。HTTP响应也由四个部分组成，分别是：**状态行**、**消息报头**、**空行**和**响应正文**。<p><img src="https://upload-images.jianshu.io/upload_images/2964446-1c4cab46f270d8ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/683/format/webp" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">      &lt;head&gt;&lt;&#x2F;head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">            &lt;!--body goes here--&gt;</span><br><span class="line">      &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3>第一部分：状态行</h3>由HTTP协议版本号， 状态码， 状态消息 三部分组成。第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）<h3>第二部分：消息报头</h3>用来说明客户端要使用的一些附加信息第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8<h3>第三部分：空行</h3>消息报头后面的空行是必须的<h3>第四部分：响应正文</h3>服务器返回给客户端的文本信息。空行后面的html部分为响应正文。<center><h1>状态码</h1></center>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:<p>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见状态码：</span><br><span class="line">200 OK                        &#x2F;&#x2F;客户端请求成功</span><br><span class="line">400 Bad Request               &#x2F;&#x2F;客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized              &#x2F;&#x2F;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span><br><span class="line">403 Forbidden                 &#x2F;&#x2F;服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found                 &#x2F;&#x2F;请求资源不存在，eg：输入了错误的URL</span><br><span class="line">500 Internal Server Error     &#x2F;&#x2F;服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable        &#x2F;&#x2F;服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure><center><h1>请求方法</h1></center>根据HTTP标准，HTTP请求可以使用多种请求方法。HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET  请求指定的页面信息，并返回实体主体。</span><br><span class="line">HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</span><br><span class="line">POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</span><br><span class="line">PUT  从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">DELETE   请求服务器删除指定的页面。</span><br><span class="line">CONNECT  HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。</span><br><span class="line">OPTIONS  允许客户端查看服务器的性能。</span><br><span class="line">TRACE    回显服务器收到的请求，主要用于测试或诊断。</span><br></pre></td></tr></table></figure><center><h1>工作原理</h1></center>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。<p><strong>以下是 HTTP 请求/响应的步骤：</strong><br>1、客户端连接到Web服务器<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn">http://www.oakcms.cn</a>。</p><p>2、发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p><p>3、服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p><p>4、释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p><p>5、客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p><p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p><ol><li><p>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p></li><li><p>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</p></li><li><p>浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</p></li><li><p>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p></li><li><p>释放 TCP连接;</p></li><li><p>浏览器将该 html 文本并显示内容;</p></li></ol><center><h1>GET和POST请求的区别</h1></center><p>GET请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;books&#x2F;?sex&#x3D;man&amp;name&#x3D;Professional HTTP&#x2F;1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko&#x2F;20050225 Firefox&#x2F;1.0.1</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure><p>POST请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko&#x2F;20050225 Firefox&#x2F;1.0.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name&#x3D;Professional%20Ajax&amp;publisher&#x3D;Wiley</span><br></pre></td></tr></table></figure><h3>提交数据的位置</h3>- GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&连接；例 如：`login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0 %E5%A5%BD`如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。<ul><li>POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据</li></ul><p><strong>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</strong></p><h3>传输数据的大小</h3>首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。而在实际开发中存在的限制主要有：<ul><li><p>GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。因此对于GET提交时，传输数据就会受到URL长度的限制。</p></li><li><p>POST:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p></li></ul><h3>安全性</h3><p>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击</p><h3>Http get,post,soap协议都是在http上运行的</h3><ul><li><p>get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的<br>查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全</p></li><li><p>post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。<br>但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。</p></li><li><p>soap：是http post的一个专用版本，遵循一种特殊的xml消息格式<br>Content-type设置为: text/xml 任何数据都可以xml化。</p></li></ul><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。<strong>GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</strong></p><h3>GET和POST的区别总结</h3><ul><li><p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</p></li><li><p>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p></li><li><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p></li><li><p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p></li></ul><center><h1>Cookie</h1></center>Cookie（复数形态Cookies），又称为“小甜饼”。类型为“小型文本文件”[1]，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。由网景公司的前雇员卢·蒙特利在1993年3月发明[2]。最初定义于RFC 2109。目前使用最广泛的 Cookie标准却不是RFC中定义的任何一个，而是在网景公司制定的标准上进行扩展后的产物。<p>因为HTTP协议是无状态的，即服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。</p><p>在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。</p><p>Cookie另一个典型的应用是当登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器<strong>发送了包含登录凭据（用户名加密码的某种加密形式）的Cookie到用户的硬盘上</strong>。第二次登录时，如果该Cookie尚未到期，浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。</p><center><h1>Session</h1></center>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session]]></content>
      
      
      <categories>
          
          <category> Web Sercurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Common Web Vulnerabilities: Causes, Damage and Defense</title>
      <link href="2020/09/18/Common-Web-Vulnerabilities-Causes-Damage-and-Defense/"/>
      <url>2020/09/18/Common-Web-Vulnerabilities-Causes-Damage-and-Defense/</url>
      
        <content type="html"><![CDATA[<h2 id="注入Injection"><a class="header-anchor" href="#注入Injection">¶</a>注入Injection</h2><p>Injection flaws, such as <strong>SQL</strong>, <strong>NoSQL</strong>, <strong>OS</strong>, and <strong>LDAP</strong> injection, occur when untrusted data is sent to an interpreter as part of a command or query. The attacker’s hostile(怀有敌意的) data can trick the interpreter into <strong>executing unintended commands</strong> or <strong>accessing data without proper authorization</strong>.</p><h3 id="Causes"><a class="header-anchor" href="#Causes">¶</a>Causes</h3><p>刚刚讲过当我们访问动态网页时, Web 服务器会向数据访问层发起 Sql 查询请求，如果权限验证通过就会执行 Sql 语句。<br>这种网站<strong>内部直接发送的Sql请求一般不会有危险</strong>，但实际情况是很多时候需要<strong>结合用户的输入数据动态构造 Sql 语句</strong>，如果用户输入的数据被构造成恶意 Sql 代码，Web 应用又未对动态构造的 Sql 语句使用的参数进行审查，则会带来意想不到的危险。<br>程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。</p><p>具体可阐述如下：</p><ol><li>WEB开发人员无法保证所有的输入都已经过滤</li><li>攻击者利用发送给SQL服务器的输入参数构造可执行的SQL代码（可加入到get请求、post请求、http头信息、cookie中）</li><li>数据库未做相应的安全配置</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">个人总结：</span><br><span class="line">网页需要根据用户输入动态构造SQL语句的时候，如果过滤之类的安全工作没做好，就会导致恶意代码执行、绕过认证、数据泄露等危害。</span><br></pre></td></tr></tbody></table></figure><h3 id="Damage"><a class="header-anchor" href="#Damage">¶</a>Damage</h3><ul><li>数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息。</li><li>绕过认证，列如绕过验证登录网站后台。</li><li>注入可以借助数据库的存储过程进行提权等操作</li><li>网页篡改：通过操作数据库对特定网页进行篡改。</li><li>网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。</li><li>数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。</li><li>服务器被远程控制，被安装后门。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。</li><li>破坏硬盘数据，瘫痪全系统。</li></ul><h3 id="Defense"><a class="header-anchor" href="#Defense">¶</a>Defense</h3><p>是开发人员应该思考的问题，作为测试人员，了解如何预防SQL注入，可以在发现注入攻击bug时，对bug产生原因进行定位。</p><ol><li><p>严格检查输入变量的类型和格式<br>对于整数参数，加判断条件：不能为空、参数类型必须为数字<br>对于字符串参数，可以使用正则表达式进行过滤：如：必须为[0-9a-zA-Z]范围内的字符串</p></li><li><p>过滤和转义特殊字符<br>例如：引号、双引号、斜杠、反斜杠、冒号、 空字符等的字符<br>过滤的对象: 用户的输入 | 提交的URL请求中的参数部分 | 从cookie中得到的数据<br>在username这个变量前进行转义，对’、"、\等特殊字符进行转义，如：php中的addslashes()函数对username参数进行转义</p></li><li><p>利用mysql的预编译机制<br>把sql语句的模板（变量采用占位符进行占位）发送给mysql服务器，mysql服务器对sql语句的模板进行编译，编译之后根据语句的优化分析对相应的索引进行优化，在最终绑定参数时把相应的参数传送给mysql服务器，直接进行执行，节省了sql查询时间，以及mysql服务器的资源，达到一次编译、多次执行的目的，除此之外，还可以防止SQL注入。具体是怎样防止SQL注入的呢？实际上当将绑定的参数传到mysql服务器，mysql服务器对参数进行编译，即填充到相应的占位符的过程中，做了转义操作。</p></li><li><p>监测方面目前大多都是日志监控+WAF（统一的filter）,部署防SQL注入系统或脚本</p></li><li><p>数据库日志容易解析,语法出错的、语法读Info表的建立黑白名单机制</p></li></ol><h3 id="References"><a class="header-anchor" href="#References">¶</a>References</h3><p><a href="https://blog.csdn.net/github_36032947/article/details/78442189?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160042717419195162113454%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160042717419195162113454&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_blog_v1-1-78442189.pc_v2_rank_blog_v1&amp;utm_term=SQL%E6%B3%A8%E5%85%A5&amp;spm=1018.2118.3001.4187">SQL注入攻击常见方式及测试方法</a><br><a href=""></a></p><h2 id="失效的身份认证Broken-Authentication"><a class="header-anchor" href="#失效的身份认证Broken-Authentication">¶</a>失效的身份认证Broken Authentication</h2><p>Application functions related to authentication and session management are often implemented incorrectly, allowing attackers to compromise passwords, keys, or session tokens, or to exploit other implementation flaws to assume(篡夺) other users’ identities temporarily or permanently.</p><h3 id="前言：名词解释"><a class="header-anchor" href="#前言：名词解释">¶</a>前言：名词解释</h3><p>Web应用程序使用的HTTP协议是一种<strong>无连接</strong>，<strong>无状态</strong>协议。</p><p>无连接是指限制每次连接只处理一个请求，服务器处理完成客户的请求，收到客户的应答之后，即断开连接，可以节省传输时间</p><p>无状态是指对于事物处理没有记忆功能，服务器不知道客户端是什么状态。即用户给服务器发送HTTP请求之后，服务器根据请求，将数据发送给用户，但是发送完成之后，不会记录任何信息。</p><p>也就是说，服务器无法保留连接到网站的每个客户端（用户）的身份/活动的内存。那么试想，每次我们登录一个网站，如果意外关闭了，就得重新登录，使用起来会非常不便。<strong>Cookie和Session因此诞生，解决无记录状态的问题</strong>。</p><h4 id="Session"><a class="header-anchor" href="#Session">¶</a>Session</h4><p>Session负责在<strong>服务器端</strong>记录用户信息，在一个用户完成身份认证之后，存储所需要的用户资料，用于持久保存网站的活动。<strong>服务器使用唯一的会话令牌产生对应的会话ID</strong></p><h4 id="Cookie"><a class="header-anchor" href="#Cookie">¶</a>Cookie</h4><p>Cookie由服务器发送并存储在<strong>客户端</strong>，在用户访问网站的时候创建，<strong>用以跟踪用户在网站中的活动</strong>，每次请求客户端都需要把它发送给服务器。当用户意外中断后，由于Cookie的存在就可以从中断的地方继续。</p><h4 id="身份认证"><a class="header-anchor" href="#身份认证">¶</a>身份认证</h4><p>身份认证最常用于系统登录，形式一般为<strong>用户名和密码登录</strong>方式，在安全性要求较高的情况下，还有验证码、客户端证书、Ukey等</p><h4 id="会话管理"><a class="header-anchor" href="#会话管理">¶</a>会话管理</h4><p><strong>HTTP利用会话机制来实现身份认证</strong>，HTTP身份认证的结果往往是<strong>获得一个令牌并放在cookie中，之后的身份识别只需读授权令牌，而无需再次进行登录认证</strong></p><h3 id="Causes-v2"><a class="header-anchor" href="#Causes-v2">¶</a>Causes</h3><ul><li>用户身份验证凭据在存储时不受保护</li><li>登录凭证可以被猜测或重写</li><li>会话ID直接暴露在URL中</li><li>会话ID容易收到会话固定攻击</li><li>会话ID不会超时失效，或者用户会话或身份验证令牌在注销时未失效</li><li>会话ID在登录成功之后不会轮换</li><li>密码，会话ID或者其他的登录凭据未经过加密传输</li></ul><h3 id="Attack"><a class="header-anchor" href="#Attack">¶</a>Attack</h3><ul><li><p>弱口令：弱口令的危害不言而喻，通常指的是仅包含简单的数字和字母组合的口令</p></li><li><p>口令破解：掌握了口令的组合方式或是加密细节</p></li><li><p>Cookie窃取&amp;伪造&amp;绕过：因为Cookie是存储在客户端的，相对而言容易被攻击者窃取</p></li><li><p>越权访问：分为垂直越权访问和水平越权访问，垂直越前访问是指不同用户级别之间的越权，比如普通用户能够执行管理员用户的权限。水平越权即同一级别用户之间的越权操作</p></li><li><p>会话固定：一种诱骗受害者使用攻击者拟定的Session ID的攻击手段，通过让合法用户使用攻击者设置的Session ID进行登录，使得web应用不在生成新的Session ID</p></li><li><p>会话劫持：就是在一次正常的通信过程中，攻击者作为第三方参与到其中，或者是在数据里加入其他信息，甚至将双方的通信模式暗中改变，即从直接联系变成有攻击者参与的联系。简单的说，就是攻击者把自己插入到受害者和目标机器之间，并设法让受害者和目标机器之间的数据通道变为受害者和目标机器之间存在一个看起来像“中转站”的代理机器（攻击者的机器）的数据通道，从而干涉两台机器之间的数据传输，例如监听敏感数据、替换数据等。由于攻击者已经介入其中，他能轻易知道双方传输的数据内容，还能根据自己的意愿去左右它。这个“中转站”可以是逻辑上的，也可以是物理上的，关键在于它能否获取到通信双方的数据。</p></li></ul><h3 id="Damage-v2"><a class="header-anchor" href="#Damage-v2">¶</a>Damage</h3><ul><li>窃取用户凭证和会话信息</li><li>恶意用户冒充用户身份查看或者变更记录，甚至执行事务</li><li>访问未授权的页面和资源</li><li>执行超越权限操作</li></ul><h3 id="Defense-v2"><a class="header-anchor" href="#Defense-v2">¶</a>Defense</h3><ul><li>在可能的情况下，实现多因素身份验证，以防止自动、凭证填充、暴力破解和被盗凭据再利用攻击。</li><li>不要使用发送或部署默认的凭证，特别是管理员用户。</li><li>执行弱密码检查，例如测试新或变更的密码，以纠正“排名前10000个弱密码” 列表。</li><li>将密码长度、复杂性和循环策略与NIST-800-63 B的指导方针的5.1.1章节-记住秘密，或其他现代的基于证据的密码策略相一致。</li><li>确认注册、凭据恢复和API路径，通过对所有输出结果使用相同的消息，用以抵御账户枚举攻击。</li><li>限制或逐渐延迟失败的登录尝试。记录所有失败信息并在凭据填充、暴力破解或其他攻击被检测时提醒管理员。</li><li>使用服务器端安全的内置会话管理器，在登录后生成高度复杂的新随机会话ID。会话ID不能在URL中，可以安全地存储和当登出、闲置、绝对超时后使其失效。</li></ul><h3 id="References-v2"><a class="header-anchor" href="#References-v2">¶</a>References</h3><p><a href="https://www.cnblogs.com/CH42e/p/13162177.html">A2 失效的身份认证和会话管理</a></p><h2 id="敏感数据泄露Sensitive-Data-Exposure"><a class="header-anchor" href="#敏感数据泄露Sensitive-Data-Exposure">¶</a>敏感数据泄露Sensitive Data Exposure</h2><p>Many web applications and APIs do not properly protect sensitive data, such as financial, healthcare, and PII. Attackers may steal or modify such weakly protected data to conduct credit card fraud, identity theft, or other crimes. Sensitive data may be compromised without extra protection, such as encryption at rest or in transit, and requires special precautions when exchanged with the browser.</p><h3 id="Causes-v3"><a class="header-anchor" href="#Causes-v3">¶</a>Causes</h3><p>对敏感数据的弱保护，具体原因如：</p><ul><li>错误的云存储配置</li><li>未受保护的代码存储库</li><li>易受攻击的开源软件</li></ul><h3 id="Damage-v3"><a class="header-anchor" href="#Damage-v3">¶</a>Damage</h3><p>利用敏感信息可以：</p><ul><li>信用卡欺诈</li><li>身份偷窃</li><li>等等</li></ul><h3 id="Defense-v3"><a class="header-anchor" href="#Defense-v3">¶</a>Defense</h3><p>对一些需要加密的敏感数据，应该起码做到以下几点：</p><ul><li>对系统处理、存储或传输的数据分类，并根据分类进行访问控制。</li><li>熟悉与敏感数据保护相关的法律和条例，并根据每项法规要求保护敏感数据。</li><li>对于没必要存放的、重要的敏感数据，应当尽快清除，或者通过PCI DSS标记或拦截。未存储的数据不能被窃取。</li><li>确保存储的所有敏感数据被加密。</li><li>确保使用了最新的、强大的标准算法或密码、参数、协议和密匙，并且密钥管理到位。</li><li>确保传输过程中的数据被加密，如：使用TLS。确保数据加密被强制执行，如：使用HTTP严格安全传输协议（HSTS ）。</li><li>禁止缓存对包含敏感数据的响应。</li><li>确保使用密码专用算法存储密码，如：Argon2 、 scrypt 、bcrypt 或者PBKDF2 。将工作因素（延迟因素）设置在可接受范围。</li><li>单独验证每个安全配置项的有效性。</li></ul><h2 id="XML外部实体-XML-External-Entities-XXE"><a class="header-anchor" href="#XML外部实体-XML-External-Entities-XXE">¶</a>XML外部实体 XML External Entities (XXE)</h2><p>Many older or poorly configured XML processors evaluate external entity references within XML documents. External entities can be used to disclose internal files using the file URI handler, internal file shares, internal port scanning, remote code execution, and denial of service attacks.<br>XML外部实体攻击是一种针对解析XML格式应用程序的攻击类型之一。此类攻击发生在当配置不当的XML解析器处理指向外部实体的文档时，可能会导致敏感文件泄露、拒绝服务攻击、服务器端请求伪造、端口扫描（解析器所在域）和其他系统影响。</p><h3 id="What-is-XML？"><a class="header-anchor" href="#What-is-XML？">¶</a>What is XML？</h3><p>XML由3个部分构成，它们分别是：文档类型定义（Document Type Definition，DTD），即XML的布局语言；可扩展的样式语言（Extensible Style Language，XSL），即XML的样式表语言；以及可扩展链接语言（Extensible Link Language，XLL）。</p><p>XML:可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。它被设计用来传输和存储数据(而不是储存数据),可扩展标记语言是一种很像超文本标记语言的标记语言。它的设计宗旨是传输数据，而不是显示数据。它的标签没有被预定义。您需要自行定义标签。它被设计为具有自我描述性。它是W3C的推荐标准。</p><p>可扩展标记语言(XML)和超文本标记语言(HTML)为不同的目的而设计</p><p>它被设计用来传输和存储数据，其<strong>焦点是数据的内容</strong>。</p><p>超文本标记语言被设计用来显示数据，其焦点是数据的外观</p><p>XML使用元素和属性来描述数据。在数据传送过程中，XML始终保留了诸如父/子关系这样的数据结构。几个应用程序 可以共享和解析同一个XML文件，不必使用传统的字符串解析或拆解过程。 相反，普通文件不对每个数据段做描述(除了在头文件中)，也不保留数据关系结构。使用XML做数据交换可以使应用程序更具有弹性，因为可以用位置(与普通文件一样)或用元素名(从数据库)来存取XML数据。</p><h3 id="XML的实体"><a class="header-anchor" href="#XML的实体">¶</a>XML的实体</h3><p>XML 中的实体分为以下五种：字符实体，命名实体，外部实体，参数实体，内部实体，普通实体和参数实体都分为内部实体和外部实体两种，外部实体定义需要加上** SYSTEM关键字**，其内容是URL所指向的外部文件实际的内容。如果不加SYSTEM关键字，则为内部实体，表示实体指代内容为字符串。</p><h3 id="Causes-v4"><a class="header-anchor" href="#Causes-v4">¶</a>Causes</h3><p>XXE注入，即XML External Entity，XML外部实体注入。通过 XML 实体，”SYSTEM”关键词导致 XML 解析器可以从本地文件或者远程 URI 中读取数据。所以攻击者可以通过 XML 实体传递自己构造的恶意值，是处理程序解析它。当引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。</p><p>既然XML可以从外部读取DTD文件，那我们就自然地想到了如果将路径换成另一个文件的路径，那么服务器在解析这个XML的时候就会把那个文件的内容赋值给SYSTEM前面的根元素中，只要我们在XML中让前面的根元素的内容显示出来，不就可以读取那个文件的内容了。这就造成了一个任意文件读取的漏洞。</p><p>那如果我们指向的是一个内网主机的端口呢？是否会给出错误信息，我们是不是可以从错误信息上来判断内网主机这个端口是否开放，这就造成了一个内部端口被探测的问题。另外，一般来说，服务器解析XML有两种方式，一种是一次性将整个XML加载进内存中，进行解析；另一种是一部分一部分的、“流式”地加载、解析。如果我们递归地调用XML定义，一次性调用巨量的定义，那么服务器的内存就会被消耗完，造成了拒绝服务攻击。</p><h3 id="Damage-v4"><a class="header-anchor" href="#Damage-v4">¶</a>Damage</h3><ul><li><p>检索文件，其中定义了包含文件内容的外部实体，并在应用程序的响应中返回。</p></li><li><p>执行SSRF攻击，其中外部实体是基于后端系统的URL定义的，如：</p></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY xxe SYSTEM "http://127.0.0.1:8080" &gt;探测端口；</span><br><span class="line"></span><br><span class="line"> &lt;!ENTITY xxe SYSTEM "expect://id" &gt;执行命令；</span><br></pre></td></tr></tbody></table></figure><ul><li><p>敏感文件泄露:无回显读取本地敏感文件(Blind OOB XXE)，敏感数据从应用服务器传输到攻击者的服务器上。</p></li><li><p>通过Blind XXE错误消息检索数据是否存在，攻击者可以触发包含敏感数据的解析错误消息。<br>具体的攻击手段和场景在案例中说明。</p></li><li><p>拒绝服务攻击</p></li><li><p>服务器端请求伪造</p></li><li><p>端口扫描（解析器所在域）</p></li></ul><h3 id="Defense-v4"><a class="header-anchor" href="#Defense-v4">¶</a>Defense</h3><p>开发人员培训是识别和减少XXE缺陷的关键，此外，防止XXE 缺陷还需要：</p><ul><li>尽可能使用简单的数据格式（如：JSON），避免对敏感数据进行序列化。</li><li>及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。同时，通过依赖项检测，将SOAP更新到1.2版本或更高版本。</li><li>参考《 OWASP Cheat Sheet ‘XXE Prevention‘ 》，在应用程序的所有XML解析器中禁用XML外部实体和DTD进程。</li><li>在服务器端实施积极的（“白名单”）输入验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据。</li><li>验证XML或XSL文件上传功能是否使用XSD验证或其他类似验证方法来验证上传的XML文件。</li><li>尽管在许多集成环境中，手动代码审查是大型、复杂应用程序的最佳选择，但是SAST 工具可以检测源代码中的XXE漏洞。</li><li>如果无法实现这些控制，请考虑使用虚拟修复程序、API安全网关或Web应用程序防火墙（ WAF ）来检测、监控和防止XXE攻击。</li></ul><h3 id="References-v3"><a class="header-anchor" href="#References-v3">¶</a>References</h3><p><a href="https://www.cnblogs.com/backlion/p/9302528.html">https://www.cnblogs.com/backlion/p/9302528.html</a></p><h2 id="失效的访问控制Broken-Access-Control"><a class="header-anchor" href="#失效的访问控制Broken-Access-Control">¶</a>失效的访问控制Broken Access Control</h2><p>Restrictions on what authenticated users are allowed to do are often not properly enforced. Attackers can exploit these flaws to access unauthorized functionality and/or data, such as access other users’ accounts, view sensitive files, modify other users’ data, change access rights, etc.</p><h3 id="Causes-v5"><a class="header-anchor" href="#Causes-v5">¶</a>Causes</h3><p>大多数Web页面需要验证功能级别的访问权限。但是，服务器需要在每个功能被访问时在服务器端执行相同的访问控制检查。如果请求没有被验证，攻击者能够伪造请求以在未经适当授权时访问某些页面。</p><h3 id="Damage-v5"><a class="header-anchor" href="#Damage-v5">¶</a>Damage</h3><ul><li>访问其他用户的账号</li><li>浏览敏感文件：文件包含/目录遍历<br>许多web应用使用文件管理作为它们日常操作的一部分。但他们使用没有被好好设计的输入验证方法，攻击者可以利用（这个漏洞）来修改或写入文件，甚至执行任意代码。</li><li>修改其他用户数据</li><li>改变访问权限、权限绕过（水平越权）<br>用户未经过身份验证访问资源，或注销后仍可访问资源，对不同用户访问的资源没有做很好的校验，如标准用户可访问管理员资源，或访问其他用户私有资源等。</li><li>权限提升（垂直越权）<br>权限提升是指用户权限从一个阶段提升到另一个阶段的问题，当用户访问的资源比通常情况下访问到的资源更多时，就发生了权限提示漏洞，应用程序应该阻止该权限提升或更改。权限提升一般是由于应用程序自身的缺陷引起的，最后导致程序执行的操作拥有比开发人员或系统管理员预期更多的权限。</li><li>不安全直接对象的引用<br>当应用程序根据用户提供的输入提供对对象的直接访问时，会发生不安全的直接对象引用。 攻击者可以直接绕过授权并访问系统中的资源，例如数据库记录或文件。</li></ul><p>由于应用程序获取用户提供的输入并使用它来检索对象而不执行足够的授权检查。不安全的直接对象引用允许攻击者通过修改用于直接指向对象的参数值来直接绕过授权和访问资源。这些资源可以是属于其他用户的数据库条目，系统中的文件等。</p><h3 id="Defense-v5"><a class="header-anchor" href="#Defense-v5">¶</a>Defense</h3><p>访问控制只有在受信服务器端代码或没有服务器的 API 中有效，这样这样攻击者才无法修改访问控制检查或元数据。</p><ul><li>除公有资源外，默认情况下拒绝访问。</li><li>使用一次性的访问控制机制，并在整个应用程序中不断重用它们，包括最小化CORS使用。</li><li>建立访问控制模型以强制执行所有权记录，而不是接受用户创建、读取、更新或删除的任何记录。</li><li>域访问控制对每个应用程序都是唯一的，但业务限制要求应由域模型强制执行。</li><li>禁用 Web服务器目录列表，并确保文件元数据（如：git）不存在于 Web的根目录中。</li><li>记录失败的访问控制，并在适当时向管理员告警（如：重复故障）。</li><li>对API和控制器的访问进行速率限制，以最大限度地降低自动化攻击工具的危害。</li><li>当用户注销后，服务器上的JWT令牌应失效。开发人员和 QA人员应包括功能访问控制单元和集成测试人员。</li><li>基于角色的访问控制（RBAC）<br>在基于角色的访问控制（RBAC）中，访问决策基于个人在组织或用户群中的角色和职责。<br>定义角色的过程通常基于分析组织的基本目标和结构，并且通常与安全策略相关联。例如，在医疗机构中，用户的不同角色可能包括医生，护士，服务员，护士，患者等等。显然，这些成员需要不同级别的访问才能执行其功能，但也需要根据安全政策和任何相关法规（HIPAA，Gramm-Leach-Bliley等）。<br>RBAC访问控制框架应该为Web应用程序安全管理员提供确定的“谁可以执行哪些操作，何时，从何处，以何种顺序以及在某些情况下在什么关系环境下“执行操作的能力。</li></ul><h2 id="安全配置错误Security-Misconfiguration"><a class="header-anchor" href="#安全配置错误Security-Misconfiguration">¶</a>安全配置错误Security Misconfiguration</h2><p>Security misconfiguration is the most commonly seen issue. This is commonly a result of insecure default configurations, incomplete or ad hoc configurations, open cloud storage, misconfigured HTTP headers, and verbose error messages containing sensitive information. Not only must all operating systems, frameworks, libraries, and applications be securely configured, but they must be patched/upgraded in a timely fashion.</p><h3 id="Causes-v6"><a class="header-anchor" href="#Causes-v6">¶</a>Causes</h3><ul><li>不安全的默认配置</li><li>不完整的或自组织配置</li><li>开放云存储</li><li>HTTP头的错误配置</li><li>包含敏感信息的冗余错误信息</li></ul><h3 id="Damage-v6"><a class="header-anchor" href="#Damage-v6">¶</a>Damage</h3><p>这些漏洞使攻击者能经常访问一些未授权的系统数据或功能。有时，这些漏洞导致系统的完全攻破。业务影响取决于应用程序和数据的保护需求。</p><h3 id="Defense-v6"><a class="header-anchor" href="#Defense-v6">¶</a>Defense</h3><p>应实施安全的安装过程，包括：</p><ul><li>一个可以快速且易于部署在另一个锁定环境的可重复的加固过程。开发、质量保证和生产环境都应该进行相同配置，并且，在每个环境中使用不同的密码。这个过程应该是自动化的，以尽量减少<br>安装一个新安全环境的耗费。</li><li>搭建最小化平台，该平台不包含任何不必要的功能、组件、文档和示例。移除或不安装不适用的功能和框架。</li><li>检查和修复安全配置项来适应最新的安全说明、更新和补丁，并将其作为更新管理过程的一部分，（参见A9：2017-使用含有已知漏洞的组件）。在检查过程中，应特别注意云存储权限（如：S3桶权限）。</li><li>一个能在组件和用户间提供有效的分离和安全性的分段应用程序架构，包括：分段、容器化和云安全组。</li><li>向客户端发送安全指令，如：安全标头。</li><li>在所有环境中能够进行正确安全配置和设置的自动化过程。</li></ul><h2 id="跨站脚本Cross-Site-Scripting（XSS）"><a class="header-anchor" href="#跨站脚本Cross-Site-Scripting（XSS）">¶</a>跨站脚本Cross-Site Scripting（XSS）</h2><p>XSS flaws occur whenever an application <strong>includes untrusted data in a new web page without proper validation or escaping</strong>, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. XSS allows attackers to execute scripts in the victim’s browser which can hijack（劫持） user sessions, deface web sites, or redirect the user to malicious sites.</p><h3 id="Causes-v7"><a class="header-anchor" href="#Causes-v7">¶</a>Causes</h3><p>在一个新网页中不带验证和绕过地包含不信任的数据，或者用用户提供的数据通过浏览器接口来更新已有网页（可以创建HTML或JS）</p><h3 id="Damage-v7"><a class="header-anchor" href="#Damage-v7">¶</a>Damage</h3><ul><li>劫持用户会话</li><li>毁坏网站</li><li>将用户重定向到恶意网站</li></ul><h3 id="Defense-v7"><a class="header-anchor" href="#Defense-v7">¶</a>Defense</h3><p>防止XSS需要将不可信数据与动态的浏览器内容区分开。这可以通过如下步骤实现：</p><ul><li>使用设计上就会自动编码来解决XSS问题的框架，如：Ruby 3.0或 React JS。了解每个框架的XSS保护的局限性，并适当地处理未覆盖的用例。</li><li>为了避免反射式或存储式的XSS漏洞，最好的办法是根据HTML输出的上下文（包括：主体、属性、JavaScript、CSS或URL）</li><li>对所有不可信的HTTP请求数据进行恰当的转义 。更多关于数据转义技术的信息见：《OWASP Cheat Sheet ‘XSS Prevention’》</li><li>在客户端修改浏览器文档时，为了避免DOM XSS攻击，最好的选择是实施上下文敏感数据编码。如果这种情况不能避免，可以采用《OWASP Cheat Sheet ‘DOM based XSS Prevention ‘》描述的类似上下文敏感的转义技术应用于浏览器API。</li><li>使用内容安全策略（CSP）是对抗XSS的深度防御策略。如果不存在可以通过本地文件放置恶意代码的其他漏洞（例如：路径遍历覆盖和允许在网络中传输的易受攻击的库），则该策略是有效的。</li></ul><h2 id="不安全的反序列化Insecure-Deserialization"><a class="header-anchor" href="#不安全的反序列化Insecure-Deserialization">¶</a>不安全的反序列化Insecure Deserialization</h2><p>Insecure deserialization often leads to remote code execution. Even if deserialization flaws do not result in remote code execution, they can be used to perform attacks, including replay attacks, injection attacks, and privilege escalation attacks.</p><h3 id="什么是序列化-反序列化？"><a class="header-anchor" href="#什么是序列化-反序列化？">¶</a>什么是序列化/反序列化？</h3><p>序列化（serialization）在计算机科学的资料处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">个人理解：</span><br><span class="line">序列化：对象到字节流；反序列化：字节流到对象</span><br></pre></td></tr></tbody></table></figure><h3 id="Causes-v8"><a class="header-anchor" href="#Causes-v8">¶</a>Causes</h3><p>PHP 的反序列化漏洞也叫PHP 对象注⼊，是⼀个⾮常常⻅的漏洞，这种漏洞充某些场景下虽然有些难以利⽤，但是⼀旦利⽤成功就会造成⾮常危险的后果。</p><p>漏洞形成的根本原因就是程序没有对⽤户输⼊的反序列化字符串进⾏检测，导致反序列化过程可以被恶意控制，进⽽造成代码执⾏、GetShell 等⼀系列不可控的后果。反序列化漏洞并不是PHP 特有的，也存在与Java、Python 语⾔中。其原理基本相同。在Java反序列化中，会调用被反序列化的readObject方法，当readObject方法书写不当时就会引发漏洞</p><h3 id="Damage-v8"><a class="header-anchor" href="#Damage-v8">¶</a>Damage</h3><ul><li>远程代码执行</li><li>重放攻击</li><li>注入攻击</li><li>提权攻击</li></ul><h3 id="Defense-v8"><a class="header-anchor" href="#Defense-v8">¶</a>Defense</h3><p>唯一安全的架构模式是不接受来自不受信源的序列化对象，或使用只允许原始数据类型的序列化媒体。<br>如果上述不可能的话，考虑使用下述方法：</p><ul><li>执行完整性检查，如：任何序列化对象的数字签名，以防止恶意对象创建或数据篡改。</li><li>在创建对象之前强制执行严格的类型约束，因为代码通常被期望成一组可定义的类。绕过这种技术的方法已经被证明，所以完全依赖于它是不可取的。</li><li>如果可能，隔离运行那些在低特权环境中反序列化的代码。</li><li>记录反序列化的例外情况和失败信息，如：传入的类型不是预期的类型，或者反序列处理引发的例外情况。</li><li>限制或监视来自于容器或服务器传入和传出的反序列化网络连接。</li><li>监控反序列化，当用户持续进行反序列化时，对用户进行警告。</li></ul><h2 id="使用含有已知漏洞的组件"><a class="header-anchor" href="#使用含有已知漏洞的组件">¶</a>使用含有已知漏洞的组件</h2><p>Using Components with Known Vulnerabilities<br>Using Components with Known Vulnerabilities<br>Using Components with Known Vulnerabilities<br>Using Components with Known Vulnerabilities</p><p>Components, such as libraries, frameworks, and other software modules, run with the same privileges as the application. If a vulnerable component is exploited, such an attack can facilitate serious data loss or server takeover. Applications and APIs using components with known vulnerabilities may undermine application defenses and enable various attacks and impacts.</p><h3 id="Causes-v9"><a class="header-anchor" href="#Causes-v9">¶</a>Causes</h3><p>用了含有漏洞的库、框架、软件模块等等</p><h3 id="Damage-v9"><a class="header-anchor" href="#Damage-v9">¶</a>Damage</h3><p>破坏应用程序的安全防护，让各种攻击得以执行</p><h3 id="Defense-v9"><a class="header-anchor" href="#Defense-v9">¶</a>Defense</h3><p>应该制定一个补丁管理流程：</p><ol><li>移除不使用的依赖、不需要的功能、组件、文件和文档。</li><li>利用如 versions、DependencyCheck 、retire.js等工具来持续的记录客户端和服务器端以及它们的依赖库的版本信息。持续监控如CVE 和 NVD等是否发布已使用组件的漏洞信息，可以使用软件分析工具来自动完成此功能。订阅关于使用组件安全漏洞的警告邮件。</li><li>仅从官方渠道安全的获取组件，并使用签名机制来降低组件被篡改或加入恶意漏洞的风险</li><li>监控那些不再维护或者不发布安全补丁的库和组件。如果不能打补丁，可以考虑部署虚拟补丁来监控、检测或保护。</li><li>每个组织都应该制定相应的计划，对整个软件生命周期进行监控、评审、升级或更改配置。</li></ol><h2 id="不足的日志记录和监控Insufficient-Logging-Monitoring"><a class="header-anchor" href="#不足的日志记录和监控Insufficient-Logging-Monitoring">¶</a>不足的日志记录和监控Insufficient Logging &amp; Monitoring</h2><p>Insufficient logging and monitoring, coupled with missing or ineffective integration with incident response, allows attackers to further attack systems, maintain persistence, pivot（以……为中心旋转） to more systems, and tamper, extract, or destroy data. Most breach studies show time to detect a breach is over 200 days, typically detected by external parties rather than internal processes or monitoring.</p><h3 id="Causes-v10"><a class="header-anchor" href="#Causes-v10">¶</a>Causes</h3><p>不足的日志和监控系统，缺失的或无效的事件相应</p><h3 id="Damage-v10"><a class="header-anchor" href="#Damage-v10">¶</a>Damage</h3><p>让攻击者可以更深入地攻击系统，毁坏数据</p><h3 id="Defense-v10"><a class="header-anchor" href="#Defense-v10">¶</a>Defense</h3><p>根据应用程序存储或处理的数据的风险：:</p><ul><li>确保所有登录、访问控制失败、输入验证失败能够被记录到日志中去，并保留足够的用户上下文信息，以识别可疑或恶意帐户，并为后期取证预留足够时间。</li><li>确保日志以一种能被集中日志管理解决方案使用的形式生成</li><li>确保高额交易有完整性控制的审计信息，以防止篡改或删除，例如审计信息保存在只能进行记录增加的数据库表中。</li><li>建立有效的监控和告警机制，使可疑活动在可接受的时间内被发现和应对。</li><li>建立或采取一个应急响应机制和恢复计划，例如：NIST 800-61 rev 2或更新版本。</li></ul><p>目前已有商业的和开源的应用程序防护框架（例如：OWASP AppSensor）、Web应用防火墙（例如 ：Modsecurity with the OWASP Core Rule Set）、带有自定义仪表盘和告警功能的日志关联软件。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web Vulnerabilities </tag>
            
            <tag> Flaw </tag>
            
            <tag> OWASP TOP 10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Software Security First Class</title>
      <link href="2020/09/14/Software-Security-First-Class/"/>
      <url>2020/09/14/Software-Security-First-Class/</url>
      
        <content type="html"><![CDATA[<h4>课外小说与视频</h4>零日<h4>调研报告</h4>暗网]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter1 网络安全引言</title>
      <link href="2020/09/14/Chapter1-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%BC%95%E8%A8%80/"/>
      <url>2020/09/14/Chapter1-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%BC%95%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-计算机安全概念"><a class="header-anchor" href="#1-1-计算机安全概念">¶</a>1.1 计算机安全概念</h2><h4 id="（1）计算机安全"><a class="header-anchor" href="#（1）计算机安全">¶</a>（1）计算机安全</h4><p><strong>用于保护数据安全和防范黑客的工具集合的通用名称</strong></p><p>为什么会出现计算机安全呢？<br>是因为引入了计算机，人们需要保护信息的自动工具了，而不是原始的物理保护（指保险箱hhh）</p><h4 id="（2）网络（互联网）安全"><a class="header-anchor" href="#（2）网络（互联网）安全">¶</a>（2）网络（互联网）安全</h4><p><strong>分布式系统的引入</strong>、网络以及在计算机终端用户与计算机之间、计算机与计算机之间进行通信的工具应用，其中都包含<strong>数据传输</strong>，需要网络安全措施来保护数据。<br><em>（其实更专业的术语叫互联网安全）</em></p><h3 id="1-1-1-计算机安全定义"><a class="header-anchor" href="#1-1-1-计算机安全定义">¶</a>1.1.1 计算机安全定义</h3><p>这是NIST对计算机安全的定义：</p><p>对某个自动化信息系统的保护措施，其目的在于实现信息系统资源的<strong>完整性</strong>、<strong>可用性</strong>以及<strong>机密性</strong>（包括硬件、软件、固件、信息/数据、电信）。</p><h5 id="（1）完整性"><a class="header-anchor" href="#（1）完整性">¶</a>（1）完整性</h5><ol><li>数据完整性：<strong>只能通过已授权的方式</strong>来更改数据</li><li>系统完整性：保证系统<strong>只做它被期待做的事</strong>，不会被奇怪的东西控制</li></ol><p>总结：有种感觉是完整性就是关于只能按照预期的什么什么……</p><h5 id="（2）机密性"><a class="header-anchor" href="#（2）机密性">¶</a>（2）机密性</h5><ol><li>数据机密性：隐私数据不泄漏给未授权的个体</li><li>隐私性：每个人可以控制自己的信息</li></ol><h5 id="（3）可用性"><a class="header-anchor" href="#（3）可用性">¶</a>（3）可用性</h5><p>服务不会拒绝已授权的用户</p><p>这三者取英文首字母组成CIA三元组。</p><p>从损失的角度，可以作如下描述：</p><ul><li>机密性：非授权的信息泄露</li><li>完整性：未经授权的信息修改和破坏</li><li>可用性：访问或使用的中断</li></ul><p>另外，也有人说可以加入真实性（信息是否来自可靠的信息源）、可计量性（能够追踪安全违规的责任方）的概念。</p><p>书P4-5有例子，说明了低、中、高三种级别的损失，以及具体实例下的数据机密性、完整性和可用性的具体内容。</p><h3 id="1-1-2-计算机安全挑战"><a class="header-anchor" href="#1-1-2-计算机安全挑战">¶</a>1.1.2 计算机安全挑战</h3><p>见书P5-6，说明了为什么计算机安全和网络安全复杂且多变。</p><h2 id="1-2-OSI安全体系结构"><a class="header-anchor" href="#1-2-OSI安全体系结构">¶</a>1.2 OSI安全体系结构</h2><p>OSI模型关注的包括以下三个方面：</p><ol><li>安全攻击</li><li>安全机制：检测、防范与恢复</li><li>安全服务：加强安全性，防范攻击</li></ol><p>关于威胁和攻击的辨析：个人觉得威胁是潜在危险，攻击是破坏手段</p><h2 id="1-3-安全攻击"><a class="header-anchor" href="#1-3-安全攻击">¶</a>1.3 安全攻击</h2><p>可以分为两大类：主动和被动攻击</p><ul><li>主动：试图改变系统资源或影响系统操作</li><li>被动：企图了解或利用系统信息<strong>但不影响系统资源</strong></li></ul><h3 id="1-3-1-被动攻击"><a class="header-anchor" href="#1-3-1-被动攻击">¶</a>1.3.1 被动攻击</h3><h4 id="（1）内容"><a class="header-anchor" href="#（1）内容">¶</a>（1）内容</h4><ul><li>本质：窃听或监视</li><li>目标：获取传输的数据信息</li><li>两种形式：消息内容泄露（传输的文件中包含机密信息）和流量分析攻击（观察交换信息的频率和长度来猜测相关通信性质）</li></ul><h4 id="（2）防范"><a class="header-anchor" href="#（2）防范">¶</a>（2）防范</h4><p>由于不改变数据，所以很难检测；一般都是防范为主（如加密），检测为次</p><h3 id="1-3-2-主动攻击"><a class="header-anchor" href="#1-3-2-主动攻击">¶</a>1.3.2 主动攻击</h3><h4 id="（1）内容-v2"><a class="header-anchor" href="#（1）内容-v2">¶</a>（1）内容</h4><ul><li>本质：数据流的改写、错误数据流的添加</li></ul><h4 id="（2）分类"><a class="header-anchor" href="#（2）分类">¶</a>（2）分类</h4><ol><li>假冒：比如可以让某个实体冒充别人后获得更多特权</li><li>重放：=被动捕获数据+主动重新传输</li><li>改写消息：合法消息被篡改——被延迟、重排、被改内容等等</li><li>拒绝服务：</li></ol><h4 id="（3）特点"><a class="header-anchor" href="#（3）特点">¶</a>（3）特点</h4><p>与被动攻击相反，主动攻击不好防范</p><h2 id="1-4-安全服务"><a class="header-anchor" href="#1-4-安全服务">¶</a>1.4 安全服务</h2><p>安全服务定义：</p><blockquote><p>对系统资源或通信的保护处理</p></blockquote><p>安全策略由安全服务实现，安全服务由安全机制实现</p><h3 id="1-4-1-认证"><a class="header-anchor" href="#1-4-1-认证">¶</a>1.4.1 认证</h3><h4 id="1-功能"><a class="header-anchor" href="#1-功能">¶</a>1. 功能</h4><ul><li>确保每个实体都是对方所要求连接的那一方</li><li>确保不会受非法第三方干扰（若被干扰，有可能实体被假冒）</li></ul><h4 id="2-两种特定认证服务"><a class="header-anchor" href="#2-两种特定认证服务">¶</a>2. 两种特定认证服务</h4><ul><li>对等实体认证：如TCP中</li><li>数据源认证：帮助确保数据来源</li></ul><h3 id="1-4-2-访问控制"><a class="header-anchor" href="#1-4-2-访问控制">¶</a>1.4.2 访问控制</h3><h4 id="1-功能-v2"><a class="header-anchor" href="#1-功能-v2">¶</a>1. 功能</h4><p>限制via通信链路访问主机系统和应用程序</p><p>那么问题来了，我们怎么知道限制哪些呢？<br>——可以基于认证，限制那些不该获得访问权限的实体</p><h3 id="1-4-3-数据机密性"><a class="header-anchor" href="#1-4-3-数据机密性">¶</a>1.4.3 数据机密性</h3><h4 id="1-功能-v3"><a class="header-anchor" href="#1-功能-v3">¶</a>1. 功能</h4><p>保护被传输的数据不遭受被动攻击（窃听+流量分析）</p><h4 id="2-两种服务层次"><a class="header-anchor" href="#2-两种服务层次">¶</a>2. 两种服务层次</h4><ul><li>广义：一定时期内两者传输的所有数据</li><li>狭义：对单个消息或者消息的某个字段</li></ul><h3 id="1-4-4-数据完整性"><a class="header-anchor" href="#1-4-4-数据完整性">¶</a>1.4.4 数据完整性</h3><h4 id="1-功能-v4"><a class="header-anchor" href="#1-功能-v4">¶</a>1. 功能</h4><p>保证数据收发一致，有的在检测到数据被篡改以后还会自动恢复</p><h3 id="1-4-5-不可抵赖性"><a class="header-anchor" href="#1-4-5-不可抵赖性">¶</a>1.4.5 不可抵赖性</h3><p>不能否认自己传输过某个消息</p><h3 id="1-4-6-可用性服务"><a class="header-anchor" href="#1-4-6-可用性服务">¶</a>1.4.6 可用性服务</h3><p>主要是为了解决DOS攻击引起的安全问题</p><h2 id="1-5-安全服务"><a class="header-anchor" href="#1-5-安全服务">¶</a>1.5 安全服务</h2><p>安全机制被分为两类：</p><ul><li>特定安全机制：可以合并到特定的协议层</li><li>普适安全机制：没有指定特定的协议层</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201224232709.png" alt=""></p><p>安全服务与机制之间的关系：（竖着为服务）</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201224232854.png" alt=""></p><h2 id="1-6-网络安全模型"><a class="header-anchor" href="#1-6-网络安全模型">¶</a>1.6 网络安全模型</h2><p>首先咱们了解一个概念——逻辑信息通道：</p><blockquote><p>可由两个信息主体，src与dst之间的路由、使用的协议来确定</p></blockquote><h3 id="1-6-1-通用安全模型"><a class="header-anchor" href="#1-6-1-通用安全模型">¶</a>1.6.1 通用安全模型</h3><p>网络安全模型如下图：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201224233728.png" alt=""></p><p>注意上图圈圈处，显示着安全技术的主要两个部分：</p><ul><li>安全相关的转换：比如加密算法</li><li>秘密信息：比如加密密钥</li></ul><p>两者共同作用，将原始消息转换为秘密消息</p><p>对于图中的可信第三方，它一般承担如下任务：</p><ul><li>负责分发秘密信息，并对攻击者隐藏</li><li>仲裁两者之间的纷争</li></ul><p>设计安全服务要做到的四个基本任务：</p><ul><li>设计“安全相关的转换”算法</li><li>生成秘密信息</li><li>设计“分发和共享秘密信息”的方法</li><li>指定两者之间的协议</li></ul><h3 id="1-6-2-网络访问安全模型"><a class="header-anchor" href="#1-6-2-网络访问安全模型">¶</a>1.6.2 网络访问安全模型</h3><p>除了1.6.1中提到的通用模型，其他可以用网络访问安全模型来描述<br>这种模型是为了保护系统免遭有害访问所做，可用下图表示：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201225002542.png" alt=""></p><h4 id="1-两种有害访问"><a class="header-anchor" href="#1-两种有害访问">¶</a>1. 两种有害访问</h4><ul><li>入侵到通过网络能访问的系统</li><li>利用计算机系统逻辑上的弱点，能影响应用程序，这种情况下，程序面临两种威胁:<ul><li>信息访问威胁：没访问权限的用户<strong>干了不该干的事</strong></li><li>服务威胁：合法用户<strong>不能干该干的事</strong></li></ul></li></ul><h4 id="2-解决有害访问的安全机制"><a class="header-anchor" href="#2-解决有害访问的安全机制">¶</a>2. 解决有害访问的安全机制</h4><p>有两大范畴：</p><ul><li>看门人功能：用口令登录，拒绝未授权用户</li><li>屏蔽逻辑：检测蠕虫等攻击，并拒绝它们</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problems during Solving 2020CUMCM-A</title>
      <link href="2020/09/10/Problems-during-Solving-2020CUMCM-A/"/>
      <url>2020/09/10/Problems-during-Solving-2020CUMCM-A/</url>
      
        <content type="html"><![CDATA[<center><h1>待查问题</h1></center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">怎么根据相邻温区之间的温度求温区间隙和边缘的温度？</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">什么关系？怎么预测？</span><br></pre></td></tr></table></figure><center><h1>可参考网址</h1></center><p><a href="https://zh.wikipedia.org/wiki/%E7%86%B1%E5%82%B3%E5%B0%8E%E6%96%B9%E7%A8%8B%E5%BC%8F">热传导方程式简介</a><br><a href="https://www.youtube.com/watch?v=Zw53kxy7yL0">回流炉视频</a><br><a href="https://www.youtube.com/watch?v=xn_oN8ZMaMk">回流炉原理更清晰</a><br><a href="https://www.youtube.com/watch?v=NQiAcJxYfAs">回流炉视频2</a><br><a href="https://www.youtube.com/watch?v=q37g3RflFQ0">物体走过对应温度曲线变化</a><br><a href="https://www.youtube.com/watch?v=4pVUMda2prQ">物体走过对应温度曲线变化2-best oven setup</a><br><a href="https://blog.51cto.com/9269309/1865554">牛顿冷却定律</a><br><a href></a><br><a href></a><br><a href></a><br><a href></a></p><center><h1>名词解释</h1></center><h3>PCB</h3>印刷电路板，又称印制电路板，印刷线路板，常用英文缩写PCB（Printed circuit board）或PWB（Printed wire board），是电子元件的支撑体，在这其中有金属导体作为连接电子元器件的线路。<p>reflow oven</p><p>reflow profile</p><p>soldering  焊接</p><p>SMT<br>SMT贴片指的是在PCB基础上进行加工的系列工艺流程的简称，PCB（Printed Circuit Board)为印刷电路板。SMT是表面组装技术（表面贴装技术）（Surface Mounted Technology的缩写），是电子组装行业里最流行的一种技术和工艺。</p><p>非稳态导热</p><p>导热和热传导的区别<br>材料直接传导热量的能力称为热传导率,或称热导率.热导率定义为单位截面、长度的材料在单位温差下和单位时间内直接传导的热量.热导率的单位为瓦每米每开尔文((W/m.K)). 导热率:物体传导热量的能力,又称为热导率 . 所以,我感觉你提出这两个概念没有区别</p><h3>辨析几个概念</h3>这些公式的适用范围？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">牛顿冷却定律</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">傅里叶导热定律</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">热传导与导热</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">牛顿冷却定律</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">稳态导热</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">非稳态导热</span><br></pre></td></tr></table></figure><center><h1>或许可用的公式</h1></center><p>热传导方程</p><p>牛顿冷却定律</p><p>傅里叶定律</p><p>Crank − Nicholson 方法</p><center><h1>一些假设</h1></center>1. 只考虑热对流、热传导2. 是从炉前区域就开始的3. 假设是热风回流焊炉，热对流传热为主<center><h1>一些想法</h1></center>]]></content>
      
      
      <categories>
          
          <category> Contest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math Modelling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Database Trigger</title>
      <link href="2020/09/07/Database-Trigger/"/>
      <url>2020/09/07/Database-Trigger/</url>
      
        <content type="html"><![CDATA[<p>触发器类似于约束，但比约束更灵活</p><h3 id="定义触发器"><a class="header-anchor" href="#定义触发器">¶</a>定义触发器</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER &lt;触发器名&gt;</span><br><span class="line">  BEFORE|AFTER &lt;触发事件&gt; ON &lt;表名&gt;</span><br><span class="line">  FOR EACH ROW|STATEMENT</span><br><span class="line">  [WHEN &lt;触发条件&gt;]</span><br><span class="line">  &lt;触发动作体&gt;</span><br></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li>表的创建者才能建立触发器，而且一个表上不是无限个</li><li>触发事件：SQL语句动词，另外如UPDATE还可以加上 OF &lt;触发列，…&gt;</li><li>触发器类型：行级：有多少行做多少次；语句级：有多少相关语句做多少次</li><li>触发动作体：可以是AS + PL/SQL块</li></ul><h3 id="激活触发器"><a class="header-anchor" href="#激活触发器">¶</a>激活触发器</h3><p>搞清楚触发器的激活顺序（定义时间先后）</p><h3 id="删除触发器"><a class="header-anchor" href="#删除触发器">¶</a>删除触发器</h3><pre><code>DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Clauses for Database Security</title>
      <link href="2020/09/07/SQL-Clauses-for-Database-Security/"/>
      <url>2020/09/07/SQL-Clauses-for-Database-Security/</url>
      
        <content type="html"><![CDATA[<center><h1>对数据的操作权限</h1></center><h2>授权</h2>GRANT语句：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GRANT &lt;权限&gt; [,&lt;权限&gt;]...</span><br><span class="line">ON &lt;对象类型&gt; &lt;对象名&gt; [,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line">TO &lt;用户&gt; [,&lt;用户&gt;]...</span><br><span class="line">[WITH GRANT OPTION];</span><br><span class="line"></span><br><span class="line">参数解释：</span><br><span class="line">- 权限：SQL语句动词、如UPDATE(Sno)、特定ALL PRIVILEGES......</span><br><span class="line">- 对象：其实一般就是写TABLE table-name这样子，也有直接“视图名”的</span><br><span class="line">- 用户：如U1、特定的PUBLIC.......</span><br><span class="line">- 最后一个可选子句：加上代表获得此权限的用户同时也有给别人授予它的权利</span><br></pre></td></tr></table></figure><h2>回收权限</h2>REVOKE语句：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REVOKE &lt;权限&gt; [,&lt;权限&gt;]...</span><br><span class="line">ON &lt;对象类型&gt; &lt;对象名&gt; [,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line">FROM &lt;用户&gt; [,&lt;用户&gt;]...[CASCADE|RESTRICT];</span><br><span class="line"></span><br><span class="line">参数说明：最后可选的是级联收回或限制操作</span><br></pre></td></tr></table></figure><center><h1>关于数据库模式的权限</h1></center>在DBA创建用户时实现<p>创建用户语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &lt;user-name&gt;</span><br><span class="line">[WITH] [DBA|RESOURCE|CONNECT];</span><br><span class="line"></span><br><span class="line">参数说明：最后括号里的是三种权限，默认最后一个，它们对应的可执行操作见下表</span><br></pre></td></tr></table></figure><p><img src="/2020/09/07/SQL-Clauses-for-Database-Security/%5CSQL-Clauses-for-Database-Security%5Cquan.png" alt></p><center><h1>数据库角色</h1></center>很神奇的是，角色居然是权限的集合（而非用户的集合）可以为拥有相同权限的一组用户创建一个角色<h2>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE ROLE &lt;角色名&gt;；</span><br></pre></td></tr></table></figure><h2>授权</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT &lt;权限&gt; [,&lt;权限&gt;]...</span><br><span class="line">ON &lt;对象类型&gt; &lt;对象名&gt; [,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line">TO &lt;角色&gt; [,&lt;角色&gt;]...</span><br></pre></td></tr></table></figure><h2>用角色授权</h2>因为角色本质是权限，所以我们可以：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT &lt;角色1&gt; [,&lt;角色2&gt;]...</span><br><span class="line">TO &lt;角色3&gt; [,&lt;角色4&gt;]...</span><br><span class="line">[WITH GRANT OPTION]</span><br></pre></td></tr></table></figure><h2>收回角色权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REVOKE &lt;权限&gt; [,&lt;权限&gt;]...</span><br><span class="line">ON &lt;对象类型&gt; &lt;对象名&gt; [,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line">FROM &lt;角色1&gt; [,&lt;角色2&gt;]...;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Database Important&amp;Difficult Exercises Collection</title>
      <link href="2020/09/06/Database-Important-Difficult-Exercises-Collection/"/>
      <url>2020/09/06/Database-Important-Difficult-Exercises-Collection/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a class="header-anchor" href="#题目">¶</a>题目</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">证明：任何一个二目关系都是3NF的</span><br></pre></td></tr></tbody></table></figure><p>正确。因为关系模式中只有两个属性，所以无传递。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">证明：任何一个二目关系都是BCNF的</span><br></pre></td></tr></tbody></table></figure><p>正确。按BCNF的定义，若X-&gt;Y,且Y不是X的子集时，<strong>每个决定因素都包含码</strong>（如果不包含，那就有属性依赖于非码属性啦！就是存在传递依赖咯），对于二目关系决定因素必然包含码。详细证明如下：（任何二元关系模式必定是BCNF）。<br>证明：设R为一个二目关系R(A1，A2)，则属性A1和A2之间可能存在以下几种依赖关系：<br>A、A1-&gt;A2，但A2不-&gt;A1，则关系R的码为A1，决定因素都包含码，所以，R是BCNF。<br>B、A1不-&gt;A2，但A2-&gt;A1，则关系R的码为A2，所以决定因素都包含码，R是BCNF。<br>C、R的码为(A1，A2)（即A1-&gt;A2，A2-&gt;A1），决定因素都包含码，为BCNF</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">证明：任何一个二目关系都是4NF的</span><br></pre></td></tr></tbody></table></figure><p>正确。因为只有两个属性，所以无非平凡的多值依赖。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">判断：</span><br><span class="line">（1）若 R.B→R.A，R.C→R.A，则 R.(B, C)→R.A</span><br><span class="line">（2）若 R.(B, C)→R.A，则 R.B→R.A，R.C→R.A </span><br></pre></td></tr></tbody></table></figure><p>（1）正确，貌似还是可以反证的<br>（2）反例：关系模式 SC（S#，C#，G） 其中有（S#，C#）→G，但是S# 不→ G，C#不→G，也就是说少了一些决定因素就不行了</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">指出下列关系模式是第几范式？并说明理由。</span><br><span class="line">① R（X，Y，Z） F={XY→Z}</span><br><span class="line">② R（X，Y，Z） F={Y→Z，XZ→Y}</span><br><span class="line">③ R（X，Y，Z） F={Y→Z，Y→X，X→Y ， X→ Z}</span><br><span class="line">④ R（X，Y，Z） F={X→Y，X→Z}</span><br><span class="line">⑤ R（W，X，Y，Z） F={X→Z，WX→Y}</span><br><span class="line">``` </span><br><span class="line">（1）码：（X，Y），主属性：X，Y，非主属性：Z</span><br><span class="line">不存在非主对码的部分函数依赖——2NF</span><br><span class="line">不存在非主对码的传递函数依赖——3NF</span><br><span class="line">每个决定因素都包含码——BCNF</span><br><span class="line">除了平凡的、函数依赖的，没有其他多值依赖——4NF</span><br><span class="line">4NF</span><br><span class="line">（2）码：（X，Z），主属性：X，Z，非主属性：Y</span><br><span class="line">不存在非主对码的部分函数依赖——2NF</span><br><span class="line">不存在非主对码的传递函数依赖——3NF</span><br><span class="line">不是每个决定因素都包含码</span><br><span class="line">3NF</span><br><span class="line">（3）码：X，Y，主属性：X，Y，非主属性：Z</span><br><span class="line">不存在非主对码的部分函数依赖——2NF</span><br><span class="line">不存在非主对码的传递函数依赖——3NF</span><br><span class="line">每个决定因素都包含码——BCNF</span><br><span class="line">除了平凡的、函数依赖的，没有其他多值依赖——4NF</span><br><span class="line">4NF</span><br><span class="line">（4）码：X，主属性：X，非主属性：Y，Z</span><br><span class="line">不存在非主对码的部分函数依赖——2NF</span><br><span class="line">不存在非主对码的传递函数依赖——3NF</span><br><span class="line">每个决定因素都包含码——BCNF</span><br><span class="line">除了平凡的、函数依赖的，没有其他多值依赖——4NF</span><br><span class="line">4NF</span><br><span class="line">（5）码：（W，X），主属性：W，X，非主属性：Y，Z</span><br><span class="line">存在非主对码的部分函数依赖</span><br><span class="line">1NF</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>设有关系模式 R(U,F)，其中 U＝ABC，F＝｛A→B，B→C｝，求 F 的闭包 F＋</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">（注：K表示空集）</span><br><span class="line">（1）自反：</span><br><span class="line">k-&gt;K,</span><br><span class="line">A-&gt;K,B-&gt;K,C-&gt;K,</span><br><span class="line">A-&gt;A,B-&gt;B,C-&gt;C,</span><br><span class="line">AB-&gt;K,BC-&gt;K,AC-&gt;K,</span><br><span class="line">AB-&gt;A,AB-&gt;B,BC-&gt;B,BC-&gt;C,AC-&gt;A,AC-&gt;C,</span><br><span class="line">AB-&gt;AB,BC-&gt;BC,AC-&gt;AC,</span><br><span class="line">ABC-&gt;K,</span><br><span class="line">ABC-&gt;A,ABC-&gt;B,ABC-&gt;C,</span><br><span class="line">ABC-&gt;AB,ABC-&gt;BC,ABC-&gt;AC,</span><br><span class="line">ABC-&gt;ABC</span><br><span class="line">（2）增广：</span><br><span class="line">（对于A→B）：A→AB,AB→B,AC→BC</span><br><span class="line">（对于B→C）：AB→AC,B→BC,BC→C</span><br><span class="line">（对于A→C）：A→AC,AB→BC,AC→C</span><br><span class="line">（3）传递：</span><br><span class="line">A-&gt;C,AC-&gt;B,AB-&gt;C</span><br><span class="line"></span><br><span class="line">**如何不重不漏？**</span><br><span class="line">这好像是个NP问题啊....</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>对题 6 的关系模式R，求其候选键并判断A→C和B→A是否属于F＋。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">候选键：A</span><br><span class="line">传递律所以A→C属于</span><br><span class="line">B→A不属于</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>对于关系模式R(ABC)，F={A→BC,BC→A}，求其候选键。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">候选键：A，（B，C）</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>设有关系模式 R(U,F)，其中 U＝ABC，F＝｛A→{B,C},B→C, A→B, {A, B}→C｝，求 Fmin。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一步：分解右边得到F＝｛A→B,A→C,B→C,{A, B}→C｝</span><br><span class="line">第二步：</span><br><span class="line">对于A→B：A在G上的闭包为{A,C}，不含B，可以保留</span><br><span class="line">对于A→C：A在G上的闭包为{A,B,C},含C，不保留</span><br><span class="line">对于B→C：B在G上的闭包为{B},不含C，保留</span><br><span class="line">对于{A, B}→C：AB在G上的闭包为{A,B,C},含C，不保留</span><br><span class="line">F＝｛A→B,B→C｝</span><br><span class="line"></span><br><span class="line">## 一些小疑问</span><br></pre></td></tr></tbody></table></figure><p>定义SQL表时，各种数据类型怎么用？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="https://www.runoob.com/sql/sql-datatypes-general.html"&gt;是一个比较全面的整理&lt;/a&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>SQL语句和用户权限相关的那部分内容？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">见博客“SQL Clauses for Database Security”</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>SQL编程这块我感觉还有好多没见过的词？？？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其实那些是PL/SQL来的</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>数据字典和数据库的关系？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据字典实际上是“关于系统数据的数据库”</span><br><span class="line">感觉有点像**元数据**的意思</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>有些复杂的引理记不清楚</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>几种等价的表达：</p><ol><li>元组表达式</li><li>汉语查询句子</li><li>关系代数表达式（语言）</li><li>域演算表达式（语言）</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 集合</span><br><span class="line">2. 中文</span><br><span class="line">3. π、ρ</span><br><span class="line">4. 基于屏幕表格的查询语言</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>触发器</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">见博客“Database Trigger”</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>证明的规范写法</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>模式分解算法要背啊</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">背了！分成两组即可！</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>怎么从求一个函数依赖集在某属性集上的投影？怎么根据属性集求对应的函数依赖集（应该是一个意思）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">![](\Database-Important-Difficult-Exercises-Collection\p.png)</span><br><span class="line">说人话：</span><br><span class="line">假如我们要求F在U上的投影</span><br><span class="line">可以首先在F中剔掉那些左边X或右边Y不包含于U的函数依赖式，余下的应该就可以</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>复杂的查询用SQL有点绕不来</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">其实有时候，多层嵌套也可以用简单粗暴的自然连接连所有来代替，只是后者显然效率不好</span><br><span class="line">除法虽然还是不懂，但是背下来了！</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>几个连接</p><pre><code>笛卡尔积：简单粗暴的排列组合，一个X等值连接：下面有条件自然连接：下面没有条件## 一句话知识点1. 数据库系统中，数据独立性是指：应用程序与数据库的结构之间相互独立2. 关系数据库包含：内模式、模式、外模式三级模式；分别对应数据库的存储文件、基表、视图(外模式也就是：子模式/用户模式，是用户看到的数据视图)## 要背的知识点1. 数据库系统的特点（物理独立性、逻辑独立性）2. 数据库系统的三级结构模式3. 完整性约束条件4. DBMS主要功能5. 数据管理技术发展过程6. 视图和基表的区别7. SQL特点8. SQL四种语言（?DQMC）9. 数据库设计的基本步骤10. 数据库的维护方法11. 查询处理步骤12. 启发式规则13. 视图的优点## 要注意的名词解释## 要熟悉的算法1. 判别无损连接性2. 判别保持函数依赖性</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Database Programming</title>
      <link href="2020/09/06/Database-Programming/"/>
      <url>2020/09/06/Database-Programming/</url>
      
        <content type="html"><![CDATA[<h2 id="静态嵌入式SQL（ESQL）"><a class="header-anchor" href="#静态嵌入式SQL（ESQL）">¶</a>静态嵌入式SQL（ESQL）</h2><h3 id="ESQL的通用使用过程"><a class="header-anchor" href="#ESQL的通用使用过程">¶</a>ESQL的通用使用过程</h3><h3 id="基本结构"><a class="header-anchor" href="#基本结构">¶</a>基本结构</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL &lt;SQL语句&gt;;</span><br></pre></td></tr></tbody></table></figure><h3 id="ESQL和主语言的通信"><a class="header-anchor" href="#ESQL和主语言的通信">¶</a>ESQL和主语言的通信</h3><ol><li>传递SQL语句执行状态：SQL通信区（SQLCA）</li><li>主语言向SQL语句传参：主变量</li><li>SQL返回结果：主变量+游标</li></ol><h3 id="SQL通信区"><a class="header-anchor" href="#SQL通信区">¶</a>SQL通信区</h3><p>SQLCA中有一个SQLCODE变量<br>为SUCCESS代表执行成功，否则就是错误代码</p><p>定义SQLCA</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL INCLUDE SQLCA;</span><br></pre></td></tr></tbody></table></figure><h3 id="主变量"><a class="header-anchor" href="#主变量">¶</a>主变量</h3><p>SQL语句中用了主程序中的变量就叫做主变量<br>分为输入主变量（主程序输入到SQL）和输出主变量<br>主变量可以附带一个指示变量，对主变量的值加以说明（比如指示主变量是否为空值）</p><p>声明：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">声明主变量、指示变量/*变量的定义就和主程序变量一样*/</span><br><span class="line">char HSno[9];/*比如这样*/</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br></pre></td></tr></tbody></table></figure><p>使用：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:主/指示变量名/*前面加冒号！*/</span><br></pre></td></tr></tbody></table></figure><h3 id="游标"><a class="header-anchor" href="#游标">¶</a>游标</h3><p>游标可以看做一个数据缓冲区<br>SQL语句输出-&gt;游标-&gt;主变量-&gt;主程序</p><p>定义游标（为了一个SQL语句）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL DECLARE [cursor-name] CURSOR FOR</span><br><span class="line">&lt;SQL语句&gt;；</span><br></pre></td></tr></tbody></table></figure><p>打开和关闭游标：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL OPEN [cursor-name]；</span><br><span class="line"></span><br><span class="line">EXEC SQL CLOSE [cursor-name]；</span><br></pre></td></tr></tbody></table></figure><p>从游标中取数据到主变量：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ( ; ; ){</span><br><span class="line">EXEC SQL FETCH [cursor-name] INTO :主变量1, :主变量2, ......</span><br><span class="line">其他操作</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="建立和关闭数据库连接"><a class="header-anchor" href="#建立和关闭数据库连接">¶</a>建立和关闭数据库连接</h3><h4 id="建立连接"><a class="header-anchor" href="#建立连接">¶</a>建立连接</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL CONNECT TO target[AS connection-name][USER user-name]；</span><br><span class="line">参数解释：</span><br><span class="line">- target:要连接的数据库服务器，标识方法有几种</span><br><span class="line">如：&lt;dbname&gt;@&lt;hostname&gt;:&lt;port&gt;</span><br><span class="line">- connection-name：应该就是按标识符的命名规矩来</span><br><span class="line">- </span><br></pre></td></tr></tbody></table></figure><h4 id="修改连接"><a class="header-anchor" href="#修改连接">¶</a>修改连接</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL SET CONNECTION connection-name;</span><br></pre></td></tr></tbody></table></figure><h4 id="关闭连接"><a class="header-anchor" href="#关闭连接">¶</a>关闭连接</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL DISCONNECT [connection];/*这个方括号里的应该就用数据库的名字dbname*/</span><br></pre></td></tr></tbody></table></figure><h4 id="关闭连接前可以来个“提交数据库更新”"><a class="header-anchor" href="#关闭连接前可以来个“提交数据库更新”">¶</a>关闭连接前可以来个“提交数据库更新”</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL COMMIT WORK;</span><br></pre></td></tr></tbody></table></figure><h3 id="不用游标的ESQL"><a class="header-anchor" href="#不用游标的ESQL">¶</a>不用游标的ESQL</h3><h4 id="查询结果为单记录的SELECT语句"><a class="header-anchor" href="#查询结果为单记录的SELECT语句">¶</a>查询结果为单记录的SELECT语句</h4><p>单记录通俗点就是：查询结果只有一行<br>所以我们既不用循环，也不用游标，用一组主变量就可以了</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL SELECT x,x,x,x</span><br><span class="line"> INTO :主变量1, :主变量2; :主变量3, :主变量4</span><br><span class="line"> FROM </span><br><span class="line"> WHERE</span><br></pre></td></tr></tbody></table></figure><h4 id="增删改语句"><a class="header-anchor" href="#增删改语句">¶</a>增删改语句</h4><p>UPDATE/DELETE/INSERT INTO</p><p>关于指示变量：</p><h3 id="用游标的ESQL"><a class="header-anchor" href="#用游标的ESQL">¶</a>用游标的ESQL</h3><h4 id="查询结果为多条记录的SELECT语句"><a class="header-anchor" href="#查询结果为多条记录的SELECT语句">¶</a>查询结果为多条记录的SELECT语句</h4><p>说明游标、打开游标、循环读记录、关闭游标</p><h4 id="CURRENT形式的UPDATE和DELETE语句"><a class="header-anchor" href="#CURRENT形式的UPDATE和DELETE语句">¶</a>CURRENT形式的UPDATE和DELETE语句</h4><h4 id="补充：什么是CURRENT形式？"><a class="header-anchor" href="#补充：什么是CURRENT形式？">¶</a>补充：什么是CURRENT形式？</h4><h2 id="动态嵌入式SQL（ESQL）"><a class="header-anchor" href="#动态嵌入式SQL（ESQL）">¶</a>动态嵌入式SQL（ESQL）</h2><p>包括动态组装SQL语句和动态参数两种形式</p><h3 id="使用SQL语句主变量"><a class="header-anchor" href="#使用SQL语句主变量">¶</a>使用SQL语句主变量</h3><p>程序主变量：就是输入输出主变量那些<br>SQL语句主变量：内容是一句SQL语句</p><p>使用方法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">const char *stmt="SQL语句;";/*SQL语句主变量，注意有两个分号*/</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br><span class="line"></span><br><span class="line">EXEC SQL EXECUTE IMMEDIATE :stmt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="动态参数"><a class="header-anchor" href="#动态参数">¶</a>动态参数</h3><ul><li>第一步：声明SQL语句主变量</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">const char *stmt="SQL语句;";/*SQL语句主变量，注意这里面不确定的参数用？代表*/</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br></pre></td></tr></tbody></table></figure><ul><li>第二步：准备语句</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL PREPARE [语句名] FROM :[SQL语句主变量];</span><br></pre></td></tr></tbody></table></figure><ul><li>第三步：执行语句</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL EXECUTE [语句名] &lt;INTO 主变量表&gt;&lt;USING 主变量或常量&gt;;</span><br></pre></td></tr></tbody></table></figure><h2 id="存储过程"><a class="header-anchor" href="#存储过程">¶</a>存储过程</h2><p>PL/SQL语言：是SQL的过程化扩展，是编写数据库存储过程的一种过程语言</p><h3 id="PL-SQL的块结构"><a class="header-anchor" href="#PL-SQL的块结构">¶</a>PL/SQL的块结构</h3><p>PL/SQL程序的基本结构是块<br>分为匿名块和命名块<br>这里是匿名的，存储过程和函数是命名块</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*定义部分*/</span><br><span class="line">DECLARE</span><br><span class="line">变量、常量、游标、异常etc</span><br><span class="line"></span><br><span class="line">/*执行部分*/</span><br><span class="line">BEGIN</span><br><span class="line">语句</span><br><span class="line">EXCEPTION</span><br><span class="line">异常处理</span><br><span class="line">END;</span><br></pre></td></tr></tbody></table></figure><h3 id="变量常量的定义"><a class="header-anchor" href="#变量常量的定义">¶</a>变量常量的定义</h3><p><em>注：方括号内的内容表示可选</em><br>变量：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 数据类型 [[NOT NULL]:=初值表达式];</span><br></pre></td></tr></tbody></table></figure><p>常量：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常量名 数据类型 CONSTANT:=常量表达式;</span><br></pre></td></tr></tbody></table></figure><p>赋值：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名称:=表达式;</span><br></pre></td></tr></tbody></table></figure><h3 id="控制结构"><a class="header-anchor" href="#控制结构">¶</a>控制结构</h3><h4 id="条件控制语句"><a class="header-anchor" href="#条件控制语句">¶</a>条件控制语句</h4><p>第一种</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IF condition THEN</span><br><span class="line">语句;</span><br><span class="line">END IF</span><br></pre></td></tr></tbody></table></figure><p>第二种</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IF condition THEN</span><br><span class="line">语句;</span><br><span class="line">ELSE</span><br><span class="line">语句;</span><br><span class="line">END IF</span><br></pre></td></tr></tbody></table></figure><p>第三种:THEN和ELSE里面可以再嵌套IF语句</p><h4 id="循环控制语句"><a class="header-anchor" href="#循环控制语句">¶</a>循环控制语句</h4><p>第一种</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOOP</span><br><span class="line">语句；</span><br><span class="line">END LOOP;</span><br></pre></td></tr></tbody></table></figure><p>第二种</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE condition LOOP</span><br><span class="line">语句；</span><br><span class="line">END LOOP;</span><br></pre></td></tr></tbody></table></figure><p>第三种</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR count IN [REVERSE] bound1,...,bound2 LOOP</span><br><span class="line">语句；</span><br><span class="line">END LOOP;</span><br></pre></td></tr></tbody></table></figure><h3 id="存储过程-v2"><a class="header-anchor" href="#存储过程-v2">¶</a>存储过程</h3><h4 id="创建存储过程"><a class="header-anchor" href="#创建存储过程">¶</a>创建存储过程</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE Procedure 过程名([参数1 数据类型，参数2 数据类型，...])/*存储过程首部*/</span><br><span class="line">AS</span><br><span class="line">&lt;PL/SQL块&gt;;/*存储过程体*/</span><br></pre></td></tr></tbody></table></figure><h4 id="重命名存储过程"><a class="header-anchor" href="#重命名存储过程">¶</a>重命名存储过程</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER Procedure 旧过程名 RENAME TO 新过程名;</span><br></pre></td></tr></tbody></table></figure><h4 id="执行存储过程"><a class="header-anchor" href="#执行存储过程">¶</a>执行存储过程</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL/PERFORM Procedure 过程名([参数1，参数2，...]);</span><br></pre></td></tr></tbody></table></figure><h4 id="删除存储过程"><a class="header-anchor" href="#删除存储过程">¶</a>删除存储过程</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP Procedure 过程名();</span><br></pre></td></tr></tbody></table></figure><h3 id="游标-v2"><a class="header-anchor" href="#游标-v2">¶</a>游标</h3><p>PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to do E-R Design</title>
      <link href="2020/09/05/How-to-do-E-R-Design/"/>
      <url>2020/09/05/How-to-do-E-R-Design/</url>
      
        <content type="html"><![CDATA[<h2 id="区分实体和属性"><a class="header-anchor" href="#区分实体和属性">¶</a>区分实体和属性</h2><h3 id="什么能叫属性？"><a class="header-anchor" href="#什么能叫属性？">¶</a>什么能叫属性？</h3><p>两条准则：<br><img src="%5CHow-to-do-E-R-Design%5Catt.png" alt=""></p><p><img src="%5CHow-to-do-E-R-Design%5Cexample.png" alt=""></p><h3 id="数据库设计过程"><a class="header-anchor" href="#数据库设计过程">¶</a>数据库设计过程</h3><h4 id="从数据流图到E-R图（概念模型）"><a class="header-anchor" href="#从数据流图到E-R图（概念模型）">¶</a>从数据流图到E-R图（概念模型）</h4><ul><li><p>第一步：最开始我们有的是一个系统图，表示各个子系统之间的关系（子系统在这里也可以叫“局部应用”），例如这种：<br><img src="%5CHow-to-do-E-R-Design%5Csystem.png" alt=""></p></li><li><p>第二步：开一个循环（？）遍历所有子系统（局部应用），为每一个设计一个E-R图。</p></li><li><p>第三步：针对一个子系统我们怎么设计它的E-R图呢？</p><ol><li>首先从该子系统的数据流图找到设计E-R图的灵感<br><strong>第一层数据流图</strong>（整个子系统的）：<br><img src="%5CHow-to-do-E-R-Design%5Cfirst.png" alt=""><br><strong>第二层数据流图</strong>（再将这个子系统细分为几个）：这里分别是接受订单、处理订单、开发票、支付过账四个<br><img src="%5CHow-to-do-E-R-Design%5C1.png" alt=""><br><img src="%5CHow-to-do-E-R-Design%5C2.png" alt=""><br><img src="%5CHow-to-do-E-R-Design%5C3.png" alt=""><br><img src="%5CHow-to-do-E-R-Design%5C4.png" alt=""></li><li>根据这些数据流图，我们可以搭一个E-R图框架<br><img src="%5CHow-to-do-E-R-Design%5Cframe.png" alt=""></li><li>现在我们可以划分关系+定义属性了<br>说得明白点，其实一个关系的名字应该就对应一个实体型，关系里的属性就对应实体型的属性。得到这样的结果：<br><img src="%5CHow-to-do-E-R-Design%5Centity.png" alt=""></li><li>根据语义，确定实体型之间的关系（1：1/1:n/m:n）</li><li>最后就可以画E-R图啦！<br>完整版本应该是带属性的<br><img src="%5CHow-to-do-E-R-Design%5CER.png" alt=""></li></ol></li><li><p>第四步：当我们把每个子系统的E-R图设计好，就可以开始合并了！</p><ol><li>合并有两种方法，一种一步到位，另一种两两合并到最后（后一种方便些）——其实核心问题都集中在合并两个E-R图的时候怎么操作了</li><li>合并两个E-R图需要两步工作：<br>（1）解决E-R图之间的冲突+合并为初步E-R图</li></ol><blockquote><p>冲突类型及解决方法详见Mindmap</p></blockquote><p>（2）消除冗余+生成基本E-R图</p><blockquote><p>消除冗余见Mindmap</p></blockquote></li></ul><h4 id="例子"><a class="header-anchor" href="#例子">¶</a>例子</h4><p><a href="https://blog.csdn.net/csdn_blog_lcl/article/details/78609119">一个完整的E-R模型设计过程</a><br>有一说一……感觉这个比书上的好懂door了！！！</p><h4 id="从E-R图（概念模型）到关系模型（逻辑模型）"><a class="header-anchor" href="#从E-R图（概念模型）到关系模型（逻辑模型）">¶</a>从E-R图（概念模型）到关系模型（逻辑模型）</h4><p>对于实体型：一个实体型——一个关系模式，属性就是属性，码就是码</p><p>对于联系：<br>1:1的关系<br>（1）成为独立的关系模式：U=与联系相连的各实体的码+联系本身属性；候选码=各实体的码<br>（2）与任意一端合并：被合并的那个加入另一端的码和联系的属性</p><p>1:n关系：<br>（1）成为独立的关系模式：U=与联系相连的各实体的码+联系本身属性；候选码=n端实体的码<br>（2）与n端合并</p><p>m:n关系与多元联系：<br>（1）成为独立的关系模式：U=与联系相连的各实体的码+联系本身属性；各实体的码为关系的码的子集</p><p>注：相同码的关系模式可以合并</p><h3 id="E-R图设计的一些练习题"><a class="header-anchor" href="#E-R图设计的一些练习题">¶</a>E-R图设计的一些练习题</h3><p><a href="https://blog.csdn.net/zxq1138634642/article/details/9121363">一些练习题</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skills for Database Exercises</title>
      <link href="2020/09/04/Skills-for-Database-Exercises/"/>
      <url>2020/09/04/Skills-for-Database-Exercises/</url>
      
        <content type="html"><![CDATA[<center><h1>如何求最小函数依赖集</h1></center><h2>教科书式的定理</h2>![](\Skills-for-Database-Exercises\min.png)<h2>说人话</h2>- 第一步：看到函数依赖式右边有多个属性的，用分解规则拆开- 第二步：考察F中的每个函数依赖，对于其中一个，令一个新的函数依赖集G，这个G就是在F中把这个函数依赖去掉所形成的。接下来，对于这个函数依赖的左边X，考察它在G上的闭包是什么，如果这个闭包包含了函数依赖的右边Y，那么就从F中去掉这个函数依赖；反之保留- 第三步：对于F中每一个左端包含多个属性的函数依赖式，选择左边X的每个子集Z,如果右边Y属于Z的在F上的闭包,则用Z->Y代替X->Y<h2>练练手</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关系模式R(U，F)中，U&#x3D;ABCDEG，F&#x3D;&#123;B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B,ADG-&gt;BC&#125;，求F的最小函数依赖集</span><br></pre></td></tr></table></figure>- 第一步：用分解规则拆右边，得到新的F={B->D，DG->C,BD->E,AG->B,ADG->B,ADG->C}- 第二步：对于B->D，B在G中的闭包是{B},不包含D，所以可以保留对于DG->C，DG在G中的闭包是{D，G}，不包含C，所以可以保留对于BD->E，BD在G中的闭包是{B，D}，不包含E，所以可以保留对于AG->B，AG在G中的闭包是{A，G}，不包含B，所以可以保留对于ADG->B，ADG在G中的闭包是{A，D，G，B，C，E}，包含B，所以丢弃对于ADG->C，ADG在G中的闭包是{A，D，G，B，C，E}，包含C，所以丢弃*注：这里每一步考察完，到下一步时用的还是原来那个F，一次考察就是一次考察，不会动态变化的，不然就很奇怪了。*好，现在的F={B->D，DG->C,BD->E,AG->B}- 第三步：对于DG->C，D在F上的闭包是{D}，没啥替换的；G在F上的闭包是{G}，同样没啥对于BD->E，B在F上的闭包是{B，D，E}，包含E，可用B->E替换BD->E对于AG->B，A在F上的闭包是{A}....所以现在的F={B->D，DG->C,B->E,AG->B}<center><h1>如何求一个属性(组)在某函数依赖集上的闭包</h1></center><h2>教科书式的定理</h2>![](\Skills-for-Database-Exercises\algorithm.png)<h2>说人话</h2>通过一个多次迭代的方法求。![](\Skills-for-Database-Exercises\algorithm1.png)*注：改正一下，应该是“在F中找到一些函数依赖式——它们的左边应该是**包含于**X(i)的”*<center><h1>如何求某函数依赖集的闭包</h1></center>其实就是用那些公理、推理规则之类的开始造作！**如何不重不漏？**这好像是个NP问题啊....<center><h1>如何判断一个函数依赖FD是否属于某函数依赖集F的闭包</h1></center>用公理+推理规则，能推导出来就是属于<center><h1>如何设计E-R图并转换</h1></center><center><h1>如何写好SQL查询</h1></center><center><h1>如何判断关系所属范式</h1></center>我觉得在实际判断中，下面这些判断方法应该一个个往后用，就像过五关斩六将一样<h2>准备工作</h2>- 第一步：找出数据表中所有的候选码。首先考察包含一个属性的所有属性组，看它们能否唯一确定别的所有属性；接下来看包含两个属性的、三个的...以此类推*Tips:假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是候选码了（因为作为码的要求里有一个“完全函数依赖”）*- 第二步：根据第一步所得到的候选码，找出所有的主属性。也就是其中用到的所有属性（候选码的并集）- 第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。<h2>判断是否为2NF</h2>**在关系模式中若没有非主属性对码的部分函数依赖即可称为2NF**<pre>考虑关系模式R（A,B,C,D），已知函数依赖有{B->D,AB->C}，关系模式R的码是（    ），R属于（    ）范式首先找码 码是AB，然后又有D依赖于B，而B属于AB，所以存在D部分函数依赖于AB，所以不是第二范式</pre><h2>判断是否为3NF</h2>**在关系模式中若没有非主属性对码的传递函数依赖即可称为3NF**<h2>判断是否为BCNF</h2>**在关系模式中，如果每一个决定因素都包含码，则属于BCNF**<h2>判断是否为4NF</h2><center><h1>如何将关系规范化（各种模式分解算法）</h1></center><center><h1>SQL语句转查询树</h1></center>给个例子你就懂了，叶子应该是关系。原SQL语句：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname</span><br><span class="line">FROM Student，SC</span><br><span class="line">WHERE Student.Sno&#x3D;SC.Sno AND SC.Cno&#x3D;&#39;2&#39;;</span><br></pre></td></tr></table></figure>优化后：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Student.Sno in (</span><br><span class="line">SELECT Sno</span><br><span class="line">FROM SC</span><br><span class="line">WHERE SC.Cno&#x3D;&#39;2&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>![](\Skills-for-Database-Exercises\tree.png)]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Model Decomposition</title>
      <link href="2020/09/03/Model-Decomposition/"/>
      <url>2020/09/03/Model-Decomposition/</url>
      
        <content type="html"><![CDATA[<h2>关系的一个分解</h2>![](\Model-Decomposition\definition.png)说人话：分解以后的关系，它们的属性集合并起来应该和原关系的属性集相等，此外呢，分解出来的各子关系，它们的属性集之间不能有包含关系那么如何确定某个子关系上的函数依赖呢？在原关系函数依赖的闭包上找，要左右两边的属性合并起来在此子关系的属性集内就可以纳入这个子关系的函数依赖中~<h2>模式分解的三种等价形式</h2>![](\Model-Decomposition\3.png)<h3>什么是“无损连接性”？</h3>个人理解：要从分解后的子关系恢复到原关系，一般是通过自然连接来实现的；假如分解后再用自然连接得到的关系并非原关系，而是一个“元组增加了，信息丢失了”的关系，这种就是有损连接性的分解<h3>什么是“保持函数依赖”？</h3>个人理解：原关系的各种函数依赖，每个应该在某子关系中出现至少一次<h2>引理</h2><h3>记号定义</h3>![](\Model-Decomposition\ydefinition.png)<h3>相关性质</h3>![](\Model-Decomposition\p.png)<h2>无损连接性</h2><h3>定义</h3>![](\Model-Decomposition\wdefinition.png)<h3>判别算法</h3>![](\Model-Decomposition\algorithm.png)<h3>说人话</h3>- 第一步：画一张初始表，所有属性按列排开，分解的有几个关系就几行- 第二步：填初始数据，一行行看，在每个关系模式的U包含的属性列那里写上a(j)，否则写b(ij)- 第三步：遍历所有FD，对于每个，左边X所在的那些列里面，找出填了相同值的那些行；这些行里面，再去看右边Y对应的属性下标对应的列，看里面是否有a(li)这个元素，有的话，全部改为a(li)注：假如有b相关的值在上一句的操作里被改掉了，那这一列所有这个值都要被改- 第四步：知道有一行是a1，a2，a3.....，就说明是无损连接性的<h3>特殊地</h3>![](\Model-Decomposition\adefinition.png)<h3>说人话</h3>如果是分解成两个关系要判别是否无损连接性，写出“U1交U2->U1-U2(谁先谁后看情况)”，看看这个函数依赖是否在F的闭包内，在的话就……<h2>保持函数依赖</h2><h3>定义</h3>![](\Model-Decomposition\depend.png)根据这个定义，我们再加上判断两个函数依赖集是否相等就可以完整地作为一个“保持函数依赖”的判别算法了！即：（原F的闭包）要和（分解后F们的并集的闭包）相等<h2>模式分解的算法</h2><h3>关于模式分解结果的几种情况</h3>1. 如果保持了“无损连接性”，则分解后的关系一定是4NF的2. 如果保持了“保持函数依赖性”，则分解后的关系一定是3NF的，不一定能到BCNF3. 如果保持了“无损连接性”和“保持函数依赖性”，则分解后的关系一定是3NF的，不一定能到BCNF（？？？）<h3>“保持函数依赖性”+3NF&emsp;模式分解算法</h3><h4>教科书式定义</h4>![](\Model-Decomposition\a1.png)<h4>说人话</h4>- 第一步：极小化F- 第二步：在U中去掉F中不包含的属性*注：接下来讨论的都是处理后的F和U了！！！*- 第三步：假如F中有函数依赖能使左右两边合并起来恰好是U，那没事了，R不用作分解，算法终止；不是的话就转第四步- 第四步：把F按照相同左边X的规则分组成几个小的函数依赖集F'(i)，对应地有它的U(i)，再用U(i)在F上找到对应的F(i)，R就这样被分解了<h3>“保持函数依赖性”+“无损连接性”+3NF&emsp;模式分解算法</h3><h4>教科书式定义</h4>![](\Model-Decomposition\a2.png)<h4>说人话</h4>- 第一步：先做算法6.3，也就是先让分解后的模式“保持函数依赖性”。- 第二步：找到原关系R的码X，和它在F上的闭包，形成一个对应关系R(x)- 第三步：在先前得到的几个子关系R(i)中，寻找一下有没有对应的U(i)包含了X的，要是有，那么这个R(x)就不用加到分解出的子关系里面了，反之是需要的<h3>“无损连接性”+BCNF&emsp;模式分解算法</h3><h4>教科书式定义</h4>![](\Model-Decomposition\a3.png)<h4>说人话</h4><ul><li>第一步：初始的状态就是从原关系R开始，</li><li>第二步：检查一下当前分解中是不是每个关系都符合BCNF了，如果是，就可以终止了；如果不是，跳第三步</li><li>第三步：对于那些不符合BCNF的关系，我们找到某个函数依赖——它的左边X并非此关系的码。我们把这个函数依赖的左右两边合并，这是一个属性集；然后在此关系属性集里面剔除“此函数依赖的右边Y”就形成另一个属性集。有了分解后的两个属性集，根据它们生成对应的F就好啦。这样就把这个关系分解好了。跳第二步</li></ul><h3>“无损连接性”+4NF&emsp;模式分解算法</h3><h4>教科书式定义</h4>![](\Model-Decomposition\a4.png)<h4>说人话</h4>- 第一步：用算法6.5做到“无损连接性”+BCNF- 第二步：考察分解中那些不符合4NF的关系，用定理6.6的方法分解- 第三步：分解中的每个子关系都属于4NF即可终止<h4>补充：什么是传说中的定理6.6呢？</h4>![](\Model-Decomposition\d1.png)这个定理的意思就是，既然这个关系不符合4NF吧，那就是有非平凡非函数依赖的多值依赖，也就是X-->Y。有了它我们把关系分成（X,Y）和（X,Z），有点奇怪的是，为什么关系可以这样表示啊？<h2>完整版数据依赖的公理系统</h2><h3>8条公理</h3>![](\Model-Decomposition\g1.png)<h3>4条推理规则</h3>![](\Model-Decomposition\g2.png)]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/09/02/Axiom-System-of-Data-Dependency/"/>
      <url>2020/09/02/Axiom-System-of-Data-Dependency/</url>
      
        <content type="html"><![CDATA[<p>—title: Axiom System of Data Dependencydate: 2020-09-02 14:33:49tags:- Databasecategories:- Courses—## Armstrong公理系统### 什么是逻辑蕴含？<img src="%5CAxiom-System-of-Data-Dependency%5Clogical.png" alt=""><br><br>### 如何确定一个函数依赖是否为F所蕴含？<img src="%5CAxiom-System-of-Data-Dependency%5CArmstrong.png" alt=""><em>注：XZ表示X并Z</em>对于Armstrong公理的简要说明：1. 自反律：其实这个和F无关，我们只要有一个大集合X和它的子集Y，就会有X-&gt;Y2. 增广率：需要推出XZ-&gt;YZ，也就是证明，如果有两个元组在XZ上的值相等，那么在YZ上的值也会相等；对于前半句：这个条件就给出两个元组在X上值相等，且在Z上值相等；根据X-&gt;Y，它们在Y上的值相等，和Z的一合并，就推出了这两个元组在YZ上的值也会相等3. 传递率：你懂的顺带导出了3条推理规则：1. 合并规则：X-&gt;Y与X-&gt;Z可得X-&gt;YZ2. 伪传递规则：X-&gt;Y与WY-&gt;Z可得XW-&gt;Z3. 分解规则：X-&gt;Y与Z包含于Y可得X-&gt;Z还顺带有个小引理：就是X-&gt;ABCDEF…与右边的分开写，是互为充要条件的<br><br>### 关于闭包函数依赖集F的闭包：是指运用Armstrong公理系统推导出来的所有F可蕴含的函数依赖，结果形式应该是一个函数依赖组成的集合属性集X关于函数依赖集F的闭包：有个推导算法可以用，结果形式应该是一个属性组成的集合算法如下：<img src="%5CAxiom-System-of-Data-Dependency%5Calgorithm.png" alt="">### 极小函数依赖集#### 定义<img src="%5CAxiom-System-of-Data-Dependency%5Cdefinition.png" alt=""><em>注：两个函数依赖集等价，就是函数依赖集的闭包相等</em>#### 化简为极小函数依赖集（亦为判定）<img src="%5CAxiom-System-of-Data-Dependency%5Cmin.png" alt=""><br><br><br><br><br></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Without Faith</title>
      <link href="2020/08/27/Without-Faith/"/>
      <url>2020/08/27/Without-Faith/</url>
      
        <content type="html"><![CDATA[<p>我的孤独像一座花园<br>里面只有没有灵魂的美</p><p>我希望<br>自己能像<br>夜晚梦到白日那样<br>充满信念</p><p>在话语里有野火<br>灵魂憔悴不堪<br>头颅在黑暗中沉默</p>]]></content>
      
      
      <categories>
          
          <category> Insights on Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Faith </tag>
            
            <tag> Life </tag>
            
            <tag> Emotion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hard-to-Understand Concepts in Database</title>
      <link href="2020/08/26/Hard-to-Understand-Concepts-in-Database/"/>
      <url>2020/08/26/Hard-to-Understand-Concepts-in-Database/</url>
      
        <content type="html"><![CDATA[<h2 id="About-Keys"><a class="header-anchor" href="#About-Keys">¶</a>About Keys</h2><p>  码、主码、候选码的关系:<br><img src="https://img-blog.csdnimg.cn/20190625173457198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bWFsaXFpbmdodWE=,size_16,color_FFFFFF,t_70" alt=""></p><p>貌似码=超键<br><a href="https://blog.csdn.net/sumaliqinghua/article/details/85872446">一篇不错的博客</a><br>全码：整个属性组是码</p><h2 id="About-Dependencies"><a class="header-anchor" href="#About-Dependencies">¶</a>About Dependencies</h2><h3 id="完全函数依赖"><a class="header-anchor" href="#完全函数依赖">¶</a>完全函数依赖</h3><p>  设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。<br>  <em>举个例子</em>：通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB.</p><h3 id="部分函数依赖"><a class="header-anchor" href="#部分函数依赖">¶</a>部分函数依赖</h3><p>  设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。<br>  <em>举个例子</em>：通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。</p><h3 id="传递函数依赖"><a class="header-anchor" href="#传递函数依赖">¶</a>传递函数依赖</h3><p>  传递函数依赖：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。<br>  <em>举个例子</em>：通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么成C传递依赖于A</p><h3 id="多值依赖"><a class="header-anchor" href="#多值依赖">¶</a>多值依赖</h3><p>设R(U)是一个属性集合U上的一个关系模式，X, Y, 和Z是U的子集，并且Z=U-X-Y，多值依赖X-&gt;-&gt;Y成立当且仅当对R的任一个关系r，r在(X,Z)上的每个值对应一组Y的值，这组值仅仅决定于X值而与Z值无关。<br>注：我突然觉得，这个与Z值无关，貌似不是什么很特别的言论。其实吧，我的理解就是，有一个X，有一个Y，一个X值对应多个Y值。（啊不过！Z的有无还是会决定这个多值依赖是非平凡/平凡的！）</p><p>若X-&gt;-&gt;Y，而Z=空集，则称X-&gt;-&gt;Y为平凡的多值依赖。否则，称X-&gt;-&gt;Y为非平凡的多值依赖。</p><p>平凡多值依赖就是，属性集合中分为两个真子集，每一个X对应一组Y的取值<br><img src="%5CHard-to-Understand-Concepts-in-Database%5Cpingdepend.png" alt=""><br>**<br>可以看出，如果把上面的一组改为一个，那么多值依赖就变成了函数依赖。当然一个值组成的组也是组，所以说，函数依赖是多值依赖的特殊情况。<br>（首先函数依赖和多值依赖的X、Y应该都可以是属性组吧，函数依赖是一个x值决定一个y值，多值依赖是一个x值决定多个y值）**<br><img src="%5CHard-to-Understand-Concepts-in-Database%5Cdepen.png" alt=""></p><h4 id="多值依赖的性质"><a class="header-anchor" href="#多值依赖的性质">¶</a>多值依赖的性质</h4><p><img src="%5CHard-to-Understand-Concepts-in-Database%5Cmdependp.png" alt=""></p><h4 id="多值依赖与函数依赖区别"><a class="header-anchor" href="#多值依赖与函数依赖区别">¶</a>多值依赖与函数依赖区别</h4><p><img src="%5CHard-to-Understand-Concepts-in-Database%5Cdifference1.png" alt=""></p><h3 id="连接依赖"><a class="header-anchor" href="#连接依赖">¶</a>连接依赖</h3><h3 id="函数依赖图"><a class="header-anchor" href="#函数依赖图">¶</a>函数依赖图</h3><p>看了这个你就懂怎么操作了<br><img src="%5CHard-to-Understand-Concepts-in-Database%5Cfdepend.png" alt=""><br>还有涉及到部分函数依赖时，可以用虚线表示<br><img src="%5CHard-to-Understand-Concepts-in-Database%5Cpdepend.png" alt=""><br>多值依赖<br><img src="%5CHard-to-Understand-Concepts-in-Database%5Cmdepend.png" alt=""></p><h2 id="零散小知识"><a class="header-anchor" href="#零散小知识">¶</a>零散小知识</h2><h3 id="二目关系"><a class="header-anchor" href="#二目关系">¶</a>二目关系</h3><p>其实<strong>目</strong>或者说<strong>度</strong>，就是一个关系中有多少个属性而已…<br>所以二目关系就是有两列的那种啦</p><h3 id="数据流图"><a class="header-anchor" href="#数据流图">¶</a>数据流图</h3><p>数据流程图（DFD）是一种能全面地描述信息系统逻辑模型的主要工具，它可以用少数几种符号综合地反映出信息在系统中的流动、处理和存储情况。数据流程图是表示<strong>操作或数据的方向</strong>。<br><img src="%5CHard-to-Understand-Concepts-in-Database%5CDFD.png" alt=""><br>数据流图有四种基本图形符号：</p><ul><li>箭头：表示数据流；</li><li>圆或椭圆：表示加工；</li><li>双杠：表示数据存储；</li><li>方框：表示数据的源点或终点。</li></ul><h3 id="决定因素"><a class="header-anchor" href="#决定因素">¶</a>决定因素</h3><p>貌似说的就是一个函数依赖的左边</p><h3 id="函数依赖集的覆盖"><a class="header-anchor" href="#函数依赖集的覆盖">¶</a>函数依赖集的覆盖</h3><p>F的最小覆盖其实就是它的极小函数依赖集</p><h3 id="表达查询的一堆语句形式"><a class="header-anchor" href="#表达查询的一堆语句形式">¶</a>表达查询的一堆语句形式</h3><h4 id="关系代数表达式"><a class="header-anchor" href="#关系代数表达式">¶</a>关系代数表达式</h4><p>应该就是π、ρ那些吧</p><h4 id="元组关系演算表达式"><a class="header-anchor" href="#元组关系演算表达式">¶</a>元组关系演算表达式</h4><p>就是那些集合的形式</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Understanding Paradigm in Database Design</title>
      <link href="2020/08/26/Understanding-Paradigm-in-Database-Design/"/>
      <url>2020/08/26/Understanding-Paradigm-in-Database-Design/</url>
      
        <content type="html"><![CDATA[<center><h1>1NF</h1></center>&emsp;&emsp;1NF的定义为：符合1NF的关系中的每个属性都不可再分，要求属性具有**原子性**，不可再分解;<p>  不符合的关系：<br><img src="https://pic4.zhimg.com/80/24afd11455ac34a280fa83e4e8d75ccc_1440w.jpg?source=1940ef5c" alt><br>  符合的关系：<br><img src="https://pic3.zhimg.com/80/6b735fb9503b0930e741faa474fed28e_1440w.jpg?source=1940ef5c" alt></p><center><h1>2NF</h1></center>2NF是对记录的**惟一性**，要求记录有惟一标识，即实体的惟一性，即不存在部分依赖；2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖，简而言之，第二范式就是非主属性完全依赖于主关键字。<h3>如何确定一个关系是否为2NF</h3>- 第一步：找出数据表中所有的候选码。首先考察包含一个属性的所有属性组，看它们能否唯一确定别的属性；接下来看包含两个属性的、三个的...以此类推*Tips:假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是候选码了（因为作为码的要求里有一个“完全函数依赖”）*- 第二步：根据第一步所得到的候选码，找出所有的主属性。也就是其中用到的所有属性（候选码的并集）- 第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。- 第四步：查看是否存在非主属性对码的部分函数依赖。![](\Understanding-Paradigm-in-Database-Design\2NF.png)<h3>如何把一个关系改造成2NF</h3>投影分解，把存在部分依赖的地方拆开<center><h1>3NF</h1></center>3NF是对字段的**冗余性**，它要求字段没有冗余，即不存在传递依赖；要求任何字段不能由其他字段派生出来每个**非主属性**都不传递依赖于R的候选键**简而言之，第三范式就是属性不依赖于其它非主属性。**> 表: 学号, 姓名, 年龄, 学院名称, 学院电话<h3>如何把一个关系改造成3NF</h3>投影分解，把存在传递依赖的地方拆开<center><h1>BCNF</h1></center>在 3NF 的基础上消除主属性对于码的部分与传递函数依赖（是修正的/扩充的第三范式），就是属性不依赖于其它非主属性（不能存在关键字段决定关键字段的情况）每个**属性**都不传递依赖于R的候选键一个满足BCNF的关系模式：- 所有非主属性对每一个码都是完全函数依赖（满足2NF）- 所有的主属性对每一个不包含它的码，是完全函数依赖（让主属性对码不存在部分函数依赖）- 没有任何属性完全函数依赖于非码的任何一组属性（主属性和非主属性都不能完全依赖于非码的任何一组属性，因为这样就存在属性对码的传递函数依赖）<p><em>Tips:全码的关系一定属于BCNF</em></p><center><h1>4NF</h1></center>![](Understanding-Paradigm-in-Database-Design\2.png)<center><h1>To put it Simple</h1></center>1、第一范式（1NF）：一个关系模式R的所有属性都是不可分的基本数据项。2、第二范式（2NF）：满足第一范式，然后消除部分依赖。（消除-非主-部分）3、第三范式（3NF）： 满足第二范式，消除传递依赖。（消除-非主-传递）4、BC范式（BCNF）：满足第三范式（消除-主与非主-部分与传递）5、第四范式（4NF）：满足BC范式，在多值依赖中，去掉了属于函数依赖的，也去掉了非平凡的（消除-非平凡与非函数依赖-多值依赖）![](https://img-blog.csdn.net/20170508213333607?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRG92ZV9Lbm93bGVkZ2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)<center><h1>规范化过程</h1></center>![](Understanding-Paradigm-in-Database-Design\1.png)<center><h1>可参考资料</h1></center><a href="https://zhuanlan.zhihu.com/p/20028672">有讲解有习题的讲范式的博客</a>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Understanding &#39;division&#39; and Its Implementation in SQL</title>
      <link href="2020/08/24/Understanding-division-and-Its-Implementation-in-SQL/"/>
      <url>2020/08/24/Understanding-division-and-Its-Implementation-in-SQL/</url>
      
        <content type="html"><![CDATA[<center><h1>What does Division really do</h1></center><h2>Process</h2>2. The result of Division of R/S, contains columns which are in R but not in S. (In other words, R's columns except which also in S.)3. Define T=R/S and T's columns is C.4. For each c in C, find their “象集” in R.5. Find S's projection on its common columns with R.6. If c's “象集” includes the result in 5, then add it to T.<h2>Example</h2>1. <br>![](https://img-blog.csdn.net/20161221185506785)2. 在R关系中A属性的值可以取{ a1，a2，a3，a4 }a1值对应的象集为 {  (b1,c2)  , (b2,c1) ,  (b2,c3)  }a2值对应的象集为 {  (b3,c7)  , (b2,c3) }a3值对应的象集为 {  (b4,c6)  }a4值对应的象集为 {  (b6,c6)  }3. 关系S在B、C上的投影为 {  (b1,c2)  , (b2,c1) ,  (b2,c3)  }4. 只有a1值对应的象集包含关系S的投影集，所以只有a1应该包含在A属性中5. R/S=<table><thead><tr><th>A</th></tr></thead><tbody><tr><td>a1</td></tr></tbody></table><center><h1>Implementation in SQL</h1></center><h2>How to do</h2>1. R(X，Y)÷S(Y，Z)的运算用结构化语言SQL 语句可表达为下列形式:2.  ![](/Understanding-division-and-Its-Implementation-in-SQL/division.png)3. 用双重`not exists`来实现，- 第一层：选出R表中，Y属性上的值和S中有相等的那些元组- 第二层：从S中排除这些元组，余下的都是在Y上S有但R没有的Y值- 第三层：<p><em>补充</em>：什么是not exists？<br>  exists，强调的是是否有返回集，不需知道具体返回的是什么,只要exists引导的子句有结果集返回，这个条件就算成立。</p>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summary for =Learn SQL= //Codecademy</title>
      <link href="2020/08/23/Summary-for-Learn-SQL-Codecademy/"/>
      <url>2020/08/23/Summary-for-Learn-SQL-Codecademy/</url>
      
        <content type="html"><![CDATA[<center><h1>Manipulation</h1></center>We’ve learned six commands commonly used to manage data stored in a relational database and how to set constraints on such data. What can we generalize so far?<ul><li>SQL is a programming language designed to manipulate and manage data stored in relational databases.</li><li>A relational database is a database that organizes information into one or more tables.</li><li>A table is a collection of data organized into rows and columns.</li><li>A statement is a string of characters that the database recognizes as a valid command.</li></ul><p>creates a new table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name(</span><br><span class="line">attribute1 type constraint,</span><br><span class="line">attribute1 type constraint</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>constraint:</p><ol><li><p><code>PRIMARY KEY</code> columns can be used to uniquely identify the row. Attempts to insert a row with an identical value to a row already in the table will result in a constraint violation which will not allow you to insert the new row.</p></li><li><p><code>UNIQUE</code> columns have a different value for every row. This is similar to PRIMARY KEY except a table can have many different UNIQUE columns.</p></li><li><p><code>NOT NULL</code> columns must have a value. Attempts to insert a row without a value for a NOT NULL column will result in a constraint violation and the new row will not be inserted.</p></li><li><p><code>DEFAULT</code> columns take an additional argument that will be the assumed value for an inserted row if the new row does not specify a value for that column.</p></li><li><p>关于外码（主码也可放最后）</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Orders</span><br><span class="line">(</span><br><span class="line">O_Id int NOT NULL,</span><br><span class="line">OrderNo int NOT NULL,</span><br><span class="line">P_Id int,</span><br><span class="line">PRIMARY KEY (O_Id),</span><br><span class="line">FOREIGN KEY (P_Id) REFERENCES Persons(P_Id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="6"><li>关于自定义约束</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">P_Id int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">CHECK (P_Id&gt;0)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;*可以给约束命名*&#x2F;</span><br><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">P_Id int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City&#x3D;&#39;Sandnes&#39;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注：如果建表时忘记加了，之后加也是可以的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City&#x3D;&#39;Sandnes&#39;)</span><br></pre></td></tr></table></figure><p>adds a new row to a table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name(a1,a2,a3) </span><br><span class="line">VALUES(v1,v2,v3);</span><br></pre></td></tr></table></figure><p>queries data from a table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT attributes</span><br><span class="line">FROM table_name </span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><p>changes an existing table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">ADD COLUMN c1_name type; </span><br></pre></td></tr></table></figure><p>edits a row in a table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line">SET .....</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><p>deletes rows from a table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><h1><center>Queries</center></h1><p><code>AS</code> is a keyword in SQL that allows you to rename a column or table using an alias. The new name can be anything you want as long as you put it inside of single quotes.</p><p>Some important things to note:</p><ul><li>Although it’s not always necessary, it’s best practice to surround your aliases with single quotes.</li><li>When using <code>AS</code>, the columns are not being renamed in the table. The aliases only appear in the result.</li><li><code>SELECT</code> is the clause we use every time we want to query information from a database.</li><li><code>AS</code> renames a column or table.</li><li><code>DISTINCT</code> return unique values.</li><li><code>WHERE</code> is a popular command that lets you filter the results of the query based on conditions that you specify.</li><li><code>LIKE</code> and <code>BETWEEN</code> are special operators.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIKE:</span><br><span class="line">The _ means you can substitute any individual character here without breaking the pattern.(一个对一个字符，汉字的话要用两个空空)</span><br><span class="line">% is a wildcard character that matches zero or more missing letters in the pattern. </span><br></pre></td></tr></table></figure><ul><li><code>AND</code> and <code>OR</code> combines multiple conditions.</li><li><code>ORDER BY</code> sorts the result.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认asc，降序是desc</span><br></pre></td></tr></table></figure><ul><li><code>LIMIT</code> specifies the maximum number of rows that the query will return.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT 数字 &#x2F;*数字就是最后显示的结果有多少行*&#x2F;</span><br></pre></td></tr></table></figure><ul><li><code>CASE</code> creates different outputs.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT name,</span><br><span class="line"> CASE</span><br><span class="line">  WHEN imdb_rating &gt; 8 THEN &#39;Fantastic&#39;</span><br><span class="line">  WHEN imdb_rating &gt; 6 THEN &#39;Poorly Received&#39;</span><br><span class="line">  ELSE &#39;Avoid at All Costs&#39;</span><br><span class="line"> END AS &#39;Review&#39;%表示新增的这一列的命名，没有貌似也可</span><br><span class="line">FROM movies;</span><br></pre></td></tr></table></figure><h1><center>Aggregate Functions</center></h1><ul><li><code>COUNT()</code>: count the number of rows</li><li><code>SUM()</code>: the sum of the values in a column</li><li><code>MAX()/MIN()</code>: the largest/smallest value</li><li><code>AVG()</code>: the average of the values in a column</li><li><code>ROUND()</code>: round the values in the column</li></ul><p>Aggregate functions combine multiple rows together to form a single value of more meaningful information.</p><ul><li><code>GROUP BY</code> is a clause used with aggregate functions to combine data from one or more columns.</li><li><code>HAVING</code> limit the results of a query based on an aggregate property.</li></ul><p>关于SQL语句的执行顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(1) from </span><br><span class="line">(3) join </span><br><span class="line">(2) on </span><br><span class="line">(4) where </span><br><span class="line">(5) group by(开始使用select中的别名，后面的语句中都可以使用)</span><br><span class="line">(6) avg,sum.... </span><br><span class="line">(7) having </span><br><span class="line">(8) select </span><br><span class="line">(9) distinct </span><br><span class="line">(10) order by</span><br><span class="line">(11) limit </span><br></pre></td></tr></table></figure><p>从这个顺序中我们不难发现，所有的查询语句都是从from开始执行的，在执行过程中，每个步骤都会为下一个步骤<strong>生成一个虚拟表</strong>，这个虚拟表将作为下一个执行步骤的输入。<br>第一步：首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 vt1（选择相对小的表做基础表）</p><p>第二步：接下来便是应用on筛选器，on 中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足on逻辑表达式的行，生成虚拟表 vt2</p><p>第三步：如果是outer join 那么这一步就将添加外部行，left outer jion 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 vt3</p><p>第四步：如果 from 子句中的表数目多余两个表，那么就将vt3和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3。</p><p>第五步：应用where筛选器，对上一步生产的虚拟表引用where筛选器，生成虚拟表vt4，在这有个比较重要的细节不得不说一下，对于包含outer join子句的查询，就有一个让人感到困惑的问题，到底在on筛选器还是用where筛选器指定逻辑表达式呢？on和where的最大区别在于，如果在on应用逻辑表达式那么在第三步outer join中还可以把移除的行再次添加回来，而where的移除的最终的。举个简单的例子，有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名=成绩.姓名）那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了,但是我们用left outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生，如果在on中应用学生.班级='x’的话，left outer join会把x班级的所有学生记录找回（感谢网友康钦谋__康钦苗的指正），所以只能在where筛选器中应用学生.班级=‘x’ 因为它的过滤是最终的。</p><p>第六步：group by 子句将中的唯一的值组合成为一组，得到虚拟表vt5。如果应用了group by，那么后面的所有步骤都只能得到的vt5的列或者是聚合函数（count、sum、avg等）。原因在于最终的结果集中只为每个组包含一行。这一点请牢记。</p><p>第七步：应用cube或者rollup选项，为vt5生成超组，生成vt6.</p><p>第八步：应用having筛选器，生成vt7。having筛选器是第一个也是为唯一一个应用到已分组数据的筛选器。</p><p>第九步：处理select子句。将vt7中的在select中出现的列筛选出来。生成vt8.</p><p>第十步：应用distinct子句，vt8中移除相同的行，生成vt9。事实上如果应用了group by子句那么distinct是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。</p><p>第十一步：应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表。sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定order by，最后，在这一步中是第一个也是唯一一个可以使用select列表中别名的步骤。</p><p>第十二步：应用top选项。此时才返回结果给请求者即用户。</p><h1><center>Multiple Tables</center></h1><p>Why is this important? The most common types of joins will be joining a foreign key from one table with the primary key from another table. For instance, when we join orders and customers, we join on customer_id, which is a foreign key in orders and the primary key in customers.</p><p>SQL has strict rules for appending data:<br>Tables must have the same number of columns.<br>The columns must have the same data types in the same order as the first table.</p><ul><li><p><code>JOIN</code> will combine rows from different tables if the join condition is true.</p></li><li><p><code>LEFT JOIN</code> will return every row in the left table, and if the join condition is not met, NULL values are used to fill in the columns from the right table.</p></li><li><p>Primary key is a column that serves a unique identifier for the rows in the table.</p></li><li><p>Foreign key is a column that contains the primary key to another table.</p></li><li><p><code>CROSS JOIN</code> lets us combine all rows of one table with all rows of another table.</p></li><li><p><code>UNION</code> stacks one dataset on top of another.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM table1</span><br><span class="line">UNION</span><br><span class="line">SELECT *</span><br><span class="line">FROM table2;</span><br></pre></td></tr></table></figure><ul><li><code>WITH</code> allows us to define one or more temporary tables that can be used in the final query.</li></ul><p>关于SQL语句的写法顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">WITH [临时表名] AS(</span><br><span class="line">&#x2F;*一段查询*&#x2F;</span><br><span class="line">)</span><br><span class="line">SELECT [列名称 *代表所有的列]</span><br><span class="line">CASE</span><br><span class="line">  WHEN [条件] THEN [对应的新属性上的值]</span><br><span class="line">  WHEN [条件] THEN [对应的新属性上的值]</span><br><span class="line">  ......</span><br><span class="line">  ELSE [对应的新属性上的值]</span><br><span class="line"> END AS [新属性名字]%表示新增的这一列的命名，没有貌似也可</span><br><span class="line">FROM [表名称]</span><br><span class="line">join_type JOIN [表名称]</span><br><span class="line">ON [join条件]</span><br><span class="line">WHERE [过滤条件]</span><br><span class="line">GROUP BY [分组字段]&#x2F;*可用select中的“列号”代表，就是直接写数字*&#x2F;</span><br><span class="line">HAVING [分组条件]</span><br><span class="line">ORDER BY [排序字段] [ASC&#x2F;DESC]</span><br><span class="line">LIMIT [输出组数]</span><br></pre></td></tr></table></figure><h1><center>小感想</center></h1><p>这门小小的SQL语句课程就结束了，虽然内容十分少，但是用SQL语句解决实际需求时，还是需要很好的逻辑和语句熟练度的！<br>过几天就要考试了，加油吧小可可！</p>]]></content>
      
      
      <categories>
          
          <category> Codecademy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summary for =Learn JavaScript= //Codecademy</title>
      <link href="2020/08/23/Summary-for-Learn-JavaScript-Codecademy/"/>
      <url>2020/08/23/Summary-for-Learn-JavaScript-Codecademy/</url>
      
        <content type="html"><![CDATA[<center><h1>Introduction</h1></center><h2>Introduction to JavaScript</h2>- Data is printed, or logged, to the console, a panel that displays messages, with `console.log()`.- We can write single-line comments with `//` and multi-line comments between `/*` and `*/`.- There are 7 fundamental data types in JavaScript: strings, numbers, booleans, null, undefined, symbol, and object.- Numbers are any number without quotes: 23.8879- Strings are characters wrapped in single or double quotes: 'Sample String'- The built-in arithmetic operators include `+`, `-`, `*`, `/`, and `%`.- Objects, including instances of data types, can have properties, stored information. The properties are denoted with a . after the name of the object, for example: `'Hello'.length`.- Objects, including instances of data types, can have methods which perform actions. Methods are called by appending the object or instance with a period, the method name, and parentheses. For example: `'hello'.toUpperCase()`.- We can access properties and methods by using the ., dot operator.- Built-in objects, including Math, are collections of **methods and properties** that JavaScript provides.<h2>Variables</h2>- Variables hold reusable data in a program and associate it with a name.- Variables are stored in memory.- The `var` keyword is used in *pre-ES6* versions of JS.- `let` is the preferred way to declare a variable when it can be **reassigned**, and `const` is the preferred way to declare a variable with a **constant** value.- Variables that have not been initialized store the primitive data type **undefined**.- Mathematical assignment operators make it easy to calculate a new value and assign it to the same variable.- The `+` operator is used to concatenate strings including string values held in variables- In ES6, template literals use `backticks` and `${}` to interpolate values into a string.- The `typeof` keyword returns the data type (as a string) of a value.<center><h1>Conditions</h1></center><h2>Conditional Statements</h2>- An `if` statement checks a condition and will execute a task if that condition evaluates to true.- `if...else` statements make binary decisions and execute different code blocks based on a provided condition.- We can add more conditions using `else if` statements.- Comparison operators, including `<`, `>`, `<=`, `>=`, `===`, and `!==` can compare two values.&emsp;*P.S. Mention that we use `===` rather than `==` in JS.*  - The logical and operator, `&&`, or “`and`”, checks if both provided expressions are truthy.- The logical operator `||`, or “`or`”, checks if either provided expression is truthy.- The bang operator, `!`, switches the truthiness and falsiness of a value.- The **ternary** operator is shorthand to simplify concise `if...else` statements.- A `switch` statement can be used to simplify the process of writing multiple else if statements. The **break** keyword stops the remaining cases from being checked and executed in a switch statement.<center><h1>Functions</h1></center><h2>Functions</h2></=`,></`,>]]></content>
      
      
      <categories>
          
          <category> Codecademy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summmary for =Learn CSS= //Codecademy</title>
      <link href="2020/08/22/Summmary-for-Learn-CSS-Codecademy/"/>
      <url>2020/08/22/Summmary-for-Learn-CSS-Codecademy/</url>
      
        <content type="html"><![CDATA[<h1>Selectors and Visual Rules</h1><h2> CSS Setup and Selectors </h2>- CSS can change the look of HTML elements. In order to do this, CSS must select HTML elements, then apply styles to them.- CSS can select HTML elements by **tag**, **class**, **or ID**.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   tag: p</span><br><span class="line">class: .</span><br><span class="line">ID: #</span><br></pre></td></tr></table></figure>- Multiple CSS classes can be applied to one HTML element.- Classes can be reusable, while IDs can only be used once.- IDs are more specific than classes, and classes are more specific than tags. That means IDs will override any styles from a class, and classes will override any styles from a tag selector.- Multiple selectors can be **chained** together to select an element. This raises the specificity, but can be necessary.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h5.description</span><br></pre></td></tr></table></figure>- Nested elements can be selected by separating selectors with a space.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.class li</span><br></pre></td></tr></table></figure>- Multiple unrelated selectors can receive the same styles by separating the selector names with **commas**.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p,</span><br><span class="line">h5</span><br></pre></td></tr></table></figure><h2>CSS Visual Rules</h2>I've learned concepts including:<ul><li>CSS declarations are structured into property and value pairs.</li><li>The <code>font-family</code> property defines the typeface of an element.</li><li><code>font-size</code> controls the size of text displayed.</li><li><code>font-weight</code> defines how thin or thick text is displayed.</li><li>The <code>text-align</code> property places text in the left, right, or center of its parent container.</li><li>Text can have two different color attributes: <code>color</code> and <code>background-color</code>. color defines the color of the text, while background-color defines the color behind the text.</li><li>CSS can make an element transparent with the <code>opacity</code> property.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opacity: 0.75;</span><br><span class="line">&#x2F;&#x2F;From 0 to 1, 0 means invisible;</span><br></pre></td></tr></table></figure><ul><li>CSS can also set the background of an element to an image with the <code>background-image</code> property.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image:url(&quot;http:&#x2F;&#x2F;....&quot;);</span><br></pre></td></tr></table></figure><ul><li>The <code>!important</code> flag will override any style, however it should almost never be used, as it is extremely difficult to override.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color: #FFF !important;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Codecademy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summary for =Learn HTML= //Codecademy</title>
      <link href="2020/08/21/A-Summary-for-Learn-HTML-Codecademy/"/>
      <url>2020/08/21/A-Summary-for-Learn-HTML-Codecademy/</url>
      
        <content type="html"><![CDATA[<h1>Learn HTML</h1><h1>Elements and Structure</h1><h2 id="1-Introduction-to-HTML"><a class="header-anchor" href="#1-Introduction-to-HTML">¶</a>1. Introduction to HTML</h2><h3 id="1-1-Summary"><a class="header-anchor" href="#1-1-Summary">¶</a>1.1 Summary</h3><ul><li>HTML stands for <strong>HyperText Markup Language</strong> and is used to create the structure and content of a webpage.</li><li>Most HTML elements contain opening and closing tags with raw text or other HTML tags between them.</li><li>HTML elements can be nested inside other elements. The enclosed element is <strong>the child of</strong> the enclosing parent element.</li><li>Any visible content should be placed within the opening and closing  tags.</li><li>Headings and sub-headings, <code>## </code> to <code>&lt;h6&gt;</code> tags, are used to enlarge text.</li><li><code>&lt;p&gt;</code>, <code>&lt;span&gt;</code> and <code>&lt;div&gt;</code> tags specify text or blocks.</li><li>The <code>&lt;em&gt;</code> and <code>&lt;strong&gt;</code> tags are used to emphasize text.</li><li>Line breaks are created with the <code>&lt;br&gt;</code> tag.</li><li>Ordered lists (<code>&lt;ol&gt;</code>) are numbered and unordered lists (<code>&lt;ul&gt;</code>) are bulleted.</li><li>Images (<code>&lt;img&gt;</code>) and videos (<code>&lt;video&gt;</code>) can be added by linking to an existing source.</li></ul><aside>*P.S. `<img>` is a single tag.*</aside><h2 id="2-HTML-Document-Standards"><a class="header-anchor" href="#2-HTML-Document-Standards">¶</a>2. HTML Document Standards</h2><h3 id="2-1-Summary"><a class="header-anchor" href="#2-1-Summary">¶</a>2.1 Summary</h3><p><em>HTML Tags</em><br> While some tags have a very specific purpose, such as image and video tags, most tags are used to describe the content that they surround, which helps us modify and style our content later. There are seemingly infinite numbers of tags to use (many more than we’ve taught). Knowing when to use each one is based on how you want to describe the content of your HTML. Descriptive, well-chosen tags are one key to high-quality web development. A full list of available HTML tags can be found in Mozilla documentation.</p><ul><li>The <code>&lt;!DOCTYPE html&gt;</code> declaration should always be the first line of code in your HTML files. This lets the browser know what version of HTML to expect.</li><li>The <code>&lt;html&gt;</code> element will contain all of your HTML code.</li><li>Information about the web page, like the title, belongs within the <code>&lt;head&gt;</code> of the page.</li><li>You can add a title to your web page by using the <code>&lt;title&gt;</code> element, inside of the head.A webpage’s title appears in a browser’s tab.</li><li>Anchor tags (<code>&lt;a&gt;</code>) are used to link to internal pages, external pages or content on the same page.You can create sections on a webpage and jump to them using <code>&lt;a&gt;</code> tags and adding ids to the elements you wish to jump to.</li><li>Whitespace between HTML elements helps make code easier to read while not changing how elements appear in the browser.Indentation also helps make code easier to read. It makes parent-child relationships visible.</li><li>Comments are written in HTML using the following syntax: <code>&lt;!-- comment --&gt;</code>.<br></li></ul><h4 id="2-2-Demo"><a class="header-anchor" href="#2-2-Demo">¶</a>2.2 Demo</h4><pre>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;Brown Bears&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;nav&gt;    &lt;a href="./index.html"&gt;Brown Bear&lt;/a&gt;    &lt;a href="./aboutme.html"&gt;About Me&lt;/a&gt;  &lt;/nav&gt;  &lt;h1&gt;The Brown Bear&lt;/h1&gt;  &lt;nav&gt;    &lt;ul&gt;      &lt;li&gt;&lt;a href="#introduction"&gt;Introduction&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href="#habitat"&gt;Habitat&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href="#media"&gt;Media&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;  &lt;/nav&gt;  &lt;div id="introduction"&gt;    &lt;h2&gt;About Brown Bears&lt;/h2&gt;    &lt;p&gt;The brown bear (&lt;em&gt;Ursus arctos&lt;/em&gt;) is native to parts of northern Eurasia and North America. Its conservation status is currently &lt;strong&gt;Least Concern&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt; There are many subspecies within the brown bear species, including the      Atlas bear and the Himalayan brown bear.&lt;/p&gt;    &lt;a href="https://en.wikipedia.org/wiki/Brown_bear" target="_blank"&gt;Learn More&lt;/a&gt;    &lt;h3&gt;Species&lt;/h3&gt;    &lt;ul&gt;      &lt;li&gt;Arctos&lt;/li&gt;      &lt;li&gt;Collarus&lt;/li&gt;      &lt;li&gt;Horribilis&lt;/li&gt;      &lt;li&gt;Nelsoni (extinct)&lt;/li&gt;    &lt;/ul&gt;    &lt;h3&gt;Features&lt;/h3&gt;    &lt;p&gt;Brown bears are not always completely brown. Some can be reddish or yellowish. They have very large, curved claws and huge paws. Male brown bears are often 30% larger than female brown bears. They can range from 5 feet to 9 feet from head to toe.&lt;/p&gt;  &lt;/div&gt;  &lt;div id="habitat"&gt;    &lt;h2&gt;Habitat&lt;/h2&gt;    &lt;h3&gt;Countries with Large Brown Bear Populations&lt;/h3&gt;    &lt;ol&gt;      &lt;li&gt;Russia&lt;/li&gt;      &lt;li&gt;United States&lt;/li&gt;      &lt;li&gt;Canada&lt;/li&gt;    &lt;/ol&gt;    &lt;h3&gt;Countries with Small Brown Bear Populations&lt;/h3&gt;    &lt;p&gt;Some countries with smaller brown bear populations include Armenia, Belarus, Bulgaria, China, Finland, France, Greece, India, Japan, Nepal, Poland, Romania, Slovenia, Turkmenistan, and Uzbekistan.&lt;/p&gt;  &lt;/div&gt;  &lt;div id="media"&gt;    &lt;h2&gt;Media&lt;/h2&gt;    &lt;img src="https://s3.amazonaws.com/codecademy-content/courses/web-101/web101-image_brownbear.jpg" /&gt;    &lt;video src="https://s3.amazonaws.com/codecademy-content/courses/freelance-1/unit-1/lesson-2/htmlcss1-vid_brown-bear.mp4" height="240" width="320" controls&gt;Video not supported&lt;/video&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</pre><p> Let’ see what it looks like in a browser:<br><img src="%5CA-Summary-for-Learn-HTML-Codecademy%5Cwebsite1.png" alt=""><br><img src="%5CA-Summary-for-Learn-HTML-Codecademy%5Cwebsite2.png" alt=""></p><h2 id="2-Tables"><a class="header-anchor" href="#2-Tables">¶</a>2. Tables</h2><h3 id="2-1-Summary-v2"><a class="header-anchor" href="#2-1-Summary-v2">¶</a>2.1  Summary</h3><p> In this lesson, we learned how to create a table, add data to it, and section the table into smaller parts that make it easier to read.</p><ul><li>The <code>&lt;table&gt;</code> element creates a table.</li><li>The <code>&lt;tr&gt;</code> element adds rows to a table.</li><li>To add data to a row, you can use the <code>&lt;td&gt;</code> element.</li><li>Table headings clarify the meaning of data. Headings are added with the <code>&lt;th&gt;</code> element.</li><li>Table data can span columns using the colspan attribute; Table data can span rows using the rowspan attribute.</li><li>Tables can be split into three main sections: a head, a body, and a footer.<br>  A table’s head is created with the <code>&lt;thead&gt;</code> element.<br>  A table’s body is created with the <code>&lt;tbody&gt;</code> element.<br>  A table’s footer is created with the <code>&lt;tfoot&gt;</code> element.</li><li>All the CSS properties you learned about in this course can be applied to tables and their data.</li></ul><h3 id="2-2-Demo-v2"><a class="header-anchor" href="#2-2-Demo-v2">¶</a>2.2 Demo</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;thead&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;th&gt;Company Name&lt;/th&gt;</span><br><span class="line">    &lt;th&gt;Number of Items to Ship&lt;/th&gt;</span><br><span class="line">    &lt;th&gt;Next Action&lt;/th&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;/thead&gt;</span><br><span class="line">  &lt;tbody&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td colspan="2"&gt;Adam’s Greenworks&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;14&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Package Items&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Davie's Burgers&lt;/td&gt;</span><br><span class="line">    &lt;td rowspan="2"&gt;2&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Send Invoice&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Baker's Bike Shop&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;3&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Send Invoice&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Miss Sally's Southern&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;4&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Ship&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Summit Resort Rentals&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;4&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Ship&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Strike Fitness&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;1&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Enter Order&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tfoot&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;td&gt;Total&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;28&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">  &lt;/tfoot&gt;</span><br><span class="line">  &lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></tbody></table></figure><p>This is what it looks like:<br><img src="%5CA-Summary-for-Learn-HTML-Codecademy%5Ctable.png" alt=""><br><br></p><h2 id="To-be-continued…"><a class="header-anchor" href="#To-be-continued…">¶</a>To be continued…</h2><hr><h2 id="0x03-Forms"><a class="header-anchor" href="#0x03-Forms">¶</a>0x03 Forms</h2><h2 id="0x04-Semantic-HTML"><a class="header-anchor" href="#0x04-Semantic-HTML">¶</a>0x04 Semantic HTML</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Codecademy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Merge Two Binary Trees //Leetcode</title>
      <link href="2020/08/21/Merge-Two-Binary-Trees-Leetcode/"/>
      <url>2020/08/21/Merge-Two-Binary-Trees-Leetcode/</url>
      
        <content type="html"><![CDATA[<h1>Description</h1><blockquote><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p><p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p></blockquote><h1>Input</h1><p><img src="/2020/08/21/Merge-Two-Binary-Trees-Leetcode/%5CMerge-Two-Binary-Trees-Leetcode%5Cinput.png" alt=""></p><h1>Output</h1><p><img src="/2020/08/21/Merge-Two-Binary-Trees-Leetcode/%5CMerge-Two-Binary-Trees-Leetcode%5Coutput.png" alt=""></p><h1>Analysis</h1><h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>默认代码中给出了“TreeNode”数据结构的定义。每个节点有一个值，这个值可以通过两种函数给出，之后就把它们叫函数1和函数2。<br>我们先来想想不用代码自己手动合并的话会怎么做——核心问题在于怎么算出一个结点的值，以及确定结果树的结构（哪里有结点哪里没有）。<br>好的，先考虑第一个问题，对于一个结点，假如它没有左右孩子，那么它的值应该用函数1计算，也就是直接赋值——因此，我们应该对那些叶节点直接赋值；除这种情况以外，剩下的用函数2计算结点值。说得程序化一点会是什么样呢？处理树可以用递归与循环两种方式来考虑。</p><h1>WAY1：Recursion</h1><h2 id="Explanation"><a class="header-anchor" href="#Explanation">¶</a>Explanation</h2><p>既然用递归，我们可以想象这个调用过程大概是：从两棵树的头部开始，一直往下往下，到叶子节点开始向上返回，两两合并组在一起。<br>编写一个mergeTrees函数，输入是两个结点。<br>假如其中一个是空的，合并结果就是另一个，直接返回就好了<br>假如两者都不空，就应该此处结点的值赋为两个相加，然后此结点的左子树等于参数1的左子树+参数2的左子树，右子树等于参数1的右子树+参数2的右子树。这个+其实就是在调用mergeTrees函数，所以是递归。</p><h2 id="Code"><a class="header-anchor" href="#Code">¶</a>Code</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() {}</span><br><span class="line"> *     TreeNode(int val) { this.val = val; }</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     }</span><br><span class="line"> * }</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {</span><br><span class="line">        if (t1==null){</span><br><span class="line">            return t2;</span><br><span class="line">        }</span><br><span class="line">        if (t2==null){</span><br><span class="line">            return t1;</span><br><span class="line">        }</span><br><span class="line">        t1.val+=t2.val;</span><br><span class="line">        t1.left=mergeTrees(t1.left,t2.left);</span><br><span class="line">        t1.right=mergeTrees(t1.right,t2.right);</span><br><span class="line">return t1;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Complexity"><a class="header-anchor" href="#Complexity">¶</a>Complexity</h2><h2 id="Attention"><a class="header-anchor" href="#Attention">¶</a>Attention</h2><ol><li>一个函数如果作为主要的递归函数，应该在每个条件分支处都有return</li><li>多画图还是很有帮助的</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leetcode Top 100 Liked Questions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to start Markdown</title>
      <link href="2020/08/18/How-to-start-Markdown/"/>
      <url>2020/08/18/How-to-start-Markdown/</url>
      
        <content type="html"><![CDATA[<p>#一、快捷键</p><p><strong>加粗ctrl+B</strong></p><p><em>斜体</em></p><blockquote><p>引用</p></blockquote><p><a href="https://blog.csdn.net/u014061630/article/details/81359144">链接</a></p><pre><code>代码</code></pre><p>图片</p><p>提升标题</p><p>有序列表</p><hr><p>#二、基本语法</p><p>#一级标题</p><h1>一级标题</h1><p>##二级标题</p><h2 id="二级标题"><a class="header-anchor" href="#二级标题">¶</a>二级标题</h2><p>本地图片</p><p><img src="/%E5%9B%BE%E7%89%87.png" alt="链接"></p><p>互联网图片</p><p><img src="https://img-blog.csdn.net/20180802154402427?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQwNjE2MzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="链接"></p><p><a href="https://www.jianshu.com/p/10aa8ba19802">https://www.jianshu.com/p/10aa8ba19802</a></p><hr><hr><hr><p>行内代码：<code>code</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code here</span><br></pre></td></tr></tbody></table></figure><pre><code>code here</code></pre><ul><li><p>无序列表1</p></li><li><p>无序列表2</p></li></ul><p>1</p><ol><li>为什么没有1</li><li>原来中间要隔字</li></ol><p>对策<br>我</p><table><thead><tr><th>学号</th><th>姓名</th></tr></thead><tbody><tr><td>820810203</td><td>胡可</td></tr></tbody></table><p>#三、常用技巧</p><p>换行是要在后面加两个空格的！</p><font color="#87CEFA" size="7" face="楷体">很漂亮</font>  <script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/08/13/hello-world/"/>
      <url>2020/08/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
