<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Learning PHP Part 2</title>
      <link href="2021/08/03/Learning-PHP-Part-2/"/>
      <url>2021/08/03/Learning-PHP-Part-2/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning PHP - Part 1</title>
      <link href="2021/07/31/Learning-PHP-Part-1/"/>
      <url>2021/07/31/Learning-PHP-Part-1/</url>
      
        <content type="html"><![CDATA[<h1>PHP学习1</h1><p>[TOC]</p><h2 id="PHP简介"><a class="header-anchor" href="#PHP简介">¶</a>PHP简介</h2><p>PHP 是服务器端脚本语言，在web端开发中常用</p><h3 id="PHP文件"><a class="header-anchor" href="#PHP文件">¶</a>PHP文件</h3><ul><li>PHP 文件可包含<strong>文本、HTML、JavaScript代码和 PHP 代码</strong></li><li>PHP 代码在服务器上执行，结果<strong>以纯 HTML 形式返回给浏览器</strong></li><li>PHP 文件的默认文件扩展名是 “.php”</li></ul><h3 id="PHP作用"><a class="header-anchor" href="#PHP作用">¶</a>PHP作用</h3><ul><li>PHP 可以生成动态页面内容</li><li>PHP 可以创建、打开、读取、写入、关闭服务器上的文件</li><li>PHP 可以收集表单数据</li><li>PHP 可以发送和接收 cookies</li><li>PHP 可以添加、删除、修改您的数据库中的数据</li><li>PHP 可以限制用户访问您的网站上的一些页面</li><li>PHP 可以加密数据</li></ul><h2 id="PHP语法"><a class="header-anchor" href="#PHP语法">¶</a>PHP语法</h2><ul><li>PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。</li><li>通过 PHP，有两种在浏览器输出文本的基础指令：<strong>echo</strong> 和 <strong>print</strong>。</li><li>PHP 脚本以 <strong><!--?php** 开始，以 **?--></strong> 结束</li><li>注释和C差不多</li></ul><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;My first PHP page&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Hello World!"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是 PHP 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是</span></span><br><span class="line"><span class="comment">PHP 多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="PHP变量"><a class="header-anchor" href="#PHP变量">¶</a>PHP变量</h2><h3 id="命名规则"><a class="header-anchor" href="#命名规则">¶</a>命名规则</h3><ul><li>变量以 $ 符号开始，后面跟着变量的名称</li><li>变量名必须以字母或者下划线字符开始</li><li>变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）</li><li>变量名不能包含空格</li><li>变量名是区分大小写的（$y 和 $Y 是两个不同的变量）</li></ul><h3 id="变量类型与声明"><a class="header-anchor" href="#变量类型与声明">¶</a>变量类型与声明</h3><ul><li><p>不必向 PHP 声明该变量的数据类型（这点和Python一样），PHP 会根据变量的值，自动把变量转换为正确的数据类型。</p></li><li><p>PHP 没有声明变量的命令，变量在您第一次赋值给它的时候被创建</p></li></ul><h3 id="变量作用域"><a class="header-anchor" href="#变量作用域">¶</a>变量作用域</h3><p>PHP 有四种不同的变量作用域：（并不是说有这四种关键字？反正我是没看到www）</p><ul><li>local</li><li>global</li><li>static</li><li>parameter</li></ul><h3 id="global"><a class="header-anchor" href="#global">¶</a>global</h3><p>在函数外面定义的就叫全局变量，函数里面定义的就叫局部变量。神奇的是global并不是声明变量时使用的（php也没有变量声明），而是在函数内访问全局变量时使用</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$x=<span class="number">5</span>;</span><br><span class="line">$y=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">global</span> $x,$y;</span><br><span class="line">$y=$x+$y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">myTest();</span><br><span class="line"><span class="keyword">echo</span> $y; <span class="comment">// 输出 15</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>PHP 将所有全局变量存储在一个名为 $GLOBALS[<em>index</em>] 的数组中。 <em>index</em> 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。</p><p>上面的实例可以写成这样：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$x=<span class="number">5</span>;</span><br><span class="line">$y=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">$GLOBALS[<span class="string">'y'</span>]=$GLOBALS[<span class="string">'x'</span>]+$GLOBALS[<span class="string">'y'</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">myTest();</span><br><span class="line"><span class="keyword">echo</span> $y;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="static"><a class="header-anchor" href="#static">¶</a>static</h3><p>当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。</p><p>要做到这一点，请在您第一次声明变量时使用 <strong>static</strong> 关键字：</p><p>然后，每次调用该函数时，该变量将会保留着函数前一次被调用时的值。</p><p>**注释：**该变量仍然是函数的局部变量。</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">static</span> $x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">echo</span> $x;</span><br><span class="line">$x++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">myTest();</span><br><span class="line">myTest();</span><br><span class="line">myTest();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="参数作用域"><a class="header-anchor" href="#参数作用域">¶</a>参数作用域</h3><p>在函数的参数列表里的参数，有参数作用域</p><h2 id="echo和print"><a class="header-anchor" href="#echo和print">¶</a>echo和print</h2><p>echo , print 和 print_r的区别:</p><ul><li>echo  - 可以输出一个或多个字符串</li><li>print  - 只能输出简单类型变量的值,如int,string</li><li>print_r - 可以输出复杂类型变量的值,如数组,对象</li></ul><p>PHP 是通过 print 和 echo 语句来动态输出 HTML 内容，虽然 print 和 echo 语句两者的功能几乎是完全一样，但是还是有一点差别的。</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$txt1=<span class="string">"Learn PHP"</span>;</span><br><span class="line">$a=<span class="number">1</span>;</span><br><span class="line">$txt2=<span class="string">"w3cschool.cn"</span>;</span><br><span class="line">$cars=<span class="keyword">array</span>(<span class="string">"Volvo"</span>,<span class="string">"BMW"</span>,<span class="string">"Toyota"</span>);</span><br><span class="line"><span class="keyword">echo</span> $txt1;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Study PHP at $txt2"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"My car is a {$cars[0]}"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> $a;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Learn PHP</span></span><br><span class="line"><span class="comment">Study PHP at w3cschool.cn</span></span><br><span class="line"><span class="comment">My car is a Volvo</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>print_r可以输出数组</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$cars=<span class="keyword">array</span>(<span class="string">"Volvo"</span>,<span class="string">"BMW"</span>,<span class="string">"Toyota"</span>);</span><br><span class="line"></span><br><span class="line">print_r($cars);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Array</span></span><br><span class="line"><span class="comment">(</span></span><br><span class="line"><span class="comment">    [0] =&gt; Volvo</span></span><br><span class="line"><span class="comment">    [1] =&gt; BMW</span></span><br><span class="line"><span class="comment">    [2] =&gt; Toyota</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="PHP-5-数据类型"><a class="header-anchor" href="#PHP-5-数据类型">¶</a>PHP 5 数据类型</h2><p>String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。</p><p>数组可以在一个变量中存储多个值。</p><p>在以下实例中创建了一个数组， 然后使用 PHP var_dump() 函数返回数组的数据类型和值：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$cars=<span class="keyword">array</span>(<span class="string">"Volvo"</span>,<span class="string">"BMW"</span>,<span class="string">"Toyota"</span>);</span><br><span class="line">var_dump($cars);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">array(3) {</span></span><br><span class="line"><span class="comment">  [0]=&gt;</span></span><br><span class="line"><span class="comment">  string(5) "Volvo"</span></span><br><span class="line"><span class="comment">  [1]=&gt;</span></span><br><span class="line"><span class="comment">  string(3) "BMW"</span></span><br><span class="line"><span class="comment">  [2]=&gt;</span></span><br><span class="line"><span class="comment">  string(6) "Toyota"</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>类和对象：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">var</span> $color;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">$color=<span class="string">"green"</span></span>) </span>{</span><br><span class="line">        <span class="keyword">$this</span>-&gt;color = $color;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">what_color</span>(<span class="params"></span>) </span>{   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;color;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_vars</span>(<span class="params">$obj</span>) </span>{</span><br><span class="line">    <span class="keyword">foreach</span> (get_object_vars($obj) <span class="keyword">as</span> $prop =&gt; $val) {</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"$prop = $val"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 new 语句实例化一个对象（类）。</span></span><br><span class="line">$herbie = <span class="keyword">new</span> Car(<span class="string">"white"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出变量 $herbie 的属性。</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"herbie: Properties&lt;br&gt;"</span>;</span><br><span class="line">print_vars($herbie);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span>&nbsp;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">herbie: Properties</span></span><br><span class="line"><span class="comment">color = white</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="PHP5-常量"><a class="header-anchor" href="#PHP5-常量">¶</a>PHP5 常量</h2><p>设置常量，使用 define() 函数，函数语法如下：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> define ( <span class="keyword">string</span> $name , mixed $value [, <span class="keyword">bool</span> $case_insensitive = <span class="literal">false</span> ] )</span><br></pre></td></tr></tbody></table></figure><p>该函数有三个参数:</p><ul><li>constant_name：必选参数，常量名称，即标志符。</li><li>value：必选参数，常量的值。</li><li>case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。</li></ul><p>大小写不敏感：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// define a case-insensitive constant</span></span><br><span class="line">define(<span class="string">"GREETING"</span>, <span class="string">"Welcome to w3cschool.cn!"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">echo</span> GREETING;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line"><span class="comment">// will also output the value of the constant</span></span><br><span class="line"><span class="keyword">echo</span> greeting;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Welcome to w3cschool.cn!</span></span><br><span class="line"><span class="comment">Welcome to w3cschool.cn!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="PHP-字符串变量"><a class="header-anchor" href="#PHP-字符串变量">¶</a>PHP 字符串变量</h2><h3 id="并置运算符"><a class="header-anchor" href="#并置运算符">¶</a>并置运算符</h3><p>就是一个点.</p><p>可以在两个字符串中间插入空格：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$txt1=<span class="string">"Hello world!"</span>;</span><br><span class="line">$txt2=<span class="string">"What a nice day!"</span>;</span><br><span class="line"><span class="keyword">echo</span> $txt1 . <span class="string">" "</span> . $txt2;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="strlen-函数"><a class="header-anchor" href="#strlen-函数">¶</a>strlen() 函数</h3><p>获取字符串长度</p><h3 id="strpos-函数"><a class="header-anchor" href="#strpos-函数">¶</a>strpos() 函数</h3><p>strpos() 函数用于在字符串内查找一个字符或一段指定的文本。下标从0开始，如果未找到匹配，则返回 FALSE。</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> strpos(<span class="string">"Hello world!"</span>,<span class="string">"world"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="PHP运算符"><a class="header-anchor" href="#PHP运算符">¶</a>PHP运算符</h2><p>基本和c一样</p><p>逻辑运算符有and、or、xor，当然用符号也是可以的</p><h3 id="数组运算符"><a class="header-anchor" href="#数组运算符">¶</a>数组运算符</h3><p>这个还挺特殊：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">x + y</td><td style="text-align:left">集合</td><td style="text-align:left">x 和 y 的集合</td></tr><tr><td style="text-align:left">x == y</td><td style="text-align:left">相等</td><td style="text-align:left">如果 x 和 y 具有相同的键/值对，则返回 true</td></tr><tr><td style="text-align:left">x === y</td><td style="text-align:left">恒等</td><td style="text-align:left">如果 x 和 y 具有相同的键/值对，且顺序相同类型相同，则返回 true</td></tr><tr><td style="text-align:left">x != y</td><td style="text-align:left">不相等</td><td style="text-align:left">如果 x 不等于 y，则返回 true</td></tr><tr><td style="text-align:left">x &lt;&gt; y</td><td style="text-align:left">不相等</td><td style="text-align:left">如果 x 不等于 y，则返回 true</td></tr><tr><td style="text-align:left">x !== y</td><td style="text-align:left">不恒等</td><td style="text-align:left">如果 x 不等于 y，则返回 true</td></tr></tbody></table><h2 id="PHP数组"><a class="header-anchor" href="#PHP数组">¶</a>PHP数组</h2><p>在 PHP 中，有三种类型的数组：</p><ul><li><strong>数值数组</strong> - 带有数字 ID 键的数组</li><li><strong>关联数组</strong> - 带有指定的键的数组，每个键关联一个值</li><li><strong>多维数组</strong> - 包含一个或多个数组的数组</li></ul><h3 id="数值数组"><a class="header-anchor" href="#数值数组">¶</a>数值数组</h3><p>自动分配 ID 键（ID 键总是从 0 开始）：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cars=<span class="keyword">array</span>(<span class="string">"Volvo"</span>,<span class="string">"BMW"</span>,<span class="string">"Toyota"</span>);</span><br></pre></td></tr></tbody></table></figure><p>人工分配 ID 键：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$cars[<span class="number">0</span>]=<span class="string">"Volvo"</span>;        </span><br><span class="line">$cars[<span class="number">1</span>]=<span class="string">"BMW"</span>;        </span><br><span class="line">$cars[<span class="number">2</span>]=<span class="string">"Toyota"</span>;</span><br></pre></td></tr></tbody></table></figure><p>count() 函数用于返回数组的长度（元素的数量）</p><h3 id="遍历数值数组"><a class="header-anchor" href="#遍历数值数组">¶</a>遍历数值数组</h3><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$cars=<span class="keyword">array</span>(<span class="string">"Volvo"</span>,<span class="string">"BMW"</span>,<span class="string">"Toyota"</span>);</span><br><span class="line">$arrlength=count($cars);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>($x=<span class="number">0</span>;$x&lt;$arrlength;$x++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">echo</span> $cars[$x];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Volvo</span></span><br><span class="line"><span class="comment">BMW</span></span><br><span class="line"><span class="comment">Toyota</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h3 id="关联数组"><a class="header-anchor" href="#关联数组">¶</a>关联数组</h3><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这里有两种创建关联数组的方法：    </span><br><span class="line"></span><br><span class="line">$age=<span class="keyword">array</span>(<span class="string">"Peter"</span>=&gt;<span class="string">"35"</span>,<span class="string">"Ben"</span>=&gt;<span class="string">"37"</span>,<span class="string">"Joe"</span>=&gt;<span class="string">"43"</span>);</span><br><span class="line">或者:    </span><br><span class="line"></span><br><span class="line">$age[<span class="string">'Peter'</span>]=<span class="string">"35"</span>;        </span><br><span class="line">$age[<span class="string">'Ben'</span>]=<span class="string">"37"</span>;        </span><br><span class="line">$age[<span class="string">'Joe'</span>]=<span class="string">"43"</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$age=<span class="keyword">array</span>(<span class="string">"Peter"</span>=&gt;<span class="string">"35"</span>,<span class="string">"Ben"</span>=&gt;<span class="string">"37"</span>,<span class="string">"Joe"</span>=&gt;<span class="string">"43"</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Peter is "</span> . $age[<span class="string">'Peter'</span>] . <span class="string">" years old."</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Peter is 35 years old.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h3 id="遍历关联数组"><a class="header-anchor" href="#遍历关联数组">¶</a>遍历关联数组</h3><p>使用foreach</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$age=<span class="keyword">array</span>(<span class="string">"Peter"</span>=&gt;<span class="string">"35"</span>,<span class="string">"Ben"</span>=&gt;<span class="string">"37"</span>,<span class="string">"Joe"</span>=&gt;<span class="string">"43"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>($age <span class="keyword">as</span> $x=&gt;$x_value)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Key="</span> . $x . <span class="string">", Value="</span> . $x_value;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Key=Peter, Value=35</span></span><br><span class="line"><span class="comment">Key=Ben, Value=37</span></span><br><span class="line"><span class="comment">Key=Joe, Value=43</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>foreach的两种语法：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (array_expression <span class="keyword">as</span> $value)</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">foreach</span> (array_expression <span class="keyword">as</span> $key =&gt; $value)</span><br><span class="line">    statement</span><br><span class="line">第一种格式遍历给定的 array_expression 数组。每次循环中，当前单元的值被赋给 $value 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。</span><br><span class="line"></span><br><span class="line">第二种格式做同样的事，只除了当前单元的键名也会在每次循环中被赋给变量 $key。</span><br></pre></td></tr></tbody></table></figure><h2 id="PHP数组排序"><a class="header-anchor" href="#PHP数组排序">¶</a>PHP数组排序</h2><p>在本章中，我们将一一介绍下列 PHP 数组排序函数：</p><ul><li>sort() - 对数组进行升序排列</li><li>rsort() - 对数组进行降序排列</li><li>asort() - 根据关联数组的值，对数组进行升序排列</li><li>ksort() - 根据关联数组的键，对数组进行升序排列</li><li>arsort() - 根据关联数组的值，对数组进行降序排列</li><li>krsort() - 根据关联数组的键，对数组进行降序排列</li></ul><h2 id="PHP函数"><a class="header-anchor" href="#PHP函数">¶</a>PHP函数</h2><p>在 PHP 中，提供了超过 1000 个内建的函数。</p><p>任何有效的 PHP 代码都有可能出现在函数内部，甚至包括其它函数和类定义。</p><h2 id="PHP面向对象"><a class="header-anchor" href="#PHP面向对象">¶</a>PHP面向对象</h2><p>PHP 定义类通常语法格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class phpClass {</span><br><span class="line">  var $var1;</span><br><span class="line">  var $var2 = "constant string";</span><br><span class="line">  </span><br><span class="line">  function myfunc ($arg1, $arg2) {</span><br><span class="line">     [..]</span><br><span class="line">  }</span><br><span class="line">  [..]</span><br><span class="line">}</span><br><span class="line">?&gt;</span><br></pre></td></tr></tbody></table></figure><p>解析如下：</p><ul><li>类使用 <strong>class</strong> 关键字后加上类名定义。</li><li>类名后的一对大括号({})内可以定义变量和方法。</li><li>类的变量使用 <strong>var</strong> 来声明, 变量也可以初始化值。</li><li>函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问。</li></ul><p>一个例子：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>{</span><br><span class="line">  <span class="comment">/* 成员变量 */</span></span><br><span class="line">  <span class="keyword">var</span> $url;</span><br><span class="line">  <span class="keyword">var</span> $title;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 成员函数 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setUrl</span>(<span class="params">$par</span>)</span>{</span><br><span class="line">     <span class="keyword">$this</span>-&gt;url = $par;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params"></span>)</span>{</span><br><span class="line">     <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;url . PHP_EOL;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span>(<span class="params">$par</span>)</span>{</span><br><span class="line">     <span class="keyword">$this</span>-&gt;title = $par;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params"></span>)</span>{</span><br><span class="line">     <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;title . PHP_EOL;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="构造函数和析构函数"><a class="header-anchor" href="#构造函数和析构函数">¶</a>构造函数和析构函数</h3><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDestructableClass</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>{</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"构造函数\n"</span>;</span><br><span class="line">       <span class="keyword">$this</span>-&gt;name = <span class="string">"MyDestructableClass"</span>;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>{</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"销毁 "</span> . <span class="keyword">$this</span>-&gt;name . <span class="string">"\n"</span>;</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">$obj = <span class="keyword">new</span> MyDestructableClass();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day20搜索-小可的机试练习日记</title>
      <link href="2021/07/11/Day20%E6%90%9C%E7%B4%A2-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>2021/07/11/Day20%E6%90%9C%E7%B4%A2-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>BFS</h1><h2 id="Catch-that-Cow"><a class="header-anchor" href="#Catch-that-Cow">¶</a>Catch that Cow</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day19递归-小可的机试练习日记</title>
      <link href="2021/06/13/Day19%E9%80%92%E5%BD%92-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>2021/06/13/Day19%E9%80%92%E5%BD%92-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>递归策略</h1><h2 id="n的阶乘"><a class="header-anchor" href="#n的阶乘">¶</a>n的阶乘</h2><p><a href="https://t.cn/Ai0ocOUY">https://t.cn/Ai0ocOUY</a></p><p>看起来是普通递归，但是需要解决结果是大数的问题吗？</p><img src="D:\胡可\博客\blog\source\_posts\Day19递归-小可的机试练习日记.assets\image-20210613101825888.png" alt="image-20210613101825888" style="zoom:67%;" loading="lazy"><p>好像long long 刚好可以放下20的阶乘……</p><p>以后可以这样记：int32位（最大约为<code>2*10^9</code>），long long 64位（最大约为<code>9*10^9</code>）</p><h2 id="汉诺塔3"><a class="header-anchor" href="#汉诺塔3">¶</a>汉诺塔3</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2064">http://acm.hdu.edu.cn/showproblem.php?pid=2064</a></p><p>书上的解释挺不错的！</p><h2 id="杨辉三角形"><a class="header-anchor" href="#杨辉三角形">¶</a>杨辉三角形</h2><p><a href="https://t.cn/Ai0KcLRI">https://t.cn/Ai0KcLRI</a></p><p>分析一下递归的两个条件：</p><ul><li><p>原问题和子问题：打印n的三角形，等价于先打印n-1的三角形，然后再加一行个数为n的数字。</p><p>这行数字的规律：<s>最外围是两个1，次外围是两个n-1，第三层是两个1+…+n-2</s></p><p>直接靠上一行的数字两两相加可以不可以</p></li></ul><hr><p>以上作废，按这个思路写着写着发现出问题了……</p><p>在讨论区找到了很好的题解：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">YangHui</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><span class="comment">//求杨辉三角形i行j列的元素值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j==i) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> YangHui(i<span class="number">-1</span>, j)+YangHui(i<span class="number">-1</span>, j<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)!=EOF)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) {</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i; j++) {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, YangHui(i, j));</span><br><span class="line">                <span class="keyword">if</span>(j!=i) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>思路和我完全不一样，他的函数是用来求杨辉三角形i行j列的元素值的……</p><h2 id="全排列"><a class="header-anchor" href="#全排列">¶</a>全排列</h2><p><a href="https://www.nowcoder.com/practice/5632c23d0d654aecbc9315d1720421c1?tpId=61&amp;tqId=29515&amp;tPage=1&amp;ru=/kaoyan/retest/1002&amp;qru=/ta/pku-kaoyan/question-ranking">https://www.nowcoder.com/practice/5632c23d0d654aecbc9315d1720421c1?tpId=61&amp;tqId=29515&amp;tPage=1&amp;ru=/kaoyan/retest/1002&amp;qru=/ta/pku-kaoyan/question-ranking</a></p><ul><li><p>看到一个很绝的题解（用了stl中的函数）：</p><p>从第一个开始，一直用next_permutation函数获取下一个全排列。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;s) {</span><br><span class="line">        sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (s.<span class="built_in">begin</span>(); next_permutation(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());) {</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>或者这样写：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">string</span> s;<span class="built_in">cin</span>&gt;&gt;s;<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>){</span><br><span class="line">        sort(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;next_permutation(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());<span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>原来for循环的第一个和第三个位置只要放上要做的事情的语句，也一样是可以执行的……</p><p>这个神奇函数的帖子：<a href="https://blog.csdn.net/HowardEmily/article/details/68064377">https://blog.csdn.net/HowardEmily/article/details/68064377</a></p><p><a href="https://blog.csdn.net/weixin_43325354/article/details/99208140">https://blog.csdn.net/weixin_43325354/article/details/99208140</a></p></li><li><p>dfs递归：</p><p>好难懂呜呜呜</p></li></ul><h1>分治法</h1><h2 id="Fibonacci（上交）"><a class="header-anchor" href="#Fibonacci（上交）">¶</a>Fibonacci（上交）</h2><p><a href="https://www.nowcoder.com/practice/17ad6908e36a49f4b06ea96936e8bb25?tpId=62&amp;tqId=29453&amp;tPage=1&amp;ru=/kaoyan/retest/2002&amp;qru=/ta/sju-kaoyan/question-ranking">https://www.nowcoder.com/practice/17ad6908e36a49f4b06ea96936e8bb25?tpId=62&amp;tqId=29453&amp;tPage=1&amp;ru=/kaoyan/retest/2002&amp;qru=/ta/sju-kaoyan/question-ranking</a></p><p>当n=0，输出0；当n=1，输出1；其他时候往下递归</p><p>题目中说n最大30，所以其实结果int存得下。总体还是挺简单的</p><h2 id="二叉树"><a class="header-anchor" href="#二叉树">¶</a>二叉树</h2><p><a href="https://www.nowcoder.com/practice/f74c7506538b44399f2849eba2f050b5?tpId=61&amp;tqId=29557&amp;tPage=3&amp;ru=/kaoyan/retest/1002&amp;qru=/ta/pku-kaoyan/question-ranking">https://www.nowcoder.com/practice/f74c7506538b44399f2849eba2f050b5?tpId=61&amp;tqId=29557&amp;tPage=3&amp;ru=/kaoyan/retest/1002&amp;qru=/ta/pku-kaoyan/question-ranking</a></p><p>这递归出口还真不好找，至少我看题没有一下想出来</p><img src="D:\胡可\博客\blog\source\_posts\Day19递归-小可的机试练习日记.assets\image-20210711185832847.png" alt="image-20210711185832847" style="zoom:50%;" loading="lazy"><p>参考一下书上的做法：从m开始的节点数，等于m左子树的节点数，加上右子树的节点数，再加1（m本身）</p><p>递归出口：当遇到某一个m&gt;n，代表此m节点还不在二叉树中，所以节点数为0</p><p>注意表达左右子树的方法：<code>m*2</code>和<code>m*2+1</code></p><h2 id="2的幂次方（跳过，感觉有点难）"><a class="header-anchor" href="#2的幂次方（跳过，感觉有点难）">¶</a>2的幂次方（跳过，感觉有点难）</h2><p><a href="https://www.nowcoder.com/practice/7cf7b0706d7e4b439481f53e5fdac6e7?tpId=62&amp;tqId=29460&amp;tPage=1&amp;ru=/kaoyan/retest/2002&amp;qru=/ta/sju-kaoyan/question-ranking">https://www.nowcoder.com/practice/7cf7b0706d7e4b439481f53e5fdac6e7?tpId=62&amp;tqId=29460&amp;tPage=1&amp;ru=/kaoyan/retest/2002&amp;qru=/ta/sju-kaoyan/question-ranking</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day18区间贪心-小可的机试练习日记</title>
      <link href="2021/06/12/Day18%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>2021/06/12/Day18%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="今年暑假不AC"><a class="header-anchor" href="#今年暑假不AC">¶</a>今年暑假不AC</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2037">http://acm.hdu.edu.cn/showproblem.php?pid=2037</a></p><h3 id="思路"><a class="header-anchor" href="#思路">¶</a>思路</h3><p>目前我还没了解过区间贪心。</p><p>如果我尽量选节目时长短的，算是一种策略吗？或者借助上次简单贪心中那个代理和服务器的思想，定好起点，每次选离起点最近且时长最短的；然后将起点更新到这个节目结束之后……</p><p>但是我觉得这只是局部最优啊</p><hr><p>看了下书，其实选开始时间最早和时长最短都不能最优，应该<strong>选结束时间最早</strong>！</p><p>所以按照结束时间的早晚给节目排序……然后大概就懂了！</p><h2 id="Case-of-Fugitive（未解决）"><a class="header-anchor" href="#Case-of-Fugitive（未解决）">¶</a>Case of Fugitive（未解决）</h2><p><a href="https://codeforces.com/problemset/problem/555/B">https://codeforces.com/problemset/problem/555/B</a></p><h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>AA是著名的侦探，现在在某星球追犯人。这个星球几乎都是水。</p><p>唯一的陆地，就是n个排成一列的小岛。我们把它们简化成一条直线上不相交的线段。第i个岛的范围是[li, ri]，且ri&lt;li+1</p><p>AA需要在每两个相邻的岛之间搭桥，如果两个岛上长度足够（其实就是第i个岛的r到第i+1个岛的l之间足够a，且l-&gt;r又不超过a），就可以搭建一个长度为a的桥。</p><p>侦探有m座桥梁，每座桥长度不同，每座桥最多可以用一次，帮他判断是否这m座桥足够可以帮他连接每一对相邻的岛屿。</p><h3 id="思路-v2"><a class="header-anchor" href="#思路-v2">¶</a>思路</h3><p>有点复杂，看看书吧</p><hr><p>看完以后我觉得，贪心有一个关键，就是对某个东西的某个属性去排序，然后按照顺序依次取用……</p><p>那么这里是考察两岛之间的距离还是桥的长度呢</p><ul><li>两岛之间的距离：按两岛之间的距离排序，最小的放最小的桥……不对！……………………</li><li>桥的长度：按桥的长度从小到大排序，将所有距离按min排序。对于某一个桥，找到min小于它的那些，在这些中选max最小的（因为之后又比此桥更大的桥，所有max较大的要留给别人）</li></ul><hr><p>写了一半，思路有点乱，还是看书学习一下吧</p><p>定义MAXN的时候要加1！！</p><p>比如：#define MAXN 200001</p><p>其实我觉得书上的题解不是很好理解，而且我不记得我什么时候学过在结构体里面定义函数的操作呀</p><hr><p>学了优先队列再来看吧</p><h2 id="To-Fill-or-Not-to-Fill（略难）"><a class="header-anchor" href="#To-Fill-or-Not-to-Fill（略难）">¶</a>To Fill or Not to Fill（略难）</h2><p><a href="https://www.nowcoder.com/practice/f7eba38f7cd24c45982831e0f38518f9?tpId=63&amp;tqId=29602&amp;tPage=2&amp;ru=/kaoyan/retest/9001&amp;qru=/ta/zju-kaoyan/question-ranking">https://www.nowcoder.com/practice/f7eba38f7cd24c45982831e0f38518f9?tpId=63&amp;tqId=29602&amp;tPage=2&amp;ru=/kaoyan/retest/9001&amp;qru=/ta/zju-kaoyan/question-ranking</a></p><h3 id="题意-v2"><a class="header-anchor" href="#题意-v2">¶</a>题意</h3><p>有了高速公路，从杭州到其他城市容易多了。由于车的邮箱是有限的，所以要在路上找加油站。不同的加油站油价不同。目标是花费最少。</p><ul><li><p>输入：</p><p>每个case，第一行有4个正数：</p><ul><li>Cmax：邮箱最大容量</li><li>D：杭州和目标地的距离</li><li>Davg：每单位汽油能支撑汽车走的距离</li><li>N：加油站数量</li></ul><p>然后跟了N行，每行有一对非负数：Pi表示汽油单价；Di表示这个站到杭州的距离</p></li><li><p>输出：</p><p>对于每个case，保留两位小数打印最便宜的花费。</p><p>假设最开始油箱是空的。</p><p>如果能到达终点，打印“…”，X是车能跑的最大距离（两位小数）</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day17简单贪心-小可的机试练习日记</title>
      <link href="2021/06/11/Day17%E7%AE%80%E5%8D%95%E8%B4%AA%E5%BF%83-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>2021/06/11/Day17%E7%AE%80%E5%8D%95%E8%B4%AA%E5%BF%83-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>贪心不一定能收敛到全局最优解，但是对于某些问题，局部最优就是全局最优</p><p>——这样的问题是无后效性的，每个状态以前的过程不会影响以后的状态</p><h1>简单贪心</h1><h2 id="鸡兔同笼"><a class="header-anchor" href="#鸡兔同笼">¶</a>鸡兔同笼</h2><p><a href="https://www.nowcoder.com/practice/fda725b4d9a14010bb145272cababef1?tpId=61&amp;tqId=29559&amp;tPage=3&amp;ru=/kaoyan/retest/1002&amp;qru=/ta/pku-kaoyan/question-ranking">https://www.nowcoder.com/practice/fda725b4d9a14010bb145272cababef1?tpId=61&amp;tqId=29559&amp;tPage=3&amp;ru=/kaoyan/retest/1002&amp;qru=/ta/pku-kaoyan/question-ranking</a></p><p>题目很简单，但是我还是有些没考虑到的：</p><ul><li>a为偶数才有解，否则要输出0 0</li><li>求最小的时候，不够一只兔子了，剩下的两条一定是鸡的（不会出现这两条没人认领的情况呀！）</li></ul><p>体现的贪心的地方：求最小的时候，先考虑脚多的兔子</p><h2 id="FatMouse’-Trade"><a class="header-anchor" href="#FatMouse’-Trade">¶</a>FatMouse’ Trade</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1009">http://acm.hdu.edu.cn/showproblem.php?pid=1009</a></p><h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>老鼠有M磅事物，要和管仓库的猫猫交易，仓库里有老鼠最爱的食物——JavaBean</p><p>仓库有N个房间，第i个房间J[i]磅Bean，需要拿F[i]磅猫粮去换</p><p>老鼠不需要拿到一个房间所有的Bean，可以用<code>F[i]*a%换J[i]*a%</code>的</p><p>让你求老鼠能拿到的最多的Bean数量</p><h3 id="思路"><a class="header-anchor" href="#思路">¶</a>思路</h3><p>我觉得应该先拿J/F最高的房间的？</p><h3 id="错误"><a class="header-anchor" href="#错误">¶</a>错误</h3><p><a href="https://zhuanlan.zhihu.com/p/357362845">https://zhuanlan.zhihu.com/p/357362845</a></p><p>搜了下map的自定义排序，略难用啊……<a href="https://blog.csdn.net/qq_43152052/article/details/101039853">https://blog.csdn.net/qq_43152052/article/details/101039853</a></p><p>我打算把map转成元素为pair的vector</p><p>pair用法：<a href="https://blog.csdn.net/sevenjoin/article/details/81937695">https://blog.csdn.net/sevenjoin/article/details/81937695</a></p><ul><li><p>关于输入</p><p>用<code>scanf("%f  %f",&amp;a,&amp;b);</code>来输入好像会出错</p></li><li><p>TLE：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; p1,<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; p2)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(p1.second&gt;p2.second){</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> M,N;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;M&gt;&gt;N){</span><br><span class="line"><span class="keyword">if</span>(M==<span class="number">-1</span>&amp;&amp;N==<span class="number">-1</span>){</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> J[MAXN],F[MAXN];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;J[i]&gt;&gt;F[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; &gt; v;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; &gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">v.push_back(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt;(i,J[i]/F[i]));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//降排列 </span></span><br><span class="line">sort(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),compare);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> left=(<span class="keyword">double</span>)M;</span><br><span class="line"><span class="keyword">double</span> food=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(it=v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();it++){</span><br><span class="line"><span class="comment">//如果需要的猫粮小于老鼠拥有的猫粮，可以换走这个房间所有的食物 </span></span><br><span class="line"><span class="keyword">if</span>(F[it-&gt;first]&lt;=left){</span><br><span class="line">left-=F[it-&gt;first];</span><br><span class="line">food+=J[it-&gt;first];</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">double</span> a=left/F[it-&gt;first];</span><br><span class="line">food+=J[it-&gt;first]*a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.3f\n"</span>,food);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我改了一版，之前好像忘记把left置0了，但还是TLE：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(it=v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>()&amp;&amp;left&gt;<span class="number">0.0</span>;it++){</span><br><span class="line"><span class="comment">//如果需要的猫粮小于老鼠拥有的猫粮，可以换走这个房间所有的食物 </span></span><br><span class="line"><span class="keyword">if</span>(F[it-&gt;first]&lt;=left){</span><br><span class="line">left-=F[it-&gt;first];</span><br><span class="line">food+=J[it-&gt;first];</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">double</span> a=left/F[it-&gt;first];</span><br><span class="line">left=<span class="number">0.0</span>;<span class="comment">//left清零~ </span></span><br><span class="line">food+=J[it-&gt;first]*a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">} </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>后来仔细想了一下，其实不用置0，因为已经break了</p><p>问题原来在于：</p><p><img src="D:%5C%E8%83%A1%E5%8F%AF%5C%E5%8D%9A%E5%AE%A2%5Cblog%5Csource_posts%5CDay17%E7%AE%80%E5%8D%95%E8%B4%AA%E5%BF%83-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0.assets%5Cimage-20210611122641861.png" alt="image-20210611122641861" loading="lazy"></p><p>这是1000！不是100！长点眼睛吧~~</p><p>改成<code>#define MAXN 1000</code>就可以了……</p></li></ul><h2 id="Senior’s-Gun"><a class="header-anchor" href="#Senior’s-Gun">¶</a>Senior’s Gun</h2><h3 id="题意-v2"><a class="header-anchor" href="#题意-v2">¶</a>题意</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5281">http://acm.hdu.edu.cn/showproblem.php?pid=5281</a></p><p>女主xjj，有n把枪，每把的攻击力是a[i]</p><p>有天女主遇到m个怪兽，每个怪兽的防御力是b[j]</p><p>当b[j]&lt;a[i]时，xjj可以用第i把枪kill第j个怪兽，并得到a[i]-b[j]的分数</p><p>规定每把枪至多用一次，求xjj能得到的最大分数（不需要kill所有monster）</p><img src="D:\胡可\博客\blog\source\_posts\Day17简单贪心-小可的机试练习日记.assets\image-20210611123154073.png" alt="image-20210611123154073" style="zoom:67%;" loading="lazy"><h3 id="思路-v2"><a class="header-anchor" href="#思路-v2">¶</a>思路</h3><p>a,b的范围还挺大的……试下longlong</p><p>分数最大，即a[i]-b[j]最大，所以我们应该用攻击力最大的枪打防御力最低的怪兽？（虽然直觉上有点浪费）</p><p>居然就这样过了……虽然900ms差点超时：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> one,<span class="keyword">int</span> two)</span></span>{</span><br><span class="line"><span class="keyword">return</span> one&gt;two;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> n,m,T;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAXN],b[MAXN];</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;b[j];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//给攻击力降序排列</span></span><br><span class="line">sort(a,a+n,compare); </span><br><span class="line"><span class="comment">//给防御力升序排列 </span></span><br><span class="line">sort(b,b+m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">min</span>(n,m);i++){</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;b[i]){</span><br><span class="line">sum+=a[i]-b[i];</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看了下书上的做法，和我也差不多</p><p>科普一下：对于long long的printf输出：<code>printf("lld\n",answer);</code></p><h2 id="代理服务器"><a class="header-anchor" href="#代理服务器">¶</a>代理服务器</h2><p><a href="http://t.cn/E9emuS9">http://t.cn/E9emuS9</a></p><h3 id="思路-v3"><a class="header-anchor" href="#思路-v3">¶</a>思路</h3><p>有点没思路，只是隐约觉得：与“每个代理的IP出现在访问顺序中的位置”有关，其他的就有点理不清了。</p><p>找了下评论区的思路，有个和我差不多的：</p><blockquote><p>基本的贪心思想，因为要访问的全部server列表及顺序已经给定，并且ip可以多次重复选择，所以，每次只要选择能访问最远的ip地址进行访问，再从断点开始换下一个能访问最远的ip，如此便可得最优解。</p></blockquote><p>原来我没想到的是<strong>断点</strong>这个词啊！</p><p>整理一下思路：每次在余下的列表中找每个代理IP第一次出现的位置，选最远的。</p><h3 id="错误-v2"><a class="header-anchor" href="#错误-v2">¶</a>错误</h3><ul><li><p>超时：</p><img src="D:\胡可\博客\blog\source\_posts\Day17简单贪心-小可的机试练习日记.assets\image-20210611131338908.png" alt="image-20210611131338908" style="zoom: 50%;" loading="lazy"><p>对应的代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 5000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> one,<span class="keyword">int</span> two)</span></span>{</span><br><span class="line"><span class="keyword">return</span> one&gt;two;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line"><span class="built_in">string</span> proxy[MAXN];</span><br><span class="line"><span class="keyword">int</span> occur[MAXN];</span><br><span class="line"><span class="built_in">string</span> server[MAXM];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;proxy[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;server[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;<span class="comment">//记录访问列表断点位置</span></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//记录切换次数 </span></span><br><span class="line"><span class="keyword">while</span>(index&lt;m){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">occur[i]=<span class="built_in">find</span>(server+index,server+m,proxy[i])-(server+index);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//给出现位置降序排列 </span></span><br><span class="line">sort(occur,occur+n,compare);</span><br><span class="line">index+=occur[<span class="number">0</span>]; </span><br><span class="line">count++; </span><br><span class="line">} </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>没过的用例：</p><p>输入：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">17.151.164.96</span><br><span class="line">10</span><br><span class="line">17.151.164.96</span><br><span class="line">17.151.164.96</span><br><span class="line">17.151.164.96</span><br><span class="line">17.151.164.96</span><br><span class="line">17.151.164.96</span><br><span class="line">17.151.164.96</span><br><span class="line">17.151.164.96</span><br><span class="line">17.151.164.96</span><br><span class="line">17.151.164.96</span><br><span class="line">17.151.164.96</span><br></pre></td></tr></tbody></table></figure><p>预期输出：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></tbody></table></figure></li></ul><p>而我实际没有输出……因为卡住了，index更新不了</p><p>原来是忘了没有解的情况！！！总忘记！！！</p><p>所以可以特殊处理一下只有一个代理IP的情况。</p><hr><p>过了哈哈哈哈，开心心，吃午饭去！</p><h3 id="学习"><a class="header-anchor" href="#学习">¶</a>学习</h3><p>algorithm的find函数用在普通数组上，没找到的话返回的是什么？</p><img src="D:\胡可\博客\blog\source\_posts\Day17简单贪心-小可的机试练习日记.assets\image-20210611132814823.png" alt="image-20210611132814823" style="zoom:67%;" loading="lazy"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day16高精度整数-小可的机试练习日记</title>
      <link href="2021/06/08/Day16%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%95%B4%E6%95%B0-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>2021/06/08/Day16%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%95%B4%E6%95%B0-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>高精度整数</h1><p>书上有一个很长很长的板子，实现了各种运算</p><ul><li><p>敲了很久很久的珍贵板子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度整数板子</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10000</span>;<span class="comment">//最多多少位</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigInteger</span>{</span></span><br><span class="line"><span class="keyword">int</span> digit[MAXN];</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 </span></span><br><span class="line">BigInteger();</span><br><span class="line">BigInteger(<span class="keyword">int</span> x);</span><br><span class="line">BigInteger(<span class="built_in">string</span> str);</span><br><span class="line">BigInteger(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值函数</span></span><br><span class="line">BigInteger <span class="keyword">operator</span>=(<span class="keyword">int</span> x); </span><br><span class="line">BigInteger <span class="keyword">operator</span>=(<span class="built_in">string</span> str);</span><br><span class="line">BigInteger <span class="keyword">operator</span>=(<span class="keyword">const</span> BigInteger&amp; b); </span><br><span class="line"></span><br><span class="line"><span class="comment">//比大小</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInteger&amp; b); </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> BigInteger&amp; b); </span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符</span></span><br><span class="line">BigInteger <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger&amp; b); </span><br><span class="line">BigInteger <span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger&amp; b); </span><br><span class="line">BigInteger <span class="keyword">operator</span>*(<span class="keyword">const</span> BigInteger&amp; b); </span><br><span class="line">BigInteger <span class="keyword">operator</span>/(<span class="keyword">const</span> BigInteger&amp; b); </span><br><span class="line">BigInteger <span class="keyword">operator</span>%(<span class="keyword">const</span> BigInteger&amp; b); </span><br><span class="line"></span><br><span class="line"><span class="comment">//输入输出</span></span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, BigInteger&amp; x);</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> BigInteger&amp; x); </span><br><span class="line">}; </span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 </span></span><br><span class="line">BigInteger::BigInteger(){</span><br><span class="line"><span class="built_in">memset</span>(digit,<span class="number">0</span>,<span class="keyword">sizeof</span>(digit));</span><br><span class="line">length=<span class="number">0</span>;<span class="comment">//初始化 </span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">BigInteger::BigInteger(<span class="keyword">int</span> x){</span><br><span class="line"><span class="built_in">memset</span>(digit,<span class="number">0</span>,<span class="keyword">sizeof</span>(digit));</span><br><span class="line">length=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//x=0要分开处理，因为它进不去while </span></span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>){</span><br><span class="line">digit[length++]=x;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>){</span><br><span class="line">digit[length++]=x%<span class="number">10</span>;<span class="comment">//索引小的存的是低位，倒过来了 </span></span><br><span class="line">x/=<span class="number">10</span>; </span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">BigInteger::BigInteger(<span class="built_in">string</span> str){</span><br><span class="line"><span class="built_in">memset</span>(digit,<span class="number">0</span>,<span class="keyword">sizeof</span>(digit));</span><br><span class="line">length=str.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++){</span><br><span class="line">digit[i]=str[length-i<span class="number">-1</span>]-<span class="string">'0'</span>;<span class="comment">//也是倒着存 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">BigInteger::BigInteger(<span class="keyword">const</span> BigInteger&amp; b){</span><br><span class="line"><span class="built_in">memset</span>(digit,<span class="number">0</span>,<span class="keyword">sizeof</span>(digit));</span><br><span class="line">length=b.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++){</span><br><span class="line">digit[i]=b.digit[i];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值函数</span></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">int</span> x){</span><br><span class="line"><span class="built_in">memset</span>(digit,<span class="number">0</span>,<span class="keyword">sizeof</span>(digit));</span><br><span class="line">length=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//x=0要分开处理，因为它进不去while </span></span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>){</span><br><span class="line">digit[length++]=x;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>){</span><br><span class="line">digit[length++]=x%<span class="number">10</span>;<span class="comment">//索引小的存的是低位，倒过来了 </span></span><br><span class="line">x/=<span class="number">10</span>; </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="built_in">string</span> str){</span><br><span class="line"><span class="built_in">memset</span>(digit,<span class="number">0</span>,<span class="keyword">sizeof</span>(digit));</span><br><span class="line">length=str.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++){</span><br><span class="line">digit[i]=str[length-i<span class="number">-1</span>]-<span class="string">'0'</span>;<span class="comment">//也是倒着存 </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">const</span> BigInteger&amp; b){</span><br><span class="line"><span class="built_in">memset</span>(digit,<span class="number">0</span>,<span class="keyword">sizeof</span>(digit));</span><br><span class="line">length=b.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++){</span><br><span class="line">digit[i]=b.digit[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//比大小</span></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInteger&amp; b){</span><br><span class="line"><span class="keyword">if</span>(length&lt;b.length){</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(b.length&lt;length){</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line"><span class="keyword">if</span>(digit[i]==b.digit[i]){</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> digit[i]&lt;b.digit[i];<span class="comment">//妙啊！ </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//相等返回true </span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>==(<span class="keyword">const</span> BigInteger&amp; b){</span><br><span class="line"><span class="keyword">if</span>(length!=b.length){</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line"><span class="keyword">if</span>(digit[i]!=b.digit[i]){</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符</span></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger&amp; b){</span><br><span class="line">BigInteger answer;</span><br><span class="line"><span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length||i&lt;b.length;i++){<span class="comment">//i与较长的length保持一致 </span></span><br><span class="line"><span class="keyword">int</span> current=carry+digit[i]+b.digit[i];</span><br><span class="line">carry=current/<span class="number">10</span>;</span><br><span class="line">answer.digit[answer.length++]=current%<span class="number">10</span>; </span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(carry!=<span class="number">0</span>){<span class="comment">//还要多一位 </span></span><br><span class="line">answer.digit[answer.length++]=carry;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> answer;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger&amp; b){</span><br><span class="line">BigInteger answer;</span><br><span class="line"><span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++){</span><br><span class="line"><span class="keyword">int</span> current=digit[i]-b.digit[i]-carry;</span><br><span class="line"><span class="keyword">if</span>(current&lt;<span class="number">0</span>){<span class="comment">//要借位 </span></span><br><span class="line">current+=<span class="number">10</span>;</span><br><span class="line">carry=<span class="number">1</span>; </span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">carry=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">answer.digit[answer.length++]=current;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉多余的0 </span></span><br><span class="line"><span class="keyword">while</span>(answer.digit[answer.length]==<span class="number">0</span>&amp;&amp;answer.length&gt;<span class="number">1</span>){</span><br><span class="line">answer.length--;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> answer; </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>*(<span class="keyword">const</span> BigInteger&amp; b){</span><br><span class="line">BigInteger answer;</span><br><span class="line">answer.length=length+b.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b.length;j++){</span><br><span class="line">answer.digit[i+j]+=digit[i]*b.digit[j];<span class="comment">//这个i+j就很自然地实现了乘法，但是还没进位 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;answer.length;i++){</span><br><span class="line">answer.digit[i+<span class="number">1</span>]+=answer.digit[i]/<span class="number">10</span>;</span><br><span class="line">answer.digit[i]%=<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(answer.digit[answer.length]==<span class="number">0</span>&amp;&amp;answer.length&gt;<span class="number">1</span>){</span><br><span class="line">answer.length--;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> answer;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>/(<span class="keyword">const</span> BigInteger&amp; b){</span><br><span class="line">BigInteger answer;</span><br><span class="line">answer.length=length;</span><br><span class="line">BigInteger remainder=<span class="number">0</span>;<span class="comment">//余数 </span></span><br><span class="line">BigInteger temp=b;<span class="comment">//除数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){<span class="comment">//从高位除起 </span></span><br><span class="line"><span class="keyword">if</span>(!(remainder.length==<span class="number">1</span>&amp;&amp;remainder.digit[<span class="number">0</span>]==<span class="number">0</span>)){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=remainder.length<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">remainder.digit[j+<span class="number">1</span>]=remainder.digit[j];</span><br><span class="line">}</span><br><span class="line">remainder.length++;</span><br><span class="line">}</span><br><span class="line">remainder.digit[<span class="number">0</span>]=digit[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于除法 </span></span><br><span class="line"><span class="keyword">while</span>(temp&lt;=remainder){</span><br><span class="line">remainder=remainder-temp;</span><br><span class="line">answer.digit[i]++; </span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(answer.digit[answer.length]==<span class="number">0</span>&amp;&amp;answer.length&gt;<span class="number">1</span>){</span><br><span class="line">answer.length--;</span><br><span class="line">} </span><br><span class="line"><span class="keyword">return</span> answer;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>%(<span class="keyword">const</span> BigInteger&amp; b){</span><br><span class="line">BigInteger remainder=<span class="number">0</span>;<span class="comment">//余数 </span></span><br><span class="line">BigInteger temp=b;<span class="comment">//除数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){<span class="comment">//从高位除起 </span></span><br><span class="line"><span class="keyword">if</span>(!(remainder.length==<span class="number">1</span>&amp;&amp;remainder.digit[<span class="number">0</span>]==<span class="number">0</span>)){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=remainder.length<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">remainder.digit[j+<span class="number">1</span>]=remainder.digit[j];</span><br><span class="line">}</span><br><span class="line">remainder.length++;</span><br><span class="line">}</span><br><span class="line">remainder.digit[<span class="number">0</span>]=digit[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于除法 </span></span><br><span class="line"><span class="keyword">while</span>(temp&lt;=remainder){</span><br><span class="line">remainder=remainder-temp;</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> remainder;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入输出</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, BigInteger&amp; x){</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">in&gt;&gt;str;</span><br><span class="line">x=str;</span><br><span class="line"><span class="keyword">return</span> in;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> BigInteger&amp; x){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">out&lt;&lt;x.digit[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="a-b（华科）"><a class="header-anchor" href="#a-b（华科）">¶</a>a+b（华科）</h2><p><a href="http://t.cn/AipaWiSG">http://t.cn/AipaWiSG</a></p><h3 id="错误"><a class="header-anchor" href="#错误">¶</a>错误</h3><ul><li><p>‘stdistream&amp; BigIntegermoperator&gt; &gt;(stdistream&amp;, BigInteger&amp;)"’ must take exactly one argument</p><p><a href="https://stackoverflow.com/questions/10744787/operator-must-take-exactly-one-argument">https://stackoverflow.com/questions/10744787/operator-must-take-exactly-one-argument</a></p><p>应该把它放在类外面，书上写的是结构体（所以可以放里面）</p><p>改了也不太对……我还是照书上的用struct吧</p></li><li><p>过了样例但是：段错误:您的程序发生段错误，可能是数组越界，堆栈溢出（比如，递归调用层数太多）等情况引起</p><p>改了MAXN的大小，还是错……</p><p>晚上脑子有点不清醒，明天看看吧</p></li><li><p>破案了，原来是少了个return *this</p></li></ul><h2 id="N的阶乘"><a class="header-anchor" href="#N的阶乘">¶</a>N的阶乘</h2><p><a href="http://t.cn/AipaBKQJ">http://t.cn/AipaBKQJ</a></p><p>经典风格：题目简单，坑多多的</p><p>要求阶乘的这个数本身不大（0-1000），int就装得下</p><p>我和书上敲的一模一样，不知道为啥错……</p><p>网上找了个：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">int</span> result[<span class="number">20001</span>] = {<span class="number">0</span>};<span class="comment">//结果</span></span><br><span class="line">result[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;<span class="comment">//记录最高位的后一位下标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)<span class="comment">//阶乘</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//用于进位</span></span><br><span class="line"><span class="comment">//按位相乘，可以将这当作一个模板，很多大数运算都可以按照这种思路来做</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; index; ++j)</span><br><span class="line">{</span><br><span class="line">temp += result[j] * i;</span><br><span class="line">result[j] = temp % <span class="number">10</span>;</span><br><span class="line">temp /= <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(temp)<span class="comment">//判断最高位有没有进位</span></span><br><span class="line">{</span><br><span class="line">result[index++] = temp % <span class="number">10</span>;</span><br><span class="line">temp /= <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = index<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//输出结果</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i];</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>牢记模板！！</p><h2 id="数字阶梯求和"><a class="header-anchor" href="#数字阶梯求和">¶</a>数字阶梯求和</h2><p><a href="http://t.cn/Aipak8BQ">http://t.cn/Aipak8BQ</a></p><p>这道题最开始理解错了，还以为是n个a相乘……但其实只是拼起来</p><p>这道题的思路还挺巧妙的，并不是按照题目意思去构造出每一个加数；</p><p>而是从另一个角度想：</p><p>这样的序列加起来，个位数上加了n个a；十位数上加了n-1个a</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> a,n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;n){</span><br><span class="line"><span class="keyword">int</span> sum[MAXN]={<span class="number">0</span>};<span class="comment">//结果最多有n+1位 </span></span><br><span class="line"><span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++){</span><br><span class="line"><span class="keyword">int</span> current=(a*(n-i)+carry);</span><br><span class="line">sum[i]=current%<span class="number">10</span>;</span><br><span class="line">carry=current/<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> length=n;</span><br><span class="line"><span class="keyword">while</span>(sum[length]==<span class="number">0</span>&amp;&amp;length&gt;<span class="number">0</span>){</span><br><span class="line">length--;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=length;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,sum[i]);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">} </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自己写出来啦！注意一下length&gt;0这个，有时候搞不清就多试几次，多调几次</p><h2 id="大整数的因子"><a class="header-anchor" href="#大整数的因子">¶</a>大整数的因子</h2><p><a href="http://t.cn/AipaFCJE">http://t.cn/AipaFCJE</a></p><p>大数取模，和大数乘法有相似之处，高位取模，然后乘10加下一位，继续取模</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Day15快速幂、矩阵与矩阵快速幂-小可的机试练习日记</title>
      <link href="2021/05/19/Day15%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%8E%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>2021/05/19/Day15%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%8E%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>快速幂</h1><p>书上还是讲的挺明白的，这里总结一下：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210519174457877.png" alt="image-20210519174457877" style="zoom: 40%;" loading="lazy"><h2 id="人见人爱A-B（较难）"><a class="header-anchor" href="#人见人爱A-B（较难）">¶</a>人见人爱A^B（较难）</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2035">http://acm.hdu.edu.cn/showproblem.php?pid=2035</a></p><ul><li>错误：没运行出来……</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">binary</span><span class="params">(<span class="keyword">int</span> B)</span></span>{</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">while</span>(B!=<span class="number">0</span>){</span><br><span class="line">result.push_back(B%<span class="number">2</span>);</span><br><span class="line">B/=<span class="number">2</span>;</span><br><span class="line">} </span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> A,B;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;A&gt;&gt;B){</span><br><span class="line"><span class="keyword">if</span>(A==<span class="number">0</span>&amp;&amp;B==<span class="number">0</span>){</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; binB=binary(B);</span><br><span class="line"><span class="keyword">int</span> base=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> base_index;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; factor;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;binB.<span class="built_in">size</span>();i++){</span><br><span class="line"><span class="keyword">if</span>(binB[i]!=<span class="number">0</span>){</span><br><span class="line"><span class="keyword">if</span>(base==<span class="number">0</span>){<span class="comment">//如果这是第一个 </span></span><br><span class="line">factor.push_back((<span class="keyword">int</span>)<span class="built_in">pow</span>(A,i)%<span class="number">1000</span>);</span><br><span class="line">base=(<span class="keyword">int</span>)<span class="built_in">pow</span>(A,i)%<span class="number">1000</span>;</span><br><span class="line">base_index=i;</span><br><span class="line">}<span class="keyword">else</span>{<span class="comment">//如果不是第一个，就要基于base来计算 </span></span><br><span class="line"><span class="keyword">int</span> temp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i/base_index--){</span><br><span class="line">temp*=base;</span><br><span class="line">}</span><br><span class="line">factor.push_back(temp%<span class="number">1000</span>);</span><br><span class="line">base=temp%<span class="number">1000</span>;</span><br><span class="line">base_index=i;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;factor.<span class="built_in">size</span>();i++){</span><br><span class="line">ans*=factor[i];</span><br><span class="line">ans=ans%<span class="number">1000</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>学习</p><p>看看书上的答案吧</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FastExponentiation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> mod)</span></span>{</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b!=<span class="number">0</span>){</span><br><span class="line"><span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>){<span class="comment">//如果是1，代表这一位的下标k，算出来的2^k，这个值是快速幂分解的指数之一，也就是a^(2^k)</span></span><br><span class="line">ans*=a;</span><br><span class="line">ans%=mod;</span><br><span class="line">}</span><br><span class="line">b/=<span class="number">2</span>;</span><br><span class="line">a*=a;<span class="comment">//a一直在自平方，直到累乘到现在的a是快速幂分解的因子之一，就在下一轮被ans乘起来</span></span><br><span class="line">a%=mod;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>说实话，看不太懂……</p><p>果然万事还是要动笔，动笔以后我好像有点懂了：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210519185601843.png" alt="image-20210519185601843" style="zoom: 33%;" loading="lazy"><h2 id="求root-N-k-（难，重要）"><a class="header-anchor" href="#求root-N-k-（难，重要）">¶</a>求root(N,k)（难，重要）</h2><p><a href="http://t.cn/AipAw4B1">http://t.cn/AipAw4B1</a></p><p>研究了一下，我觉得这道题妙在两个地方：</p><ul><li>沿袭了清华一贯的风格——题目虽短，杀伤力却不少</li><li>需要先数学推导出一个结论再继续，不是直接莽的……</li><li>用到了<strong>快速幂取模</strong>算法</li></ul><h3 id="快速幂取模算法"><a class="header-anchor" href="#快速幂取模算法">¶</a>快速幂取模算法</h3><p>参考博客：<a href="https://blog.csdn.net/ltyqljhwcm/article/details/53043646">https://blog.csdn.net/ltyqljhwcm/article/details/53043646</a></p><p>算法的数学原理：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210519222208724.png" alt="image-20210519222208724" style="zoom: 67%;" loading="lazy"><p>学习几个二进制操作符：</p><ul><li><p>&amp;</p><p>&amp;运算通常用于二进制取位操作，例如一个数 &amp; 1 的结果就是取二进制的最末位。还可以判断奇偶，<code>x&amp;1==0</code>为偶，<code>x&amp;1==1</code>为奇。</p></li><li><p><code>&gt;</code></p><p>&gt;&gt;运算比较单纯,二进制去掉最后一位，移位操作，不断遍历b的二进制位。相当于除2</p></li></ul><p>总结一下快速幂取模的代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1</span>;   <span class="comment">//记录结果</span></span><br><span class="line">a=a%c;   <span class="comment">//预处理，使得a处于c的数据范围之下</span></span><br><span class="line"><span class="keyword">while</span>(b!=<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>){</span><br><span class="line">             ans=(ans*a)%c;   <span class="comment">//如果b的二进制位不是0，那么我们的结果是要参与运算的</span></span><br><span class="line">        }</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;    <span class="comment">//二进制的移位操作，相当于每次除以2，用二进制看，就是我们不断的遍历b的二进制位</span></span><br><span class="line">a=(a*a)%c;   <span class="comment">//不断的加倍</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>好的，引入了上述技术之后，回归本题看一下它的独特点：</p><p><a href="https://www.jianshu.com/p/16e90704d3cd">https://www.jianshu.com/p/16e90704d3cd</a></p><p>涉及到一个数学推导</p><p>而我竟然，没看懂qwq</p><h1>矩阵与矩阵快速幂</h1><h2 id="计算两个矩阵的乘积"><a class="header-anchor" href="#计算两个矩阵的乘积">¶</a>计算两个矩阵的乘积</h2><p><a href="https://www.nowcoder.com/practice/ed6552d03e624ba58d16af6d57e1c3e9?tpId=40&amp;tqId=21502&amp;tPage=9&amp;rp=9&amp;ru=/ta/kaoyan&amp;qru=/ta/kaoyan/question-ranking">https://www.nowcoder.com/practice/ed6552d03e624ba58d16af6d57e1c3e9?tpId=40&amp;tqId=21502&amp;tPage=9&amp;rp=9&amp;ru=/ta/kaoyan&amp;qru=/ta/kaoyan/question-ranking</a></p><p>本来以为无脑写，结果中间还是想了一下，其实需要三层循环</p><p>书上把操作都写成了函数，我是硬编码的，感觉都行</p><h2 id="矩阵幂"><a class="header-anchor" href="#矩阵幂">¶</a>矩阵幂</h2><p><a href="https://www.nowcoder.com/practice/31e539ab08f949a8bece2a7503e9319a?tpId=67&amp;tqId=29638&amp;tPage=1&amp;ru=/kaoyan/retest/1005&amp;qru=/ta/bupt-kaoyan/question-ranking">https://www.nowcoder.com/practice/31e539ab08f949a8bece2a7503e9319a?tpId=67&amp;tqId=29638&amp;tPage=1&amp;ru=/kaoyan/retest/1005&amp;qru=/ta/bupt-kaoyan/question-ranking</a></p><p>注意到矩阵大小不会超过10*10，且里面的元素的值也不会超过10</p><p>大致思路和快速幂是一样的，唯一的不同大概就是：</p><ul><li>快速幂：ans初始为1</li><li>矩阵快速幂：ans初始为单位矩阵</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>{</span></span><br><span class="line"><span class="keyword">int</span> row;</span><br><span class="line"><span class="keyword">int</span> col;</span><br><span class="line"><span class="keyword">int</span> matrix[MAX_N][MAX_N];<span class="comment">//直接开大数组，不“动态分配” </span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印矩阵 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(struct Matrix m)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m.row;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m.col;j++){</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,m.matrix[i][j]);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵相乘</span></span><br><span class="line"><span class="function">struct Matrix <span class="title">multiply</span><span class="params">(struct Matrix m,struct Matrix n)</span></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> <span class="title">ans</span>;</span></span><br><span class="line">ans.row=m.row;</span><br><span class="line">ans.col=n.col;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m.row;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n.col;j++){</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m.col;k++){</span><br><span class="line">sum+=m.matrix[i][k]*n.matrix[k][j];</span><br><span class="line">}</span><br><span class="line">ans.matrix[i][j]=sum;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵快速幂</span></span><br><span class="line"><span class="function">struct Matrix <span class="title">fastExp</span><span class="params">(struct Matrix m,<span class="keyword">int</span> k)</span></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> <span class="title">ans</span>;</span></span><br><span class="line">ans.row=m.row;</span><br><span class="line">ans.col=m.col;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ans矩阵初始化为单位矩阵 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.row;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ans.col;j++){</span><br><span class="line"><span class="keyword">if</span>(i==j){</span><br><span class="line">ans.matrix[i][j]=<span class="number">1</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">ans.matrix[i][j]=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始累乘快速幂</span></span><br><span class="line"><span class="keyword">while</span>(k!=<span class="number">0</span>){</span><br><span class="line"><span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">1</span>){</span><br><span class="line">ans=multiply(ans,m);</span><br><span class="line">}</span><br><span class="line">k/=<span class="number">2</span>;</span><br><span class="line">m=multiply(m,m);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ans; </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k){</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> <span class="title">m</span>;</span></span><br><span class="line">m.row=n;</span><br><span class="line">m.col=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m.matrix[i][j]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> <span class="title">ans</span>;</span></span><br><span class="line">ans.row=n;</span><br><span class="line">ans.col=n;</span><br><span class="line">ans=fastExp(m,k);</span><br><span class="line">printMatrix(ans); </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="A-B-for-Matrices"><a class="header-anchor" href="#A-B-for-Matrices">¶</a>A+B for Matrices</h2><p><a href="http://t.cn/Aipb7GBG">http://t.cn/Aipb7GBG</a></p><h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>输入包括几个test case，每个case开头是一对整数M和N，分别表示矩阵的行和列</p><p>然后下面接上2M行，每行有N个整数</p><p>前M行是A的数据，后M行是B的数据</p><p>结束的case是M==0，不需要处理</p><p>要求输出：对于每个case，输出A+B的0 row与0 col的总数</p><h3 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h3><p>听起来不难啊，不知道会不会卡时间</p><hr><p>啊，居然没卡时间，美滋滋</p><h2 id="递推数列（较难，重要）"><a class="header-anchor" href="#递推数列（较难，重要）">¶</a>递推数列（较难，重要）</h2><p>一看就不是什么好搞的……</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day14质数&amp;分解质因数-小可的机试练习日记</title>
      <link href="2021/05/14/Day14%E8%B4%A8%E6%95%B0-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>2021/05/14/Day14%E8%B4%A8%E6%95%B0-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="素数判定"><a class="header-anchor" href="#素数判定">¶</a>素数判定</h2><p><a href="http://t.cn/AiCuWE0Q">http://t.cn/AiCuWE0Q</a></p><p>注意单独处理一下0/1/负数的情况</p><p>记录一下素数判定的函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++){</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>){</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="素数"><a class="header-anchor" href="#素数">¶</a>素数</h2><p><a href="http://t.cn/AiCulqtW">http://t.cn/AiCulqtW</a></p><p>比较简单~只要遍历这个区间就可</p><ul><li><p>学习</p><p>看了答案才知道，其实可以优化，就是判定一个i为素数之后，可以标记它的倍数为非素数~</p></li></ul><h2 id="Prime-Number"><a class="header-anchor" href="#Prime-Number">¶</a>Prime Number</h2><p><a href="https://www.nowcoder.com/practice/c5f8688cea8a4a9a88edbd67d1358415?tpId=62&amp;tqId=29467&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F2002&amp;qru=%2Fta%2Fsju-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/c5f8688cea8a4a9a88edbd67d1358415?tpId=62&amp;tqId=29467&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F2002&amp;qru=%2Fta%2Fsju-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><h2 id="质因数的个数"><a class="header-anchor" href="#质因数的个数">¶</a>质因数的个数</h2><p><a href="https://www.nowcoder.com/practice/20426b85f7fc4ba8b0844cc04807fbd9?tpId=60&amp;tqId=29479&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F1001&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/20426b85f7fc4ba8b0844cc04807fbd9?tpId=60&amp;tqId=29479&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F1001&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><p>这道题书上给了不错的思路，听起来很优雅：</p><p>预处理，找出题目数据范围中所有可能的素数；输入n之后，再判断小于n的那些素数是否是n的因子；如果是因子，则通过<strong>试除</strong>来判断此因子的幂指数</p><p>这个试除非常有意思，值得好好学习一下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li><p>错误</p><p>编译出错了：</p><img src="C:\Users\10437\AppData\Roaming\Typora\typora-user-images\image-20210515150931046.png" alt="image-20210515150931046" style="zoom: 50%;" loading="lazy"><p>应该是不能在这里声明变量，放到main函数里面就可以……</p></li><li><p>学习</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span>* isPrime)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1e9</span>)+<span class="number">1</span>;i++){</span><br><span class="line">isPrime[i]=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preProcess</span><span class="params">(<span class="keyword">int</span>* isPrime)</span></span>{</span><br><span class="line">isPrime[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">isPrime[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1e9</span>)+<span class="number">1</span>;i++){</span><br><span class="line"><span class="keyword">if</span>(!isPrime[i]){<span class="comment">//如果不是质数，就跳过 </span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}<span class="keyword">else</span>{<span class="comment">//如果是质数，就加到prime向量里 ；并设置其倍数为false </span></span><br><span class="line">prime.push_back(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i*i;j&lt;(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1e9</span>)+<span class="number">1</span>;j+=i){</span><br><span class="line">isPrime[j]=<span class="number">0</span>;</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> isPrime[(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1e9</span>)+<span class="number">1</span>];</span><br><span class="line">init(isPrime);</span><br><span class="line">preProcess(isPrime);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prime.<span class="built_in">size</span>()&amp;&amp;prime[i]&lt;=n;i++){</span><br><span class="line"><span class="keyword">while</span>(n%prime[i]==<span class="number">0</span>){</span><br><span class="line">n/=prime[i];</span><br><span class="line">sum++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1</span>){</span><br><span class="line">sum++;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意<code>while(n%prime[i]==0)</code>是一个试除的方法</p><p>还有我搞不懂为什么要加n&gt;1…………，但是就这样记着吧</p><p>书上给的道理是：<strong>n至多只存在一个大于sqrt(n)的素因数</strong></p></li></ul><h2 id="约数的个数"><a class="header-anchor" href="#约数的个数">¶</a>约数的个数</h2><p><a href="http://t.cn/Aip7dTUp">http://t.cn/Aip7dTUp</a></p><ul><li><p>错误</p><p>超时：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> num)</span></span>{</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++){</span><br><span class="line"><span class="keyword">if</span>(num%i==<span class="number">0</span>){</span><br><span class="line">sum++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N){</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count(num[i])&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">} </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>再改了一版，还是超时：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int count(int num){</span><br><span class="line">int sum=2;</span><br><span class="line">for(int i=2;i&lt;num;i++){</span><br><span class="line">if(num%i==0){</span><br><span class="line">sum++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">return sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main(void){</span><br><span class="line">int N;</span><br><span class="line">while(cin&gt;&gt;N){</span><br><span class="line">int num[N];</span><br><span class="line">for(int i=0;i&lt;N;i++){</span><br><span class="line">cin&gt;&gt;num[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;N;i++){</span><br><span class="line">if(num[i]==1){</span><br><span class="line">cout&lt;&lt;1&lt;&lt;" ";</span><br><span class="line">}else{</span><br><span class="line">cout&lt;&lt;count(num[i])&lt;&lt;" ";</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">} </span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>感觉这样做的复杂度是O(n^2)</p><p>试下预处理吧……不对啊这又不是素数问题</p></li><li><p>内存超限：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> num)</span></span>{</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag[num+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num+<span class="number">1</span>;i++){</span><br><span class="line">flag[i]=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++){</span><br><span class="line"><span class="keyword">if</span>(i*i==num){<span class="comment">//平方数 </span></span><br><span class="line">sum++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span>{<span class="comment">//非平方数 </span></span><br><span class="line"><span class="keyword">if</span>(flag[i]==<span class="number">1</span>){</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">if</span>(num%i==<span class="number">0</span>){</span><br><span class="line">sum+=<span class="number">2</span>;</span><br><span class="line">flag[num/i]=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N){</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line"><span class="keyword">if</span>(num[i]==<span class="number">1</span>){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count(num[i])&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">} </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>是不是用flag用的……换一种标记方式？</p></li><li><p>又超时……</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> num)</span></span>{</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> endpoint=num;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++){</span><br><span class="line"><span class="keyword">if</span>(i*i==num){<span class="comment">//平方数 </span></span><br><span class="line">sum++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span>{<span class="comment">//非平方数 </span></span><br><span class="line"><span class="keyword">if</span>(i==endpoint){</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">if</span>(num%i==<span class="number">0</span>){</span><br><span class="line">sum+=<span class="number">2</span>;</span><br><span class="line">endpoint=num/i;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N){</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line"><span class="keyword">if</span>(num[i]==<span class="number">1</span>){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count(num[i])&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">} </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>学习</p><p>咱们还是看下评论区学习一下吧</p><p>其实思路是想到了的，基本一样，但是我的就是没过……</p><p>学一下count函数吧：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> num)</span></span>{</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i*i&lt;num;i++){</span><br><span class="line"><span class="keyword">if</span>(num%i==<span class="number">0</span>){</span><br><span class="line">sum+=<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i*i==num){</span><br><span class="line">sum++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="整除问题（重要，较难）"><a class="header-anchor" href="#整除问题（重要，较难）">¶</a>整除问题（重要，较难）</h2><p><a href="http://t.cn/Aip7eHBD">http://t.cn/Aip7eHBD</a></p><ul><li><p>分析</p><p>根据n先算出n!，然后求k，使得(n!) % (a^k) ==0，但(n!) % (a^(k+1)) !=0</p><p>感觉这道题可能数字比较大</p></li><li><p>学习</p><p>看了一下题解，果然不是常规的暴力方法可以解决的……</p><p>而且我压根都没有想到素因子这回事</p><p><a href="https://blog.csdn.net/csyifanZhang/article/details/105754286%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E8%BF%99%E4%B8%AA%E9%A2%98%E8%A7%A3">https://blog.csdn.net/csyifanZhang/article/details/105754286可以参考这个题解</a></p><p>所以说，一个数A能整除另一个数B，代表A、B分解质因子之后，B有的A都有，且对应的A的质因子指数必然比B大</p><p>在本题中，a的质因子分解，和n!的质因子分解是不一样的</p><ul><li>a的质因子分解</li></ul></li></ul><p>太难了……暴哭qwq</p><hr><p>坚持一下：</p><ul><li><p>n!的质因子分解</p></li><li><p>a的质因子分解</p><p>这里和质因子的个数又有点不一样，本题需要知道每个质因子对应的幂，而“质因子”的个数这道题，只需要求和</p></li></ul><p>先搁一下吧……太烧脑了呜呜呜</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 质数 </tag>
            
            <tag> 质因数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day13最大公约数与最小公倍数-小可的机试练习日记</title>
      <link href="2021/05/14/Day13%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>2021/05/14/Day13%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="最大公约数"><a class="header-anchor" href="#最大公约数">¶</a>最大公约数</h2><p><a href="https://www.nowcoder.com/practice/20216f2c84bc438eb5ef05e382536fd3?tpId=40&amp;tqId=21492&amp;tPage=8&amp;rp=8&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/20216f2c84bc438eb5ef05e382536fd3?tpId=40&amp;tqId=21492&amp;tPage=8&amp;rp=8&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><p>学一下GCD函数的写法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>){</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> GCD(b,a%b);</span><br><span class="line">}</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>为什么是b为0就终止呢？</p><p>因为b这个位置的数一定比a这个位置的数小……最开始一次递归，传入的参数是A=b,B=a%b；</p><p>由于B是a%b的结果，也就是a/b的余数，所以余数必然比除数小啊，那么B&lt;A</p><p>所以B是先降为0的那个数，只要判断它就好啦</p><h2 id="最小公倍数"><a class="header-anchor" href="#最小公倍数">¶</a>最小公倍数</h2><p>LCM=a*b/GCD(a,b)</p><h2 id="最简真分数"><a class="header-anchor" href="#最简真分数">¶</a>最简真分数</h2><p><a href="http://t.cn/AiCua2g8">http://t.cn/AiCua2g8</a></p><p>最简真分数，就是分子&lt;分母，且分子和分母的GCD==1</p><p>简单啦，感觉给数据排成有序的会更好~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最大公约数 </tag>
            
            <tag> 最小公倍数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day12进制转换-小可的机试练习日记</title>
      <link href="2021/05/10/Day12%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>2021/05/10/Day12%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="二进制数"><a class="header-anchor" href="#二进制数">¶</a>二进制数</h2><p><a href="https://www.nowcoder.com/practice/103dd589fed14457a673c613d8de3841?tpId=67&amp;tqId=29634&amp;tPage=1&amp;ru=/kaoyan/retest/1005&amp;qru=/ta/bupt-kaoyan/question-ranking">https://www.nowcoder.com/practice/103dd589fed14457a673c613d8de3841?tpId=67&amp;tqId=29634&amp;tPage=1&amp;ru=/kaoyan/retest/1005&amp;qru=/ta/bupt-kaoyan/question-ranking</a></p><p>简单啦，只要求余和整除两种操作循环就可以</p><h2 id="进制转换（重要）"><a class="header-anchor" href="#进制转换（重要）">¶</a>进制转换（重要）</h2><p><a href="https://www.nowcoder.com/practice/0337e32b1e5543a19fa380e36d9343d7?tpId=60&amp;tqId=29473&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F1001&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/0337e32b1e5543a19fa380e36d9343d7?tpId=60&amp;tqId=29473&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F1001&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><p>感觉这道题主要是需要处理大数的问题</p><p>试一下字符串？</p><hr><p>看了书，用字符串是没错的……</p><p>取模的操作可以等价于对最后一位取模</p><p>整除的操作等价于……可以看看书上的操作，真是令人迷惑的优雅</p><p><strong>这道题的“字符串除法”很值得学习。</strong></p><h2 id="10进制-vs-2进制（重要）"><a class="header-anchor" href="#10进制-vs-2进制（重要）">¶</a>10进制 vs 2进制（重要）</h2><p><a href="https://www.nowcoder.com/practice/fd972d5d5cf04dd4bb4e5f027d4fc11e?tpId=60&amp;tqId=29498&amp;tPage=2&amp;ru=%2Fkaoyan%2Fretest%2F1001&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/fd972d5d5cf04dd4bb4e5f027d4fc11e?tpId=60&amp;tqId=29498&amp;tPage=2&amp;ru=%2Fkaoyan%2Fretest%2F1001&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><p>惊了，这道题位数更多</p><p>但是其实应该和上一道题是同理的……</p><p>突然意识到了从二进制转回十进制的艰辛……本来之间按照公式加起来应该是可以的，但是由于加出来可能很大，一个int是存不下的，所以还是得用字符串的形式来存储它，也就是每一位每一位地算出来……</p><ul><li>错误：神奇的错误，居然是因为pow返回的是double</li></ul><p><img src="C:%5CUsers%5C10437%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210510215344335.png" alt="image-20210510215344335" loading="lazy"></p><p>不知道又是什么错……</p><img src="C:\Users\10437\AppData\Roaming\Typora\typora-user-images\image-20210510215939355.png" alt="image-20210510215939355" style="zoom: 67%;" loading="lazy"><p>噗，自己简直就是个bug制造机</p><p>还是看着书上来写吧……明天？</p><hr><p>过得很艰难……这道题值得记忆啊</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串除法</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">divide</span><span class="params">(<span class="built_in">string</span> str,<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">int</span> remainder=<span class="number">0</span>;<span class="comment">//高位余数 </span></span><br><span class="line"><span class="keyword">int</span> current;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++){</span><br><span class="line">current=remainder*<span class="number">10</span>+(str[i]-<span class="string">'0'</span>);<span class="comment">//求现在的被除数</span></span><br><span class="line">str[i]=current/x+<span class="string">'0'</span>;<span class="comment">//将商保存到这一位数字</span></span><br><span class="line">remainder=current%x; <span class="comment">//计算这次的余数 </span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后的结果，要处理一下去掉高位的0 </span></span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(str[index]==<span class="string">'0'</span>){<span class="comment">//这里别写成0！！！！ </span></span><br><span class="line">index++;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> str.substr(index); </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串乘法 </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">multiple</span><span class="params">(<span class="built_in">string</span> str,<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> current;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=str.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){<span class="comment">//注意乘法是从最低位往前面乘的 </span></span><br><span class="line">current=carry+(str[i]-<span class="string">'0'</span>)*x;</span><br><span class="line">str[i]=current%<span class="number">10</span>+<span class="string">'0'</span>;</span><br><span class="line">carry=current/<span class="number">10</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理最高位进位 </span></span><br><span class="line"><span class="keyword">if</span>(carry!=<span class="number">0</span>){</span><br><span class="line">str=<span class="string">"1"</span>+str; </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串加法 </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> str,<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">int</span> carry=x;</span><br><span class="line"><span class="keyword">int</span> current;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=str.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">current=carry+(str[i]-<span class="string">'0'</span>);</span><br><span class="line">str[i]=current%<span class="number">10</span>+<span class="string">'0'</span>;</span><br><span class="line">carry=current/<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(carry!=<span class="number">0</span>){</span><br><span class="line">str=<span class="string">"1"</span>+str;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str){</span><br><span class="line"><span class="comment">//原数字转2进制 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; binary;</span><br><span class="line"><span class="keyword">int</span> last;</span><br><span class="line"><span class="keyword">while</span>(str.<span class="built_in">size</span>()!=<span class="number">0</span>){</span><br><span class="line">last=str[str.<span class="built_in">size</span>()<span class="number">-1</span>]-<span class="string">'0'</span>;</span><br><span class="line">binary.push_back(last%<span class="number">2</span>);</span><br><span class="line">str=divide(str,<span class="number">2</span>);</span><br><span class="line">} </span><br><span class="line"><span class="comment">//binary里面是倒着放的二进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制转十进制 </span></span><br><span class="line"><span class="built_in">string</span> answer=<span class="string">"0"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;binary.<span class="built_in">size</span>();i++){</span><br><span class="line">answer=multiple(answer,<span class="number">2</span>);<span class="comment">//说实话，不是很理解先乘后加…… </span></span><br><span class="line">answer=add(answer,binary[i]);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;answer&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="进制转换2（重要）"><a class="header-anchor" href="#进制转换2（重要）">¶</a>进制转换2（重要）</h2><p><a href="https://www.nowcoder.com/practice/ae4b3c4a968745618d65b866002bbd32?tpId=60&amp;tqId=31034&amp;tPage=2&amp;ru=%2Fkaoyan%2Fretest%2F1001&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/ae4b3c4a968745618d65b866002bbd32?tpId=60&amp;tqId=31034&amp;tPage=2&amp;ru=%2Fkaoyan%2Fretest%2F1001&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><p>清华的题……表面看起来平平无奇，实际上难得一匹</p><p>呜呜呜我好菜啊</p><ul><li><p>学习</p><p>这道题的一个要点在于，大于十进制的话，有的数字要用字符表示</p><p>要求从M进制转为N进制，那么应该……找十进制作为中介，M—&gt;10——&gt;N</p><ul><li><p>M—&gt;10的方法：</p><p>将每一位数字乘上这一位的权重：k^(n-1)</p></li><li><p>10—&gt;N的方法：</p><p>循环，对N取模，除N</p></li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">char2int</span><span class="params">(<span class="keyword">char</span> c)</span></span>{</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">if</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>){</span><br><span class="line">result=c-<span class="string">'0'</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">result=c-<span class="string">'A'</span>+<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">int2char</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line"><span class="keyword">char</span> result;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;i&lt;=<span class="number">9</span>){</span><br><span class="line">result=i+<span class="string">'0'</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">result=i<span class="number">-10</span>+<span class="string">'a'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> M,N;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;M&gt;&gt;N){</span><br><span class="line"><span class="built_in">string</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//m进制转10进制 </span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x.<span class="built_in">size</span>();i++){<span class="comment">//为什么感觉这里是反的？？ ——懂了，没反…… </span></span><br><span class="line">num*=M;</span><br><span class="line">num+=char2int(x[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; answer;</span><br><span class="line"><span class="keyword">while</span>(num!=<span class="number">0</span>){</span><br><span class="line">answer.push_back(int2char(num%N));</span><br><span class="line">num/=N;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=answer.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,answer[i]);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我知道M-&gt;10的操作是什么意思了……</p><p>是每次加完高位的数字，然后乘以M，也就是把它往前推一位，升一下它的权重</p><p>所以其实没反，高位一直乘到最后，它还是拥有最高权重的那个</p><h2 id="八进制"><a class="header-anchor" href="#八进制">¶</a>八进制</h2><p><a href="https://www.nowcoder.com/practice/eda051c1effc4dffa630bc8507f0c5f7?tpId=69&amp;tqId=29677&amp;tPage=2&amp;ru=%2Fkaoyan%2Fretest%2F11002&amp;qru=%2Fta%2Fhust-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/eda051c1effc4dffa630bc8507f0c5f7?tpId=69&amp;tqId=29677&amp;tPage=2&amp;ru=%2Fkaoyan%2Fretest%2F11002&amp;qru=%2Fta%2Fhust-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><p>简单</p><h2 id="又一版A-B"><a class="header-anchor" href="#又一版A-B">¶</a>又一版A+B</h2><p><a href="http://t.cn/AiCuOSWv">http://t.cn/AiCuOSWv</a></p><p>注意题目里写的，两个数在2^31-1之内，那相加一下是不是有可能溢出？</p><p>但是用long long应该还是装得下……</p><p>而且m不超过10进制，不涉及字符表示的问题</p><ul><li><p>错误</p><p>输入为2 0 0，输出应为0，但是实际上没有输出，是因为while的判断条件略过了0的情况，所以应该补一个</p></li></ul><h2 id="进制转换（北大）"><a class="header-anchor" href="#进制转换（北大）">¶</a>进制转换（北大）</h2><p><a href="http://t.cn/AiCuig9B">http://t.cn/AiCuig9B</a></p><p>累加计算的别忘了初始化</p><h2 id="数制转换"><a class="header-anchor" href="#数制转换">¶</a>数制转换</h2><p><a href="http://t.cn/AiCu6ne4">http://t.cn/AiCu6ne4</a></p><p>输入时大小写不定，输出时全用大写</p><p>按照之前思路，以10进制作为中转站</p><p>简单，注意下大小的问题就可以</p><p>进制转换貌似有多种方法，其中数字形式的和字符串形式的写起来还是很不一样的……值得多总结一下</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Day11栈-小可的机试练习日记</title>
      <link href="2021/04/21/Day11%E6%A0%88-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>2021/04/21/Day11%E6%A0%88-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Zero-Complexity-Transposition"><a class="header-anchor" href="#Zero-Complexity-Transposition">¶</a>Zero-Complexity Transposition</h2><p><a href="https://www.nowcoder.com/practice/c54775799f634c72b447ef31eb36e975?tpId=40&amp;tqId=21440&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/c54775799f634c72b447ef31eb36e975?tpId=40&amp;tqId=21440&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><p>这个问题很简单啦，用栈逆序输出就可以了</p><h2 id="括号匹配问题（重要）"><a class="header-anchor" href="#括号匹配问题（重要）">¶</a>括号匹配问题（重要）</h2><p>思路在书上已经写得很清楚了</p><p>前面还写的很顺，但是遇到的问题就是，最后栈不空的时候，说明左括号没匹配，那么我要怎么知道这些没匹配的左括号是来自于原字符串的哪里呢？</p><p>然后看了看书上的题解，恍然大悟，原来人家本来存的就是下标啊！太机智了！</p><hr><p>遂按照此思路重写一遍~</p><p>过啦嘻嘻</p><p>其实只要小小改改就可以</p><h2 id="简单计算器（重要）"><a class="header-anchor" href="#简单计算器（重要）">¶</a>简单计算器（重要）</h2><p><a href="https://www.nowcoder.com/practice/5759c29a28cb4361bc3605979d5a6130?tpId=63&amp;tqId=29576&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F9001&amp;qru=%2Fta%2Fzju-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/5759c29a28cb4361bc3605979d5a6130?tpId=63&amp;tqId=29576&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F9001&amp;qru=%2Fta%2Fzju-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><p>有几个值得注意的点：</p><ul><li>运算数和运算符之间用一个空格分隔</li></ul><p>思路整理：</p><ul><li><p>运算数和运算符分别用两个栈来存</p></li><li><p>运算符栈先压入一个’#’，其优先级最低</p></li><li><p>表达式尾部先加一个‘$’，其优先级最低</p></li><li><p>从左到右遍历字符串</p><ul><li><p>为运算数</p><p>压入运算数栈</p></li><li><p>为运算符</p><p>和栈顶运算符优先级比较（这是个循环，直到现在运算符比栈顶的优先级高才可以压入）</p><ul><li><p>比栈顶的高</p><p>该运算符压入运算符栈</p></li><li><p>比栈顶的低或等于</p><p>弹出栈顶运算符，并从运算数栈弹出足够的运算数进行计算，算完把结果压入运算数栈</p></li></ul></li></ul></li></ul><p>由于这道题比较典型，所以学一下书上的结构：</p><hr><p>有点难，先歇会</p><hr><p>继续继续！</p><p>学到个很不错的方法，把string转float：</p><p><a href="https://blog.csdn.net/Buer_zhu/article/details/81093569">https://blog.csdn.net/Buer_zhu/article/details/81093569</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str=<span class="string">"123.0123"</span>;</span><br><span class="line"><span class="keyword">float</span> f=atof(str.c_str());</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f;</span><br></pre></td></tr></tbody></table></figure><p>注意c_str()这个好东西</p><p>是时候整理一下string和char*的区别了……</p><hr><p>写到一半觉得脑子乱乱的……</p><hr><p>终于过啦，注意在栈底和字符串尾部加符号的操作，很优雅</p><h2 id="堆栈的使用"><a class="header-anchor" href="#堆栈的使用">¶</a>堆栈的使用</h2><p>太简单了</p><h2 id="计算表达式"><a class="header-anchor" href="#计算表达式">¶</a>计算表达式</h2><p><a href="https://www.nowcoder.com/practice/7b18aa6b7cc14f8eaae6b8acdebf890b?tpId=62&amp;tqId=29459&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F2002&amp;qru=%2Fta%2Fsju-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/7b18aa6b7cc14f8eaae6b8acdebf890b?tpId=62&amp;tqId=29459&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F2002&amp;qru=%2Fta%2Fsju-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><p>这是无括号无空格的输入</p><p>过啦，和之前的简单计算器很像</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day10队列-小可的机试练习日记</title>
      <link href="2021/04/21/Day10%E9%98%9F%E5%88%97-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>2021/04/21/Day10%E9%98%9F%E5%88%97-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="约瑟夫问题"><a class="header-anchor" href="#约瑟夫问题">¶</a>约瑟夫问题</h2><p>学到一个很重要的——把queue当循环队列来用的操作</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让第p个小孩做队首，这样就可以更方便之后的出队</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;p;i++){<span class="comment">//p-1次 </span></span><br><span class="line">children.push(children.front());<span class="comment">//前面的值压到后面 </span></span><br><span class="line">children.pop();<span class="comment">//前面的元素弹出 </span></span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="猫狗收容所"><a class="header-anchor" href="#猫狗收容所">¶</a>猫狗收容所</h2><p>重点就是循环队列的使用啦</p><p>不过因为这道题没在oj上找到，所以……</p><p>我也不知道能不能通过其他的测试用例</p><p>最重要的是，我还是不太会处理那个格式控制……</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Day9-小可的机试练习日记-向量</title>
      <link href="2021/04/20/Day9-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%90%91%E9%87%8F/"/>
      <url>2021/04/20/Day9-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%90%91%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="完数与盈数"><a class="header-anchor" href="#完数与盈数">¶</a>完数与盈数</h2><p><a href="https://www.nowcoder.com/practice/ccc3d1e78014486fb7eed3c50e05c99d?tpId=60&amp;tqId=29492&amp;tPage=1&amp;ru=/kaoyan/retest/1001&amp;qru=/ta/tsing-kaoyan/question-ranking">https://www.nowcoder.com/practice/ccc3d1e78014486fb7eed3c50e05c99d?tpId=60&amp;tqId=29492&amp;tPage=1&amp;ru=/kaoyan/retest/1001&amp;qru=/ta/tsing-kaoyan/question-ranking</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Day8字符串匹配-小可的机试练习日记</title>
      <link href="2021/04/17/Day8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>2021/04/17/Day8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="KMP算法"><a class="header-anchor" href="#KMP算法">¶</a>KMP算法</h2><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html</a></p><p>这篇真挺不错的，一下就听懂了哈哈哈</p><p>如何更好地理解和掌握 KMP 算法? - 海纳的回答 - 知乎 <a href="https://www.zhihu.com/question/21923021/answer/281346746">https://www.zhihu.com/question/21923021/answer/281346746</a></p><p>还有这篇对于PMT的解释挺不错的~</p><p><a href="https://www.youtube.com/watch?v=GTJr8OvyEVQ%E8%BF%99%E4%B8%AA%E8%A7%86%E9%A2%91%E8%BF%98%E4%B8%8D%E9%94%99">https://www.youtube.com/watch?v=GTJr8OvyEVQ这个视频还不错</a></p><p><a href="https://blog.csdn.net/starstar1992/article/details/54913261">https://blog.csdn.net/starstar1992/article/details/54913261</a> 600多赞的博客</p><h3 id="关于实现"><a class="header-anchor" href="#关于实现">¶</a>关于实现</h3><ul><li>Youtube的Tusha的</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">computePrefix</span><span class="params">(<span class="built_in">string</span> pat)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> m = pat.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">longestPrefix</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt; m; i++){</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; pat[k] != pat[i]){</span><br><span class="line">            k = longestPrefix[k - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pat[i] == pat[k]){</span><br><span class="line">            longestPrefix[i] = ++k;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            longestPrefix[i] = k;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> longestPrefix;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> str,<span class="built_in">string</span> pat)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m = pat.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; longestPrefix = computePrefix(pat);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; pat[k] != str[i]){</span><br><span class="line">            k = longestPrefix[k - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(str[i] == pat[k]){</span><br><span class="line">            k++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(k == m){</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i - m + <span class="number">1</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">            k = longestPrefix[k - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>根据这个算法，实践一下——如何计算PMT：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210418202513307.png" alt="image-20210418202513307" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210418202623962.png" alt="image-20210418202623962" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210418202733113.png" alt="image-20210418202733113" loading="lazy"></p><p>接下来，操作一下KMP算法：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210418205613508.png" alt="image-20210418205613508" loading="lazy"></p><p><img src="C:%5CUsers%5C10437%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210418205702043.png" alt="image-20210418205702043" loading="lazy"></p><p><img src="C:%5CUsers%5C10437%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210418205710647.png" alt="image-20210418205710647" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210418205737718.png" alt="image-20210418205737718" loading="lazy"></p><h2 id="Number-Sequence"><a class="header-anchor" href="#Number-Sequence">¶</a>Number Sequence</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1711">http://acm.hdu.edu.cn/showproblem.php?pid=1711</a></p><h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>有a，b两个数组里面存了数，a是被匹配的，b是模式，只要找到第一个匹配处就可以了，如果没有匹配就输出-1</p><p>歪个楼……我终于知道怎么多行缩进了……就是选中多行再按TAB啊！！！</p><h3 id="错误"><a class="header-anchor" href="#错误">¶</a>错误</h3><p>第一次交出现了Runtime Error(ACCESS_VIOLATION)的提示……</p><p>可能是哪里越界了？</p><p>好的，注意到了题目里面的数字范围，改了一下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">computePMT</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pat,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>{</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">PMT</span><span class="params">(m)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>,k=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">while</span>(k&gt;<span class="number">0</span>&amp;&amp;pat[i]!=pat[k]){</span><br><span class="line">k=PMT[k<span class="number">-1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pat[i]==pat[k]){</span><br><span class="line">PMT[i]=k+<span class="number">1</span>;</span><br><span class="line">k++;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">PMT[i]=k;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> PMT;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pat,<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; PMT)</span></span>{</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> index=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>,k=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">while</span>(k&gt;<span class="number">0</span>&amp;&amp;str[i]!=pat[k]){</span><br><span class="line">k=PMT[k<span class="number">-1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str[i]==pat[k]){</span><br><span class="line">k++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k==m){<span class="comment">//如果k在模式串的最右端了 </span></span><br><span class="line">index=i-m+<span class="number">2</span>;<span class="comment">//本来是+1的，但是这道题的索引是从1开始的 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;index&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">k=PMT[k<span class="number">-1</span>];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(index==<span class="number">-1</span>){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--){</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">str</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">pat</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">str[i]=temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">pat[i]=temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; PMT;</span><br><span class="line">PMT=computePMT(pat,m);</span><br><span class="line">KMP(str,pat,n,m,PMT);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后由于用了太多vector，被制裁了——Memory Limit Exceeded</p><p>改了str和pat的vector，然而又出问题了……</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 10001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">computePMT</span><span class="params">(<span class="built_in">string</span>* pat,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>{</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">PMT</span><span class="params">(m)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>,k=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">while</span>(k&gt;<span class="number">0</span>&amp;&amp;pat[i]!=pat[k]){</span><br><span class="line">k=PMT[k<span class="number">-1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pat[i]==pat[k]){</span><br><span class="line">PMT[i]=k+<span class="number">1</span>;</span><br><span class="line">k++;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">PMT[i]=k;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> PMT;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span>* str,<span class="built_in">string</span>* pat,<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; PMT)</span></span>{</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> index=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>,k=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">while</span>(k&gt;<span class="number">0</span>&amp;&amp;str[i]!=pat[k]){</span><br><span class="line">k=PMT[k<span class="number">-1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str[i]==pat[k]){</span><br><span class="line">k++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k==m){<span class="comment">//如果k在模式串的最右端了 </span></span><br><span class="line">index=i-m+<span class="number">2</span>;<span class="comment">//本来是+1的，但是这道题的索引是从1开始的 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;index&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">k=PMT[k<span class="number">-1</span>];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(index==<span class="number">-1</span>){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--){</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">string</span> str[MAX_N];</span><br><span class="line"><span class="built_in">string</span> pat[MAX_M];</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">str[i]=temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">pat[i]=temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; PMT;</span><br><span class="line">PMT=computePMT(pat,m);</span><br><span class="line">KMP(str,pat,n,m,PMT);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调试了发现又是这个常见的老问题：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210418224251946.png" alt="image-20210418224251946" style="width:50%;" loading="lazy"><p>下了一下断点，发现一开始甚至没输入数据就报了这个错……</p><p>所以……</p><hr><p>咱们还是看题解对比一下吧</p><h3 id="学习"><a class="header-anchor" href="#学习">¶</a>学习</h3><p>关于C++中数据类型范围的那些事：</p><p>惭愧啊……我一直以为int只能表示到65536，这是什么错到离谱的印象啊</p><p>看到题目里写的<code> (1 &lt;= M &lt;= 10000, 1 &lt;= N &lt;= 1000000)</code>，居然开了long long</p><p>难怪编译器不干了</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210418225817613.png" alt="image-20210418225817613" loading="lazy"></p><p>所以，int的左右是21亿，2*(10^9)</p><p>long int好像是8个字节……</p><p>总结来说，这道题int完全够用啊！</p><hr><p>hai，改了数据类型还是错</p><p>直接看书上题解吧</p><hr><p>啊！！！过了！！！</p><p>有一个关键是，只输出第一个匹配处的索引！！！</p><p>太开心了</p><p>这是迄今为止最来之不易的AC！<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f600.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f600.png?v8">😀</span></p><h2 id="Oulipo"><a class="header-anchor" href="#Oulipo">¶</a>Oulipo</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1686">http://acm.hdu.edu.cn/showproblem.php?pid=1686</a></p><h3 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h3><p>一个法国作家写了一本书，书中没有e，他是Oulipo团体的一员，书中的一句话是：</p><p>balblabla</p><p>这个作家参加一个比赛，比赛要求人们对于某个主题写一段话，尽量少地出现某个词。</p><p>我们的任务是计算一段话里面出现一个词的次数，从而求得参赛者的排名</p><p>参赛者常常会写出没有意义的长文本：可能会有500000个连续的T，他们从来不用空格</p><p>所以我们想找出某个词在一段话中出现的频率，更形式化的描述：</p><p>给一个字母表{A,B,…,Z}，以及两个有限的字符串（由字母表中的字符组成）——一个是word W，另一个是text T。求出W在T中出现的次数</p><hr><p>其实就是KMP之类的啦……只是不是输出位置，而是计数总次数</p><p>哈哈哈哈一发AC！</p><h2 id="字符串匹配（有点难，暂留）"><a class="header-anchor" href="#字符串匹配（有点难，暂留）">¶</a>字符串匹配（有点难，暂留）</h2><p><a href="https://www.nowcoder.com/practice/fbdc522ef958455687654b38a4ca01e0?tpId=66&amp;tqId=29633&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F1004&amp;qru=%2Fta%2Fbuaa-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/fbdc522ef958455687654b38a4ca01e0?tpId=66&amp;tqId=29633&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F1004&amp;qru=%2Fta%2Fbuaa-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><p>注意几个点：</p><ul><li>中括号的规定</li><li>输出格式</li><li>不区分大小写</li></ul><h3 id="思路"><a class="header-anchor" href="#思路">¶</a>思路</h3><p>首先把最后那个可能带中括号的字符串转换成多个字符串，作为被匹配的</p><h3 id="错误-v2"><a class="header-anchor" href="#错误-v2">¶</a>错误</h3><p>我说怎么过不了……原来是不能写find，应该写str.find！</p><h3 id="学习-v2"><a class="header-anchor" href="#学习-v2">¶</a>学习</h3><p>学学string的replace函数</p><p>一个迷惑的错误：<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210419114953438.png" alt="image-20210419114953438" style="width:70%" loading="lazy"></p><p>这绝对是我遇到过最神奇的bug……</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210419115522827.png" alt="image-20210419115522827" style="width:67%;" loading="lazy"><p>这样就是对的，原来是错在不能写’a’，要写"a"……</p><p>略略迷惑</p><p>那么学习一下：c++中char转string</p><p><a href="https://blog.csdn.net/carbon06/article/details/79353821">https://blog.csdn.net/carbon06/article/details/79353821</a></p><hr><p>呜呜呜快疯了，改了好久都没改好</p><p>看看书吧</p><hr><p>看了讨论区才发现，这道题还是有挺多坑的……不论是自己的操作还是题面的不清晰……</p><h2 id="String-Matching"><a class="header-anchor" href="#String-Matching">¶</a>String Matching</h2><p><a href="https://www.nowcoder.com/practice/00438b0bc9384ceeb65613346b42e88a?tpId=62&amp;tqId=29448&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F2002&amp;qru=%2Fta%2Fsju-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/00438b0bc9384ceeb65613346b42e88a?tpId=62&amp;tqId=29448&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F2002&amp;qru=%2Fta%2Fsju-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><h3 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h3><p>在一个text中找出一个pattern的所有出现。假设text是长度为n的数组，pattern是长度为m的数组。在假设P和T的元素都是来自字母表。</p><p>有一种说法：模式P在textT中以shiftS出现：当…</p><p>总结来说就是统计一个模式在字符串中的出现次数</p><p>题目说n和m都不会超过1000000，所以开大数组吧</p><hr><p>好耶！一遍过！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小可的机试练习日记Day7-字符串2</title>
      <link href="2021/04/15/%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0Day7-%E5%AD%97%E7%AC%A6%E4%B8%B22/"/>
      <url>2021/04/15/%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0Day7-%E5%AD%97%E7%AC%A6%E4%B8%B22/</url>
      
        <content type="html"><![CDATA[<h2 id="skew数"><a class="header-anchor" href="#skew数">¶</a>skew数</h2><p><a href="https://www.nowcoder.com/practice/5928127cc6604129923346e955e75984?tpId=61&amp;tqId=29517&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F1002&amp;qru=%2Fta%2Fpku-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/5928127cc6604129923346e955e75984?tpId=61&amp;tqId=29517&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F1002&amp;qru=%2Fta%2Fpku-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><p>就这？简单简单~</p><h2 id="单词替换"><a class="header-anchor" href="#单词替换">¶</a>单词替换</h2><p><a href="https://www.nowcoder.com/practice/5b58a04679d5419caf62c2b238e5c9c7?tpId=61&amp;tqId=29518&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F1002&amp;qru=%2Fta%2Fpku-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/5b58a04679d5419caf62c2b238e5c9c7?tpId=61&amp;tqId=29518&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F1002&amp;qru=%2Fta%2Fpku-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><p>有点神奇，感觉gets反而不好用了，不如把单词分开存储</p><p>我悟了……北大的题都是看起来简单，做起来难/有坑的……</p><hr><p>看讨论学习一下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRA <span class="meta-string">"CCCCCC III A BBB CCCCCC AAAA III CCCCCC A AAAA CCCC CCC AAAA gold white CC white A BBB AAAA"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>], a[<span class="number">100</span>], b[<span class="number">100</span>], *t;</span><br><span class="line">    gets(s);  gets(a);  gets(b);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(b, <span class="string">"white"</span>))   <span class="comment">// 单独讨论一下问题case</span></span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">printf</span>(WRA);</span><br><span class="line">    t = strtok(s, <span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="built_in">strcmp</span>(t, a)? <span class="built_in">printf</span>(t): <span class="built_in">printf</span>(b);   <span class="comment">// 如果串t和串a不同，原样输出，否则输出串b</span></span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">    } <span class="keyword">while</span> (t = strtok(<span class="literal">NULL</span>, <span class="string">" "</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>太简约太优雅了……</p><p>C++的：(这个更符合我的风格)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">string</span> sentence;<span class="comment">//保存句子 </span></span><br><span class="line">    <span class="built_in">string</span> a;<span class="comment">//被替换的单词 </span></span><br><span class="line">    <span class="built_in">string</span> b;<span class="comment">//用来替换的单词 </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words;<span class="comment">//保存句子中的单词</span></span><br><span class="line">    words.push_back(<span class="string">""</span>);</span><br><span class="line">    getline(<span class="built_in">cin</span>, sentence);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(sentence == <span class="string">"CCCCCC III A BBB CCCCCC AAAA III CCCCCC A AAAA CCCC CCC AAAA gold CC CC CC A BBB AAAA"</span>)</span><br><span class="line">    {<span class="comment">//为了ac而加的一句。。。</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"CCCCCC III A BBB CCCCCC AAAA III CCCCCC A AAAA CCCC CCC AAAA gold white CC white A BBB AAAA"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; sentence.length(); i++)</span><br><span class="line">    {<span class="comment">//将句子分割为单词，存入words中 </span></span><br><span class="line">        <span class="keyword">if</span>(sentence[i] != <span class="string">' '</span>)</span><br><span class="line">            words[j] += sentence[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            words.push_back(<span class="string">""</span>);</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">            </span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//依次将words中的单词与a做比较，若相同，则替换为b</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(words[i] == a)</span><br><span class="line">            words[i] = b;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; words[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; words[words.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>好的，大概吸取了思想……</p><p>首先简单读入句子</p><p>然后把句子分割成单词</p><p>LEVEL UP！</p><h2 id="首字母大写"><a class="header-anchor" href="#首字母大写">¶</a>首字母大写</h2><p><a href="https://www.nowcoder.com/practice/91f9c70e7b6f4c0ab23744055632467a?tpId=61&amp;tqId=29529&amp;tPage=2&amp;ru=/kaoyan/retest/1002&amp;qru=/ta/pku-kaoyan/question-ranking">https://www.nowcoder.com/practice/91f9c70e7b6f4c0ab23744055632467a?tpId=61&amp;tqId=29529&amp;tPage=2&amp;ru=/kaoyan/retest/1002&amp;qru=/ta/pku-kaoyan/question-ranking</a></p><p>按照题意来，一下就过了</p><p>学会了getline还是挺舒服的</p><h2 id="浮点数加法（有点难）"><a class="header-anchor" href="#浮点数加法（有点难）">¶</a>浮点数加法（有点难）</h2><p><a href="https://www.nowcoder.com/practice/ddec753f446e4ba4944e35378ba635c8?tpId=61&amp;tqId=29551&amp;tPage=3&amp;ru=/kaoyan/retest/1002&amp;qru=/ta/pku-kaoyan/question-ranking">https://www.nowcoder.com/practice/ddec753f446e4ba4944e35378ba635c8?tpId=61&amp;tqId=29551&amp;tPage=3&amp;ru=/kaoyan/retest/1002&amp;qru=/ta/pku-kaoyan/question-ranking</a></p><p>woc，这道题涉及大数处理啊</p><p>是不是还要管进位？看了讨论区，好像是有点复杂qwq，回去再研究一下</p><h3 id="学习"><a class="header-anchor" href="#学习">¶</a>学习</h3><ul><li><p>STL的find函数</p><p><a href="http://www.cplusplus.com/reference/string/string/find/">http://www.cplusplus.com/reference/string/string/find/</a></p></li><li><p>用carry表示进位</p></li><li><p>初始化带长度的string：<code>std::string s6 (10, 'x');</code></p></li></ul><p>哈哈哈哈过了，我真是太聪明了！</p><h2 id="后缀子串排序"><a class="header-anchor" href="#后缀子串排序">¶</a>后缀子串排序</h2><p><a href="https://www.nowcoder.com/practice/f89f96ea3145418b8e6c3eb75773f65a?tpId=62&amp;tqId=29472&amp;tPage=2&amp;ru=%2Fkaoyan%2Fretest%2F2002&amp;qru=%2Fta%2Fsju-kaoyan%2Fquestion-ranking&amp;tab=answerKey://1t.click/VGP">https://www.nowcoder.com/practice/f89f96ea3145418b8e6c3eb75773f65a?tpId=62&amp;tqId=29472&amp;tPage=2&amp;ru=%2Fkaoyan%2Fretest%2F2002&amp;qru=%2Fta%2Fsju-kaoyan%2Fquestion-ranking&amp;tab=answerKey://1t.click/VGP</a></p><p>书上的链接有点点奇怪qwq</p><p>不过题目很简单嘿嘿嘿~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小可的机试练习日记Day6-字符串</title>
      <link href="2021/04/14/%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0Day6-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2021/04/14/%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0Day6-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="特殊乘法"><a class="header-anchor" href="#特殊乘法">¶</a>特殊乘法</h2><p><a href="https://www.nowcoder.com/practice/a5edebf0622045468436c74c3a34240f?tpId=60&amp;tqId=29490&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F1001&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/a5edebf0622045468436c74c3a34240f?tpId=60&amp;tqId=29490&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F1001&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><p>没想到啊，一个看似简单的问题……</p><p>居然把我卡了这么久……</p><p>一直错</p><p>晚上可能脑子不清楚，明天起来拿iPad打草稿看看</p><hr><p>打草稿算是清楚一点了</p><p>不过又出现了新的问题：字符串没清空</p><p><a href="https://blog.csdn.net/DONOT_WORRY_BE_HAPPY/article/details/80780398">https://blog.csdn.net/DONOT_WORRY_BE_HAPPY/article/details/80780398</a></p><p>学习一下</p><p>另外：我是怎么发现这个问题的呢？因为测试顺序不同结果不同，第一个测试的总是对的，所以我觉得可能后面的是受影响了</p><h3 id="错误"><a class="header-anchor" href="#错误">¶</a>错误</h3><ul><li><p>只过了三组样例的：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辗转相除法求最大公约数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line"><span class="keyword">int</span> larger=<span class="built_in">max</span>(a,b);</span><br><span class="line"><span class="keyword">int</span> smaller=<span class="built_in">min</span>(a,b);</span><br><span class="line"><span class="keyword">if</span>(larger%smaller==<span class="number">0</span>){</span><br><span class="line"><span class="keyword">return</span> smaller;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> gcd(smaller,larger%smaller);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line"><span class="keyword">return</span> a*b/gcd(a,b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="built_in">string</span> str1,str2;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str1&gt;&gt;str2){</span><br><span class="line"><span class="keyword">int</span> len1=str1.length();</span><br><span class="line"><span class="keyword">int</span> len2=str2.length();</span><br><span class="line"><span class="keyword">int</span> total_length=lcm(len1,len2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> num1[total_length],num2[total_length];</span><br><span class="line"><span class="keyword">int</span> times1=total_length/len1;</span><br><span class="line"><span class="keyword">int</span> times2=total_length/len2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i*times1;j&lt;(i+<span class="number">1</span>)*times1;j++){</span><br><span class="line">num1[j]=str1[i];</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total_length;i++){</span><br><span class="line">num2[i]=str2[i%len2];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total_length;i++){</span><br><span class="line"><span class="keyword">int</span> n1=num1[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">int</span> n2=num2[i]-<span class="string">'0'</span>;</span><br><span class="line">sum+=n1*n2;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">str1.<span class="built_in">clear</span>();</span><br><span class="line">str2.<span class="built_in">clear</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输入：600154635 295150688</p><p>正确输出应该是1320</p><p>但是程序输出了138</p></li></ul><hr><p>原来是我理解错题意了……</p><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span></p><p>taiganle</p><p>题意是，第一个数字的每一位去乘第二个数字的每一位……</p><p>而不是什么复杂的填充</p><p>靠……</p><p>这题目出得就有问题</p><h2 id="密码翻译"><a class="header-anchor" href="#密码翻译">¶</a>密码翻译</h2><p><a href="https://www.nowcoder.com/practice/136de4a719954361a8e9e41c8c4ad855?tpId=61&amp;tqId=29505&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F1002&amp;qru=%2Fta%2Fpku-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/136de4a719954361a8e9e41c8c4ad855?tpId=61&amp;tqId=29505&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F1002&amp;qru=%2Fta%2Fpku-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><p>发现一个问题，用string读入的话，遇到空格就自动断开了</p><hr><p>评论区发现一句话：</p><blockquote><p>//这个题有点问题 题目给的样例中第一行是一个数字，但是输出却没处理数字 我以为是表示要输入的数据规模，结果怎么搞都是运行时间超过限制,题目的测试案例应该是一行行的字符串 根本没数据规模的数字</p></blockquote><p>呜呜呜</p><p>这题目搞我</p><h3 id="错误-v2"><a class="header-anchor" href="#错误-v2">¶</a>错误</h3><ul><li><p>下面这个，好像一直让输入，while的条件不起作用……</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">char</span> temp;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; str;</span><br><span class="line"><span class="keyword">while</span>(temp!=<span class="string">'\n'</span>){</span><br><span class="line">str.push_back(temp);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Next"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++){</span><br><span class="line"><span class="keyword">if</span>(str[i]&gt;=<span class="string">'a'</span>&amp;&amp;str[i]&lt;=<span class="string">'z'</span>){</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">'z'</span>){</span><br><span class="line">str[i]=<span class="string">'a'</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">str[i]+=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(str[i]&gt;=<span class="string">'A'</span>&amp;&amp;str[i]&lt;=<span class="string">'Z'</span>){</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">'Z'</span>){</span><br><span class="line">str[i]=<span class="string">'A'</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">str[i]+=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str[i]; </span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3><p>终于过了……</p><p>注意这个gets和puts的神奇用法</p><p>还是要用c的头文件，注意提交的时候选好编译器</p><h2 id="简单密码"><a class="header-anchor" href="#简单密码">¶</a>简单密码</h2><p><a href="http://t.cn/Ai8bih2z">http://t.cn/Ai8bih2z</a></p><p>感觉要记一下ASCII码了</p><p>A=65，a=97</p><h3 id="学习"><a class="header-anchor" href="#学习">¶</a>学习</h3><p>我觉得我有必要整理一下字符串的读入了……</p><ul><li>getline</li><li>gets</li><li>cin&gt;&gt;</li><li>scanf</li></ul><p><a href="https://blog.csdn.net/niushuai666/article/details/6410239?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-2.control&amp;dist_request_id=1331645.22331.16184797700217959&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-2.control">https://blog.csdn.net/niushuai666/article/details/6410239?utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-2.control&amp;dist_request_id=1331645.22331.16184797700217959&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-2.control</a></p><p>这篇还不错</p><h3 id="错误-v3"><a class="header-anchor" href="#错误-v3">¶</a>错误</h3><p>啊……终于知道自己错在哪了</p><p>就很神奇</p><p>只能写strcmp，不能直接==</p><p>错误的程序：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cmd==<span class="string">"START"</span>){</span><br><span class="line"><span class="keyword">char</span> cipher[N];</span><br><span class="line">gets(cipher);</span><br><span class="line"><span class="built_in">puts</span>(cipher);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(cipher);i++){</span><br><span class="line"><span class="keyword">if</span>(cipher[i]&gt;=<span class="string">'F'</span>&amp;&amp;cipher[i]&lt;=<span class="string">'Z'</span>){</span><br><span class="line">cipher[i]-=<span class="number">5</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">cipher[i]+=<span class="number">21</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(cipher);</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(cmd==<span class="string">"END"</span>){</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(cmd==<span class="string">"ENDOFINPUT"</span>){</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正确的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">"START"</span>)==<span class="number">0</span>){</span><br><span class="line"><span class="keyword">char</span> cipher[N];</span><br><span class="line">gets(cipher);</span><br><span class="line"><span class="built_in">puts</span>(cipher);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(cipher);i++){</span><br><span class="line"><span class="keyword">if</span>(cipher[i]&gt;=<span class="string">'F'</span>&amp;&amp;cipher[i]&lt;=<span class="string">'Z'</span>){</span><br><span class="line">cipher[i]-=<span class="number">5</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">cipher[i]+=<span class="number">21</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(cipher);</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">"END"</span>)==<span class="number">0</span>){</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">"ENDOFINPUT"</span>)==<span class="number">0</span>){</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="统计字符"><a class="header-anchor" href="#统计字符">¶</a>统计字符</h2><h3 id="错误-v4"><a class="header-anchor" href="#错误-v4">¶</a>错误</h3><p>奇怪的错误出现了：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210415184550774.png" alt="image-20210415184550774" loading="lazy"></p><p>知道为什么了……</p><p>两个字符比较可以用==啊，用strcmp反而是错的</p><ul><li>超时</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N1 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N2 80</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">char</span> search[N1],str[N2];</span><br><span class="line">gets(search);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">strcmp</span>(search,<span class="string">"#"</span>)!=<span class="number">0</span>){</span><br><span class="line">gets(str);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(search);i++){</span><br><span class="line"><span class="keyword">char</span> ch=search[i];</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(str);j++){</span><br><span class="line"><span class="keyword">if</span>(ch==str[j]){</span><br><span class="line">count++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c %d\n"</span>,ch,count);</span><br><span class="line">}</span><br><span class="line">gets(search);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>超时了……</p><p>看了下评论区，应该不是算法的问题，应该读取字符串中超时了，由于一些语句操作不当，卡住了什么的</p><p>改了下，过了的版本长这样：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N1 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N2 80</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">char</span> search[N1],str[N2];</span><br><span class="line"><span class="keyword">while</span>(gets(search)){</span><br><span class="line"><span class="keyword">if</span>(search[<span class="number">0</span>]==<span class="string">'#'</span>){</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"></span><br><span class="line">gets(str);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(search);i++){</span><br><span class="line"><span class="keyword">char</span> ch=search[i];</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(str);j++){</span><br><span class="line"><span class="keyword">if</span>(ch==str[j]){</span><br><span class="line">count++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c %d\n"</span>,ch,count);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>说实话，没明白为什么超时……</p><p>但是以后，如果超时了，就试着换换输入吧……</p><h2 id="字母统计"><a class="header-anchor" href="#字母统计">¶</a>字母统计</h2><p><a href="https://www.nowcoder.com/practice/de7bf0945c1c4bd1aa9d49573b831f3c?tpId=62&amp;tqId=29470&amp;tPage=2&amp;ru=%2Fkaoyan%2Fretest%2F2002&amp;qru=%2Fta%2Fsju-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/de7bf0945c1c4bd1aa9d49573b831f3c?tpId=62&amp;tqId=29470&amp;tPage=2&amp;ru=%2Fkaoyan%2Fretest%2F2002&amp;qru=%2Fta%2Fsju-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><p>哈哈哈，有了前几次摔的坑，这次终于一遍好了qwq</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小可的机试练习日记Day5-查找</title>
      <link href="2021/04/12/%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0Day5-%E6%9F%A5%E6%89%BE/"/>
      <url>2021/04/12/%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0Day5-%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="找x"><a class="header-anchor" href="#找x">¶</a>找x</h2><h3 id="题目"><a class="header-anchor" href="#题目">¶</a>题目</h3><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210412170940126.png" alt="image-20210412170940126" style="width:67%;" loading="lazy"><p>太简单了，代码自己去文件夹找吧</p><h2 id="查找"><a class="header-anchor" href="#查找">¶</a>查找</h2><p><a href="http://t.cn/E9g8aaR">http://t.cn/E9g8aaR</a></p><p>太简单</p><h2 id="找最小数"><a class="header-anchor" href="#找最小数">¶</a>找最小数`</h2><p><a href="http://t.cn/E9gekWa">http://t.cn/E9gekWa</a></p><p>也很简单，注意自己定义compare函数就可以</p><h2 id="打印极值点下标"><a class="header-anchor" href="#打印极值点下标">¶</a>打印极值点下标</h2><p><a href="http://t.cn/E9ehDw4">http://t.cn/E9ehDw4</a></p><p>思路：暴力的话，对于每个点向左向右看</p><p>太暴力了……暴力了两百多行，自己懒得改了……</p><p>重开吧<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span></p><hr><p>啊！原来是我理解错题意了！！</p><p>相邻指的是左右两个而已啊！</p><h2 id="找位置"><a class="header-anchor" href="#找位置">¶</a>找位置</h2><p><a href="https://www.nowcoder.com/practice/e3b2cc44aa9b4851bdca89dd79c53150?tpId=40&amp;tqId=21560&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/e3b2cc44aa9b4851bdca89dd79c53150?tpId=40&amp;tqId=21560&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p><h3 id="学习"><a class="header-anchor" href="#学习">¶</a>学习</h3><p>学一下find函数的用法</p><blockquote><p>find() 函数本质上是一个模板函数，用于在指定范围内查找和目标元素值相等的第一个元素。</p></blockquote><p>注意是第一个</p><p><a href="http://c.biancheng.net/view/7489.html">http://c.biancheng.net/view/7489.html</a></p><p>还有map的用法</p><p><a href="https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html">https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html</a></p><p>还有pair的用法</p><p><a href="https://blog.csdn.net/sevenjoin/article/details/81937695">https://blog.csdn.net/sevenjoin/article/details/81937695</a></p><p>还有queue（STL)：</p><hr><p>过了，完美，可以睡觉了</p><p>其实虽然看起来简单，但是字符串处理还是要点心思的</p><p>用到的数据结构、变量，都和我的第一直觉有所区别</p><p>也是在一遍遍的迭代中才得到比较好的思路的</p><p>所以说，不要怕错，要用于尝试，脑子转的快的话，一下揪出来了正确思路</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Day3-小可的CCF备战日记-开启图之旅</title>
      <link href="2021/04/09/Day3-%E5%B0%8F%E5%8F%AF%E7%9A%84CCF%E5%A4%87%E6%88%98%E6%97%A5%E8%AE%B0-%E5%BC%80%E5%90%AF%E5%9B%BE%E4%B9%8B%E6%97%85/"/>
      <url>2021/04/09/Day3-%E5%B0%8F%E5%8F%AF%E7%9A%84CCF%E5%A4%87%E6%88%98%E6%97%A5%E8%AE%B0-%E5%BC%80%E5%90%AF%E5%9B%BE%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<h2 id="2012-4"><a class="header-anchor" href="#2012-4">¶</a>2012-4</h2><p>食材运输这道题还是难得我毫无头绪……</p><p>所以网上搜了一下，果然有好多我不懂的词</p><p>比如状态压缩啊什么的……</p><hr><p>稍微学一下偏骗技巧吧！（做一部分题</p><p>这是这道题的一些题解：</p><p><a href="https://leetcode-cn.com/circle/discuss/aMnV0M/">https://leetcode-cn.com/circle/discuss/aMnV0M/</a></p><p><a href="https://blog.csdn.net/weixin_44627639/article/details/115052571?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control">https://blog.csdn.net/weixin_44627639/article/details/115052571?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control</a></p><p><a href="https://blog.csdn.net/qq_41730604/article/details/112150614">https://blog.csdn.net/qq_41730604/article/details/112150614</a></p><p>发现一个还挺有用的东西：CCF历年第四题的知识点：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210410145155928.png" alt="image-20210410145155928" style="width:67%;"><p>前几年还好，最近几年太变态了……</p><h3 id="学习"><a class="header-anchor" href="#学习">¶</a>学习</h3><ul><li><p>树状dp、状压dp</p><p>发现一个很不错的网站：oi-wikihttps://oi-wiki.org/dp/state/</p></li></ul><h2 id="2012-3"><a class="header-anchor" href="#2012-3">¶</a>2012-3</h2><p><a href="https://blog.csdn.net/qq_41730604/article/details/112297998?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control">https://blog.csdn.net/qq_41730604/article/details/112297998?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control</a></p><p>这么长的题解，害怕<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f628.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f628.png?v8">😨</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSP认证 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Day2-小可的CCF备战日记</title>
      <link href="2021/04/08/Day2-%E5%B0%8F%E5%8F%AF%E7%9A%84CCF%E5%A4%87%E6%88%98%E6%97%A5%E8%AE%B0/"/>
      <url>2021/04/08/Day2-%E5%B0%8F%E5%8F%AF%E7%9A%84CCF%E5%A4%87%E6%88%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1903-2"><a class="header-anchor" href="#1903-2">¶</a>1903-2</h2><ul><li><p>分析：</p><p>其实就是实现有运算符优先级的四则运算</p><p>有点想用stack，遇到乘号就pop，push结果</p><p>好像又有点不对……</p></li><li><p>学习：</p><p>想想还是学习一下https://www.geek-share.com/detail/2794345166.html</p><p>先把中缀表达式改成后缀，再用逆波兰算后缀？</p><p>遇到一个问题：怎么比较优雅地描述运算符的优先级</p><p>在上面的帖子里我学到的是给运算符编号</p><p>居然没有现成的清空stack的函数，只能搞个while循环了</p><p>转成后缀以后，用逆波兰来算：<a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">https://zh.wikipedia.org/wiki/逆波兰表示法</a></p></li><li><p>错误：</p><ul><li>记录一个神奇的错误：</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210409004823996.png" alt="image-20210409004823996"></p><p>这里好像空栈不能调用top？</p><ul><li><p>过了样例但只有70分</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ASCII码：+是43，-是45，x是120，/是47 </span></span><br><span class="line"><span class="comment">//优先级大小和ASCII码大小好像…… </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_prior</span><span class="params">(<span class="keyword">char</span> c)</span></span>{</span><br><span class="line"><span class="keyword">switch</span>(c){</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:<span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'x'</span>:<span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line"><span class="keyword">char</span> reverse[n][<span class="number">7</span>];</span><br><span class="line"><span class="keyword">char</span> middle[n][<span class="number">7</span>];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; transform;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; calc; </span><br><span class="line"></span><br><span class="line"><span class="comment">//先读进字符数组里面吧 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;middle[i][<span class="number">0</span>]&gt;&gt;middle[i][<span class="number">1</span>]&gt;&gt;middle[i][<span class="number">2</span>]&gt;&gt;middle[i][<span class="number">3</span>]&gt;&gt;middle[i][<span class="number">4</span>]&gt;&gt;middle[i][<span class="number">5</span>]&gt;&gt;middle[i][<span class="number">6</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//中缀转后缀 </span></span><br><span class="line"><span class="keyword">char</span> temp,top_op;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//每处理一行表达式，都要清空transform栈，因为它只是处理运算符的中转站</span></span><br><span class="line"><span class="comment">//但是仔细一想，好像每次处理完都会全部弹出去了？ </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">7</span>;j++){</span><br><span class="line">temp=middle[i][j];</span><br><span class="line"><span class="keyword">if</span>(temp&gt;=<span class="number">48</span>&amp;&amp;temp&lt;=<span class="number">57</span>){<span class="comment">//是操作数的话，直接存到后缀表达式的字符数组里面 </span></span><br><span class="line">reverse[i][k++]=temp;</span><br><span class="line">}<span class="keyword">else</span>{<span class="comment">//如果是操作符 </span></span><br><span class="line"> <span class="keyword">if</span>(transform.empty()){<span class="comment">//栈为空可以直接压栈 </span></span><br><span class="line"> transform.push(temp);</span><br><span class="line"> }<span class="keyword">else</span>{<span class="comment">//栈不空就比较优先级 </span></span><br><span class="line"> top_op=transform.top();<span class="comment">//获取栈顶运算符</span></span><br><span class="line"><span class="keyword">if</span>(get_prior(temp)&gt;get_prior(top_op)){</span><br><span class="line">transform.push(temp);</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">while</span>(get_prior(top_op)&gt;=get_prior(temp)&amp;&amp;(!transform.empty())){</span><br><span class="line">reverse[i][k++]=transform.top();</span><br><span class="line">transform.pop();</span><br><span class="line"><span class="keyword">if</span>(transform.empty()){</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//栈空了就直接退出while </span></span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">top_op=transform.top();</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line">transform.push(temp);</span><br><span class="line">}</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//各字符处理完毕，栈中剩余的运算符直接出栈 </span></span><br><span class="line"><span class="keyword">while</span>(!transform.empty()){</span><br><span class="line">reverse[i][k++]=transform.top();</span><br><span class="line">transform.pop(); </span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//后缀运算，把每个表达式利用calc来做计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">7</span>;j++){</span><br><span class="line">temp=reverse[i][j];</span><br><span class="line"><span class="keyword">if</span>(temp&gt;=<span class="number">48</span>&amp;&amp;temp&lt;=<span class="number">57</span>){</span><br><span class="line">calc.push(temp);</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">int</span> op2=calc.top()<span class="number">-48</span>;</span><br><span class="line">calc.pop();</span><br><span class="line"><span class="keyword">int</span> op1=calc.top()<span class="number">-48</span>;</span><br><span class="line">calc.pop();</span><br><span class="line"><span class="keyword">switch</span>(temp){</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">calc.push(op1+op2+<span class="string">'0'</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">calc.push(op1-op2+<span class="string">'0'</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'x'</span>:</span><br><span class="line">calc.push(op1*op2+<span class="string">'0'</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">calc.push(op1/op2+<span class="string">'0'</span>);<span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//看结果是否等于24 </span></span><br><span class="line"><span class="keyword">if</span>(calc.top()<span class="number">-48</span>==<span class="number">24</span>){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>1551实在想不出哪里错了</p><p>明天网上找一下吧</p><hr><p><a href="https://zhuanlan.zhihu.com/p/74893803">https://zhuanlan.zhihu.com/p/74893803</a></p><p>↑我觉得我的问题可能是这个……</p><hr><p>除此之外，我发现网上的题解好简单啊qwq</p><p><a href="https://blog.csdn.net/richenyunqi/article/details/89188626">https://blog.csdn.net/richenyunqi/article/details/89188626</a></p><p><a href="https://cloud.tencent.com/developer/article/1535695">https://cloud.tencent.com/developer/article/1535695</a></p><p><a href="https://blog.siriyang.cn/posts/20191231211726id.html">https://blog.siriyang.cn/posts/20191231211726id.html</a></p><hr><p>果然！！！！！就是char栈溢出什么的</p><p>100分，好开心<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSP认证 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Day1 小可的CCF备战日记</title>
      <link href="2021/03/24/Day1-%E5%B0%8F%E5%8F%AF%E7%9A%84CCF%E5%A4%87%E6%88%98%E6%97%A5%E8%AE%B0/"/>
      <url>2021/03/24/Day1-%E5%B0%8F%E5%8F%AF%E7%9A%84CCF%E5%A4%87%E6%88%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="2006-2"><a class="header-anchor" href="#2006-2">¶</a>2006-2</h2><h3 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h3><ul><li>向量维数下标从1开始</li></ul><h3 id="错误"><a class="header-anchor" href="#错误">¶</a>错误</h3><ul><li><p>第一遍，华丽丽的超时……30分</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> n,a,b;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b){</span><br><span class="line"><span class="keyword">int</span> v1[a][<span class="number">2</span>],v2[b][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;v1[i][<span class="number">0</span>]&gt;&gt;v1[i][<span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;v2[i][<span class="number">0</span>]&gt;&gt;v2[i][<span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b;j++){</span><br><span class="line"><span class="keyword">if</span>(v1[i][<span class="number">0</span>]==v2[j][<span class="number">0</span>]){</span><br><span class="line">result+=v1[i][<span class="number">1</span>]*v2[j][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>改进思路：</p><ul><li>改用vector，就可以用find试试</li><li>填充完对应相乘（好low</li></ul></li><li><p>第二遍，我想用map，但是出现了非常神奇的错误：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(void){</span><br><span class="line">int n,a,b;</span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;a&gt;&gt;b){</span><br><span class="line">//vector&lt;vector&lt;int&gt; &gt; v1,v2;</span><br><span class="line">//Í»È»¸Ð¾õÓÃmap¸üºÃ</span><br><span class="line">map&lt;int,int&gt; v1,v2;</span><br><span class="line">map&lt;int,int&gt;::iterator it; </span><br><span class="line">int tempk,tempv;</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">for(i=0,it=v1.begin();i&lt;a;i++,it++){</span><br><span class="line">cin&gt;&gt;tempk&gt;&gt;tempv;</span><br><span class="line">it-&gt;first=tempk;</span><br><span class="line">it-&gt;second=tempv; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for(i=0,it=v2.begin();i&lt;b;i++,it++){</span><br><span class="line">cin&gt;&gt;tempk&gt;&gt;tempv;</span><br><span class="line">it-&gt;first=tempk;</span><br><span class="line">it-&gt;second=tempv; </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line">for(int i=0;i&lt;a;i++){</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>[Error] assignment of read-only member 'std::pair&lt;const int, int&gt;::first’</strong></p></li><li><p>第三遍：自己测试答案是对的，但是显示“错误，60分”，我觉得应该是过了6个测试点</p><p>是不是int用错了？</p><p>都改成long，还是错的……</p><p>好家伙，改成long long就对了</p></li></ul><h3 id="学习"><a class="header-anchor" href="#学习">¶</a>学习</h3><p>map的使用：<a href="https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html">https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html</a></p><p>好吧，貌似是我一意孤行用错了哈哈哈</p><h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3><p>有时候居然要用上long long</p><h2 id="1912-2"><a class="header-anchor" href="#1912-2">¶</a>1912-2</h2><p>好累……还是改用STL吧，蹭蹭函数</p><p>突然想到一个思路：bool值 ，将有点的位置布尔值设为true</p><p>好一番挣扎，“错误50分”</p><p>我觉得是后面五个样例的数字太大了，分配数组的时候吃到内存空间了……所以才有段错误</p><p>我感觉得另外写个算法了，从另一个思路：</p><p>n不会超过1000，所以其实点的数量没那么恐怖，反而是点的位置会有上亿的数字</p><p>想到一种方法，给点排个序？这样搜索范围会小很多</p><hr><p>按照上面的说法试了，还是不太行……样例都没过</p><hr><p>直接网上找下答案学习一下~</p><p><a href="https://tigerisland.blog.csdn.net/article/details/104213820?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control&amp;dist_request_id=1328767.72420.16177217915540465&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control">https://tigerisland.blog.csdn.net/article/details/104213820?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control&amp;dist_request_id=1328767.72420.16177217915540465&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CCF201912-2 回收站选址 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p[N];<span class="comment">//p是存点的数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[CN + <span class="number">1</span>];<span class="comment">//算每个分数对应的点的数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; ps;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">        p[i] = <span class="built_in">make_pair</span>(x, y);</span><br><span class="line">        ps[p[i]] = <span class="number">1</span>;<span class="comment">//使用map作为数据结构，key是点，value是</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));<span class="comment">//将cnt数组元素全部置0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">int</span> x = p[i].first;</span><br><span class="line">        <span class="keyword">int</span> y = p[i].second;<span class="comment">//原来pair元素可以这样用~</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ps[<span class="built_in">make_pair</span>(x, y <span class="number">-1</span>)] &amp;&amp; ps[<span class="built_in">make_pair</span>(x, y + <span class="number">1</span>)] &amp;&amp;</span><br><span class="line">                ps[<span class="built_in">make_pair</span>(x - <span class="number">1</span>, y)] &amp;&amp; ps[<span class="built_in">make_pair</span>(x + <span class="number">1</span>, y)])</span><br><span class="line">            cnt[ps[<span class="built_in">make_pair</span>(x - <span class="number">1</span>, y - <span class="number">1</span>)] + ps[<span class="built_in">make_pair</span>(x - <span class="number">1</span>, y + <span class="number">1</span>)] +</span><br><span class="line">                    ps[<span class="built_in">make_pair</span>(x + <span class="number">1</span>, y - <span class="number">1</span>)] + ps[<span class="built_in">make_pair</span>(x + <span class="number">1</span>, y + <span class="number">1</span>)]]++;<span class="comment">//太妙了</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= CN; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">1 0</span></span><br><span class="line"><span class="comment">2 0</span></span><br><span class="line"><span class="comment">0 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">-100000 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">9 10</span></span><br><span class="line"><span class="comment">10 10</span></span><br><span class="line"><span class="comment">11 10</span></span><br><span class="line"><span class="comment">12 10</span></span><br><span class="line"><span class="comment">13 10</span></span><br><span class="line"><span class="comment">11 9</span></span><br><span class="line"><span class="comment">11 8</span></span><br><span class="line"><span class="comment">12 9</span></span><br><span class="line"><span class="comment">10 9</span></span><br><span class="line"><span class="comment">10 11</span></span><br><span class="line"><span class="comment">12 11</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>学习</li></ul><p><a href="https://www.cplusplus.com/reference/cstring/memset/">https://www.cplusplus.com/reference/cstring/memset/</a></p><ul><li><p>总结——这个题解妙在哪里？</p><ul><li>用了map</li><li>用了pair作为数组元素</li><li>if里面的判定一个点是否存在的方式，注意存在的点先赋值为1的这个操作</li></ul></li><li><p>感想</p><p>其实作为第二题，肯定不会太难的，有时候甚至代码都不长……只要思维角度对了</p><p>有几个点值得注意：</p><ul><li><p>选择什么数据结构</p><blockquote><p>坐标值范围比较大，而且坐标有可能是负数，难以用矩阵来存储坐标点，所以使用稀疏矩阵来存储。用STL的map来存储坐标是最为简单的。</p></blockquote></li><li><p>用什么算法，空间换时间很常见</p></li></ul></li></ul><h2 id="1909-2"><a class="header-anchor" href="#1909-2">¶</a>1909-2</h2><ul><li><p>分析</p><p>根据题目描述，苹果树围成一个圆，这很符合循环链表的用法啊</p><p>（默默吐槽一句，ccf真的很擅长把简单的叙述用复杂的公式写出来吓人qwq）</p><p>T：我觉得可以倒着看每棵树的数据</p><p>D和E可以一起考虑，我们不仅需要知道有多少，还需要知道是哪些</p><p>所以是否可以把苹果是否掉落记在结构体里面？</p></li><li><p>学习-STL list</p><p><a href="http://c.biancheng.net/view/6892.html">http://c.biancheng.net/view/6892.html</a></p></li></ul><p>哈哈哈最后循环链表也没用，list也没用，但还是过了</p><p>有的时候运行不出来可能是卡在哪里了，比如这次很蠢地写出了<code>cin&gt;&gt;tree[N][i]</code>的下饭操作……</p><p>以及忘记在for循环里面加上j++</p><p>总之还是快乐地一遍过了！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSP认证 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小可的机试练习日记Day4-排序</title>
      <link href="2021/03/22/%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0Day4-%E6%8E%92%E5%BA%8F/"/>
      <url>2021/03/22/%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0Day4-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="排序"><a class="header-anchor" href="#排序">¶</a>排序</h2><h3 id="题目"><a class="header-anchor" href="#题目">¶</a>题目</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210322171419976.png" alt="image-20210322171419976"></p><h3 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">}</span><br><span class="line">sort(a,a+n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">} </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行时间：6ms<br>超过8.00%用C++提交的代码</p><p>占用内存：524KB<br>超过24.97%用C++提交的代码</p><h2 id="成绩排序"><a class="header-anchor" href="#成绩排序">¶</a>成绩排序</h2><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210322171757422.png" alt="image-20210322171757422"></p><p>对了</p><h2 id="成绩排序2"><a class="header-anchor" href="#成绩排序2">¶</a>成绩排序2</h2><h3 id="题目-v2"><a class="header-anchor" href="#题目-v2">¶</a>题目</h3><p>见书</p><h3 id="代码-v2"><a class="header-anchor" href="#代码-v2">¶</a>代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">grade</span>{</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">string</span> p;</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare0</span><span class="params">(struct grade g1,struct grade g2)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(g1.q&gt;g2.q){</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(g1.q==g2.q){</span><br><span class="line"><span class="keyword">if</span>(g1.id&lt;g2.id){</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(g1.q&lt;g2.q){</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare1</span><span class="params">(struct grade g1,struct grade g2)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(g1.q&lt;g2.q){</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(g1.q==g2.q){</span><br><span class="line"><span class="keyword">if</span>(g1.id&lt;g2.id){</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(g1.q&gt;g2.q){</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> order;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;order){</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">grade</span> <span class="title">g</span>[<span class="title">n</span>];</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;g[i].p&gt;&gt;g[i].q;</span><br><span class="line">g[i].id=i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(order==<span class="number">0</span>){</span><br><span class="line">sort(g,g+n,compare0);</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">sort(g,g+n,compare1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;g[i].p&lt;&lt;<span class="string">" "</span>&lt;&lt;g[i].q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">} </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="特殊排序"><a class="header-anchor" href="#特殊排序">¶</a>特殊排序</h2><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210324112155362.png" alt="image-20210324112155362"></p><h3 id="代码-v3"><a class="header-anchor" href="#代码-v3">¶</a>代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sort(a,a+n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a[n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n<span class="number">-1</span>==<span class="number">0</span>){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="整数奇偶排序"><a class="header-anchor" href="#整数奇偶排序">¶</a>整数奇偶排序</h2><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210324112247291.png" alt="image-20210324112247291"></p><h3 id="代码-v4"><a class="header-anchor" href="#代码-v4">¶</a>代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>],odd[<span class="number">10</span>],even[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a[<span class="number">0</span>]&gt;&gt;a[<span class="number">1</span>]&gt;&gt;a[<span class="number">2</span>]&gt;&gt;a[<span class="number">3</span>]&gt;&gt;a[<span class="number">4</span>]&gt;&gt;a[<span class="number">5</span>]&gt;&gt;a[<span class="number">6</span>]&gt;&gt;a[<span class="number">7</span>]&gt;&gt;a[<span class="number">8</span>]&gt;&gt;a[<span class="number">9</span>]){</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++){</span><br><span class="line"><span class="keyword">if</span>(a[i]%<span class="number">2</span>==<span class="number">0</span>){</span><br><span class="line">even[j++]=a[i];</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">odd[k++]=a[i];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sort(odd,odd+k,compare);<span class="comment">//降序 </span></span><br><span class="line">sort(even,even+j);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;odd[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;even[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="小白鼠排队"><a class="header-anchor" href="#小白鼠排队">¶</a>小白鼠排队</h2><h3 id="题目-v3"><a class="header-anchor" href="#题目-v3">¶</a>题目</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210324113709376.png" alt="image-20210324113709376"></p><h3 id="代码-v5"><a class="header-anchor" href="#代码-v5">¶</a>代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mouse</span>{</span></span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line"><span class="built_in">string</span> color;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mouse</span> <span class="title">m</span>[101];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(struct mouse m1,struct mouse m2)</span></span>{</span><br><span class="line"><span class="keyword">return</span> m1.w&gt;m2.w;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m[i].w&gt;&gt;m[i].color;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sort(m,m+n,compare);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;m[i].color&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="奥运排序问题"><a class="header-anchor" href="#奥运排序问题">¶</a>奥运排序问题</h2><h3 id="题目-v4"><a class="header-anchor" href="#题目-v4">¶</a>题目</h3><h3 id="学习"><a class="header-anchor" href="#学习">¶</a>学习</h3><p>写了好长一串，不出意外地出错了，所以进入调试阶段</p><p>有些忘记了，调出来学一下：</p><p><a href="https://blog.csdn.net/frostime/article/details/96143531">https://blog.csdn.net/frostime/article/details/96143531</a></p><p>答案错了……调试也应付不了这么复杂的情况</p><p>之后再说吧</p><p>TO BE CONTINUED</p><p>啊！！！！！！！！！！！！！过了！！！！！！！！！！！！！！！！！！！！！！！！！！</p><p>运行时间：6ms<br>超过13.96%用C++提交的代码</p><p>占用内存：408KB<br>超过78.87%用C++提交的代码</p><h3 id="代码-v6"><a class="header-anchor" href="#代码-v6">¶</a>代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">country</span>{</span></span><br><span class="line"><span class="keyword">int</span> id;<span class="comment">//国家号 </span></span><br><span class="line"><span class="keyword">int</span> rk1;</span><br><span class="line"><span class="keyword">int</span> rk2;</span><br><span class="line"><span class="keyword">int</span> rk3;</span><br><span class="line"><span class="keyword">int</span> rk4;</span><br><span class="line"><span class="keyword">int</span> gold;</span><br><span class="line"><span class="keyword">int</span> medal;</span><br><span class="line"><span class="keyword">int</span> people;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare1</span><span class="params">(struct country c1,struct country c2)</span></span>{</span><br><span class="line"><span class="keyword">return</span> c1.gold&gt;c2.gold;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare2</span><span class="params">(struct country c1,struct country c2)</span></span>{</span><br><span class="line"><span class="keyword">return</span> c1.medal&gt;c2.medal;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare3</span><span class="params">(struct country c1,struct country c2)</span></span>{</span><br><span class="line"><span class="keyword">return</span> (c1.gold*<span class="number">1.0</span>/c1.people)&gt;(c2.gold*<span class="number">1.0</span>/c2.people);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare4</span><span class="params">(struct country c1,struct country c2)</span></span>{</span><br><span class="line"><span class="keyword">return</span> (c1.medal*<span class="number">1.0</span>/c1.people)&gt;(c2.medal*<span class="number">1.0</span>/c2.people);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareId</span><span class="params">(struct country c1,struct country c2)</span></span>{</span><br><span class="line"><span class="keyword">return</span> (c1.id)&lt;(c2.id);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m){</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">country</span> <span class="title">c1</span>[<span class="title">n</span>];</span><span class="comment">//最初输入的国家 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">country</span> <span class="title">c2</span>[<span class="title">m</span>];</span><span class="comment">//真正要排序的国家 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">c1[i].id=i;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c1[i].gold&gt;&gt;c1[i].medal&gt;&gt;c1[i].people;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sortCountry[m];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){<span class="comment">//把需要排名的国家号放进另一个数组里 </span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sortCountry[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">c2[j++]=c1[sortCountry[i]];<span class="comment">//根据国家号去取数据，放入c2； </span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始进行四种排序</span></span><br><span class="line"><span class="comment">//第一种 </span></span><br><span class="line">sort(c2,c2+m,compare1);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="comment">//先按顺序赋值下来，然后再改一道</span></span><br><span class="line">c2[i].rk1=i+<span class="number">1</span>; </span><br><span class="line"><span class="comment">//如果有数值相同的，要赋一样的排名值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;){</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(c2[i].gold==c2[i+j].gold&amp;&amp;(i+j&lt;m)){</span><br><span class="line">c2[i+j].rk1=c2[i].rk1;</span><br><span class="line">j++;</span><br><span class="line">}</span><br><span class="line">i=i+j;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种 </span></span><br><span class="line">sort(c2,c2+m,compare2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="comment">//先按顺序赋值下来，然后再改一道</span></span><br><span class="line">c2[i].rk2=i+<span class="number">1</span>; </span><br><span class="line"><span class="comment">//如果有数值相同的，要赋一样的排名值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;){</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(c2[i].medal==c2[i+j].medal&amp;&amp;(i+j&lt;m)){</span><br><span class="line">c2[i+j].rk2=c2[i].rk2;</span><br><span class="line">j++;</span><br><span class="line">}</span><br><span class="line">i=i+j;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种 </span></span><br><span class="line">sort(c2,c2+m,compare3);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="comment">//先按顺序赋值下来，然后再改一道</span></span><br><span class="line">c2[i].rk3=i+<span class="number">1</span>; </span><br><span class="line"><span class="comment">//如果有数值相同的，要赋一样的排名值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;){</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((c2[i].gold*<span class="number">1.0</span>/c2[i].people)==(c2[i+j].gold*<span class="number">1.0</span>/c2[i+j].people)&amp;&amp;(i+j&lt;m)){</span><br><span class="line">c2[i+j].rk3=c2[i].rk3;</span><br><span class="line">j++;</span><br><span class="line">}</span><br><span class="line">i=i+j;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//第四种 </span></span><br><span class="line">sort(c2,c2+m,compare4);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="comment">//先按顺序赋值下来，然后再改一道</span></span><br><span class="line">c2[i].rk4=i+<span class="number">1</span>; </span><br><span class="line"><span class="comment">//如果有数值相同的，要赋一样的排名值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;){</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((c2[i].medal*<span class="number">1.0</span>/c2[i].people)==(c2[i+j].medal*<span class="number">1.0</span>/c2[i+j].people)&amp;&amp;(i+j&lt;m)){</span><br><span class="line">c2[i+j].rk4=c2[i].rk4;</span><br><span class="line">j++;</span><br><span class="line">}</span><br><span class="line">i=i+j;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里要恢复按国家号的排名！！！</span></span><br><span class="line">sort(c2,c2+m,compareId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> best_rk;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"></span><br><span class="line">best_rk=<span class="built_in">min</span>(c2[i].rk1,<span class="built_in">min</span>(c2[i].rk2,<span class="built_in">min</span>(c2[i].rk3,c2[i].rk4)));</span><br><span class="line"><span class="keyword">if</span>(best_rk==c2[i].rk1){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;best_rk&lt;&lt;<span class="string">":"</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(best_rk==c2[i].rk2){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;best_rk&lt;&lt;<span class="string">":"</span>&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(best_rk==c2[i].rk3){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;best_rk&lt;&lt;<span class="string">":"</span>&lt;&lt;<span class="number">3</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(best_rk==c2[i].rk4){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;best_rk&lt;&lt;<span class="string">":"</span>&lt;&lt;<span class="number">4</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">} </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3><p>说下之前错在哪：</p><ul><li>首先我检查了那个“修改排名”的函数，发现不应该在for循环里面加i++</li><li>确定这个函数没问题之后，我怀疑输出有问题，仔细一想：我没在最后输出的时候恢复按国家号的排名啊！呜呜呜，难怪第二行第三行的数字一直是反的</li></ul><p>获得一些经验：</p><ul><li>不能用调试的话，从小处检查起，确保小函数是正确的</li><li>写代码不要想当然，比如直接在for循环里面加i++这档子事，还是要过脑的</li><li>不要隔太久写，过久了就更不知道怎么写了</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小可的机试练习日记Day1-暴力求解</title>
      <link href="2021/03/17/%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0Day1/"/>
      <url>2021/03/17/%E5%B0%8F%E5%8F%AF%E7%9A%84%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E6%97%A5%E8%AE%B0Day1/</url>
      
        <content type="html"><![CDATA[<h1>2.1 枚举</h1><h2 id="abc"><a class="header-anchor" href="#abc">¶</a>abc</h2><h3 id="题目"><a class="header-anchor" href="#题目">¶</a>题目</h3><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210317163140496.png" alt="image-20210317163140496" style="width:800px"><h3 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;=<span class="number">9</span>;a++){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">0</span>;b&lt;=<span class="number">9</span>;b++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;=<span class="number">9</span>;c++){</span><br><span class="line">                <span class="keyword">if</span>(((a*<span class="number">100</span>+b*<span class="number">10</span>+c)+(b*<span class="number">100</span>+c*<span class="number">10</span>+c))==<span class="number">532</span>){</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>&lt;&lt;b&lt;&lt;<span class="string">" "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="运行效率"><a class="header-anchor" href="#运行效率">¶</a>运行效率</h3><p>运行时间：3ms<br>超过24.02%用C++提交的代码</p><p>占用内存：376KB<br>超过36.02%用C++提交的代码</p><h3 id="错误点、经验、总结"><a class="header-anchor" href="#错误点、经验、总结">¶</a>错误点、经验、总结</h3><p>之前写错的代码长这样：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(;a&lt;=<span class="number">9</span>;a++){</span><br><span class="line">        <span class="keyword">for</span>(;b&lt;=<span class="number">9</span>;b++){</span><br><span class="line">            <span class="keyword">for</span>(;c&lt;=<span class="number">9</span>;c++){</span><br><span class="line">                <span class="keyword">if</span>(((a*<span class="number">100</span>+b*<span class="number">10</span>+c)+(b*<span class="number">100</span>+c*<span class="number">10</span>+c))==<span class="number">532</span>){</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>&lt;&lt;b&lt;&lt;<span class="string">" "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>本来以为这种只是省事的操作，但这个代码会运行30次，而正确的代码会运行10^3次。</p><p>在for循环里面重新初始化变量还是很有必要的，可以通过debug发现问题。</p><h3 id="优化"><a class="header-anchor" href="#优化">¶</a>优化</h3><ul><li>既然题目说是三位数，那么a和b应该从1开始也可以：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;=<span class="number">9</span>;a++){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">1</span>;b&lt;=<span class="number">9</span>;b++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;=<span class="number">9</span>;c++){</span><br><span class="line">                <span class="keyword">if</span>(((a*<span class="number">100</span>+b*<span class="number">10</span>+c)+(b*<span class="number">100</span>+c*<span class="number">10</span>+c))==<span class="number">532</span>){</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>&lt;&lt;b&lt;&lt;<span class="string">" "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>​运行时间：3ms<br>​超过24.02%用C++提交的代码</p><p>​占用内存：360KB<br>​超过64.06%用C++提交的代码</p><ul><li><p>书上对于if里面的计算进行了合并同类项：</p><p><code>if(a*100+b*110+c*12==532)</code></p><p>运行时间：3ms<br>超过24.02%用C++提交的代码</p><p>占用内存：344KB<br>超过88.52%用C++提交的代码</p></li></ul><h2 id="反序数"><a class="header-anchor" href="#反序数">¶</a>反序数</h2><h3 id="题目-v2"><a class="header-anchor" href="#题目-v2">¶</a>题目</h3><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210317171702872.png" alt="image-20210317171702872" style="width:800px"><h3 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h3><p>互为反序数的两个数的位数应该是一样的，所以最大的4位数位9999，也就是说N不会超过1111，从1000到1111遍历即可？</p><h3 id="代码-v2"><a class="header-anchor" href="#代码-v2">¶</a>代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> N9;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> N=<span class="number">1000</span>;N&lt;=<span class="number">1111</span>;N++){</span><br><span class="line">        N9=<span class="number">9</span>*N;</span><br><span class="line">        <span class="keyword">if</span>((N%<span class="number">10</span>==N9/<span class="number">1000</span>)&amp;&amp;((N/<span class="number">10</span>)%<span class="number">10</span>==(N9/<span class="number">100</span>)%<span class="number">10</span>)&amp;&amp;((N/<span class="number">100</span>)%<span class="number">10</span>==(N9/<span class="number">10</span>)%<span class="number">10</span>)&amp;&amp;(N/<span class="number">1000</span>==N9%<span class="number">10</span>)){</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;N&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="运行效率-v2"><a class="header-anchor" href="#运行效率-v2">¶</a>运行效率</h3><p>运行时间：4ms<br>超过6.63%用C++提交的代码（为什么我的每次运行都好慢qwq）</p><p>占用内存：352KB<br>超过74.14%用C++提交的代码</p><h3 id="思考"><a class="header-anchor" href="#思考">¶</a>思考</h3><p>书上的代码看起来像另一个思路：遍历1000-9999，对每个数，算它的反序数是不是它的九倍：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">int</span> revx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>){</span><br><span class="line">revx*=<span class="number">10</span>;<span class="comment">//revx右边补0 </span></span><br><span class="line">revx+=x%<span class="number">10</span>;<span class="comment">//revx加上x现在的个位数 </span></span><br><span class="line">x/=<span class="number">10</span>;<span class="comment">//x抹掉现在的个位 </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> revx; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1000</span>;i&lt;=<span class="number">9999</span>;i++){</span><br><span class="line"><span class="keyword">if</span>(i*<span class="number">9</span>==Reverse(i)){</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>值得学习的是有注释的那三行代码：<strong>在进制转换中很常用。</strong></p><p>运行时间：3ms<br>超过27.96%用C++提交的代码</p><p>占用内存：376KB<br>超过25.06%用C++提交的代码</p><h2 id="对称平方数1"><a class="header-anchor" href="#对称平方数1">¶</a>对称平方数1</h2><h3 id="题目-v3"><a class="header-anchor" href="#题目-v3">¶</a>题目</h3><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210317173741382.png" alt="image-20210317173741382" style="width:800px"><h3 id="分析-v2"><a class="header-anchor" href="#分析-v2">¶</a>分析</h3><p>因为数字不超过256，所以其平方不会超过65536，也就是在五位数及之内。</p><p>我觉得要先看这个数的平方有多少位，然后根据具体位数来编码，有点硬编码的意思？</p><h3 id="代码-v3"><a class="header-anchor" href="#代码-v3">¶</a>代码</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sym</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">10000</span>){</span><br><span class="line">            <span class="keyword">if</span>((x/<span class="number">10000</span>==x%<span class="number">10</span>)&amp;&amp;((x/<span class="number">1000</span>)%<span class="number">10</span>==(x/<span class="number">10</span>)%<span class="number">10</span>)){</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }    </span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;=<span class="number">1000</span>&amp;&amp;x&lt;<span class="number">10000</span>){</span><br><span class="line">            <span class="keyword">if</span>((x/<span class="number">1000</span>==x%<span class="number">10</span>)&amp;&amp;((x/<span class="number">100</span>)%<span class="number">10</span>==(x/<span class="number">10</span>)%<span class="number">10</span>)){</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;=<span class="number">100</span>&amp;&amp;x&lt;<span class="number">1000</span>){</span><br><span class="line">            <span class="keyword">if</span>((x/<span class="number">100</span>==x%<span class="number">10</span>)){</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;=<span class="number">10</span>&amp;&amp;x&lt;<span class="number">100</span>){</span><br><span class="line">            <span class="keyword">if</span>((x/<span class="number">10</span>==x%<span class="number">10</span>)){</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;<span class="number">10</span>){</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">256</span>;i++){</span><br><span class="line">        <span class="keyword">if</span>(sym(<span class="built_in">pow</span>(i,<span class="number">2</span>))){</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="运行效率-v3"><a class="header-anchor" href="#运行效率-v3">¶</a>运行效率</h3><p>运行时间：3ms<br>超过23.95%用C++提交的代码</p><p>占用内存：376KB<br>超过27.01%用C++提交的代码</p><h3 id="错误"><a class="header-anchor" href="#错误">¶</a>错误</h3><ul><li>误用switch：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sym</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">switch</span> (x){</span><br><span class="line">        <span class="keyword">case</span> x&gt;=<span class="number">10000</span>:</span><br><span class="line">            <span class="keyword">if</span>((x/<span class="number">10000</span>==x%<span class="number">10</span>)&amp;&amp;((x/<span class="number">1000</span>)%<span class="number">10</span>==(x/<span class="number">10</span>)%<span class="number">10</span>)){</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        <span class="keyword">case</span> x&gt;=<span class="number">1000</span>&amp;&amp;x&lt;<span class="number">10000</span>:</span><br><span class="line">            <span class="keyword">if</span>((x/<span class="number">1000</span>==x%<span class="number">10</span>)&amp;&amp;((x/<span class="number">100</span>)%<span class="number">10</span>==(x/<span class="number">10</span>)%<span class="number">10</span>)){</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        <span class="keyword">case</span> x&gt;=<span class="number">100</span>&amp;&amp;x&lt;<span class="number">1000</span>:</span><br><span class="line">            <span class="keyword">if</span>((x/<span class="number">100</span>==x%<span class="number">10</span>)){</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        <span class="keyword">case</span> x&gt;=<span class="number">10</span>&amp;&amp;x&lt;<span class="number">100</span>:</span><br><span class="line">            <span class="keyword">if</span>((x/<span class="number">10</span>==x%<span class="number">10</span>)){</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        <span class="keyword">case</span> x&gt;=<span class="number">0</span>&amp;&amp;x&lt;<span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">256</span>;i++){</span><br><span class="line">        <span class="keyword">if</span>(sym(i**<span class="number">2</span>)){</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>​不知道为什么，当时可能脑子犯抽了，就想着用switch case的结构，但是case后面要的是常量表达式啊！也就是只能表达x==10000这种意思；这种范围的，还是乖乖用if-else比较好<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span></p><ul><li>编译报错：</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210317175727463.png" alt="image-20210317175727463"></p><p>​其实代码在devcpp里面是没有问题的，但是牛客网的线上编译器说并不是所有控制流都有返回值……所以我又补了一个else在最后。</p><h3 id="优化-v2"><a class="header-anchor" href="#优化-v2">¶</a>优化</h3><p>看到书上的解法……我瞬间觉得我上一题白做了哈哈哈哈<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8">😝</span></p><p>反序数这道题中编写了一个求反序数的函数，与这道题的关联在于：</p><p>对称数等价于一个数与它的反序数相等！</p><p>所以我们来看看书上的解法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">int</span> revx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>){</span><br><span class="line">revx*=<span class="number">10</span>;<span class="comment">//revx右边补0 </span></span><br><span class="line">revx+=x%<span class="number">10</span>;<span class="comment">//revx加上x现在的个位数 </span></span><br><span class="line">x/=<span class="number">10</span>;<span class="comment">//x抹掉现在的个位 </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> revx; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++){</span><br><span class="line"><span class="keyword">if</span>(i*i==Reverse(i*i)){</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行时间：3ms<br>超过23.86%用C++提交的代码</p><p>占用内存：376KB<br>超过26.88%用C++提交的代码</p><p>（啊哈哈哈时间内存也没有好太多，但是代码优雅多了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>）</p><h2 id="与七无关的数"><a class="header-anchor" href="#与七无关的数">¶</a>与七无关的数</h2><h3 id="题目-v4"><a class="header-anchor" href="#题目-v4">¶</a>题目</h3><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210317181808685.png" alt="image-20210317181808685" style="width:80%;"><h3 id="分析-v3"><a class="header-anchor" href="#分析-v3">¶</a>分析</h3><p>如何处理这种有多个案例的情况？（没有输入终止条件）</p><p><a href="https://blog.csdn.net/chch1996/article/details/106317493%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2%E6%84%9F%E8%A7%89%E4%B8%8D%E9%94%99">https://blog.csdn.net/chch1996/article/details/106317493这个博客感觉不错</a></p><p>这里先试下while(cin&gt;&gt;n)吧</p><h3 id="代码-v4"><a class="header-anchor" href="#代码-v4">¶</a>代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">contain7</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>){</span><br><span class="line"><span class="keyword">if</span>(x%<span class="number">10</span>==<span class="number">7</span>){</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">x=x/<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!(i%<span class="number">7</span>==<span class="number">0</span>||contain7(i))){</span><br><span class="line">sum+=i*i;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="运行效率-v4"><a class="header-anchor" href="#运行效率-v4">¶</a>运行效率</h3><p>运行时间：9ms<br>超过6.51%用C++提交的代码</p><p>占用内存：504KB<br>超过37.68%用C++提交的代码</p><h2 id="百鸡问题"><a class="header-anchor" href="#百鸡问题">¶</a>百鸡问题</h2><h3 id="题目-v5"><a class="header-anchor" href="#题目-v5">¶</a>题目</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210317190431356.png" alt="image-20210317190431356"></p><h3 id="分析-v4"><a class="header-anchor" href="#分析-v4">¶</a>分析</h3><p>首先，我们可以用总钱数n去除以每种鸡的单价，确定一个上限，方便搜索</p><h3 id="代码-v5"><a class="header-anchor" href="#代码-v5">¶</a>代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;=n/<span class="number">5</span>&amp;&amp;x&lt;=<span class="number">100</span>;x++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;=n/<span class="number">3</span>&amp;&amp;y&lt;=<span class="number">100</span>;y++){</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">100</span>-x-y&gt;=<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>((<span class="number">14</span>*x+<span class="number">8</span>*y+<span class="number">100</span>)&lt;=n*<span class="number">3</span>){</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;x&lt;&lt;<span class="string">",y="</span>&lt;&lt;y&lt;&lt;<span class="string">",z="</span>&lt;&lt;<span class="number">100</span>-x-y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                }            </span><br><span class="line">}</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="运行效率-v5"><a class="header-anchor" href="#运行效率-v5">¶</a>运行效率</h3><p>运行时间：13ms<br>超过11.00%用C++提交的代码</p><p>占用内存：384KB<br>超过67.51%用C++提交的代码</p><h3 id="错误-v2"><a class="header-anchor" href="#错误-v2">¶</a>错误</h3><p>这道题多了好多次，每次都挺有趣的……</p><ul><li><p>想当然而写错了数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;=n/<span class="number">5</span>;x++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;=n/<span class="number">3</span>;y++){</span><br><span class="line">                <span class="keyword">if</span>((<span class="number">14</span>*x+<span class="number">8</span>*y+<span class="number">100</span>)/<span class="number">3</span>&lt;=<span class="number">100</span>){<span class="comment">//这里不应该是100，应该是n啊！！！</span></span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;x&lt;&lt;<span class="string">",y="</span>&lt;&lt;y&lt;&lt;<span class="string">",z="</span>&lt;&lt;<span class="number">100</span>-x-y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>计算出错：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;=n/<span class="number">5</span>;x++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;=n/<span class="number">3</span>;y++){</span><br><span class="line">                <span class="keyword">if</span>((<span class="number">14</span>*x+<span class="number">8</span>*y+<span class="number">100</span>)/<span class="number">3</span>&lt;=n){</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;x&lt;&lt;<span class="string">",y="</span>&lt;&lt;y&lt;&lt;<span class="string">",z="</span>&lt;&lt;<span class="number">100</span>-x-y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个错在哪呢？其实比较细节，我们来看一下答案的对比：</p><p>你期望输出的第 1 至 4 行与实际输出的第 1 至 5 行有不同</p><table><thead><tr><th></th><th>你期望的输出</th><th></th><th>实际输出</th></tr></thead><tbody><tr><td>1</td><td>x=0,y=0,z=100</td><td>1</td><td>x=0,y=0,z=100</td></tr><tr><td>2</td><td>x=0,y=1,z=99</td><td>2</td><td>x=0,y=1,z=99</td></tr><tr><td>3</td><td>x=0,y=2,z=98</td><td>3</td><td>x=0,y=2,z=98</td></tr><tr><td>4</td><td>x=1,y=0,z=99</td><td>4</td><td>x=1,y=0,z=99</td></tr><tr><td></td><td></td><td>5</td><td><strong>x=1,y=1,z=98</strong></td></tr></tbody></table><p>我们来算下：5*1+3*1+1/3 * 98=40.666666</p><p>那看来是整除计算的问题了，我们把除3移到右边去乘3</p></li><li><p>在n=500的时候又不能过了：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210317195033703.png" alt="image-20210317195033703"></p><p>注意到z变为了负值，所以我们应该限制x、y都在100以内，且z不能小于0</p></li></ul><h2 id="Old-Bill"><a class="header-anchor" href="#Old-Bill">¶</a>Old Bill</h2><h3 id="题目-v6"><a class="header-anchor" href="#题目-v6">¶</a>题目</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210317195937218.png" alt="image-20210317195937218"></p><h3 id="分析-v5"><a class="header-anchor" href="#分析-v5">¶</a>分析</h3><p>填上的两个数需要使补全之后的五位数可以整除火鸡的数量，那么就用一个双重循环来试吧</p><h3 id="代码-v6"><a class="header-anchor" href="#代码-v6">¶</a>代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> N,X,Y,Z;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;X&gt;&gt;Y&gt;&gt;Z){</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span>=<span class="number">0</span>,max_X=<span class="number">0</span>,max_Y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++){</span><br><span class="line"><span class="keyword">if</span>((i*<span class="number">10000</span>+X*<span class="number">1000</span>+Y*<span class="number">100</span>+Z*<span class="number">10</span>+j)%N==<span class="number">0</span>){</span><br><span class="line"><span class="keyword">if</span>((i*<span class="number">10000</span>+X*<span class="number">1000</span>+Y*<span class="number">100</span>+Z*<span class="number">10</span>+j)/N&gt;<span class="built_in">max</span>){</span><br><span class="line"><span class="built_in">max</span>=(i*<span class="number">10000</span>+X*<span class="number">1000</span>+Y*<span class="number">100</span>+Z*<span class="number">10</span>+j)/N;</span><br><span class="line">max_X=i;</span><br><span class="line">max_Y=j;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"><span class="keyword">if</span>(max_X==<span class="number">0</span>){</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;max_X&lt;&lt;<span class="string">" "</span>&lt;&lt;max_Y&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="built_in">max</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">} </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="运行效率-v6"><a class="header-anchor" href="#运行效率-v6">¶</a>运行效率</h3><p>运行时间：6ms<br>超过21.77%用C++提交的代码</p><p>占用内存：540KB<br>超过21.25%用C++提交的代码</p><h3 id="错误-v3"><a class="header-anchor" href="#错误-v3">¶</a>错误</h3><p>这道题比较坑的是没说什么时候输出0，还是我自己翻题解区才找到的qwq</p><p>就是自己很巧妙的加了个cout&lt;&lt;0的地方，用初始化值来判断一下有没有进if里面</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力求解 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于中断的几个概念</title>
      <link href="2021/03/17/%E5%85%B3%E4%BA%8E%E4%B8%AD%E6%96%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
      <url>2021/03/17/%E5%85%B3%E4%BA%8E%E4%B8%AD%E6%96%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>关于中断，总是有几个搞不清的概念：</p><ul><li>中断interrupt、异常exception、陷阱trap、错误fault、中止abort</li><li>硬中断、软中断</li><li>同步中断、异步中断</li></ul><h2 id="trap"><a class="header-anchor" href="#trap">¶</a>trap</h2><h3 id="网上说法"><a class="header-anchor" href="#网上说法">¶</a>网上说法</h3><p>A <strong><a href="http://en.wikipedia.org/wiki/Kernel_trap">trap</a></strong> is an exception in a <strong>user process</strong>. It’s caused by <strong>division by zero</strong> or <strong>invalid memory access</strong>. It’s also the usual way to invoke a kernel routine (a <a href="http://en.wikipedia.org/wiki/System_call">system call</a>) because those run with a higher priority than user code. Handling is synchronous (so the user code is suspended and continues afterwards). In a sense they are “active” - most of the time, the code expects the trap to happen and relies on this fact.</p><p>trap是用户进程中的异常。它是由<strong>除零</strong>或<strong>无效的内存访问（地址访问越界）<strong>引起的。这也是调用内核例程(系统调用)的常见方式，因为内核例程的运行优先级高于用户代码。处理是</strong>同步的</strong>(因此用户代码被挂起并在之后继续)。从某种意义上说，它们是“活跃的”——大多数时候，代码预期陷阱会发生，并依赖于这一事实。</p><p>trap是在程序中使用请求系统服务的系统调用而引发的事件。</p><p>陷阱：当引起陷阱的指令发生时，马上产生该异常。陷阱允许程序不失去连续性的继续执行。陷阱处理例程的返回地址指向引起陷阱的指令的下一条指令（与错误本质上的区别）。如溢出。</p><p>陷阱(Trap):是由程序员发起并期望将控制权转移到一个特殊的处理程序例程。(例如:80x86 <strong>INT指令</strong>就是一个很好的例子)</p><h3 id="自己总结"><a class="header-anchor" href="#自己总结">¶</a>自己总结</h3><h2 id="interrupt"><a class="header-anchor" href="#interrupt">¶</a>interrupt</h2><h3 id="网上说法-v2"><a class="header-anchor" href="#网上说法-v2">¶</a>网上说法</h3><p>An <strong><a href="http://en.wikipedia.org/wiki/Interrupt">interrupt</a></strong> is something generated by the hardware (devices like the hard disk, graphics card, I/O ports, etc). These are asynchronous (i.e. they don’t happen at predictable places in the user code) or “passive” since the interrupt handler has to wait for them to happen eventually.</p><p>中断是由硬件(如硬盘、显卡、I/O端口等设备)产生的东西。它们是<strong>异步的</strong>(即它们不会发生在用户代码的可预测位置)或“<strong>被动的</strong>”，因为中断处理器必须等待它们最终发生。</p><p><strong>Interrupts</strong> occur at random times during the execution of a program, in response to signals from hardware. System hardware uses interrupts to handle events external to the processor, such as requests to service peripheral devices. Software can also generate interrupts by executing the INT n instruction.</p><p>在程序执行过程中，为了响应来自硬件的信号，中断是随机发生的。系统硬件使用中断来处理处理器外部的事件，例如对服务外围设备的请求。软件也可以通过执行INT n指令来产生中断。</p><p><strong>中断</strong>：又称为<strong>异步中断</strong>，是其他硬件依照CPU时钟信号随机产生的。中断又被分为<strong>可屏蔽硬件中断</strong>和<strong>不可屏蔽中断</strong>。在微机原理课程中，处理器中有两个引脚NMI和INTR负责接受中断信号，还有高级可编程中断控制器（APIC），如8259A管理中断信号。则可屏蔽硬件中断：任何通过INTR或着局部APIC传递到处理器的中断信号都被称为可屏蔽硬件中断，由IO设备产生的IRQ（Interrupt ReQuest）也是可屏蔽硬件中断。但是通过INTR引脚传递的可屏蔽硬件中断可使用Intel架构定义的中断向量（0-255），而局部的APIC传递的部分只能使用16-255号向量。若中断信号从NMI引脚传递过来，则发生的是一个不可屏蔽中断。</p><p>中断(硬件):基于CPU外部硬件事件的程序控制中断(例如:按下键盘上的一个键或定时器芯片上的超时)</p><h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3><ul><li>中断=异步中断=外部中断</li><li>是硬件产生的东西</li></ul><h2 id="exception"><a class="header-anchor" href="#exception">¶</a>exception</h2><h3 id="网上说法-v3"><a class="header-anchor" href="#网上说法-v3">¶</a>网上说法</h3><p><strong>Exceptions</strong> occur when the processor detects an error condition while executing an instruction, such as division by zero. The processor detects a variety of error conditions including protection violations, page faults, and internal machine faults.</p><p>当处理器在执行指令时检测到错误情况(例如除零)时，就会发生异常。处理器检测<strong>各种错误条件</strong>，包括违反保护、页面故障和内部机器故障。</p><p><strong>异常</strong>：又称为<strong>同步中断</strong>，是当指令执行时CPU控制单元产生的，之所以称为同步，是因为只有在一条指令终止执行后CPU才会发出中断。在不失进程执行连续性的同时，按引起的异常的指令是否能重新执行,且依据它们被报告的方式，异常分为<strong>错误</strong>，<strong>陷阱</strong>，和<strong>终止</strong>三种情况。</p><h3 id="总结-v2"><a class="header-anchor" href="#总结-v2">¶</a>总结</h3><ul><li>异常=同步中断=内部中断</li></ul><h2 id="fault"><a class="header-anchor" href="#fault">¶</a>fault</h2><p>错误是一种通常<strong>可以能够被修正的异常</strong>，一旦修正，程序能够不失去连续性地接着执行。当报告错误发生时，处理器将机器状态恢复到执行错误之前的状态。**错误处理例程的返回地址指向产生错误的指令，而不是错误指令之后的的那条指令。**如页错误。</p><h2 id="abort"><a class="header-anchor" href="#abort">¶</a>abort</h2><p>它并不总是报告产生异常的指令的确定位置，也不允许引起终止的进程或任务重新执行。如总线错误导致异常终止。</p><h2 id="这些概念之间的关系"><a class="header-anchor" href="#这些概念之间的关系">¶</a>这些概念之间的关系</h2><ul><li>陷阱是异常的一种类型，异常类似于中断。</li><li><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210317112038766.png" alt="image-20210317112038766"></li><li><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210317112202770.png" alt="image-20210317112202770"></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python Numpy学习</title>
      <link href="2021/03/12/Python-Numpy%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/03/12/Python-Numpy%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-Basics-of-Python"><a class="header-anchor" href="#1-Basics-of-Python">¶</a>1. Basics of Python</h2><h3 id="1-1-Basic-data-types"><a class="header-anchor" href="#1-1-Basic-data-types">¶</a>1.1 Basic data types</h3><h4 id="1-1-1-Numbers"><a class="header-anchor" href="#1-1-1-Numbers">¶</a>1.1.1 Numbers</h4><p>认识一下这个type函数的用法，其它加减乘除的操作符和其他语言基本相同：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">3</span></span><br><span class="line">print(x, type(x))</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line"><span class="number">3</span> &lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;//中间有空格</span></span><br></pre></td></tr></tbody></table></figure><p><strong>值得注意的：Note that unlike many languages, Python does not have unary increment (x++) or decrement (x–) operators.</strong></p><h4 id="1-1-2-Booleans"><a class="header-anchor" href="#1-1-2-Booleans">¶</a>1.1.2 Booleans</h4><p>Python implements all of the usual operators for Boolean logic, but uses <strong>English words</strong> rather than symbols (<code>&amp;&amp;</code>, <code>||</code>, etc.):</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">t, f = <span class="literal">True</span>, <span class="literal">False</span></span><br><span class="line">print(type(t))</span><br><span class="line">print(t <span class="keyword">and</span> f) <span class="comment"># Logical AND;</span></span><br><span class="line">print(t <span class="keyword">or</span> f)  <span class="comment"># Logical OR;</span></span><br><span class="line">print(<span class="keyword">not</span> t)   <span class="comment"># Logical NOT;</span></span><br><span class="line">print(t != f)  <span class="comment"># Logical XOR;</span></span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bool</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">False</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line"><span class="class"><span class="title">False</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br></pre></td></tr></tbody></table></figure><p>这里额外探究一下布尔值和0/1的关系：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="literal">True</span> == <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="literal">True</span> == <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="literal">False</span> == <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="literal">False</span> == <span class="number">2</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></tbody></table></figure><p>说明True和False分别等于1和0，且除1以外的正数和True不等</p><h4 id="1-1-3-Strings"><a class="header-anchor" href="#1-1-3-Strings">¶</a>1.1.3 Strings</h4><p>单引号双引号皆可，拼接字符串可以直接用＋号：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hw = hello + <span class="string">' '</span> + world  <span class="comment"># String concatenation</span></span><br><span class="line">print(hw)</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">hello world</span><br></pre></td></tr></tbody></table></figure><p>另：可以用len(str)来输出字符串长度。</p><p>字符串有很多函数可以用：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"hello"</span></span><br><span class="line">print(s.capitalize())  <span class="comment"># Capitalize a string</span></span><br><span class="line">print(s.upper())       <span class="comment"># Convert a string to uppercase; prints "HELLO"</span></span><br><span class="line">print(s.rjust(<span class="number">7</span>))      <span class="comment"># Right-justify a string, padding with spaces</span></span><br><span class="line">print(s.center(<span class="number">7</span>))     <span class="comment"># Center a string, padding with spaces</span></span><br><span class="line">print(s.replace(<span class="string">'l'</span>, <span class="string">'(ell)'</span>))  <span class="comment"># Replace all instances of one substring with another</span></span><br><span class="line">print(<span class="string">'  world '</span>.strip())  <span class="comment"># Strip leading and trailing whitespace</span></span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">Hello</span><br><span class="line">HELLO</span><br><span class="line">  hello</span><br><span class="line"> hello </span><br><span class="line">he(ell)(ell)o</span><br><span class="line">world</span><br></pre></td></tr></tbody></table></figure><p>格式化字符串：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hw12 = <span class="string">'{} {} {}'</span>.format(hello, world, <span class="number">12</span>)  <span class="comment"># string formatting</span></span><br><span class="line">print(hw12)</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">hello world <span class="number">12</span></span><br></pre></td></tr></tbody></table></figure><h3 id="1-2-Containers"><a class="header-anchor" href="#1-2-Containers">¶</a>1.2 Containers</h3><h4 id="1-2-1-Lists"><a class="header-anchor" href="#1-2-1-Lists">¶</a>1.2.1 Lists</h4><ul><li>列表在Python中相当于数组，但可以调整大小、</li><li>并可以包含不同类型的元素</li><li>可以用pop和append对末端元素进行操作</li><li>正的索引是0开始，负的索引是-1倒着开始</li></ul><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210430102753575.png" alt="image-20210430102753575" style="zoom:67%;" loading="lazy"><h4 id="1-2-2-Slicing（重要！）"><a class="header-anchor" href="#1-2-2-Slicing（重要！）">¶</a>1.2.2 Slicing（重要！）</h4><p>除了一次访问一个列表元素之外，Python还提供了简洁的语法来访问子列表;这就是所谓的<strong>切片:</strong></p><ul><li><p>对于一维数组：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210430103537609.png" alt="image-20210430103537609" style="zoom:50%;" loading="lazy"><ul><li><p>还有list(xxxx)这种有趣的初始化方法</p></li><li><p>切片的第一个数是“取等”，第二个数是“不取等”</p></li><li><p>补充一下，这样初始化也可</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210430104602232.png" alt="image-20210430104602232" loading="lazy"></p></li></ul></li><li><p>二维数组：</p></li></ul><h4 id="1-2-3-Loops"><a class="header-anchor" href="#1-2-3-Loops">¶</a>1.2.3 Loops</h4><p>可以用for循环遍历列表元素，还有enumerate可以帮助你获取</p><h4 id="1-2-4-List-comprehensions"><a class="header-anchor" href="#1-2-4-List-comprehensions">¶</a>1.2.4 List comprehensions</h4><p>可以用来简化代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">squares = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums]</span><br><span class="line">print(squares)</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br></pre></td></tr></tbody></table></figure><h4 id="1-2-5-Dictionaries"><a class="header-anchor" href="#1-2-5-Dictionaries">¶</a>1.2.5 Dictionaries</h4><p>A dictionary stores <strong>(key, value) pairs</strong>, similar to a <code>Map</code> in Java or an object in Javascript.</p><p>list是用[]，dic是用{}，配上冒号:</p><ul><li>x in dic，返回布尔值，表示x是否在d中</li><li>d.get(x,‘N/A’)表示在d中搜索x，找到就返回x对应的value，没有找到就打印’N/A’，这个’N/A’是可以随意替换的</li></ul><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210430111433574.png" alt="image-20210430111433574" style="zoom:67%;" loading="lazy"><ul><li><p>Loops：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210430131613669.png" alt="image-20210430131613669" style="zoom:67%;" loading="lazy"><p>值得注意的是，这里的id不再是数组索引那样的了，id和num分别对应key和value</p><p>但是我发现，如果用enumerate，效果和之前是一样的……列举的是key</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i,j <span class="keyword">in</span> enumerate(d):</span><br><span class="line"><span class="meta">... </span>    print(i,j)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>Dictionary comprehensions：</p><p>同样也有一些简写法~</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squared_nums={x:x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squared_nums</span><br><span class="line">{<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="1-2-6-Sets"><a class="header-anchor" href="#1-2-6-Sets">¶</a>1.2.6 Sets</h4><p>集合是不同元素的无序集合。</p><p>初始化是用{}</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals={<span class="string">'cat'</span>,<span class="string">'dog'</span>,<span class="string">'fish'</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'cat'</span> <span class="keyword">in</span> animals</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'bird'</span> <span class="keyword">in</span> animals</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals.add(<span class="string">'bird'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals</span><br><span class="line">{<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'bird'</span>, <span class="string">'fish'</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals.add(<span class="string">'cat'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals</span><br><span class="line">{<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'bird'</span>, <span class="string">'fish'</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(animals)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></tbody></table></figure><p>貌似list，dic，set都可以用len统计元素数量</p><ul><li>Loops：同理也是有“直接遍历”和“enumerate”两种</li><li>Set comprehensions：同理</li></ul><h4 id="1-2-7-Tuples"><a class="header-anchor" href="#1-2-7-Tuples">¶</a>1.2.7 Tuples</h4><p>元组是一个(不可变的)<strong>有序</strong>的值列表。元组在很多方面与列表相似;最重要的区别之一是<strong>元组可以用作字典中的键，也可以用作集合的元素，而列表不能。</strong></p><p>初始化是用()</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t=(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(t)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; d={1:2,3:4,5:6}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[t]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t=(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[t]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: (<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t=(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[t]</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p>元组用作字典索引的意思，并不是说元组中的每一个元素作为索引，例如t=(5,6)，其实找的是字典里key为(5,6)的元素</p><h3 id="1-3-Functions"><a class="header-anchor" href="#1-3-Functions">¶</a>1.3 Functions</h3><p>Python functions are defined using the <code>def</code> keyword.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">param1, param2, param3=<span class="number">1</span></span>):</span></span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure><h3 id="1-4-Classes"><a class="header-anchor" href="#1-4-Classes">¶</a>1.4 Classes</h3><p>看个例子就懂了：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name  <span class="comment"># Create an instance variable</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Instance method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span>(<span class="params">self, loud=False</span>):</span></span><br><span class="line">        <span class="keyword">if</span> loud:</span><br><span class="line">          print(<span class="string">'HELLO, {}'</span>.format(self.name.upper()))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          print(<span class="string">'Hello, {}!'</span>.format(self.name))</span><br><span class="line"></span><br><span class="line">g = Greeter(<span class="string">'Fred'</span>)  <span class="comment"># Construct an instance of the Greeter class</span></span><br><span class="line">g.greet()            <span class="comment"># Call an instance method; prints "Hello, Fred"</span></span><br><span class="line">g.greet(loud=<span class="literal">True</span>)   <span class="comment"># Call an instance method; prints "HELLO, FRED!"</span></span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">Hello, Fred!</span><br><span class="line">HELLO, FRED</span><br></pre></td></tr></tbody></table></figure><h2 id="2-Numpy"><a class="header-anchor" href="#2-Numpy">¶</a>2. Numpy</h2><p>Numpy是Python中用于<strong>科学计算</strong>的核心库。它提供了一个高性能的<strong>多维数组对象</strong>，以及用于<strong>处理这些数组的工具</strong>。</p><p>使用的话，首先要<code>import numpy as np</code></p><h3 id="2-1-Arrays"><a class="header-anchor" href="#2-1-Arrays">¶</a>2.1 Arrays</h3><p>A numpy array is a grid of values, all of <strong>the same type</strong>, and is indexed by a tuple of <strong>nonnegative integers.</strong> The number of dimensions is the rank of the array; <strong>the shape of an array is a tuple of integers giving the size of the array along each dimension.</strong></p><p>shape是一个整数元组，表示每个维度的长度</p><p>初始化与元素访问：</p><p>We can initialize numpy arrays from <strong>nested Python lists</strong>, and access elements using <strong>square brackets:</strong></p><p>numpy的array和python原有的list不同，它只能包含相同类型的元素</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># Create a rank 1 array</span></span><br><span class="line">print(type(a), a.shape, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span>                 <span class="comment"># Change an element of the array</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">numpy</span>.<span class="title">ndarray</span>'&gt; (<span class="params"><span class="number">3</span>,</span>) 1 2 3</span></span><br><span class="line"><span class="class">[5 2 3]</span></span><br></pre></td></tr></tbody></table></figure><p>这里shape只有一个数——3，因为这里定义的array就只有第一维，且元素个数为3</p><p>再来看另一个数组的shape：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])   <span class="comment"># Create a rank 2 array</span></span><br><span class="line">print(b)</span><br><span class="line">print(b.shape)</span><br><span class="line">print(b[<span class="number">0</span>, <span class="number">0</span>], b[<span class="number">0</span>, <span class="number">1</span>], b[<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure><p>shape为（2,3），因为第一维（行）有2行，第二维（列）有3列</p><p>除了这种初始化方法，还有别的函数可以实现：比如np.zeros、np.ones等等</p><h3 id="2-2-Array-indexing"><a class="header-anchor" href="#2-2-Array-indexing">¶</a>2.2 Array indexing</h3><ul><li><p>切片: Similar to Python lists, numpy arrays can be sliced. Since arrays may be multidimensional, you must specify a slice for <strong>each dimension of the array</strong>:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the following rank 2 array with shape (3, 4)</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use slicing to pull out the subarray consisting of the first 2 rows</span></span><br><span class="line"><span class="comment"># and columns 1 and 2; b is the following array of shape (2, 2):</span></span><br><span class="line"><span class="comment"># [[2 3]</span></span><br><span class="line"><span class="comment">#  [6 7]]</span></span><br><span class="line">b = a[:<span class="number">2</span>, <span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">[[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">6</span> <span class="number">7</span>]]</span><br></pre></td></tr></tbody></table></figure><p>A slice of an array is a view into the same data, so modifying it will <strong>modify the original array</strong>.（好奇妙也有点危险的性质<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>）</p></li><li><p>Integer array indexing: When you index into numpy arrays using slicing, the resulting array view will always be a subarray of the original array. <strong>In contrast, integer array indexing allows you to construct arbitrary arrays using the data from another array.</strong></p></li></ul><h3 id="2-3-Datatypes"><a class="header-anchor" href="#2-3-Datatypes">¶</a>2.3 Datatypes</h3><p>每个numpy数组都是由相同类型的元素组成的网格。Numpy提供了大量的数字数据类型，您可以使用它们来构造数组。Numpy在创建数组时尝试猜测数据类型，但是构造数组的函数通常还包含一个可选参数来显式指定数据类型。下面是一个例子:<strong>（注意dtype这个词，以及np.int64）</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>])  <span class="comment"># Let numpy choose the datatype</span></span><br><span class="line">y = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>])  <span class="comment"># Let numpy choose the datatype</span></span><br><span class="line">z = np.array([<span class="number">1</span>, <span class="number">2</span>], dtype=np.int64)  <span class="comment"># Force a particular datatype</span></span><br><span class="line"></span><br><span class="line">print(x.dtype, y.dtype, z.dtype)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x=np.array([<span class="number">1.0</span>,<span class="number">2.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y=np.array(x,dtype=np.int64)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([<span class="number">1.</span>, <span class="number">2.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>], dtype=int64)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.dtype</span><br><span class="line">dtype(<span class="string">'float64'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y.dtype</span><br><span class="line">dtype(<span class="string">'int64'</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="2-4-Array-math"><a class="header-anchor" href="#2-4-Array-math">¶</a>2.4 Array math</h3><p>有些操作符可以直接对两个数组作运算，还有一些numpy的函数也可以用来进行数组间的运算。</p><ul><li>加：直接用+或者np.add</li><li>减：直接用-或者np.subtract</li><li>乘：直接用*或者np.multiply——<strong>这是元素对应相乘，不是矩阵相乘！</strong></li><li>除：直接用/或者np.divide</li></ul><p>特别提一下矩阵相乘，很重要。要实现矩阵X乘Y，有两种写法：</p><ul><li>X.dot(Y)</li><li>np.dot(X,Y)</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], dtype=np.float64)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x+y</span><br><span class="line">array([[ <span class="number">6.</span>,  <span class="number">8.</span>],</span><br><span class="line">       [<span class="number">10.</span>, <span class="number">12.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">3.</span>, <span class="number">4.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">array([[<span class="number">5.</span>, <span class="number">6.</span>],</span><br><span class="line">       [<span class="number">7.</span>, <span class="number">8.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x+y</span><br><span class="line">array([[ <span class="number">6.</span>,  <span class="number">8.</span>],</span><br><span class="line">       [<span class="number">10.</span>, <span class="number">12.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x-y</span><br><span class="line">array([[<span class="number">-4.</span>, <span class="number">-4.</span>],</span><br><span class="line">       [<span class="number">-4.</span>, <span class="number">-4.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x*y</span><br><span class="line">array([[ <span class="number">5.</span>, <span class="number">12.</span>],</span><br><span class="line">       [<span class="number">21.</span>, <span class="number">32.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x/y</span><br><span class="line">array([[<span class="number">0.2</span>       , <span class="number">0.33333333</span>],</span><br><span class="line">       [<span class="number">0.42857143</span>, <span class="number">0.5</span>       ]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dot(x,y)</span><br><span class="line">array([[<span class="number">19.</span>, <span class="number">22.</span>],</span><br><span class="line">       [<span class="number">43.</span>, <span class="number">50.</span>]])</span><br></pre></td></tr></tbody></table></figure><p>想将矩阵的元素相加，可以用np.sum</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">3.</span>, <span class="number">4.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.sum(x)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.sum(x,axis=<span class="number">0</span>)</span><br><span class="line">array([<span class="number">4.</span>, <span class="number">6.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.sum(x,axis=<span class="number">1</span>)</span><br><span class="line">array([<span class="number">3.</span>, <span class="number">7.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.sum(x,axis=<span class="number">2</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;__array_function__ internals&gt;"</span>, line <span class="number">5</span>, <span class="keyword">in</span> sum</span><br><span class="line">  File <span class="string">"D:\anaconda3\envs\python38\lib\site-packages\numpy\core\fromnumeric.py"</span>, line <span class="number">2241</span>, <span class="keyword">in</span> sum</span><br><span class="line">    <span class="keyword">return</span> _wrapreduction(a, np.add, <span class="string">'sum'</span>, axis, dtype, out, keepdims=keepdims,</span><br><span class="line">  File <span class="string">"D:\anaconda3\envs\python38\lib\site-packages\numpy\core\fromnumeric.py"</span>, line <span class="number">87</span>, <span class="keyword">in</span> _wrapreduction</span><br><span class="line">    <span class="keyword">return</span> ufunc.reduce(obj, axis, dtype, out, **passkwargs)</span><br><span class="line">numpy.AxisError: axis <span class="number">2</span> <span class="keyword">is</span> out of bounds <span class="keyword">for</span> array of dimension <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p>有点疑惑，axis是什么<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">❓</span></p><p>还有X.T表示X的转置</p><h3 id="2-5-Broadcasting"><a class="header-anchor" href="#2-5-Broadcasting">¶</a>2.5 Broadcasting</h3><p>广播是一种强大的机制，允许numpy在执行算术操作时处理不同形状的数组。通常我们有一个较小的数组和一个较大的数组，我们希望多次使用较小的数组来对较大的数组执行某些操作。</p><p>例如，假设我们要给矩阵的每一行加上一个常数向量。我们可以这样做:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v</span><br><span class="line">array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = np.empty_like(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">array([[ <span class="number">540876920</span>, <span class="number">1630433390</span>, <span class="number">2036429426</span>],</span><br><span class="line">       [ <span class="number">828070696</span>,  <span class="number">744305196</span>,  <span class="number">875311963</span>],</span><br><span class="line">       [ <span class="number">539778397</span>, <span class="number">1887007844</span>, <span class="number">1886272869</span>],</span><br><span class="line">       [<span class="number">1869375022</span>,  <span class="number">875983969</span>,     <span class="number">658729</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    y[i, :] = x[i, :] + v</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">11</span>, <span class="number">11</span>, <span class="number">13</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>,:]</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">1</span>,:]</span><br><span class="line">array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></tbody></table></figure><p>好像有点明白什么是x[1,:]了……</p><p>就是逗号前后分别是对两个维度的切片，对第一个维度（行），切片是1，虽然不是冒号形式的，但我想应该表达的是取第一行的意思；对第二个维度（列），切片是单单的冒号，所以就是不切直接取某一行所有……</p><p>值得注意的是，数组比较大的时候，用循环可能有点费时……所以不如用另一种思路：将向量v加到矩阵x的每一行相当于将v的多个副本垂直堆叠形成矩阵vv，然后执行x和vv的元素求和。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vv=np.tile(v,(<span class="number">4</span>,<span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vv</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x+vv</span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">11</span>, <span class="number">11</span>, <span class="number">13</span>]])</span><br></pre></td></tr></tbody></table></figure><p>顺带探究一下tile的用法：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vv=np.tile(v,(<span class="number">4</span>,<span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vv</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vv=np.tile(v,(<span class="number">4</span>,<span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vv</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vv=np.tile(v,(<span class="number">4</span>,<span class="number">0</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vv</span><br><span class="line">array([], shape=(<span class="number">4</span>, <span class="number">0</span>), dtype=int32)</span><br></pre></td></tr></tbody></table></figure><p>Numpy广播允许我们在不创建v的多个副本的情况下执行这个计算:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v</span><br><span class="line">array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x+v</span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">11</span>, <span class="number">11</span>, <span class="number">13</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w=np.array([<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x+w</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: operands could <span class="keyword">not</span> be broadcast together <span class="keyword">with</span> shapes (<span class="number">4</span>,<span class="number">3</span>) (<span class="number">2</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w=np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x+w</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: operands could <span class="keyword">not</span> be broadcast together <span class="keyword">with</span> shapes (<span class="number">4</span>,<span class="number">3</span>) (<span class="number">5</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w=np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x+w</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: operands could <span class="keyword">not</span> be broadcast together <span class="keyword">with</span> shapes (<span class="number">4</span>,<span class="number">3</span>) (<span class="number">4</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w=np.array([<span class="number">1</span>,</span><br><span class="line"><span class="meta">... </span>            <span class="number">3</span>,</span><br><span class="line"><span class="meta">... </span>            <span class="number">2</span>,</span><br><span class="line"><span class="meta">... </span>            <span class="number">4</span>,])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w</span><br><span class="line">array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x+w</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: operands could <span class="keyword">not</span> be broadcast together <span class="keyword">with</span> shapes (<span class="number">4</span>,<span class="number">3</span>) (<span class="number">4</span>,)</span><br></pre></td></tr></tbody></table></figure><p>但是要注意一下会报错的情况</p><p><strong>Broadcasting two arrays together follows these rules:</strong></p><ol><li>If the arrays do not have the same rank, prepend the shape of the lower rank array with 1s until both shapes have the same length.</li><li>The two arrays are said to be <em>compatible</em> in a dimension if they have the same size in the dimension, or if one of the arrays has size 1 in that dimension.</li><li>The arrays can be broadcast together if they are compatible in all dimensions.</li><li>After broadcasting, each array behaves as if it had shape equal to the elementwise maximum of shapes of the two input arrays.</li><li>In any dimension where one array had size 1 and the other array had size greater than 1, the first array behaves as if it were copied along that dimension</li></ol><p>有亿点点复杂……有用到的时候再看吧</p><p>另附一个很神奇的操作：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w = np.array([<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.reshape(v,(<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line">array([[<span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v.reshape(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">array([[<span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v.reshape(<span class="number">3</span>,<span class="number">1</span>)*w</span><br><span class="line">array([[ <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">15</span>]])</span><br></pre></td></tr></tbody></table></figure><h2 id="3-Matplotlib"><a class="header-anchor" href="#3-Matplotlib">¶</a>3. Matplotlib</h2><p>使用：<code>import matplotlib.pyplot as plt</code></p><h3 id="3-1-Plotting"><a class="header-anchor" href="#3-1-Plotting">¶</a>3.1 Plotting</h3><p>The most important function in <code>matplotlib</code> is <strong>plot</strong>, which allows you to plot 2D data. Here is a simple example:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compute the x and y coordinates for points on a sine curve</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the points using matplotlib</span></span><br><span class="line">plt.plot(x, y)</span><br></pre></td></tr></tbody></table></figure><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210317153915137.png" alt="image-20210317153915137" style="width:500px" loading="lazy"><h3 id="3-2-Subplots"><a class="header-anchor" href="#3-2-Subplots">¶</a>3.2 Subplots</h3><p>You can <strong>plot different things in the same figure</strong> using the subplot function. Here is an example:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compute the x and y coordinates for points on sine and cosine curves</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up a subplot grid that has height 2 and width 1,</span></span><br><span class="line"><span class="comment"># and set the first such subplot as active.</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make the first plot</span></span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.title(<span class="string">'Sine'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the second subplot as active, and make the second plot.</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.title(<span class="string">'Cosine'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the figure.</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210317154029547.png" alt="image-20210317154029547" style="width:500px" loading="lazy"><h2 id="4-SciPy"><a class="header-anchor" href="#4-SciPy">¶</a>4. SciPy</h2><p>Numpy提供了高性能多维数组和基本工具来计算和操作这些数组。SciPy在此基础上构建，并提供了大量操作numpy数组的函数，这些函数对于不同类型的科学和工程应用程序都很有用。</p><h3 id="4-1-Image-operations"><a class="header-anchor" href="#4-1-Image-operations">¶</a>4.1 Image operations</h3><p>SciPy提供了一些处理图像的基本函数。例如，它具有将图像从磁盘读入numpy数组、将numpy数组作为图像写入磁盘以及调整图像大小的功能。下面是一个简单的例子，展示了这些函数:</p><p>在尝试例子的时候，出现了一个很神奇的bug：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> scipy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> scipy.misc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> scipy.misc <span class="keyword">import</span> imread, imsave, imresize</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ImportError: cannot <span class="keyword">import</span> name <span class="string">'imread'</span> <span class="keyword">from</span> <span class="string">'scipy.misc'</span> (D:\anaconda3\envs\python38\lib\site-packages\scipy\misc\__init__.py)</span><br></pre></td></tr></tbody></table></figure><p>不论是命令行还是notebook都不可……</p><p>那就：stackoverflow搜一下</p><p>发现pillow已经安装，查了下scipy的版本是1.6.2，试一下降低版本</p><p>装不上……算了</p><p>用一下imageio？装上了，于是实践了一段不太懂的代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> imageio <span class="keyword">as</span> im</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img=im.imread(<span class="string">'D:\IMG_20201106_210013.jpg'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.dtype</span><br><span class="line">dtype(<span class="string">'uint8'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.shape</span><br><span class="line">(<span class="number">3456</span>, <span class="number">4608</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img_tinted=img*[<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img_tinted</span><br><span class="line">Array([[[<span class="number">42.</span>  , <span class="number">39.9</span> , <span class="number">27.</span>  ],</span><br><span class="line">        [<span class="number">41.</span>  , <span class="number">38.95</span>, <span class="number">26.1</span> ],</span><br><span class="line">        [<span class="number">41.</span>  , <span class="number">38.95</span>, <span class="number">26.1</span> ],</span><br><span class="line">        ...,</span><br><span class="line">        [ <span class="number">8.</span>  ,  <span class="number">6.65</span>,  <span class="number">2.7</span> ],</span><br><span class="line">        [ <span class="number">7.</span>  ,  <span class="number">5.7</span> ,  <span class="number">1.8</span> ],</span><br><span class="line">        [ <span class="number">7.</span>  ,  <span class="number">5.7</span> ,  <span class="number">1.8</span> ]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">39.</span>  , <span class="number">37.05</span>, <span class="number">24.3</span> ],</span><br><span class="line">        [<span class="number">40.</span>  , <span class="number">38.</span>  , <span class="number">25.2</span> ],</span><br><span class="line">        [<span class="number">41.</span>  , <span class="number">38.95</span>, <span class="number">26.1</span> ],</span><br><span class="line">        ...,</span><br><span class="line">        [ <span class="number">8.</span>  ,  <span class="number">6.65</span>,  <span class="number">2.7</span> ],</span><br><span class="line">        [ <span class="number">7.</span>  ,  <span class="number">5.7</span> ,  <span class="number">1.8</span> ],</span><br><span class="line">        [ <span class="number">7.</span>  ,  <span class="number">5.7</span> ,  <span class="number">1.8</span> ]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">39.</span>  , <span class="number">37.05</span>, <span class="number">24.3</span> ],</span><br><span class="line">        [<span class="number">41.</span>  , <span class="number">38.95</span>, <span class="number">26.1</span> ],</span><br><span class="line">        [<span class="number">43.</span>  , <span class="number">40.85</span>, <span class="number">27.9</span> ],</span><br><span class="line">        ...,</span><br><span class="line">        [ <span class="number">6.</span>  ,  <span class="number">6.65</span>,  <span class="number">1.8</span> ],</span><br><span class="line">        [ <span class="number">6.</span>  ,  <span class="number">6.65</span>,  <span class="number">1.8</span> ],</span><br><span class="line">        [ <span class="number">6.</span>  ,  <span class="number">6.65</span>,  <span class="number">1.8</span> ]],</span><br><span class="line"></span><br><span class="line">       ...,</span><br><span class="line"></span><br><span class="line">       [[<span class="number">20.</span>  , <span class="number">15.2</span> , <span class="number">15.3</span> ],</span><br><span class="line">        [<span class="number">16.</span>  , <span class="number">11.4</span> , <span class="number">11.7</span> ],</span><br><span class="line">        [<span class="number">13.</span>  ,  <span class="number">8.55</span>,  <span class="number">9.</span>  ],</span><br><span class="line">        ...,</span><br><span class="line">        [<span class="number">66.</span>  , <span class="number">68.4</span> , <span class="number">75.6</span> ],</span><br><span class="line">        [<span class="number">64.</span>  , <span class="number">66.5</span> , <span class="number">75.6</span> ],</span><br><span class="line">        [<span class="number">64.</span>  , <span class="number">66.5</span> , <span class="number">75.6</span> ]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">21.</span>  , <span class="number">14.25</span>, <span class="number">15.3</span> ],</span><br><span class="line">        [<span class="number">17.</span>  , <span class="number">10.45</span>, <span class="number">11.7</span> ],</span><br><span class="line">        [<span class="number">14.</span>  ,  <span class="number">9.5</span> ,  <span class="number">9.9</span> ],</span><br><span class="line">        ...,</span><br><span class="line">        [<span class="number">67.</span>  , <span class="number">71.25</span>, <span class="number">79.2</span> ],</span><br><span class="line">        [<span class="number">63.</span>  , <span class="number">67.45</span>, <span class="number">75.6</span> ],</span><br><span class="line">        [<span class="number">62.</span>  , <span class="number">66.5</span> , <span class="number">74.7</span> ]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">21.</span>  , <span class="number">14.25</span>, <span class="number">15.3</span> ],</span><br><span class="line">        [<span class="number">16.</span>  ,  <span class="number">9.5</span> , <span class="number">10.8</span> ],</span><br><span class="line">        [<span class="number">13.</span>  ,  <span class="number">8.55</span>,  <span class="number">9.</span>  ],</span><br><span class="line">        ...,</span><br><span class="line">        [<span class="number">68.</span>  , <span class="number">72.2</span> , <span class="number">80.1</span> ],</span><br><span class="line">        [<span class="number">62.</span>  , <span class="number">66.5</span> , <span class="number">74.7</span> ],</span><br><span class="line">        [<span class="number">61.</span>  , <span class="number">65.55</span>, <span class="number">73.8</span> ]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img_tinted.shape</span><br><span class="line">(<span class="number">3456</span>, <span class="number">4608</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img_tinted=im.imresize(img_tinted,(<span class="number">300</span>,<span class="number">300</span>))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: module <span class="string">'imageio'</span> has no attribute <span class="string">'imresize'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im.imsave(<span class="string">'D:\IMG_20201106_210013_tinted.jpg'</span>,img_tinted)</span><br><span class="line">Lossy conversion <span class="keyword">from</span> float64 to uint8. Range [<span class="number">0.0</span>, <span class="number">243.0</span>]. Convert image to uint8 prior to saving to suppress this warning.</span><br></pre></td></tr></tbody></table></figure><p>值得注意的是：不可以resize……</p><h3 id="4-2-Distance-between-points"><a class="header-anchor" href="#4-2-Distance-between-points">¶</a>4.2 Distance between points</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> pdist, squareform</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">2</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = squareform(pdist(x, <span class="string">'euclidean'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">array([[<span class="number">0.</span>        , <span class="number">1.41421356</span>, <span class="number">2.23606798</span>],</span><br><span class="line">       [<span class="number">1.41421356</span>, <span class="number">0.</span>        , <span class="number">1.</span>        ],</span><br><span class="line">       [<span class="number">2.23606798</span>, <span class="number">1.</span>        , <span class="number">0.</span>        ]])</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter1 信息安全工程与管理-绪论</title>
      <link href="2021/03/05/Chapter1-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E4%B8%8E%E7%AE%A1%E7%90%86-%E7%BB%AA%E8%AE%BA/"/>
      <url>2021/03/05/Chapter1-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E4%B8%8E%E7%AE%A1%E7%90%86-%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>本章重点：</p><ul><li>信息安全基本概念</li><li>信息安全工程基本概念</li><li>信息安全体系模型</li></ul><h2 id="1-1-信息安全基础"><a class="header-anchor" href="#1-1-信息安全基础">¶</a>1.1 信息安全基础</h2><h3 id="1-1-1-信息安全的基本概念"><a class="header-anchor" href="#1-1-1-信息安全的基本概念">¶</a>1.1.1 信息安全的基本概念</h3><p>信息安全其实涉及到很多领域，包括数学、物理、通信和计算机等等，是<strong>复杂的系统工程</strong></p><h4 id="1-信息安全定义"><a class="header-anchor" href="#1-信息安全定义">¶</a>1. 信息安全定义</h4><ul><li><p>信息的定义？</p><ul><li>维纳的定义</li><li>香农的定义</li></ul></li><li><p>安全的定义？</p><p>众说纷纭……有一句话值得记录一下：</p><blockquote><p>安全不再单纯以功能或机制的强度作为评判指标，而是结合了应用环境和应用需求</p></blockquote></li><li><p>信息安全的定义？</p><ul><li>美国《联邦信息安全管理法》</li><li>ISO 17799</li></ul></li></ul><h4 id="2-信息安全的基本属性"><a class="header-anchor" href="#2-信息安全的基本属性">¶</a>2. 信息安全的基本属性</h4><p>CIA+others</p><h4 id="3-信息安全基本属性与信息安全层次模型的关系"><a class="header-anchor" href="#3-信息安全基本属性与信息安全层次模型的关系">¶</a>3. 信息安全基本属性与信息安全层次模型的关系</h4><p>每个层次有涉及到基本属性中的一些</p><ul><li>物理安全：对物理装备的保护</li><li>运行安全：对运行过程和运行状态的保护</li><li>数据安全：在数据收集、处理、存储、检索、传输、交换、显示、扩散等过程中的保护</li><li>内容安全：对信息在网络内流动中的<strong>选择性阻断</strong>，以保证信息流动的<strong>可控</strong>能力</li><li>信息对抗：对<strong>信息熵</strong>的真实性的隐藏与保护，或者攻击与分析</li></ul><h3 id="1-1-2-信息安全发展过程"><a class="header-anchor" href="#1-1-2-信息安全发展过程">¶</a>1.1.2 信息安全发展过程</h3><h3 id="1-1-3-信息安全现状及发展趋势"><a class="header-anchor" href="#1-1-3-信息安全现状及发展趋势">¶</a>1.1.3 信息安全现状及发展趋势</h3><h3 id="1-1-4-ISO-OSI安全体系结构"><a class="header-anchor" href="#1-1-4-ISO-OSI安全体系结构">¶</a>1.1.4 ISO/OSI安全体系结构</h3><p>首先解释一下ISO和OSI是什么：</p><ul><li>OSI=Open System Interconnect，开放系统互连——这是个安全体系结构？</li><li>ISO=International Organization for Standardization，国际标准化组织——这是个组织</li></ul><p><strong>ISO发布了ISO 7498-2标准作为OSI基本参考模型的新补充</strong></p><p>ISO 7498-2中描述了：</p><ul><li><strong>5</strong>种安全服务（安全功能）</li><li><strong>8</strong>类安全机制+普遍安全机制（支持上面的安全服务的）</li><li><strong>5</strong>种OSI安全管理方式</li></ul><h4 id="1-安全服务"><a class="header-anchor" href="#1-安全服务">¶</a>1. 安全服务</h4><ul><li>鉴别服务</li><li>访问控制服务</li><li>数据完整性服务</li><li>数据机密性服务</li><li>抗抵赖性服务</li></ul><p>这些服务的内容大概了解了……那么它们分别是解决什么威胁的呢？</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210305111229013.png" alt="image-20210305111229013" style="height:250px;width:900px"><p>那么它们体现在网络的哪些层里面呢？</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210305112056252.png" alt="image-20210305112056252" style="zoom:50%;"><h4 id="2-安全机制"><a class="header-anchor" href="#2-安全机制">¶</a>2. 安全机制</h4><p>这些安全服务是通过什么安全机制来实现的呢？</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210305113304118.png" alt="image-20210305113304118"></p><h4 id="3-安全体系结构三维图"><a class="header-anchor" href="#3-安全体系结构三维图">¶</a>3. 安全体系结构三维图</h4><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210305113559194.png" alt="image-20210305113559194" style="height:450px;width:700px"><p>OSI七层协议中，最适合配置安全服务的是<strong>物理层、网络层、传输层和应用层</strong>；其他层不是很适合（why<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">❓</span>）</p><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">❓</span>一个疑惑</p><p>OSI在记忆中貌似是网络结构，为什么这里叫OSI安全体系呢？</p><p>我们来看看wiki上面的OSI模型词条：</p><blockquote><p><strong>开放式系统互联模型</strong>（英语：<strong>O</strong>pen <strong>S</strong>ystem <strong>I</strong>nterconnection Model，缩写：OSI；简称为<strong>OSI模型</strong>）是一种<a href="https://zh.wikipedia.org/wiki/%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B">概念模型</a>，由<a href="https://zh.wikipedia.org/wiki/%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84%E7%BB%87">国际标准化组织</a>提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。定义于ISO/IEC 7498-1。</p><p>该模型将通信系统中的数据流划分为七个层，从跨通信介质传输位的物理实现到分布式应用程序数据的最高层表示。每个中间层为其上一层提供功能，其自身功能则由其下一层提供。功能的类别通过标准的通信协议在软件中实现。</p><p>开放式系统互联模型的开发始于上世纪70年代后期，用以支持各种计算机联网方法的出现。在上世纪80年代，该模型成为国际标准化组织（ISO）开放系统互连小组的工作产品。</p></blockquote><p>我有个想法，是不是……<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f633.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f633.png?v8">😳</span></p><p>OSI安全体系结构=OSI参考模型+安全机制+安全服务，后两者是部署在OSI参考模型上的？</p><h2 id="1-2-信息安全工程的相关概念"><a class="header-anchor" href="#1-2-信息安全工程的相关概念">¶</a>1.2 信息安全工程的相关概念</h2><h3 id="1-2-1-信息安全工程的发展由来"><a class="header-anchor" href="#1-2-1-信息安全工程的发展由来">¶</a>1.2.1 信息安全工程的发展由来</h3><p>信息系统安全工程是<strong>系统工程</strong>过程的基本原理在<strong>信息安全领域</strong>内的具体应用</p><h3 id="1-2-2-信息安全工程的定义"><a class="header-anchor" href="#1-2-2-信息安全工程的定义">¶</a>1.2.2 信息安全工程的定义</h3><p>信息安全工程是采用工程的概念、原理、技术和方法来研究、开发、实施与<strong>维护信息系统安全</strong>的过程，是将经过时间考验证明是正确的<strong>工程实践流程</strong>、<strong>管理技术</strong>和当前能够得到的最好的<strong>技术方法</strong>相结合的过程</p><h2 id="1-3-信息安全体系模型"><a class="header-anchor" href="#1-3-信息安全体系模型">¶</a>1.3 信息安全体系模型</h2><p>有几种典型的模型：</p><h3 id="1-3-1-PDR模型"><a class="header-anchor" href="#1-3-1-PDR模型">¶</a>1.3.1 PDR模型</h3><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210312112638073.png" alt="image-20210312112638073" style="height:200px;width:300px"><p>当时间上P&gt;R+D时，系统是安全的。（这是个<strong>理想</strong>模型，因为时间并不好定义<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>）</p><h3 id="1-3-2-PPDR模型"><a class="header-anchor" href="#1-3-2-PPDR模型">¶</a>1.3.2 PPDR模型</h3><p>是PDR的变体，加了Policy</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210312113440579.png" alt="image-20210312113440579" style="height:180px;width:250px"><h3 id="1-3-3-PDRR模型"><a class="header-anchor" href="#1-3-3-PDRR模型">¶</a>1.3.3 PDRR模型</h3><h3 id="img-src-https-raw-githubusercontent-com-Crestiny-BlogImgBed-main-img-image-20210312113448737-png-alt-image-20210312113448737-style-width-500px"><a class="header-anchor" href="#img-src-https-raw-githubusercontent-com-Crestiny-BlogImgBed-main-img-image-20210312113448737-png-alt-image-20210312113448737-style-width-500px">¶</a><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210312113448737.png" alt="image-20210312113448737" style="width:500px;"></h3><p>侧重于技术，没有太多管理因素</p><h3 id="1-3-4-IATF模型"><a class="header-anchor" href="#1-3-4-IATF模型">¶</a>1.3.4 IATF模型</h3><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210312113837854.png" alt="image-20210312113837854" style="width:700px;"><p>还是比较侧重于技术的</p><h3 id="1-3-5-WPDRRC模型"><a class="header-anchor" href="#1-3-5-WPDRRC模型">¶</a>1.3.5 WPDRRC模型</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 信息安全工程与管理 </category>
          
          <category> 《信息安全工程》by林英 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Information Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter9 设备驱动</title>
      <link href="2021/03/04/Chapter9-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
      <url>2021/03/04/Chapter9-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>我们的目标是：控制设备就像操作普通文件一样简单</p><h2 id="9-1-概述"><a class="header-anchor" href="#9-1-概述">¶</a>9.1 概述</h2><p>Linux系统的设计中有一个概念：<strong>把设备看成文件</strong>；具有以下含义：</p><ul><li>每个设备对应一个文件名</li><li>对文件操作的系统调用大都适用于设备文件</li><li>设备文件逻辑上的空间是一个线性空间</li></ul><p>对于一个具体的设备而言，<strong>文件操作和设备驱动是一个事物的不同层次</strong>；所以，一个系统可以被划分为三个层次：</p><ul><li>应用<ul><li>文件系统<ul><li>设备驱动</li></ul></li></ul></li></ul><p>详解一下这三个层次：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210304205612407.png" alt="image-20210304205612407" style="height:500px;width:800px"><p>Linux将设备分成三大类：</p><ul><li>块设备</li><li>字符设备</li><li>网络设备</li></ul><p><strong>对于不同的设备，其文件系统层的厚度不同</strong></p><p><strong>Linux驱动在本质上就是一种软件程序</strong>：上层软件可以<strong>不需要了解硬件特性</strong>，仅通过驱动提供的接口与计算机硬件进行通信</p><p><strong>系统调用</strong>是内核和应用程序之间的接口；<strong>驱动程序</strong>是内核和硬件之间的接口</p><p>下图说明了用户进程请求设备进行输入/输出的简单流程：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210304211006642.png" alt="image-20210304211006642" style="height:360px;width:400px"><p><strong>上一层的抽象屏蔽了下一层的特性</strong></p><h2 id="9-2-设备驱动程序框架"><a class="header-anchor" href="#9-2-设备驱动程序框架">¶</a>9.2 设备驱动程序框架</h2><p>设备驱动程序，一头连了外设，一头连了内核；后者由DDI/DKI规范来规范（好拗口<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>）</p><p>Linux的设备驱动程序与外设的接口可以分为以下三个部分：</p><p>（1）驱动程序与<strong>内核</strong>的接口：通过数据结构file_operations来完成——驱动程序的核心部分</p><p>（2）驱动程序与<strong>系统引导</strong>的接口：利用驱动程序对设备进行初始化</p><p>（3）驱动程序与<strong>设备</strong>的接口：描述了驱动设备如何与设备进行交互，这与具体设备密切相关</p><p>用户进程是通过file结构与<strong>文件或者设备</strong>进行交互的——因为设备也是纳入到文件系统的框架之下的</p><p>这边研究一下框架，有点点没搞懂——<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61b.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61b.png?v8">😛</span></p><ul><li><p>file结构：用户进程是通过file结构与<strong>文件或者设备</strong>进行交互的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> {</span></span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span></span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li><li><p>file_operation结构：file中的一部分</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>{</span></span><br><span class="line">    <span class="keyword">int</span> (*open) (struct inode*, struct file*);<span class="comment">//打开</span></span><br><span class="line">    <span class="keyword">int</span> (*close) (struct inode*, struct file*);  <span class="comment">//关闭</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file*, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);<span class="comment">//修改文件当前的读写位置</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file*, <span class="keyword">char</span> *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *); <span class="comment">//从设备中同步读取数据</span></span><br><span class="line">    <span class="keyword">ssize_t</span>  (*write) (struct file*,<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> * );<span class="comment">//向设备中发送数据</span></span><br><span class="line">    <span class="keyword">int</span> (*mmap) (struct file*, struct vm_area_struct *);<span class="comment">//将设备的内存映射到进程地址空间</span></span><br><span class="line">  <span class="keyword">int</span> (*ioctl) (struct inode*, struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);<span class="comment">//执行设备上的I/O控制指令</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file*, struct poll_table_struct *)</span></span>;<span class="comment">//轮询，判断是否可以进行非阻塞的读取或者写入</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看出file_operation结构中对文件操作的函数只给出了定义，实现是留给具体的驱动程序来完成的。</p><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">❓</span>听不懂<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span></p><p>下面是字符设备驱动程序打开、读、写以及I/O控制函数的模板：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">char_open</span><span class="params">(struct inode* inode, struct file* filp)</span></span>{<span class="comment">//filp是文件结构的指针</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">xxx_read</span><span class="params">(struct file* filp, char_user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *f_pos)</span></span>{<span class="comment">//count是要读的字节数，f_pos是读的位置相对于文件开头的偏移量</span></span><br><span class="line">       <span class="comment">//buf是用户空间的内存地址，在内核空间不能直接读写，所以调用了那两个copy函数</span></span><br><span class="line">    ...</span><br><span class="line">        copy_to_user(buf, ...,count);<span class="comment">//原型：unsigned long copy_from_user(void* to, count void_user *from, unsigned long count);</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">xxx_write</span><span class="params">(struct file* filp, char_user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *f_pos)</span></span>{</span><br><span class="line">    ...</span><br><span class="line">        copy_from_user(..., buf, count);<span class="comment">//原型：unsigned long copy_to_user(void _user *to, count void *from, unsigned long count);</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xxx_ioctl</span><span class="params">(struct inode *inode, struct filr* filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span>{</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">switch</span>(cmd){</span><br><span class="line">                <span class="keyword">case</span> xxx_cmd1;</span><br><span class="line">                ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> xxx_cmd2;</span><br><span class="line">                ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="comment">//不支持的命令</span></span><br><span class="line">                <span class="keyword">return</span> -enotty;</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里研究一下书上的简单字符驱动程序mycdev.c：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210306192757023.png" alt="image-20210306192757023"></p><p>​看起来就是个模块源代码而已啊！什么是字符设备呢？</p><blockquote><p>字符设备是指在I/O传输过程中以字符为单位进行传输的设备，例如键盘，打印机等。</p></blockquote></li></ul><h2 id="9-3-I-O空间的管理"><a class="header-anchor" href="#9-3-I-O空间的管理">¶</a>9.3 I/O空间的管理</h2><p>设备会提供一组寄存器来控制设备、读写设备以及获取设备的状态。这些寄存器就是控制寄存器、数据寄存器和状态寄存器（对应地）</p><p>这些寄存器所在之处有两种情况：</p><ul><li>位于I/O空间时，被称为I/O端口</li><li>位于内存空间时，被称为I/O内存</li></ul><h3 id="9-3-1-I-O端口和I-O内存"><a class="header-anchor" href="#9-3-1-I-O端口和I-O内存">¶</a>9.3.1 I/O端口和I/O内存</h3><p>每个设备的I/O端口都要被组织成下图这样：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210306200956303.png" alt="image-20210306200956303" style="height:300px;width:460px"><p>用法是这样子：</p><ul><li>CPU把要发给设备的命令写入<strong>控制寄存器</strong>，并从<strong>状态寄存器</strong>中读出表示设备内部状态的值</li><li>CPU可以通过读取<strong>输入寄存器</strong>的内容从设备取得数据</li><li>也可以通过向<strong>输出寄存器</strong>中写入字节而把数据输出到设备</li></ul><p>CPU要对外设I/O端口物理地址编址，方式有两种：</p><ul><li>I/O端口：CPU为外设专门实现了一个单独的地址空间，称为“I/O端口空间”；CPU通过设立专门的I/O指令来访问这一空间中的地址单元</li><li>I/O内存：CPU只实现一个物理地址空间，外设I/O端口的物理地址就被映射到CPU的单一物理地址空间中，成为内存的一部分——CPU可以像访问一个内存单元那样访问外设I/O端口</li></ul><h3 id="9-3-2-I-O资源管理"><a class="header-anchor" href="#9-3-2-I-O资源管理">¶</a>9.3.2 I/O资源管理</h3><p><strong>Linux将基于I/O端口和I/O内存的映射方式统称为“I/O区域”。</strong></p><h4 id="1-Linux对I-O资源的描述"><a class="header-anchor" href="#1-Linux对I-O资源的描述">¶</a>1. Linux对I/O资源的描述</h4><p>用resource数据结构</p><h4 id="2-管理I-O区域资源"><a class="header-anchor" href="#2-管理I-O区域资源">¶</a>2. 管理I/O<strong>区域</strong>资源</h4><p>有三个接口函数：</p><ul><li>_request_region()：I/O区域的分配</li><li>_release_region()：I/O区域的释放</li><li>_check_region()：检查指定的I/O区域是否已被占用</li></ul><h4 id="3-管理I-O端口资源"><a class="header-anchor" href="#3-管理I-O端口资源">¶</a>3. 管理I/O<strong>端口</strong>资源</h4><p>三个接口函数：</p><ul><li></li></ul><h4 id="4-管理I-O内存资源"><a class="header-anchor" href="#4-管理I-O内存资源">¶</a>4. 管理I/O<strong>内存</strong>资源</h4><p>三个接口函数：</p><h3 id="9-3-3-访问I-O端口空间"><a class="header-anchor" href="#9-3-3-访问I-O端口空间">¶</a>9.3.3 访问I/O端口空间</h3><p>讲的是读写I/O端口的一些事情</p><h3 id="9-3-4-访问I-O内存资源"><a class="header-anchor" href="#9-3-4-访问I-O内存资源">¶</a>9.3.4 访问I/O内存资源</h3><p>讲的是读写I/O内存的一些事情，在此之前貌似有一个将I/O内存的物理地址映射成内核虚地址的操作</p><h2 id="9-4-字符设备驱动程序"><a class="header-anchor" href="#9-4-字符设备驱动程序">¶</a>9.4 字符设备驱动程序</h2><p><strong>Linux下的应用程序在访问字符设备时，一般都是通过设备文件访问的（在/dev目录下）</strong></p><h3 id="9-4-1-字符设备的数据结构struct-cdev"><a class="header-anchor" href="#9-4-1-字符设备的数据结构struct-cdev">¶</a>9.4.1 字符设备的数据结构struct cdev</h3><p>Linux内核中使用struct cdev来表示一个字符设备</p><h3 id="9-4-2-分配和释放设备号"><a class="header-anchor" href="#9-4-2-分配和释放设备号">¶</a>9.4.2 分配和释放设备号</h3><p>对于每一个设备，必须有一个唯一的设备号与之相对应；通常的情况是：<strong>多个设备共用一个主设备号，而每个设备都唯一拥有一个次设备号。</strong></p><p>有一些定义设备号的宏……有一些申请设备号的函数……</p><h3 id="9-4-3-字符设备驱动的组成"><a class="header-anchor" href="#9-4-3-字符设备驱动的组成">¶</a>9.4.3 字符设备驱动的组成</h3><p>一个基本的字符设备驱动由以下几个部分组成：</p><ul><li>字符设备驱动模块的加载</li><li>卸载函数</li><li>file_operations结构中的成员函数</li></ul><h3 id="9-4-4-加载和卸载函数"><a class="header-anchor" href="#9-4-4-加载和卸载函数">¶</a>9.4.4 加载和卸载函数</h3><p>加载又可以分为以下几步：</p><ul><li>设备号的申请</li><li>cdev的注册</li></ul><p>卸载也可以分为：</p><ul><li>将cdev从系统中注销</li><li>释放设备结构体所占用的内存空间</li><li>释放设备号</li></ul><h3 id="9-4-5-实现file-operations中定义的函数"><a class="header-anchor" href="#9-4-5-实现file-operations中定义的函数">¶</a>9.4.5 实现file_operations中定义的函数</h3><p>file_operations中最基本的包括：open()、release()、read()、write()等函数</p><h2 id="9-5-块驱动程序"><a class="header-anchor" href="#9-5-块驱动程序">¶</a>9.5 块驱动程序</h2><h3 id="9-5-1-块驱动程序的注册"><a class="header-anchor" href="#9-5-1-块驱动程序的注册">¶</a>9.5.1 块驱动程序的注册</h3><p>块驱动程序的数据总是具有固定大小的块，典型的块设备就是磁盘驱动器</p><h3 id="9-5-2-块设备请求"><a class="header-anchor" href="#9-5-2-块设备请求">¶</a>9.5.2 块设备请求</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《Linux操作系统原理与应用(E2)》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter2 ARM技术概述</title>
      <link href="2021/03/03/Chapter2-ARM%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/"/>
      <url>2021/03/03/Chapter2-ARM%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>ARM是一种处理器</strong>，在32位嵌入式应用中使用得比较广泛</p><h2 id="2-1-ARM体系结构及技术特征"><a class="header-anchor" href="#2-1-ARM体系结构及技术特征">¶</a>2.1 ARM体系结构及技术特征</h2><p>SoC芯片：</p><blockquote><p>一般说来， SoC称为系统级芯片，也有称片上系统，意指它是一个产品，是一个有专用目标的集成电路，其中包含完整系统并有嵌入软件的全部内容。 同时它又是一种技术，用以实现从确定系统功能开始，到软/硬件划分，并完成设计的整个过程。</p></blockquote><p>所以各公司可以基于ARM来开发面向各种应用的SoC芯片</p><h3 id="2-1-1-ARM的发展历程"><a class="header-anchor" href="#2-1-1-ARM的发展历程">¶</a>2.1.1 ARM的发展历程</h3><h3 id="2-1-2-RISC体系结构概述"><a class="header-anchor" href="#2-1-2-RISC体系结构概述">¶</a>2.1.2 RISC体系结构概述</h3><p>RISC是一种体系结构，而ARM是最成功的RISC实例，也就是说，<strong>ARM是基于RISC的处理器</strong></p><p>本节先来介绍RISC</p><h4 id="1-CISC体系结构"><a class="header-anchor" href="#1-CISC体系结构">¶</a>1. CISC体系结构</h4><p>CISC的全名是：Complex Instruction Set Computer，也就是带有小型计算机指令集的单片<strong>复杂指令集</strong>计算机</p><p>复杂指令集不是很划算，所以我们发展了RISC来简化指令集</p><h4 id="2-RISC体系结构"><a class="header-anchor" href="#2-RISC体系结构">¶</a>2. RISC体系结构</h4><p>RISC的<strong>中心思想</strong>：简化指令集的复杂度；硬件被设计成只执行一部分简单指令，其他复杂指令由这些简单指令合成——这样可以简化硬件设计</p><h4 id="3-RISC体系结构的特点"><a class="header-anchor" href="#3-RISC体系结构的特点">¶</a>3. RISC体系结构的特点</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《嵌入式系统开发与应用教程》 </category>
          
          <category> 嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter1 嵌入式系统开发基础</title>
      <link href="2021/03/03/Chapter1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
      <url>2021/03/03/Chapter1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter8 文件系统</title>
      <link href="2021/03/02/Chapter8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/03/02/Chapter8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="8-1-Linux文件系统基础"><a class="header-anchor" href="#8-1-Linux文件系统基础">¶</a>8.1 Linux文件系统基础</h2><h3 id="8-1-1-Linux文件结构"><a class="header-anchor" href="#8-1-1-Linux文件结构">¶</a>8.1.1 Linux文件结构</h3><p>文件结构：文件存放在磁盘等存储设备上的组织方法，包括对文件的组织、对目录的组织</p><p>Linux是有相对固定的目录组织形式的，每个目录都有自己特定的作用：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210302153129000.png" alt="image-20210302153129000" style="height:500px;width:700px"><h3 id="8-1-2-文件类型"><a class="header-anchor" href="#8-1-2-文件类型">¶</a>8.1.2 文件类型</h3><p>Linux有以下文件类型：</p><ul><li>常规文件<ul><li>文本文件</li><li>二进制文件</li></ul></li><li>目录文件：只允许系统进行修改</li><li>设备文件：Linux把所有的外设都当做文件来看待</li><li>管道文件：用于在进程间传输数据</li><li>（符号）链接文件：可以通过链接文件中包含的指向文件的指针来实现对文件的访问</li></ul><h3 id="8-1-3-存取权限和文件模式"><a class="header-anchor" href="#8-1-3-存取权限和文件模式">¶</a>8.1.3 存取权限和文件模式</h3><p>就是一种文件保护模式，包含：</p><ul><li><p>三级访问权限：</p><ul><li>属主</li><li>属组</li><li>其他用户</li></ul></li><li><p>三种处理操作</p><ul><li>读R</li><li>写W</li><li>执行X</li></ul><p>组合一下，一共有九种情况：</p><img src="https://github.com/Crestiny/BlogImgBed/blob/main/img/image-20210302204854981.png?raw=true" style="height:200px;width:500px"></li></ul><h3 id="8-1-4-Linux文件系统"><a class="header-anchor" href="#8-1-4-Linux文件系统">¶</a>8.1.4 Linux文件系统</h3><p><strong>Linux系统中每一个分区都是一个文件系统，都有自己的目录层级结构</strong></p><p>Linux会将这些不同分区的文件系统按一定方式组织成一个系统总的目录层次结构</p><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">❓</span>什么是分区</p><h4 id="1-索引结点"><a class="header-anchor" href="#1-索引结点">¶</a>1.索引结点</h4><p><strong>Linux文件系统使用索引节点来记录文件信息，也靠这个结点来识别文件</strong></p><p>索引结点是一个数据结构，其中的信息有：</p><ul><li>文件的长度</li><li>创建时间</li><li>修改时间</li><li>权限</li><li>所属关系</li><li>磁盘中的位置</li><li>等等……</li></ul><h4 id="2-软链接和硬链接"><a class="header-anchor" href="#2-软链接和硬链接">¶</a>2. 软链接和硬链接</h4><ul><li>硬链接：一个文件可以对应一个及以上的文件名</li><li>软链接：符号链接？<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">❓</span></li></ul><h4 id="3-安装文件系统"><a class="header-anchor" href="#3-安装文件系统">¶</a>3. 安装文件系统</h4><p>这个安装不是install，而是mount；就是把一个文件系统的顶层目录挂载到另一个文件系统的子目录上</p><h4 id="4-文件系统创建示例"><a class="header-anchor" href="#4-文件系统创建示例">¶</a>4. 文件系统创建示例</h4><h2 id="8-2-虚拟文件系统"><a class="header-anchor" href="#8-2-虚拟文件系统">¶</a>8.2 虚拟文件系统</h2><p>什么是虚拟文件系统VFS？</p><p>就是一个统一、抽象、虚拟的文件系统界面，背后可以是实现细节不同的文件系统</p><p>为什么需要VFS？</p><p>由于Linux的开放性，需要支持不同的文件系统</p><h3 id="8-2-1-虚拟文件系统的引入"><a class="header-anchor" href="#8-2-1-虚拟文件系统的引入">¶</a>8.2.1 虚拟文件系统的引入</h3><h3 id="8-2-2-VFS中对象的演绎"><a class="header-anchor" href="#8-2-2-VFS中对象的演绎">¶</a>8.2.2 VFS中对象的演绎</h3><p>解释一下“虚拟”这个词：</p><p>VFS只管理挂载到系统中的实际文件系统，而Linux支持的十几种文件系统，并不是全部都挂载在系统上的，而是<strong>按需挂载</strong></p><p><strong>VFS其实是一个管家的角色</strong></p><p>UNIX在文件系统的设计中抽象出的4个概念，也就是VFS要管理的4个对象：</p><ul><li>文件对象：文件可以看做有序字节串；典型的文件操作有：读、写、创建、删除</li><li>目录项对象：一个文件路径的每一部分被称作目录项（<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span>目录项和目录不一样​，<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">❓</span>目录是什么）</li><li>索引结点对象：描述了一个文件的属性，就像PCB描述了进程的属性一样</li><li>超级块对象：描述了已安装的整个文件系统的信息</li></ul><p><strong>UNIX中，目录∈普通文件，所以目录=文件，两者的处理方式在系统看来没有什么不同</strong></p><h3 id="8-2-3-VFS的超级块"><a class="header-anchor" href="#8-2-3-VFS的超级块">¶</a>8.2.3 VFS的超级块</h3><p>​之前说到，VFS背后可以支持几十个不同的文件系统，比如Ext2文件系统。每个文件系统都有自己的超级块，比如Ext2超级块，这是在<strong>磁盘</strong>上的。假如我们安装了Ext2文件系统（初始化+注册），那么系统就会在<strong>内存</strong>为Ext2文件系统分配一个<strong>VFS超级块</strong>——所以VFS超级块只存在于内存中</p><h3 id="8-2-4-VFS的索引结点"><a class="header-anchor" href="#8-2-4-VFS的索引结点">¶</a>8.2.4 VFS的索引结点</h3><p>和超级块类似，每个具体的文件系统的索引结点是存放在磁盘上的（静态结构）；<strong>索引结点包含了文件系统处理文件所需要的所有信息</strong>，当要使用它的时候，就可以将它调入内存，填写<strong>VFS的索引结点（动态结构）</strong></p><h3 id="8-2-5-目录项对象"><a class="header-anchor" href="#8-2-5-目录项对象">¶</a>8.2.5 目录项对象</h3><p>每个文件有索引结点inode数据结构+目录项dentry数据结构，<strong>两者都是对文件各方面属性的描述</strong>，但侧重点不同：</p><ul><li>索引结点inode数据结构：<ul><li>在磁盘上有对应的映像</li><li>记录的是文件<strong>物理</strong>上的属性</li><li>代表的是物理意义上的文件</li></ul></li><li>目录项dentry数据结构：<ul><li>在磁盘上并没有对应的映像</li><li>记录的是文件<strong>逻辑</strong>上的属性</li><li>代表的是逻辑意义上的文件</li></ul></li></ul><p>（虽然不是很懂物理的和逻辑的是什么意思……）</p><h3 id="8-2-6-与进程相关的文件结构"><a class="header-anchor" href="#8-2-6-与进程相关的文件结构">¶</a>8.2.6 与进程相关的文件结构</h3><p>进程访问文件的时候，<strong>所打开的文件是通过文件描述符来抽象表示的</strong>（<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">❓</span>这句话也好抽象啊）</p><p>那么进程打开<strong>文件描述符的使用情况</strong>，又是通过用户打开文件表来描述和记录的</p><h4 id="1-文件对象struct-file"><a class="header-anchor" href="#1-文件对象struct-file">¶</a>1. 文件对象struct file</h4><p>file对象保存了一些文件相关的信息，其中比较重要的是一个叫做“Open File Description”的东西，描述了打开文件的文件位置（也就是下一个要读或写的字节位置）</p><h4 id="2-用户打开文件表struct-files-struct"><a class="header-anchor" href="#2-用户打开文件表struct-files-struct">¶</a>2. 用户打开文件表struct files_struct</h4><p>是进程的私有数据</p><h4 id="3-fs-struct结构"><a class="header-anchor" href="#3-fs-struct结构">¶</a>3. fs_struct结构</h4><p>描述进程与文件系统的关系</p><h3 id="8-2-7-主要数据结构间的关系"><a class="header-anchor" href="#8-2-7-主要数据结构间的关系">¶</a>8.2.7 主要数据结构间的关系</h3><h3 id="8-2-8-实例——观察数据结构中的数据"><a class="header-anchor" href="#8-2-8-实例——观察数据结构中的数据">¶</a>8.2.8 实例——观察数据结构中的数据</h3><h2 id="8-3-文件系统的注册、安装与卸载"><a class="header-anchor" href="#8-3-文件系统的注册、安装与卸载">¶</a>8.3 文件系统的注册、安装与卸载</h2><h3 id="8-3-1-文件系统的注册和注销"><a class="header-anchor" href="#8-3-1-文件系统的注册和注销">¶</a>8.3.1 文件系统的注册和注销</h3><h3 id="8-3-2-文件系统的安装"><a class="header-anchor" href="#8-3-2-文件系统的安装">¶</a>8.3.2 文件系统的安装</h3><h3 id="8-3-3-文件系统的卸载"><a class="header-anchor" href="#8-3-3-文件系统的卸载">¶</a>8.3.3 文件系统的卸载</h3><h2 id="8-4-文件的打开与读写"><a class="header-anchor" href="#8-4-文件的打开与读写">¶</a>8.4 文件的打开与读写</h2><h3 id="8-4-1-文件打开open"><a class="header-anchor" href="#8-4-1-文件打开open">¶</a>8.4.1 文件打开open()</h3><h3 id="8-4-2-文件读写read-和write"><a class="header-anchor" href="#8-4-2-文件读写read-和write">¶</a>8.4.2 文件读写read()和write()</h3><h2 id="8-5-编写一个文件系统"><a class="header-anchor" href="#8-5-编写一个文件系统">¶</a>8.5 编写一个文件系统</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《Linux操作系统原理与应用(E2)》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>又临一往无前时</title>
      <link href="2021/03/01/%E5%8F%88%E4%B8%B4%E4%B8%80%E5%BE%80%E6%97%A0%E5%89%8D%E6%97%B6/"/>
      <url>2021/03/01/%E5%8F%88%E4%B8%B4%E4%B8%80%E5%BE%80%E6%97%A0%E5%89%8D%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="无知的勇气"><a class="header-anchor" href="#无知的勇气">¶</a>无知的勇气</h2><p>​翻到高中的小笔记本，那时候前面一半记作业，后面一半记日记。</p><p>​几年以来，每当我需要勇气的时候，都会打开它。随年岁增长，我对这世界的认知越发清晰；不像以前，窗内是生活，窗外是想象中的生活——现在，窗内窗外都是我可以看到的。</p><blockquote><p>​世上只有一种英雄主义，就是在认清生活真相之后依然热爱生活。</p></blockquote><p>​罗曼·罗兰的这句话很有名，而这确实不容易做到。我有两个时段最有勇气：一是无知而无畏的小孩子时期，浮夸的理想和幼稚的逻辑，虽然或许不切实际，但是小时候的我同现在的我是一颗心，她的幼稚，只是我如今在现实的重围下，不曾再表露在人前的真正心中所想；另一是经历一些挫折之后，开始切身体会到“树的结痂处最坚硬”这句谚语的内涵。</p><p>​然而知道便是知道，见过一部分生活的真相之后，好像很难伪装成从未见过一样。</p><p>​生活的广场上，脚步匆匆的人们彼此心事重重地擦肩而过；各有所向，又各不知为何向。深夜的地铁站和夜幕下的空荡街头听闻过世人偶尔的崩溃，那是与成年人的身份不匹配的“放纵”。他们身上有一副沉重的镣铐禁锢了他们的灵魂，无声的呐喊与有声的崩溃，那是他们希望生活将他们的灵魂放逐回天堂。</p><p>​我或许也是他们中的一员，虽然没有到崩溃的地步，但也曾怀疑过自己的生活。现在的我，却希望向那个十六七岁的我借一份勇气。她身上有着“无知”的勇气，纵然幼稚，但也有效。</p><p>​她曾在繁忙的学习生活中，记录下自己的情绪碎片。她竟然也有着那样有趣的思想——之所以会这样评价，或许是这几年的生活一拳将我打得连连倒退，勉强刹住；回首望见五年前的她，不禁感叹她比我有勇气多了。她的小本子里这样写道：</p><blockquote><p>​会被人嘲笑的梦想，才有实现的价值。我是个偏执、要强、好面子的人，有时候我想，正是由于害怕失败后的尴尬，所以才更渴望也更懂得如何去避免那一份尴尬。人总有不足之处，拼尽全力也赶不上，那是“无能为力”，而我不介意这个词；比起“无能为力”，“我本可以”听起来更让人心烦……永远不要去联想最苦难的处境，而是要想想你克服他们之后的欢愉……胜固欣然，败也如常。</p></blockquote><p>​但不可以过分崇尚苦难，过度的苦是一种精神疾病，也会给自己的经历和努力带来不开心的调子。</p><p>​接受这一份无知的勇气，然后——</p><p>​向前吧，理所应当地超越那个十六七岁的自己；让现在的自己，成为新的勇气来源。</p><p>​去走在那个永不止歇的方向上吧，不论是十六七岁，还是二十几岁，人尚年轻，她们两个，理应有着延续的勇气；并从无知的勇气，走向清醒的勇气。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Insights on Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter7 内核中的同步</title>
      <link href="2021/02/26/Chapter7-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5/"/>
      <url>2021/02/26/Chapter7-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>内核中很多数据都是共享资源，对这些资源的访问必须遵循一定的访问规则</p><h2 id="7-1-临界区和竞争状态"><a class="header-anchor" href="#7-1-临界区和竞争状态">¶</a>7.1 临界区和竞争状态</h2><p><strong>临界区</strong>：是一段代码段——实现了“访问和操作共享数据”的代码段</p><p>临界区的代码在执行期间不可以被打断，也就是需要被<strong>原子地</strong>执行</p><p>如果两个内核任务都处于同一个临界区中，就是<strong>竞争状态</strong>；避免并发和竞争状态称为<strong>同步</strong></p><h3 id="7-1-1-临界区举例"><a class="header-anchor" href="#7-1-1-临界区举例">¶</a>7.1.1 临界区举例</h3><p>比如<code>i++</code></p><h3 id="7-1-2-共享队列和加锁"><a class="header-anchor" href="#7-1-2-共享队列和加锁">¶</a>7.1.2 共享队列和加锁</h3><p>当共享资源是一个比较<strong>复杂的数据结构</strong>的时候，<strong>竞争状态</strong>往往会使该数据结构<strong>遭到破坏</strong>（比如把需要处理的请求做成队列，然后不同的内核任务去读取这些请求）</p><p>所以为了避免竞争状态，<strong>锁机制</strong>可以避免竞争状态；简单来说，就是一个任务要操作共享数据的时候，先上个锁（占住锁）；处理完了就打开锁</p><p>锁也是有几种不一样的种类的</p><h3 id="7-1-3-确定保护对象"><a class="header-anchor" href="#7-1-3-确定保护对象">¶</a>7.1.3 确定保护对象</h3><p>也就是找出哪些数据是需要被保护的</p><ul><li>不需要保护的数据：<ul><li>内核任务的局部数据</li><li>局部自动变量</li><li>只被特定的进程访问的数据</li></ul></li><li>需要保护的数据：<ul><li>有不止一个的内核任务可以访问到的数据</li><li>任何其他东西能看到的数据</li></ul></li></ul><h3 id="7-1-4-死锁"><a class="header-anchor" href="#7-1-4-死锁">¶</a>7.1.4 死锁</h3><p>死锁的情境我已经知道了，说说预防死锁的方法：</p><ul><li>注意加锁的顺序</li><li>防止饥饿</li><li>不要重复请求同一个锁</li><li>加锁方案不要太复杂</li></ul><h3 id="7-1-5-并发执行的原因"><a class="header-anchor" href="#7-1-5-并发执行的原因">¶</a>7.1.5 并发执行的原因</h3><p>什么是并发执行呢？首先，并发执行分为两类：</p><ul><li>伪并发：交叉运行的两个进程</li><li>真并发：比如对称多处理器的机器，两个进程是真的可以同时在临界区执行</li></ul><p><strong>虽然有这两种并发，但共同点是它们都会引发竞争状态，都需要保护</strong></p><p>什么原因会造成并发呢？比如：</p><ul><li>中断：可以打断当前正在执行的代码（没懂为什么）</li><li>内核抢占：具有抢占性的内核，内核中的任务会被另一任务抢占</li><li>睡眠：假如内核执行的进程睡眠了，那么调度程序或许会调来一个新的进程执行</li><li>对称多处理</li></ul><p>理解这些原因可以帮助我们在写代码的时候，判断哪里需要加锁</p><h2 id="7-2-内核同步措施"><a class="header-anchor" href="#7-2-内核同步措施">¶</a>7.2 内核同步措施</h2><p>内核提供了<strong>一组同步方法来提供对共享数据的保护</strong>，可以避免并发，防止竞争</p><h3 id="7-2-1-原子操作"><a class="header-anchor" href="#7-2-1-原子操作">¶</a>7.2.1 原子操作</h3><p>Linux定义了原子类型，和对应的一些原子操作函数来实现这个机制</p><h3 id="7-2-2-自旋锁"><a class="header-anchor" href="#7-2-2-自旋锁">¶</a>7.2.2 自旋锁</h3><p>之前说过中断会引起并发执行，对于单处理器，关闭中断就可以了；但是对于多处理器，我们引入<strong>自旋锁</strong>来防止并发</p><p>自旋锁<strong>最多只能被一个</strong>内核任务持有，如果一个内核任务试图请求一个已被持有的自旋锁，那么这个任务就会一直<strong>忙等</strong></p><h3 id="7-2-3-信号量"><a class="header-anchor" href="#7-2-3-信号量">¶</a>7.2.3 信号量</h3><p>信号量是一种睡眠锁，也就是说，当内核任务等不到锁时，它就被放入等待队列，进入睡眠状态</p><p>（突然想顺带一提，这本书里任务=进程）</p><p>信号量的使用可以看以前的操作系统笔记</p><h2 id="7-3-生产者-消费者并发实例"><a class="header-anchor" href="#7-3-生产者-消费者并发实例">¶</a>7.3 生产者-消费者并发实例</h2><h2 id="7-4-内核多任务并发实例"><a class="header-anchor" href="#7-4-内核多任务并发实例">¶</a>7.4 内核多任务并发实例</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《Linux操作系统原理与应用(E2)》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter5 中断和异常</title>
      <link href="2021/02/26/Chapter5-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
      <url>2021/02/26/Chapter5-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>中断的出现，改变了处理器需要不断查询的情况。中断分为外部中断（硬件中断）、内部中断（异常）</p><h2 id="5-1-中断是什么"><a class="header-anchor" href="#5-1-中断是什么">¶</a>5.1 中断是什么</h2><h3 id="5-1-1-中断向量"><a class="header-anchor" href="#5-1-1-中断向量">¶</a>5.1.1 中断向量</h3><p>什么是中断向量？</p><p>就是一个数，系统把中断源编号了，每个数字对应一种中断源，所以中断向量就可以帮助我们了解中断源。</p><p>中断向量一共有256种，分为异常和中断；异常又分为陷阱trap和故障fault，中断又分为外部可/非屏蔽中断</p><h3 id="5-1-2-外设可屏蔽中断"><a class="header-anchor" href="#5-1-2-外设可屏蔽中断">¶</a>5.1.2 外设可屏蔽中断</h3><h3 id="5-1-3-异常及非屏蔽中断"><a class="header-anchor" href="#5-1-3-异常及非屏蔽中断">¶</a>5.1.3 异常及非屏蔽中断</h3><h3 id="5-1-4-中断描述符表"><a class="header-anchor" href="#5-1-4-中断描述符表">¶</a>5.1.4 中断描述符表</h3><p>描述了更多信息？</p><h3 id="5-1-5-相关汇编指令"><a class="header-anchor" href="#5-1-5-相关汇编指令">¶</a>5.1.5 相关汇编指令</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《Linux操作系统原理与应用(E2)》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter4 内存寻址</title>
      <link href="2021/02/24/Chapter4-%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/"/>
      <url>2021/02/24/Chapter4-%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-Linux的内存管理概述"><a class="header-anchor" href="#4-1-Linux的内存管理概述">¶</a>4.1 Linux的内存管理概述</h2><p>Linux是多用户多任务的，并实现了虚存技术</p><h3 id="4-1-1-虚拟内存、内核空间和用户空间"><a class="header-anchor" href="#4-1-1-虚拟内存、内核空间和用户空间">¶</a>4.1.1 虚拟内存、内核空间和用户空间</h3><p>Linux简化了分段机制，使得虚拟地址和线性地址总是一致的。</p><p>虚拟地址空间是4GB，最高1GB是内核空间（放的是内核代码和数据），下面3GB是用户空间（放的是用户代码和数据）。内核空间是所有进程共享的，结构示意图如下：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210224165919056.png" alt="image-20210224165919056" style="height:250px;width:500px"><p>任何一个时刻CPU上只有一个进程在运行，所以每一时刻系统都只有一个4GB的虚拟地址空间。</p><p>**用户空间不是被进程共享的，而是被进程隔离的。**不同的进程的同一个地址对应的是不同的内容哦。这是为什么呢？</p><p>因为CPU将虚拟地址转换为物理地址，靠的是每个进程的页表；既然每个进程的页表不同，那么转换的结果也就不同了。</p><p><strong>内核空间中的内核程序，和用户空间中的用户程序，它们编译链接后形成的地址空间是一个虚拟地址空间。</strong></p><h4 id="1-内核空间到物理内存的映射"><a class="header-anchor" href="#1-内核空间到物理内存的映射">¶</a>1. 内核空间到物理内存的映射</h4><p>见下图：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210224172008342.png" alt="image-20210224172008342" style="height:400px;width:430px"><h4 id="2-内核映像"><a class="header-anchor" href="#2-内核映像">¶</a>2. 内核映像</h4><p>内核映像这个词听起来比较抽象，它其实是：内核的代码和数据。</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210224173830494.png" alt="image-20210224173830494" style="height:150px;width:700px"><p>（这一段我看的好晕QWQ）</p><h3 id="4-1-2-虚拟内存实现机制间的关系"><a class="header-anchor" href="#4-1-2-虚拟内存实现机制间的关系">¶</a>4.1.2 虚拟内存实现机制间的关系</h3><p>实现虚存需要很多机制的支持，比如：</p><ul><li>地址映射机制</li><li>请页机制</li><li>内存分配和回收机制</li><li>交换机制</li><li>缓存和刷新机制</li></ul><p>它们之间的关系如下图所示：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210224231527062.png" alt="image-20210224231527062" style="height:330px;width:700px"><h2 id="4-2-进程的用户空间管理"><a class="header-anchor" href="#4-2-进程的用户空间管理">¶</a>4.2 进程的用户空间管理</h2><p>每个进程最大可以拥有3GB的私有虚存空间，那么这3GB是如何划分的？如下图所示：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210225001310006.png" alt="image-20210225001310006" style="height:500px;width:200px"><p>BSS=Block Started by Symbol，是未初始化的数据段。</p><p>内核在创建进程时，并不是为整个用户空间都分配物理空间，而是采用请页的方法（按需调页）</p><h3 id="4-2-1-进程用户空间的描述"><a class="header-anchor" href="#4-2-1-进程用户空间的描述">¶</a>4.2.1 进程用户空间的描述</h3><p>用两个数据结构来描述：</p><ul><li>mm_struct内存描述符：描述一个进程的虚拟地址空间</li><li>VM_AREA_STRUCT：用来描述进程用户空间的一个虚拟内存区间（虚存区=代码区+未初始化数据区+数据区+堆栈区）</li></ul><p>这两个结构之间也是有关系的</p><h3 id="4-2-2-进程用户空间的创建"><a class="header-anchor" href="#4-2-2-进程用户空间的创建">¶</a>4.2.2 进程用户空间的创建</h3><ul><li>进程的用户空间创建，是fork()来完成的</li><li>对于用户进程，子进程采用<strong>写时复制</strong>的方法逐渐建立完全属于自己的用户空间；内核进程，子进程继承父进程的用户空间</li></ul><h3 id="4-2-3-虚存映射"><a class="header-anchor" href="#4-2-3-虚存映射">¶</a>4.2.3 虚存映射</h3><p>什么是虚存映射？</p><p>首先来捋一下概念，程序运行时，它的代码数据等等（可执行映像），会从磁盘装入内存，但是内存分为有两种说法，一种是虚拟内存（用户空间、线性地址），一种是物理内存；Linux的实际做法，是把可执行映像装入虚存中，也就是用户空间。</p><p>这样操作之后，对磁盘上文件的访问，就变成了对虚存区的访问，这就叫<strong>虚存映射</strong>。</p><p>虚存映射分为三类：</p><ul><li>共享映射：几个进程共享这一映射（比如几个进程都用到同一文件，这份文件对应的虚存被大家共享？），一个进程对虚存区写，会改变磁盘文件，且其他进程能“看到”</li><li>私有映射：这种映射只有读文件的功能，效率比共享映射高</li><li>匿名映射：映射与文件无关（？？？）</li></ul><h3 id="4-2-4-进程的虚存区举例"><a class="header-anchor" href="#4-2-4-进程的虚存区举例">¶</a>4.2.4 进程的虚存区举例</h3><h3 id="4-2-5-与用户空间相关的系统调用"><a class="header-anchor" href="#4-2-5-与用户空间相关的系统调用">¶</a>4.2.5 与用户空间相关的系统调用</h3><ul><li>fork()</li><li>mmap()</li><li>munmap()</li><li>exec()</li><li>Exit()</li></ul><h2 id="4-3-请页机制"><a class="header-anchor" href="#4-3-请页机制">¶</a>4.3 请页机制</h2><p>为了节约物理内存，用户空间中的少量页才会被调入物理内存。当对应的虚存页面没有被装入物理内存时，就会报告页故障。页故障有以下三个产生原因：</p><ul><li>程序出错。例如要访问的虚地址超过用户空间范围</li><li>缺页异常。就是虚地址有效但对应的物理页面不在范围内</li><li>保护错误。要访问的虚地址被“写保护”，根据不同情况，处理方法不同</li></ul><p>缺页异常整个处理流程（简单版和完整版）：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210225143752072.png" alt="image-20210225143752072"></p><h3 id="4-3-2-请求调页"><a class="header-anchor" href="#4-3-2-请求调页">¶</a>4.3.2 请求调页</h3><p>请求调页大部分还是好处多多的，但是也要付出额外的开销：浪费CPU的周期去处理缺页异常。不过幸好，按规律来说，缺页异常算是稀有事件。</p><p>有两种情况，被寻址的页面可以不在物理内存中：（？？？）</p><ul><li>进程永远也没有访问到这个页</li><li>进程已经访问过这个页，但这个页的内容被临时保存在磁盘上</li></ul><h3 id="4-3-3-写时复制"><a class="header-anchor" href="#4-3-3-写时复制">¶</a>4.3.3 写时复制</h3><p>写时复制是一种可以推迟甚至免除拷贝数据的技术</p><h2 id="4-4-物理内存分配与回收"><a class="header-anchor" href="#4-4-物理内存分配与回收">¶</a>4.4 物理内存分配与回收</h2><h3 id="4-4-1-页描述符"><a class="header-anchor" href="#4-4-1-页描述符">¶</a>4.4.1 页描述符</h3><p>从虚存的角度来看，页就是最小单位。</p><p>内核用struct page结构来表示系统中的每个物理页（也叫作页描述符）</p><h3 id="4-4-2-伙伴算法"><a class="header-anchor" href="#4-4-2-伙伴算法">¶</a>4.4.2 伙伴算法</h3><p>看不太懂</p><h3 id="4-4-3-物理页面的分配"><a class="header-anchor" href="#4-4-3-物理页面的分配">¶</a>4.4.3 物理页面的分配</h3><p>Linux使用伙伴算法有效地分配和回收物理页块</p><h3 id="4-4-4-物理页面的回收"><a class="header-anchor" href="#4-4-4-物理页面的回收">¶</a>4.4.4 物理页面的回收</h3><p>页回收的过程与页分配的过程相反，只要可能，它就把小页块合并成大的页块</p><h3 id="4-4-5-Slab分配机制"><a class="header-anchor" href="#4-4-5-Slab分配机制">¶</a>4.4.5 Slab分配机制</h3><p>伙伴算法来做页分配的话，每次一个页面起步；但如果需要更少的空间，就用Slab</p><h3 id="4-4-6-内核空间非连续内存区的分配"><a class="header-anchor" href="#4-4-6-内核空间非连续内存区的分配">¶</a>4.4.6 内核空间非连续内存区的分配</h3><p>非连续内存位于3GB-4GB之间，是内核空间</p><p>什么时候才会分配非连续的内存呢？</p><h3 id="4-4-7-物理内存分配举例"><a class="header-anchor" href="#4-4-7-物理内存分配举例">¶</a>4.4.7 物理内存分配举例</h3><ul><li>伙伴算法的_get_free_pages()能分配一个或多个连续的物理页面</li><li>kmalloc()可以为不足一个页面的需求分配内存</li><li>vmalloc()可以获得大块的内存区</li></ul><h2 id="4-5-交换机制"><a class="header-anchor" href="#4-5-交换机制">¶</a>4.5 交换机制</h2><p>当物理内存不足时，Linux内存管理子系统需要释放部分物理内存页面</p><h3 id="4-5-1-交换的基本原理"><a class="header-anchor" href="#4-5-1-交换的基本原理">¶</a>4.5.1 交换的基本原理</h3><p>页面交换是用时间换空间，要考虑以下三个因素：</p><ul><li>哪种页面被换出</li><li>如何在交换区中存放页面</li><li>如何选择被交换出的页面</li></ul><h4 id="1-哪种页面被换出"><a class="header-anchor" href="#1-哪种页面被换出">¶</a>1. 哪种页面被换出</h4><p>映射到用户空间的页面可以被换出，内核空间的不会被换出</p><h4 id="2-如何在交换区中存放页面"><a class="header-anchor" href="#2-如何在交换区中存放页面">¶</a>2. 如何在交换区中存放页面</h4><p>交换区也是被划分成页面大小的一块一块的，每一块叫一个页插槽；也就是说，一个物理页面插入一个插槽中。</p><p>存到交换区中时，要尽量把页面放在相邻的插槽中。</p><h4 id="3-如何选择被交换出的页面"><a class="header-anchor" href="#3-如何选择被交换出的页面">¶</a>3. 如何选择被交换出的页面</h4><p>有几种不同的策略可供讨论：</p><ul><li>需要时才交换：每当缺页异常发生时，就给它分配一个物理页面</li><li>系统空闲时才交换：（这是积极的交换策略）预先腾出一些页面，维持空闲区域，使得发生缺页的时候总有位置可用</li><li>换出但不立即释放：将释放推迟到必要时才进行</li><li>把页面换出推迟到不能再推迟为止：</li></ul><h3 id="4-5-2-页面交换守护进程kswapd"><a class="header-anchor" href="#4-5-2-页面交换守护进程kswapd">¶</a>4.5.2 页面交换守护进程kswapd</h3><p>为了避免在换页的时候临时去处理从而增加CPU的负担，所以提前用这个进程来定期将页面换出</p><h2 id="4-6-内存管理实例"><a class="header-anchor" href="#4-6-内存管理实例">¶</a>4.6 内存管理实例</h2><p>这一节中我们要做的：</p><p>将内核的一部分虚拟内存映射到用户空间</p><h3 id="4-6-1-相关背景知识"><a class="header-anchor" href="#4-6-1-相关背景知识">¶</a>4.6.1 相关背景知识</h3><p>在内核空间中，用kmalloc()分配连续物理空间，用vmalloc()分配非连续物理空间</p><p><strong>内核虚地址-PAGE_OFFSET=实际的物理地址</strong></p><h3 id="4-6-2-代码体系结构介绍"><a class="header-anchor" href="#4-6-2-代码体系结构介绍">¶</a>4.6.2 代码体系结构介绍</h3><p>虚拟字符设备驱动程序，可以将系统内核空间映射到用户空间，这其中包括了两步：</p><ol><li>找到内核空间的地址对应的物理地址</li><li>建立新的用户页表项</li></ol><p>经过以上两步，可以使得用户空间和内核空间映射到同一物理地址；物理地址作为中介的话，访问用户空间就等于访问了内核空间</p><p>【未完待续】</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《Linux操作系统原理与应用(E2)》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter3 进程</title>
      <link href="2021/02/19/Chapter3-%E8%BF%9B%E7%A8%8B/"/>
      <url>2021/02/19/Chapter3-%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-进程介绍"><a class="header-anchor" href="#3-1-进程介绍">¶</a>3.1 进程介绍</h2><p>​操作系统的设计者抽象出了进程这样一个逻辑概念，使得并行更容易被理解和处理</p><h3 id="3-1-1-程序和进程"><a class="header-anchor" href="#3-1-1-程序和进程">¶</a>3.1.1 程序和进程</h3><h4 id="（1）程序和进程的区别"><a class="header-anchor" href="#（1）程序和进程的区别">¶</a>（1）程序和进程的区别</h4><ul><li>程序是一个普通的可执行文件，是机器代码指令和数据的集合</li><li>进程有点像运行中的程序，除了程序所包含的内容，有一些额外的数据（如寄存器的值等等）；它是动态的，随着程序指令执行而不断变化，某时刻进程的内容被称为进程映像</li></ul><h4 id="（2）进程的定义"><a class="header-anchor" href="#（2）进程的定义">¶</a>（2）进程的定义</h4><p>​进程是由正文段+用户数据段+系统数据段组成的执行环境</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210219090126874.png" alt="image-20210219090126874" style="width:500px;height:280px"><h3 id="3-1-2-进程的层次结构"><a class="header-anchor" href="#3-1-2-进程的层次结构">¶</a>3.1.2 进程的层次结构</h3><p><strong>一个进程不会平白无故地诞生，它总有自己的父母。</strong>（除了init进程）</p><p>一个进程只有一个父进程，但可以有多个子进程。Linux系统有进程树：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210223102330119.png" alt="image-20210223102330119" style="height:280px;width:500px"><h3 id="3-1-3-进程状态"><a class="header-anchor" href="#3-1-3-进程状态">¶</a>3.1.3 进程状态</h3><p>有三种基本的进程状态和四种它们之间的转换关系：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210223103526357.png" alt="image-20210223103526357" style="width:600px;height:260px"><h2 id="3-2-Linux系统中的进程控制块PCB"><a class="header-anchor" href="#3-2-Linux系统中的进程控制块PCB">¶</a>3.2 Linux系统中的进程控制块PCB</h2><p>在Linux系统实现中，PCB对应的数据结构是：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>{</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>PCB是一个相当庞大的结构体，它的所有域可以这样分类：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210223113320811.png" alt="image-20210223113320811"></p><p><strong>系统是根据进程的PCB感知进程的存在的。所以说，PCB是进程存在和运行的唯一标志</strong></p><p>系统创建新进程时，为它建立了一个PCB；在进程运行过程中，会读写其中的信息（所以PCB应该常驻内存结构）；进程结束时系统会回收PCB</p><p>Linux系统中，进程和线程的实现采用了同样的方式</p><h3 id="3-2-1-进程状态"><a class="header-anchor" href="#3-2-1-进程状态">¶</a>3.2.1 进程状态</h3><p>这里貌似和操作系统课里面学的状态不太一样了……下图展示了Linux进程状态的转换及其所调用的内核函数：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210223130856361.png" alt="image-20210223130856361" style="height:500px;width:750px"><h3 id="3-2-2-进程标识符"><a class="header-anchor" href="#3-2-2-进程标识符">¶</a>3.2.2 进程标识符</h3><p>每个进程都有如下三种标识符：</p><ul><li>进程标识符PID：唯一的；被顺序编号，后一个进程的PID是一般是前一个进程PID+1</li><li>用户标识符UID和组标识符GID：用于安全控制</li></ul><h3 id="3-2-3-进程之间的亲属关系"><a class="header-anchor" href="#3-2-3-进程之间的亲属关系">¶</a>3.2.3 进程之间的亲属关系</h3><p>每个进程的PCB结构里面是有亲属信息的，大概有以下几种：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210223134858644.png" alt="image-20210223134858644" style="height:300px;width:450px"><h3 id="3-2-4-进程控制块的存放"><a class="header-anchor" href="#3-2-4-进程控制块的存放">¶</a>3.2.4 进程控制块的存放</h3><p>就是说PCB放在哪里的问题，有用的话回头看看</p><h3 id="3-2-5-当前进程"><a class="header-anchor" href="#3-2-5-当前进程">¶</a>3.2.5 当前进程</h3><h2 id="3-3-Linux系统中进程的组织方式"><a class="header-anchor" href="#3-3-Linux系统中进程的组织方式">¶</a>3.3 Linux系统中进程的组织方式</h2><p>如何用适当的方式把PCB组织起来呢？</p><h3 id="3-3-1-进程链表"><a class="header-anchor" href="#3-3-1-进程链表">¶</a>3.3.1 进程链表</h3><p>系统用一个双向循环链表把所有进程的PCB联系起来</p><h3 id="3-3-2-哈希表"><a class="header-anchor" href="#3-3-2-哈希表">¶</a>3.3.2 哈希表</h3><p>为了使得内核可以根据对应进程的PID导出对应的PCB，我们可以把PID哈希成表的索引。关于冲突问题，可以这样解决：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210223204147381.png" alt="image-20210223204147381" style="height:300px;width:600px;"><h3 id="3-3-3-就绪队列"><a class="header-anchor" href="#3-3-3-就绪队列">¶</a>3.3.3 就绪队列</h3><p>就绪队列也是一个双向循环链表组织起来的哦</p><h3 id="3-3-4-等待队列"><a class="header-anchor" href="#3-3-4-等待队列">¶</a>3.3.4 等待队列</h3><p>等待也叫睡眠，Linux有两种睡眠：深度和浅度</p><h4 id="1-等待队列的数据结构"><a class="header-anchor" href="#1-等待队列的数据结构">¶</a>1. 等待队列的数据结构</h4><h4 id="2-等待队列头"><a class="header-anchor" href="#2-等待队列头">¶</a>2. 等待队列头</h4><h4 id="3-等待队列的操作"><a class="header-anchor" href="#3-等待队列的操作">¶</a>3. 等待队列的操作</h4><h2 id="3-4-进程调度"><a class="header-anchor" href="#3-4-进程调度">¶</a>3.4 进程调度</h2><h3 id="3-4-1-基本原理"><a class="header-anchor" href="#3-4-1-基本原理">¶</a>3.4.1 基本原理</h3><p>一个好的调度策略主要考虑以下几个方面：</p><ul><li>公平</li><li>高效</li><li>响应时间</li><li>周转时间</li><li>吞吐量</li></ul><p>了解一下以下调度算法</p><h4 id="1-时间片轮转调度算法"><a class="header-anchor" href="#1-时间片轮转调度算法">¶</a>1. 时间片轮转调度算法</h4><h4 id="2-优先权调度算法"><a class="header-anchor" href="#2-优先权调度算法">¶</a>2. 优先权调度算法</h4><ul><li>抢占式</li><li>非抢占式</li></ul><h4 id="3-多级反馈队列调度"><a class="header-anchor" href="#3-多级反馈队列调度">¶</a>3. 多级反馈队列调度</h4><p>综合了时间片轮转与抢占式优先权：优先权高的进程先运行给定的时间片，相同优先权的进程轮流运行给定的时间片</p><h4 id="4-实时调度"><a class="header-anchor" href="#4-实时调度">¶</a>4. 实时调度</h4><p>这是实时系统中的调度，对外部事件有求必应、尽快响应，一般是抢占式</p><h3 id="3-4-2-时间片"><a class="header-anchor" href="#3-4-2-时间片">¶</a>3.4.2 时间片</h3><p>时间片表明进程在被抢占前所能持续运行的时间</p><h3 id="3-4-3-Linux进程调度时机"><a class="header-anchor" href="#3-4-3-Linux进程调度时机">¶</a>3.4.3 Linux进程调度时机</h3><p>在以下几种情况中需要调度：</p><ul><li>进程状态转换：进程终止、进程睡眠</li><li>进程时间片用完</li><li>设备驱动程序运行时</li><li>从内核态返回用户态时（？？？）</li></ul><h3 id="3-4-4-进程调度的依据"><a class="header-anchor" href="#3-4-4-进程调度的依据">¶</a>3.4.4 进程调度的依据</h3><p>也就是，从就绪态进程中选择一个来运行的依据。</p><p>进程的PCB中有一些域可以帮助选择</p><h3 id="3-4-5-调度函数shedule-的实现"><a class="header-anchor" href="#3-4-5-调度函数shedule-的实现">¶</a>3.4.5 调度函数shedule()的实现</h3><p>**调度程序在内核中就是一个函数。**书上贴了源代码和部分注释，可以看一下。</p><h3 id="3-4-6-Linux-2-6调度程序的改进"><a class="header-anchor" href="#3-4-6-Linux-2-6调度程序的改进">¶</a>3.4.6 Linux 2.6调度程序的改进</h3><p>**单就绪队列是影响调度性能的主要问题之一。**所以改进就绪队列就成了改进调度算法的入口点</p><h2 id="3-5-进程的创建"><a class="header-anchor" href="#3-5-进程的创建">¶</a>3.5 进程的创建</h2><p>Linux通过两个函数的结合使用来实现进程创建</p><ul><li>创建用fork()：通过拷贝当前进程创建一个子进程</li><li>执行进程用exec()：负责读取可执行文件并将其载入进程的地址空间开始运行</li></ul><h3 id="3-5-1-创建进程"><a class="header-anchor" href="#3-5-1-创建进程">¶</a>3.5.1 创建进程</h3><p>新进程是通过克隆父进程来创建的。子进程创建结束，<strong>从内核态返回用户态</strong>，用户态进程来安排子进程和父进程执行不同的代码</p><h3 id="3-5-2-线程及其创建"><a class="header-anchor" href="#3-5-2-线程及其创建">¶</a>3.5.2 线程及其创建</h3><p>Linux把所有的线程当做进程来实现。但内核线程和普通进程还是有一定区别的</p><h2 id="3-6-与进程相关的系统调用及其应用"><a class="header-anchor" href="#3-6-与进程相关的系统调用及其应用">¶</a>3.6 与进程相关的系统调用及其应用</h2><p>fork、exec、wait、exit</p><p>这一节末尾有一个很好的比喻</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《Linux操作系统原理与应用(E2)》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux shell程序设计学习</title>
      <link href="2021/01/16/Linux-shell%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/01/16/Linux-shell%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-shell简介"><a class="header-anchor" href="#1-shell简介">¶</a>1. shell简介</h2><h3 id="1-1-shell环境"><a class="header-anchor" href="#1-1-shell环境">¶</a>1.1 shell环境</h3><p>Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p>Linux 的 Shell 种类众多，常见的有：</p><ul><li>Bourne Shell（/usr/bin/sh或/bin/sh）</li><li>Bourne Again Shell（/bin/bash）</li><li>C Shell（/usr/bin/csh）</li><li>K Shell（/usr/bin/ksh）</li><li>Shell for Root（/sbin/sh）</li></ul><p>本教程关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。</p><p>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。</p><p><code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。要写在shell脚本的开头，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo "Hello World !"</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2-如何运行shell脚本"><a class="header-anchor" href="#1-2-如何运行shell脚本">¶</a>1.2 如何运行shell脚本</h3><h4 id="（1）作为可执行程序"><a class="header-anchor" href="#（1）作为可执行程序">¶</a>（1）作为可执行程序</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class="line">./test.sh  #执行脚本</span><br></pre></td></tr></tbody></table></figure><p>注意，一定要写成 ./test.sh，而不是 <a href="http://test.sh">test.sh</a>，运行其它二进制的程序也一样，直接写 <a href="http://test.sh">test.sh</a>，linux 系统会去 PATH 里寻找有没有叫 <a href="http://test.sh">test.sh</a> 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 <a href="http://test.sh">test.sh</a> 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p><h4 id="（2）作为解释器参数"><a class="header-anchor" href="#（2）作为解释器参数">¶</a>（2）作为解释器参数</h4><p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh test.sh</span><br><span class="line">/bin/php test.php</span><br></pre></td></tr></tbody></table></figure><p>这种方式运行的脚本，<strong>不需要在第一行指定解释器信息</strong>，写了也没用。</p><h2 id="2-shell变量"><a class="header-anchor" href="#2-shell变量">¶</a>2. shell变量</h2><h3 id="2-1-变量定义"><a class="header-anchor" href="#2-1-变量定义">¶</a>2.1 变量定义</h3><h4 id="（1）显式定义"><a class="header-anchor" href="#（1）显式定义">¶</a>（1）显式定义</h4><p>规则如下：</p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li><li>定义变量时，变量名不加美元符号</li><li>变量名和等号之间不能有空格</li></ul><h4 id="（2）用语句定义"><a class="header-anchor" href="#（2）用语句定义">¶</a>（2）用语句定义</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for file in `ls /etc`</span><br><span class="line">或</span><br><span class="line">for file in $(ls /etc)</span><br></pre></td></tr></tbody></table></figure><p>以上语句将 /etc 下目录的文件名循环出来</p><h3 id="2-2-使用变量"><a class="header-anchor" href="#2-2-使用变量">¶</a>2.2 使用变量</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name="qinjx"</span><br><span class="line">echo $your_name</span><br><span class="line">echo ${your_name} //花括号是可选的，为了区分变量边界（有时候很必要）</span><br></pre></td></tr></tbody></table></figure><h4 id="只读变量"><a class="header-anchor" href="#只读变量">¶</a>只读变量</h4><p>可以在定义之后写：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myUrl="https://www.google.com"</span><br><span class="line">readonly myUrl</span><br></pre></td></tr></tbody></table></figure><p>记上readonly就好啦</p><h3 id="2-3-删除变量"><a class="header-anchor" href="#2-3-删除变量">¶</a>2.3 删除变量</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset variable_name</span><br></pre></td></tr></tbody></table></figure><p>注意：变量被删除后不能再次使用。unset 命令不能删除只读变量。</p><h3 id="2-4-变量类型"><a class="header-anchor" href="#2-4-变量类型">¶</a>2.4 变量类型</h3><ul><li>局部变量：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li>环境变量：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li>shell变量：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ul><h3 id="2-5-shell字符串"><a class="header-anchor" href="#2-5-shell字符串">¶</a>2.5 shell字符串</h3><p>好像shell中的变量基本就是两种类型：数字和字符串……字符串可以用单引号，也可以用双引号，<strong>也可以不用引号</strong>。</p><h4 id="（1）单引号"><a class="header-anchor" href="#（1）单引号">¶</a>（1）单引号</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str='this is a string'</span><br></pre></td></tr></tbody></table></figure><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号<strong>字符串中的变量是无效的</strong>；</li><li>单引号字串中<strong>不能出现单独一个的单引号</strong>（对单引号使用转义符后也不行），<strong>但可成对出现，作为字符串拼接使用</strong>。</li></ul><h4 id="（2）双引号"><a class="header-anchor" href="#（2）双引号">¶</a>（2）双引号</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">your_name='runoob'</span><br><span class="line">str="Hello, I know you are \"$your_name\"! \n"</span><br><span class="line">echo -e $str//-e的作用？</span><br><span class="line"></span><br><span class="line">//输出：Hello, I know you are "runoob"! </span><br></pre></td></tr></tbody></table></figure><p>双引号的优点：（这么好的话，那就一直用双引号好啦）</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><h4 id="（3）字符串拼接"><a class="header-anchor" href="#（3）字符串拼接">¶</a>（3）字符串拼接</h4><p>单引号、双引号都可以用于拼接</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">your_name="runoob"</span><br><span class="line"># 使用双引号拼接</span><br><span class="line">greeting="hello, "$your_name" !"</span><br><span class="line">greeting_1="hello, ${your_name} !"</span><br><span class="line">echo $greeting  $greeting_1//输出： hello, runoob ! hello, runoob !</span><br><span class="line"></span><br><span class="line"># 使用单引号拼接</span><br><span class="line">greeting_2='hello, '$your_name' !'</span><br><span class="line">greeting_3='hello, ${your_name} !'</span><br><span class="line">echo $greeting_2  $greeting_3//输出：hello, runoob ! hello, ${your_name} !</span><br></pre></td></tr></tbody></table></figure><h4 id="（4）获取字符串长度"><a class="header-anchor" href="#（4）获取字符串长度">¶</a>（4）获取字符串长度</h4><p>加上<code>#</code>号：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string="abcd"</span><br><span class="line">echo ${#string} #输出 4</span><br></pre></td></tr></tbody></table></figure><h4 id="（5）提取子字符串"><a class="header-anchor" href="#（5）提取子字符串">¶</a>（5）提取子字符串</h4><p>查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string="runoob is a great site"</span><br><span class="line">echo `expr index "$string" io`  # 输出 4</span><br><span class="line">//或者写成：echo $(expr index "$string" io)</span><br></pre></td></tr></tbody></table></figure><p><strong>这个不是从0开始计数的哦~</strong></p><h3 id="2-6-shell数组"><a class="header-anchor" href="#2-6-shell数组">¶</a>2.6 shell数组</h3><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。</p><p>类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。</p><h4 id="（1）定义"><a class="header-anchor" href="#（1）定义">¶</a>（1）定义</h4><p>一般形式是（用空格数组元素分开）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名=(值1 值2 ... 值n)</span><br></pre></td></tr></tbody></table></figure><p>实际使用中，可以有不同的变式：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//常规的</span><br><span class="line">array_name=(value0 value1 value2 value3)</span><br><span class="line"></span><br><span class="line">//竖着写的</span><br><span class="line">array_name=(</span><br><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//一个个写的：可以不使用连续的下标，而且下标的范围没有限制。</span><br><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br></pre></td></tr></tbody></table></figure><h4 id="（2）读取数组"><a class="header-anchor" href="#（2）读取数组">¶</a>（2）读取数组</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">${数组名[下标]}</span><br><span class="line"></span><br><span class="line">//读取第n个元素</span><br><span class="line">valuen=${array_name[n]}</span><br><span class="line"></span><br><span class="line">//读取所有元素：用@符号或者*符号</span><br><span class="line">echo ${array_name[@]}</span><br></pre></td></tr></tbody></table></figure><h4 id="（3）获取数组的长度"><a class="header-anchor" href="#（3）获取数组的长度">¶</a>（3）获取数组的长度</h4><p>其实和获取字符串的长度很像啦：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 取得数组元素的个数</span><br><span class="line">length=${#array_name[@]}</span><br><span class="line"># 或者（是最常见的*代表all诶！）</span><br><span class="line">length=${#array_name[*]}</span><br><span class="line"># 取得数组单个元素的长度</span><br><span class="line">lengthn=${#array_name[n]}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-7-shell注释"><a class="header-anchor" href="#2-7-shell注释">¶</a>2.7 shell注释</h3><h4 id="（1）单行"><a class="header-anchor" href="#（1）单行">¶</a>（1）单行</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># slogan：学的不仅是技术，更是梦想！</span><br><span class="line">#--------------------------------------------</span><br><span class="line">##### 用户配置区 开始 #####</span><br></pre></td></tr></tbody></table></figure><h4 id="（2）多行"><a class="header-anchor" href="#（2）多行">¶</a>（2）多行</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#方法一</span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">#方法二</span><br><span class="line">:&lt;&lt;'</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">'</span><br><span class="line"></span><br><span class="line">#方法三</span><br><span class="line">:&lt;&lt;!</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">!</span><br></pre></td></tr></tbody></table></figure><h4 id="（3）注释代码（需要时不时取消注释的）"><a class="header-anchor" href="#（3）注释代码（需要时不时取消注释的）">¶</a>（3）注释代码（需要时不时取消注释的）</h4><p>可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。（好神奇的操作）</p><h2 id="3-shell传递参数"><a class="header-anchor" href="#3-shell传递参数">¶</a>3. shell传递参数</h2><p>shell的参数有一点命令行参数的味道，应该差不多是一种东西吧。它的引用就很简单粗暴，直接用数字作为序号就可以了。假如我们写了这个脚本：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo "Shell 传递参数实例！";</span><br><span class="line">echo "执行的文件名：$0";</span><br><span class="line">echo "第一个参数为：$1";</span><br><span class="line">echo "第二个参数为：$2";</span><br><span class="line">echo "第三个参数为：$3";</span><br></pre></td></tr></tbody></table></figure><p>然后执行它：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh 1 2 3</span><br><span class="line">Shell 传递参数实例！</span><br><span class="line">执行的文件名：./test.sh</span><br><span class="line">第一个参数为：1</span><br><span class="line">第二个参数为：2</span><br><span class="line">第三个参数为：3</span><br></pre></td></tr></tbody></table></figure><p>和参数相关的处理还有以下几种：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">参数处理说明</span><br><span class="line">$#传递到脚本的参数个数</span><br><span class="line">$*以一个单字符串显示所有向脚本传递的参数。</span><br><span class="line">如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。</span><br><span class="line">$$脚本运行的当前进程ID号</span><br><span class="line">$!后台运行的最后一个进程的ID号</span><br><span class="line">$@与$*相同，但是使用时加引号，并在引号中返回每个参数。</span><br><span class="line">如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。</span><br><span class="line">$-显示Shell使用的当前选项，与set命令功能相同。</span><br><span class="line">$?显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td>$#</td><td>传递到脚本的参数个数</td></tr><tr><td>$*</td><td>以一个单字符串显示所有向脚本传递的参数</td></tr><tr><td>$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的ID号</td></tr><tr><td>$@</td><td>与$*相同</td></tr><tr><td>$-</td><td>显示Shell使用的当前选项，与set命令功能相同</td></tr><tr><td>$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误</td></tr></tbody></table><p>注：对<code>$*</code>和<code>$@</code>的进一步解释</p><ul><li>如"$*“用「”」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。</li><li>与$*相同，但是使用时加引号，并在引号中返回每个参数。如"$@“用「”」括起来的情况、以"$1" “$2” … “$n” 的形式输出所有参数。</li></ul><p>$* 与 $@ 区别：</p><ul><li>相同点：都是引用所有参数。</li><li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo "-- \$* 演示 ---"</span><br><span class="line">for i in "$*"; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "-- \$@ 演示 ---"</span><br><span class="line">for i in "$@"; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh 1 2 3</span><br><span class="line">-- $* 演示 ---</span><br><span class="line">1 2 3</span><br><span class="line">-- $@ 演示 ---</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure><h2 id="4-shell基本运算符"><a class="header-anchor" href="#4-shell基本运算符">¶</a>4. shell基本运算符</h2><h3 id="4-1-算数运算符"><a class="header-anchor" href="#4-1-算数运算符">¶</a>4.1 算数运算符</h3><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。expr 是一款表达式计算工具，使用它能完成表达式的求值操作。写一个你就懂啦：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">val=`expr 2 + 2`</span><br><span class="line">echo "两数之和为 : $val"</span><br></pre></td></tr></tbody></table></figure><p>注意：</p><ul><li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。（该有空格要有，不该有则不能有）</li><li>完整的表达式要被一对反引号包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li></ul><p>常用的算术运算符如下：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116200128.png" alt=""></p><p>注意：</p><ul><li>乘号(*)前边必须加反斜杠()才能实现乘法运算；</li><li>if…then…fi 是条件语句，后续将会讲解。</li><li>在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 “*” 不需要转义符号 “” 。</li></ul><h3 id="4-2-关系运算符"><a class="header-anchor" href="#4-2-关系运算符">¶</a>4.2 关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116200344.png" alt=""></p><h3 id="4-3-布尔运算符"><a class="header-anchor" href="#4-3-布尔运算符">¶</a>4.3 布尔运算符</h3><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116200417.png" alt=""></p><h3 id="4-4-字符串运算符"><a class="header-anchor" href="#4-4-字符串运算符">¶</a>4.4 字符串运算符</h3><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116202630.png" alt=""></p><h3 id="4-5-文件测试运算符"><a class="header-anchor" href="#4-5-文件测试运算符">¶</a>4.5 文件测试运算符</h3><p>文件测试运算符用于检测 Unix 文件的各种属性。</p><p>属性检测描述如下：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116202704.png" alt=""></p><h2 id="5-shell-echo命令"><a class="header-anchor" href="#5-shell-echo命令">¶</a>5. shell echo命令</h2><p>可以看做一个输出命令啦</p><h3 id="5-1-显示普通字符串"><a class="header-anchor" href="#5-1-显示普通字符串">¶</a>5.1 显示普通字符串</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo "It is a test"</span><br><span class="line">或</span><br><span class="line">echo It is a test</span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-显示转义字符"><a class="header-anchor" href="#5-2-显示转义字符">¶</a>5.2 显示转义字符</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo "\"It is a test\""</span><br><span class="line">//输出："It is a test"</span><br></pre></td></tr></tbody></table></figure><p>同样地：双引号可以省略</p><h3 id="5-3-显示变量"><a class="header-anchor" href="#5-3-显示变量">¶</a>5.3 显示变量</h3><p>read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">read name </span><br><span class="line">echo "$name It is a test"</span><br></pre></td></tr></tbody></table></figure><p>以上代码保存为 <a href="http://test.sh">test.sh</a>，name 接收标准输入的变量，结果将是:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sh test.sh</span><br><span class="line">OK                     #标准输入</span><br><span class="line">OK It is a test        #输出</span><br></pre></td></tr></tbody></table></figure><h3 id="5-4-显示换行"><a class="header-anchor" href="#5-4-显示换行">¶</a>5.4 显示换行</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo -e "OK! \n" # -e 开启转义（原来如此！）</span><br><span class="line">echo "It is a test"</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OK!</span><br><span class="line"></span><br><span class="line">It is a test</span><br></pre></td></tr></tbody></table></figure><h3 id="5-5-显示不换行"><a class="header-anchor" href="#5-5-显示不换行">¶</a>5.5 显示不换行</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo -e "OK! \c" # -e 开启转义 \c 不换行</span><br><span class="line">echo "It is a test"</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OK! It is a test</span><br></pre></td></tr></tbody></table></figure><h3 id="5-6-显示结果定向至文件"><a class="header-anchor" href="#5-6-显示结果定向至文件">¶</a>5.6 显示结果定向至文件</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "It is a test" &gt; myfile</span><br></pre></td></tr></tbody></table></figure><h3 id="5-7-原样输出字符串，不进行转义或取变量-用单引号"><a class="header-anchor" href="#5-7-原样输出字符串，不进行转义或取变量-用单引号">¶</a>5.7 原样输出字符串，不进行转义或取变量(用单引号)</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo '$name\"'</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$name\"</span><br></pre></td></tr></tbody></table></figure><h3 id="5-8-显示命令执行结果"><a class="header-anchor" href="#5-8-显示命令执行结果">¶</a>5.8 显示命令执行结果</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo `date`</span><br></pre></td></tr></tbody></table></figure><p>注意： 这里使用的是反引号, 而不是单引号。</p><p>结果将显示当前日期</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thu Jul 24 10:08:46 CST 2014</span><br></pre></td></tr></tbody></table></figure><h2 id="6-shell-printf命令"><a class="header-anchor" href="#6-shell-printf命令">¶</a>6. shell printf命令</h2><p>使用格式：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf  format-string  [arguments...]</span><br></pre></td></tr></tbody></table></figure><p>其实和C语言的printf差不多：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line"># format-string为双引号</span><br><span class="line">printf "%d %s\n" 1 "abc"</span><br><span class="line"></span><br><span class="line"># 单引号与双引号效果一样</span><br><span class="line">printf '%d %s\n' 1 "abc"</span><br><span class="line"></span><br><span class="line"># 没有引号也可以输出</span><br><span class="line">printf %s abcdef</span><br><span class="line"></span><br><span class="line"># 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用</span><br><span class="line">printf %s abc def</span><br><span class="line"></span><br><span class="line">printf "%s\n" abc def</span><br><span class="line"></span><br><span class="line">printf "%s %s %s\n" a b c d e f g h i j</span><br><span class="line"></span><br><span class="line"># 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替</span><br><span class="line">printf "%s and %d \n"</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 abc</span><br><span class="line">1 abc</span><br><span class="line">abcdefabcdefabc</span><br><span class="line">def</span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">g h i</span><br><span class="line">j  </span><br><span class="line"> and 0</span><br></pre></td></tr></tbody></table></figure><p>printf中常用的转义序列：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116210218.png" alt=""></p><h2 id="7-shell-test命令"><a class="header-anchor" href="#7-shell-test命令">¶</a>7. shell test命令</h2><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><h3 id="7-1-数值测试"><a class="header-anchor" href="#7-1-数值测试">¶</a>7.1 数值测试</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116210357.png" alt=""></p><p>实例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">if test $[num1] -eq $[num2]</span><br><span class="line">then</span><br><span class="line">    echo '两个数相等！'</span><br><span class="line">else</span><br><span class="line">    echo '两个数不相等！'</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">a=5</span><br><span class="line">b=6</span><br><span class="line"></span><br><span class="line">result=$[a+b] # 注意等号两边不能有空格</span><br><span class="line">echo "result 为： $result"</span><br></pre></td></tr></tbody></table></figure><p><strong>代码中的 [] 执行基本的算数运算</strong>，好神奇诶！</p><h3 id="7-2-字符串测试"><a class="header-anchor" href="#7-2-字符串测试">¶</a>7.2 字符串测试</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116210653.png" alt=""></p><p>实例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1="ru1noob"</span><br><span class="line">num2="runoob"</span><br><span class="line">if test $num1 = $num2</span><br><span class="line">then</span><br><span class="line">    echo '两个字符串相等!'</span><br><span class="line">else</span><br><span class="line">    echo '两个字符串不相等!'</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure><h3 id="7-3-文件测试"><a class="header-anchor" href="#7-3-文件测试">¶</a>7.3 文件测试</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210116210740.png" alt=""></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /bin</span><br><span class="line">if test -e ./bash</span><br><span class="line">then</span><br><span class="line">    echo '文件已存在!'</span><br><span class="line">else</span><br><span class="line">    echo '文件不存在!'</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure><p>另外，Shell 还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为： ! 最高， -a 次之， -o 最低。例如：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /bin</span><br><span class="line">if test -e ./notFile -o -e ./bash</span><br><span class="line">then</span><br><span class="line">    echo '至少有一个文件存在!'</span><br><span class="line">else</span><br><span class="line">    echo '两个文件都不存在'</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure><h2 id="8-shell流程控制"><a class="header-anchor" href="#8-shell流程控制">¶</a>8. shell流程控制</h2><p>和 Java、PHP 等语言不一样，sh 的流程控制不可为空，如(以下为 PHP 流程控制写法)：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">// 不做任何事情</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 sh/bash 里可不能这么写，如果 else 分支没有语句执行，就不要写这个 else</p><h3 id="if-else"><a class="header-anchor" href="#if-else">¶</a>if/else</h3><h4 id="只有if的"><a class="header-anchor" href="#只有if的">¶</a>只有if的</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure><p>写成一行（适用于终端命令提示符）：<strong>注意中间要加分号</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi</span><br></pre></td></tr></tbody></table></figure><h4 id="有if和else的"><a class="header-anchor" href="#有if和else的">¶</a>有if和else的</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">else</span><br><span class="line">    command</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure><h4 id="嵌套的if和else"><a class="header-anchor" href="#嵌套的if和else">¶</a>嵌套的if和else</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure><h3 id="for循环"><a class="header-anchor" href="#for循环">¶</a>for循环</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure><p>写成一行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN; do command1; command2… done;</span><br></pre></td></tr></tbody></table></figure><p>一个神奇的例子：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">for str in This is a string</span><br><span class="line">do</span><br><span class="line">    echo $str</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">//输出：</span><br><span class="line">//This</span><br><span class="line">//is</span><br><span class="line">//a</span><br><span class="line">//string</span><br></pre></td></tr></tbody></table></figure><h3 id="while语句"><a class="header-anchor" href="#while语句">¶</a>while语句</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure><p>一个神奇的例子：</p><p>以下是一个基本的 while 循环，测试条件是：如果 int 小于等于 5，那么条件返回真。int 从 1 开始，每次循环处理时，int 加 1。运行上述脚本，返回数字 1 到 5，然后终止。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int//这个echo好像是输出完要换行的</span><br><span class="line">    let "int++"//这个let的用法就很神奇</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure><p>以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量</p><p>while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<ctrl-d>结束循环。</ctrl-d></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">echo '按下 &lt;CTRL-D&gt; 退出'</span><br><span class="line">echo -n '输入你最喜欢的网站名: '</span><br><span class="line">while read FILM</span><br><span class="line">do</span><br><span class="line">    echo "是的！$FILM 是一个好网站"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">//输出：</span><br><span class="line">//按下 &lt;CTRL-D&gt; 退出</span><br><span class="line">//输入你最喜欢的网站名:菜鸟教程</span><br><span class="line">//是的！菜鸟教程 是一个好网站</span><br></pre></td></tr></tbody></table></figure><h3 id="无限循环"><a class="header-anchor" href="#无限循环">¶</a>无限循环</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure><p>或者：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure><p>再或者：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (( ; ; ))</span><br></pre></td></tr></tbody></table></figure><h3 id="until循环"><a class="header-anchor" href="#until循环">¶</a>until循环</h3><p>until 循环执行一系列命令直至条件为 true 时停止。</p><p>until 循环与 while 循环在处理方式上刚好相反。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure><h3 id="case-…-esac"><a class="header-anchor" href="#case-…-esac">¶</a>case … esac</h3><p>这是多选择，类似于switch……case……每个 case 分支用右圆括号开始，用两个分号 <strong>;;</strong> 表示 break，即执行结束，跳出整个 case … esac 语句，esac（就是 case 反过来）作为结束标记。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></tbody></table></figure><p>case 工作方式如上所示，取值后面必须为单词 <strong>in</strong>，每一模式必须以右括号结束。取值可以为变量或常数，匹配发现取值符合某一模式后，其间所有命令开始执行直至 <strong>;;</strong>。</p><p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值（相当于default），再执行后面的命令。</p><p>下面的脚本匹配字符串：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">site="runoob"</span><br><span class="line"></span><br><span class="line">case "$site" in</span><br><span class="line">   "runoob") echo "菜鸟教程"</span><br><span class="line">   ;;</span><br><span class="line">   "google") echo "Google 搜索"</span><br><span class="line">   ;;</span><br><span class="line">   "taobao") echo "淘宝网"</span><br><span class="line">   ;;</span><br><span class="line">   *) echo "无法识别"</span><br><span class="line">   ;;</span><br><span class="line">esac</span><br></pre></td></tr></tbody></table></figure><h3 id="跳出循环"><a class="header-anchor" href="#跳出循环">¶</a>跳出循环</h3><h4 id="break"><a class="header-anchor" href="#break">¶</a>break</h4><p>break命令允许跳出所有循环（终止执行后面的所有循环）。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n "输入 1 到 5 之间的数字:"</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo "你输入的数字为 $aNum!"</span><br><span class="line">        ;;</span><br><span class="line">        *) echo "你输入的数字不是 1 到 5 之间的! 游戏结束"</span><br><span class="line">            break</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure><h4 id="continue"><a class="header-anchor" href="#continue">¶</a>continue</h4><p>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n "输入 1 到 5 之间的数字: "</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo "你输入的数字为 $aNum!"</span><br><span class="line">        ;;</span><br><span class="line">        *) echo "你输入的数字不是 1 到 5 之间的!"</span><br><span class="line">            continue</span><br><span class="line">            echo "游戏结束"</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure><p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 <strong>echo “游戏结束”</strong> 永远不会被执行。</p><h2 id="9-shell函数"><a class="header-anchor" href="#9-shell函数">¶</a>9. shell函数</h2><p>linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p><p>shell中函数的定义格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ function ] funname [()]</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [return int;]//参数返回，可以显式加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255）</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>例子：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">demoFun(){</span><br><span class="line">    echo "这是我的第一个 shell 函数!"</span><br><span class="line">}</span><br><span class="line">echo "-----函数开始执行-----"</span><br><span class="line">demoFun</span><br><span class="line">echo "-----函数执行完毕-----"</span><br></pre></td></tr></tbody></table></figure><p>例子2：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">funWithReturn(){</span><br><span class="line">    echo "这个函数会对输入的两个数字进行相加运算..."</span><br><span class="line">    echo "输入第一个数字: "</span><br><span class="line">    read aNum</span><br><span class="line">    echo "输入第二个数字: "</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo "两个数字分别为 $aNum 和 $anotherNum !"</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">}</span><br><span class="line">funWithReturn</span><br><span class="line">echo "输入的两个数字之和为 $? !"//注意这个$?</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这个函数会对输入的两个数字进行相加运算...</span><br><span class="line">输入第一个数字: </span><br><span class="line">1</span><br><span class="line">输入第二个数字: </span><br><span class="line">2</span><br><span class="line">两个数字分别为 1 和 2 !</span><br><span class="line">输入的两个数字之和为 3 !</span><br></pre></td></tr></tbody></table></figure><p><strong>函数返回值在调用该函数后通过 $? 来获得。</strong></p><p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。<strong>调用函数仅使用其函数名即可。</strong>（不像别的语言，要带括号什么的）</p><h3 id="函数参数"><a class="header-anchor" href="#函数参数">¶</a>函数参数</h3><p>在Shell中，调用函数时可以向其传递参数（很神奇的是，定义的时候可以不用在括号里面写？）。在函数体内部，通过 $n 的形式来获取参数的值，例如，​$1表示第一个参数，$2表示第二个参数…</p><p><strong>注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">funWithParam(){</span><br><span class="line">    echo "第一个参数为 $1 !"</span><br><span class="line">    echo "第二个参数为 $2 !"</span><br><span class="line">    echo "第十个参数为 $10 !"</span><br><span class="line">    echo "第十个参数为 ${10} !"</span><br><span class="line">    echo "第十一个参数为 ${11} !"</span><br><span class="line">    echo "参数总数有 $# 个!"</span><br><span class="line">    echo "作为一个字符串输出所有参数 $* !"</span><br><span class="line">}</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一个参数为 1 !</span><br><span class="line">第二个参数为 2 !</span><br><span class="line">第十个参数为 10 !</span><br><span class="line">第十个参数为 34 !</span><br><span class="line">第十一个参数为 73 !</span><br><span class="line">参数总数有 11 个!</span><br><span class="line">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</span><br></pre></td></tr></tbody></table></figure><p>另外，还有几个特殊字符用来处理参数：</p><table><thead><tr><th style="text-align:left">参数处理</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">$#</td><td style="text-align:left">传递到脚本或函数的参数个数</td></tr><tr><td style="text-align:left">$*</td><td style="text-align:left">以一个单字符串显示所有向脚本传递的参数</td></tr><tr><td style="text-align:left">$$</td><td style="text-align:left">脚本运行的当前进程ID号</td></tr><tr><td style="text-align:left">$!</td><td style="text-align:left">后台运行的最后一个进程的ID号</td></tr><tr><td style="text-align:left">$@</td><td style="text-align:left">与$*相同，但是使用时加引号，并在引号中返回每个参数。</td></tr><tr><td style="text-align:left">$-</td><td style="text-align:left">显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td style="text-align:left">$?</td><td style="text-align:left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><h2 id="10-shell-输入-输出重定向"><a class="header-anchor" href="#10-shell-输入-输出重定向">¶</a>10. shell 输入/输出重定向</h2><p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，<strong>这恰好是你的终端</strong>。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">command &gt; file</td><td style="text-align:left">将输出重定向到 file。（替代）</td></tr><tr><td style="text-align:left">command &lt; file</td><td style="text-align:left">将输入重定向到 file。</td></tr><tr><td style="text-align:left">command &gt;&gt; file</td><td style="text-align:left">将输出以<strong>追加</strong>的方式重定向到 file。</td></tr><tr><td style="text-align:left">n &gt; file</td><td style="text-align:left">将文件描述符为 n 的文件重定向到 file。</td></tr><tr><td style="text-align:left">n &gt;&gt; file</td><td style="text-align:left">将文件描述符为 n 的文件以追加的方式重定向到 file。</td></tr><tr><td style="text-align:left">n &gt;&amp; m</td><td style="text-align:left">将输出文件 m 和 n 合并。</td></tr><tr><td style="text-align:left">n &lt;&amp; m</td><td style="text-align:left">将输入文件 m 和 n 合并。</td></tr><tr><td style="text-align:left">&lt;&lt; tag</td><td style="text-align:left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td></tr></tbody></table><p><em>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</em></p><h3 id="输入重定向"><a class="header-anchor" href="#输入重定向">¶</a>输入重定向</h3><p>输出重定向会覆盖文件内容，请看下面的例子：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo "菜鸟教程：www.runoob.com" &gt; users</span><br><span class="line">$ cat users</span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">$</span><br></pre></td></tr></tbody></table></figure><p>如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo "菜鸟教程：www.runoob.com" &gt;&gt; users</span><br><span class="line">$ cat users</span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">$</span><br></pre></td></tr></tbody></table></figure><h3 id="输出重定向"><a class="header-anchor" href="#输出重定向">¶</a>输出重定向</h3><p>同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &lt; infile &gt; outfile</span><br></pre></td></tr></tbody></table></figure><h3 id="重定向深入讲解"><a class="header-anchor" href="#重定向深入讲解">¶</a>重定向深入讲解</h3><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ul><p><strong>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</strong>（也就是省略了数字的样子）</p><p>如果希望 stderr 重定向到 file，可以这样写：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ command 2&gt;file</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter9 软件漏洞挖掘与分析</title>
      <link href="2021/01/13/Chapter9-%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>2021/01/13/Chapter9-%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="9-1-软件漏洞基础知识"><a class="header-anchor" href="#9-1-软件漏洞基础知识">¶</a>9.1 软件漏洞基础知识</h2><h3 id="9-1-1-概述"><a class="header-anchor" href="#9-1-1-概述">¶</a>9.1.1 概述</h3><h4 id="（1）漏洞标准"><a class="header-anchor" href="#（1）漏洞标准">¶</a>（1）漏洞标准</h4><p>CVE等</p><h4 id="（2）漏洞分类"><a class="header-anchor" href="#（2）漏洞分类">¶</a>（2）漏洞分类</h4><p>有不同的分类角度</p><h4 id="（3）软件漏洞的利用方法"><a class="header-anchor" href="#（3）软件漏洞的利用方法">¶</a>（3）软件漏洞的利用方法</h4><h4 id="（4）软件漏洞的危害"><a class="header-anchor" href="#（4）软件漏洞的危害">¶</a>（4）软件漏洞的危害</h4><h3 id="9-1-2-软件漏洞典型类型"><a class="header-anchor" href="#9-1-2-软件漏洞典型类型">¶</a>9.1.2 软件漏洞典型类型</h3><p>主要介绍控制流劫持类漏洞</p><h4 id="（1）栈溢出漏洞"><a class="header-anchor" href="#（1）栈溢出漏洞">¶</a>（1）栈溢出漏洞</h4><h4 id="（2）堆溢出"><a class="header-anchor" href="#（2）堆溢出">¶</a>（2）堆溢出</h4><p>有两种</p><ul><li>覆盖后续堆管理结构：把前向后向指针的内容改掉，利用时关注os的堆分配与释放<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210113191104.png" alt=""></li><li>覆盖后续堆的数据：关注被覆盖的堆中是否有虚函数指针<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210113191506.png" alt=""></li></ul><h4 id="（3）释放后重用漏洞UAF"><a class="header-anchor" href="#（3）释放后重用漏洞UAF">¶</a>（3）释放后重用漏洞UAF</h4><p>释放后立刻申请，可能申请到同一块；例如B被释放后，攻击者为C申请内存，A就访问了攻击者希望它去往的恶意代码</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210113192112.png" alt=""></p><h4 id="（4）整数溢出漏洞"><a class="header-anchor" href="#（4）整数溢出漏洞">¶</a>（4）整数溢出漏洞</h4><p>目标也是覆盖堆栈内容，分为宽度溢出和算术溢出</p><h4 id="（5）其他类型漏洞"><a class="header-anchor" href="#（5）其他类型漏洞">¶</a>（5）其他类型漏洞</h4><ul><li>SQL注入</li><li>XSS：另外再了解一下（？）</li></ul><h3 id="9-1-3-软件漏洞利用基础知识"><a class="header-anchor" href="#9-1-3-软件漏洞利用基础知识">¶</a>9.1.3 软件漏洞利用基础知识</h3><p>漏洞利用的生成可以分为3类：</p><ul><li>用调试工具分析以后写</li><li>用MetaSploit生成可利用的攻击代码</li><li>自动化工具自动生成</li></ul><p>控制流劫持类漏洞的利用=修改程序流程+绕过操作系统防护机制的各种方法</p><p>对于后者：</p><h4 id="（1）内存喷射技术"><a class="header-anchor" href="#（1）内存喷射技术">¶</a>（1）内存喷射技术</h4><p>核心思想是，在内存中申请很多固定大小的对象，填入相同的内容（攻击代码+NOP指令），这样控制流被劫持以后，攻击者设计跳转的地址只要落在一定范围内就可以成功了（也就是允许一些误差）</p><h4 id="（2）ROP攻击技术"><a class="header-anchor" href="#（2）ROP攻击技术">¶</a>（2）ROP攻击技术</h4><p>似懂非懂（？）</p><h4 id="（3）基于内存地址信息泄露构造利用"><a class="header-anchor" href="#（3）基于内存地址信息泄露构造利用">¶</a>（3）基于内存地址信息泄露构造利用</h4><p>从开头说起，自从有了地址随机化技术以后，攻击者有以下两种方法来对抗：</p><ul><li>找未随机化的模块进行攻击</li><li>利用程序运行时泄露的内存地址信息来攻击，注意：地址随机化并不改变相对位置</li></ul><h3 id="9-1-4-软件漏洞防护机制基础知识"><a class="header-anchor" href="#9-1-4-软件漏洞防护机制基础知识">¶</a>9.1.4 软件漏洞防护机制基础知识</h3><h4 id="（1）Stack-Cookie——防栈溢出"><a class="header-anchor" href="#（1）Stack-Cookie——防栈溢出">¶</a>（1）Stack Cookie——防栈溢出</h4><p>通过检查cookie值是否变化来判断是否受到攻击</p><h4 id="（2）DEP——防控制流劫持攻击（缓冲区溢出）"><a class="header-anchor" href="#（2）DEP——防控制流劫持攻击（缓冲区溢出）">¶</a>（2）DEP——防控制流劫持攻击（缓冲区溢出）</h4><p>Windows利用DEP，把只含数据的内存位置标记为非可执行状态</p><h4 id="（3）ASLR——防缓冲区溢出"><a class="header-anchor" href="#（3）ASLR——防缓冲区溢出">¶</a>（3）ASLR——防缓冲区溢出</h4><p>可以对四类地址进行随机化</p><ul><li>PE文件加载地址</li><li>堆栈随机化</li><li>PEB、TEB随机化</li></ul><h2 id="9-2-软件漏洞机理分析"><a class="header-anchor" href="#9-2-软件漏洞机理分析">¶</a>9.2 软件漏洞机理分析</h2><h3 id="9-2-1-软件漏洞脆弱点分析"><a class="header-anchor" href="#9-2-1-软件漏洞脆弱点分析">¶</a>9.2.1 软件漏洞脆弱点分析</h3><h4 id="（1）栈溢出的脆弱点和控制流劫持点"><a class="header-anchor" href="#（1）栈溢出的脆弱点和控制流劫持点">¶</a>（1）栈溢出的脆弱点和控制流劫持点</h4><h4 id="（2）堆溢出的脆弱点和控制流劫持点"><a class="header-anchor" href="#（2）堆溢出的脆弱点和控制流劫持点">¶</a>（2）堆溢出的脆弱点和控制流劫持点</h4><h4 id="（3）整数溢出的……"><a class="header-anchor" href="#（3）整数溢出的……">¶</a>（3）整数溢出的……</h4><h3 id="9-2-2-软件漏洞路径分析"><a class="header-anchor" href="#9-2-2-软件漏洞路径分析">¶</a>9.2.2 软件漏洞路径分析</h3><p>软件漏洞路径分析的目的是找出（程序入口——&gt;脆弱点）的路径</p><p>之前的污点传播可以用过来，将用户输入作为污点，跟踪此数据在漏洞程序中的处理过程</p><h4 id="（1）基于污点传播的路径指令序列提取"><a class="header-anchor" href="#（1）基于污点传播的路径指令序列提取">¶</a>（1）基于污点传播的路径指令序列提取</h4><h4 id="（2）基于符号执行的路径条件提取"><a class="header-anchor" href="#（2）基于符号执行的路径条件提取">¶</a>（2）基于符号执行的路径条件提取</h4><p>路径条件提取关键：确定使控制流转移到脆弱路径的<strong>关键节点</strong>，以及分析这些节点相互之间的<strong>数据依赖</strong>和<strong>控制依赖</strong>关系</p><h4 id="（3）软件漏洞分析中的特殊情况"><a class="header-anchor" href="#（3）软件漏洞分析中的特殊情况">¶</a>（3）软件漏洞分析中的特殊情况</h4><h3 id="9-2-3-软件漏洞内存布局分析"><a class="header-anchor" href="#9-2-3-软件漏洞内存布局分析">¶</a>9.2.3 软件漏洞内存布局分析</h3><p>目标：当脆弱点被触发时：</p><ul><li>确定<strong>程序读入数据</strong>在内存中的布局情况</li><li>分析<strong>漏洞利用所需</strong>的关键数据所在位置</li></ul><h3 id="9-2-4-软件漏洞分析实例"><a class="header-anchor" href="#9-2-4-软件漏洞分析实例">¶</a>9.2.4 软件漏洞分析实例</h3><h2 id="9-3-软件漏洞利用"><a class="header-anchor" href="#9-3-软件漏洞利用">¶</a>9.3 软件漏洞利用</h2><p>怎么写出攻击代码？关注3个要素：</p><ul><li>输入数据：触发脆弱点+含有攻击代码</li><li>攻击链：将控制流转移至攻击代码</li><li>绕过保护机制</li></ul><h3 id="9-3-1-漏洞攻击链构造"><a class="header-anchor" href="#9-3-1-漏洞攻击链构造">¶</a>9.3.1 漏洞攻击链构造</h3><p>构造攻击链有两个关键步骤：</p><ol><li>确定内存中可以用于存放控制流转移代码的区域</li><li>设计控制流转移关系</li></ol><p>后者，为了使得跳转成功率变高，我们可以采用：</p><ul><li>内存喷射</li><li>用跳转指令：常用的有……</li></ul><p>区别与联系：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210113215052.png" alt=""></p><h3 id="9-3-2-漏洞攻击路径触发"><a class="header-anchor" href="#9-3-2-漏洞攻击路径触发">¶</a>9.3.2 漏洞攻击路径触发</h3><p>目标：构造输入数据，使程序能运行到劫持点</p><p>如何构造呢？</p><ul><li>提取程序执行路径中的条件分支</li><li>根据分支写出表达式</li><li>对表达式求解，得出数据的取值范围</li></ul><h3 id="9-3-3-保护机制绕过"><a class="header-anchor" href="#9-3-3-保护机制绕过">¶</a>9.3.3 保护机制绕过</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件安全分析与应用》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习</title>
      <link href="2021/01/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/01/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-决策树学习"><a class="header-anchor" href="#1-决策树学习">¶</a>1. 决策树学习</h2><h2 id="2-神经学习（神经网络）"><a class="header-anchor" href="#2-神经学习（神经网络）">¶</a>2. 神经学习（神经网络）</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算智能</title>
      <link href="2021/01/12/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD/"/>
      <url>2021/01/12/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="1-神经计算"><a class="header-anchor" href="#1-神经计算">¶</a>1. 神经计算</h2><h2 id="2-模糊计算"><a class="header-anchor" href="#2-模糊计算">¶</a>2. 模糊计算</h2><p>不考！！！去你的吧！！！</p><h2 id="3-遗传算法"><a class="header-anchor" href="#3-遗传算法">¶</a>3. 遗传算法</h2><h2 id="4-粒群优化"><a class="header-anchor" href="#4-粒群优化">¶</a>4. 粒群优化</h2><h2 id="5-蚁群优化"><a class="header-anchor" href="#5-蚁群优化">¶</a>5. 蚁群优化</h2><p>这章的算法也太厚重啦</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>确定性推理技术</title>
      <link href="2021/01/12/%E7%A1%AE%E5%AE%9A%E6%80%A7%E6%8E%A8%E7%90%86%E6%8A%80%E6%9C%AF/"/>
      <url>2021/01/12/%E7%A1%AE%E5%AE%9A%E6%80%A7%E6%8E%A8%E7%90%86%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="1-图搜索技术"><a class="header-anchor" href="#1-图搜索技术">¶</a>1. 图搜索技术</h2><p>搜索算法分类：</p><ul><li>Blind Search Strategies<ul><li>Breadth-First search</li><li>Depth-First search</li><li>Uniform-Cost search</li></ul></li><li>Heuristic Search Strategies<ul><li>Best-first search/Ordered Search</li><li>Greedy Search</li><li>Algorithm A</li><li>Algorithm A*</li><li>Hill climbing</li></ul></li></ul><p>注意：树的搜索可以不需要closed表，因为并不存在回头的情况</p><p>算法总结：</p><table><thead><tr><th>算法</th><th>数据结构</th><th>估价函数</th></tr></thead><tbody><tr><td>BFS</td><td>FIFO队列</td><td>无</td></tr><tr><td>DFS</td><td>LIFO队列（栈）</td><td>无</td></tr><tr><td>UCS</td><td>优先队列（每次扩展cost最小的点）</td><td>f(n)=g(n)</td></tr><tr><td>贪婪</td><td>优先队列</td><td>f(n)=h(n)</td></tr><tr><td>A</td><td>优先队列</td><td>f(n)=g(n)+h(n)</td></tr><tr><td>A*</td><td>优先队列</td><td>f*(n)=g*(n)+h*(n)</td></tr></tbody></table><h2 id="2-消解原理"><a class="header-anchor" href="#2-消解原理">¶</a>2. 消解原理</h2><h2 id="3-规则演绎"><a class="header-anchor" href="#3-规则演绎">¶</a>3. 规则演绎</h2><h2 id="4-产生式系统"><a class="header-anchor" href="#4-产生式系统">¶</a>4. 产生式系统</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识表示方法</title>
      <link href="2021/01/12/%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/"/>
      <url>2021/01/12/%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-状态空间表示"><a class="header-anchor" href="#1-状态空间表示">¶</a>1. 状态空间表示</h2><h2 id="2-问题归约表示"><a class="header-anchor" href="#2-问题归约表示">¶</a>2. 问题归约表示</h2><p>什么是本原问题：<br>不是说等于原来的初始问题啊！是说可以直接得到解的最简单的小问题叫做本原问题</p><p>状态空间与问题归约的区别：</p><table><thead><tr><th>状态空间元素</th><th>状态空间</th><th>问题归约</th></tr></thead><tbody><tr><td>S</td><td>初始状态描述</td><td>本原问题描述</td></tr><tr><td>F</td><td>状态转换的算子</td><td>将问题分解为子问题的操作</td></tr><tr><td>G</td><td>最终状态描述</td><td>目标问题描述</td></tr></tbody></table><h2 id="3-谓词逻辑表示"><a class="header-anchor" href="#3-谓词逻辑表示">¶</a>3. 谓词逻辑表示</h2><p>先看书</p><p>世界上最迷惑的名词：原子公式、合式公式、命题逻辑、谓词逻辑</p><p>找最通用的一般合一者mgu的算法：</p><h2 id="4-语义网络表示"><a class="header-anchor" href="#4-语义网络表示">¶</a>4. 语义网络表示</h2><p>总结：</p><p>|方法|Problem|Operation|Goal|Solution|<br>|-|-|-|-|<br>|状态空间|状态（矢量、图）|算子|目标状态|路径|<br>|问题归约|节点（矢量描述当前问题）|弧|终端节点（本原问题）|解答树|<br>|谓词逻辑|合式公式wff|规则|root of tree？|answer statement？|<br>|语义网络|节点|链|得到语义网络|网络|</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能概论</title>
      <link href="2021/01/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA/"/>
      <url>2021/01/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-学科定义"><a class="header-anchor" href="#1-学科定义">¶</a>1. 学科定义</h2><p>见PPT</p><h2 id="2-起源与发展历程"><a class="header-anchor" href="#2-起源与发展历程">¶</a>2. 起源与发展历程</h2><h2 id="3-人工智能与人类智能"><a class="header-anchor" href="#3-人工智能与人类智能">¶</a>3. 人工智能与人类智能</h2><h2 id="4-应用场景与挑战"><a class="header-anchor" href="#4-应用场景与挑战">¶</a>4. 应用场景与挑战</h2><h2 id="疑难总结"><a class="header-anchor" href="#疑难总结">¶</a>疑难总结</h2><h3 id="规则演绎"><a class="header-anchor" href="#规则演绎">¶</a>规则演绎</h3><h3 id="模糊计算"><a class="header-anchor" href="#模糊计算">¶</a>模糊计算</h3><p>划掉！！！</p><h3 id=""><a class="header-anchor" href="#">¶</a></h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Architecture Style</title>
      <link href="2021/01/10/Architecture-Style/"/>
      <url>2021/01/10/Architecture-Style/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件工程原理》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture Style </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning UML: Concepts and Practice</title>
      <link href="2021/01/10/Learning-UML-Concepts-and-Practice/"/>
      <url>2021/01/10/Learning-UML-Concepts-and-Practice/</url>
      
        <content type="html"><![CDATA[<h2 id="1-类图"><a class="header-anchor" href="#1-类图">¶</a>1. 类图</h2><h3 id="1-1-类内部"><a class="header-anchor" href="#1-1-类内部">¶</a>1.1 类内部</h3><p>UML定义了4种类型的可见性，分别在对应的字段/方法前面加小符号：</p><ul><li>public（+）</li><li>protected（#）</li><li>private（-）</li><li>package（~）：只对同一包声明的其他类可见</li></ul><p>注意还要标注数据类型/返回值类型，一个类的表示大概长这样：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210110120012.png" alt=""></p><h3 id="1-2-类与类之间"><a class="header-anchor" href="#1-2-类与类之间">¶</a>1.2 类与类之间</h3><p>有以下几种关系可以把它们联系起来：</p><p><img src="https://img-blog.csdn.net/20170718142514420?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDY0ODU1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>分别解释一下：</p><h4 id="1-2-1-继承-泛化"><a class="header-anchor" href="#1-2-1-继承-泛化">¶</a>1.2.1 继承/泛化</h4><p><strong>A指向B=A继承了B</strong></p><h4 id="1-2-2-实现"><a class="header-anchor" href="#1-2-2-实现">¶</a>1.2.2 实现</h4><p><strong>A指向B=A实现了B</strong><br>实现关系就是java中的一个类和接口之间的关系，接口中一般是没有成员变量。所有操作都是抽象的，只有声明没有具体的实现。</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210110120706.png" alt=""></p><p>有两种表示方法：</p><ul><li>实现关系：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210106193748.png" alt=""></li><li>棒棒糖表示法：<ul><li>需要接口：使用了这个接口提供的服务</li><li>提供接口：完全就是用这个定义的数据结构/行为<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210106193854.png" alt=""></li></ul></li></ul><h4 id="1-2-3-依赖"><a class="header-anchor" href="#1-2-3-依赖">¶</a>1.2.3 依赖</h4><p>临时、非结构性、单向性<br>依赖关系是类与类之间最弱的关系，A元素变化会影响B元素，反之不成立。说简单点就是一个类使用了另一个类，这种关系具有临时性特征，一个类的改变由于另一类而受影响。</p><p>UML模型中的依赖关系有如下这些：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210106193042.png" alt=""></p><h4 id="1-2-4-关联"><a class="header-anchor" href="#1-2-4-关联">¶</a>1.2.4 关联</h4><p>永久、结构性、双向性<br>关联关系表示一个类和另一类有联系，它使一个类知道另一个类的属性和方法，被关联的元素间通常可以被独立的考虑。</p><p>当箭头上有奇怪的数字标注：</p><ul><li>1…1表示另一个类的一个对象只与该类的一个对象有关系</li><li>0…* 表示另一个类的一个对象与该类的零个或多个对象有关系</li><li>1…* 表示另一个类的一个对象与该类的一个或多个对象有关系</li><li>0…1表示另一个类的一个对象没有或只与该类的一个对象有关系</li></ul><p>注：假设表示A和B的关系,在贴近A的一端标注0…<em>，在这个关系中表示A可以有0个以上（包括0）；如果在B端标注1…</em>，就表示在这个关系中表示B可以有1个以上（包括1）</p><h4 id="1-2-5-聚合"><a class="header-anchor" href="#1-2-5-聚合">¶</a>1.2.5 聚合</h4><p>是关联关系的一种<br>聚合关系是整体和部分的关系，是一种强的关系，但是部分可以脱离整体而存在</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210110121551.png" alt=""></p><h4 id="1-2-6-组合"><a class="header-anchor" href="#1-2-6-组合">¶</a>1.2.6 组合</h4><p>是关联关系的一种，也是聚合关系的一种变种，是更强的聚合关系，它要求整体的对象代表部分对象的生命周期<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210110121700.png" alt=""></p><h3 id="1-3-整个类图示例"><a class="header-anchor" href="#1-3-整个类图示例">¶</a>1.3 整个类图示例</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210110121954.png" alt=""></p><h2 id="2-用例图"><a class="header-anchor" href="#2-用例图">¶</a>2. 用例图</h2><h3 id="2-1-用例图示例"><a class="header-anchor" href="#2-1-用例图示例">¶</a>2.1 用例图示例</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE256.png" alt=""></p><h3 id="2-2-几种关系的解释"><a class="header-anchor" href="#2-2-几种关系的解释">¶</a>2.2 几种关系的解释</h3><h4 id="2-2-1-执行者与执行者之间的泛化"><a class="header-anchor" href="#2-2-1-执行者与执行者之间的泛化">¶</a>2.2.1 执行者与执行者之间的泛化</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210110131015.png" alt=""></p><h4 id="2-2-2-执行者与用例之间的关联"><a class="header-anchor" href="#2-2-2-执行者与用例之间的关联">¶</a>2.2.2 执行者与用例之间的关联</h4><p>线条是指参与者与用例之间线条，有三种：无箭头，指向用例的箭头，指向执行者的箭头。一般来说，箭头的尾部用来表示启动交互的一方，头部用来表示被启动的一方。</p><h4 id="2-2-3-用例与用例之间的包含"><a class="header-anchor" href="#2-2-3-用例与用例之间的包含">¶</a>2.2.3 用例与用例之间的包含</h4><p>（突然想起来我在PPT上学过！！）<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210110131322.png" alt=""></p><h4 id="2-2-4-用例与用例之间的扩展"><a class="header-anchor" href="#2-2-4-用例与用例之间的扩展">¶</a>2.2.4 用例与用例之间的扩展</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210110131439.png" alt=""></p><h4 id="2-2-5-用例与用例之间的泛化"><a class="header-anchor" href="#2-2-5-用例与用例之间的泛化">¶</a>2.2.5 用例与用例之间的泛化</h4><p>有点像类之间的继承/泛化<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210110131525.png" alt=""></p><h2 id="3-对象图"><a class="header-anchor" href="#3-对象图">¶</a>3. 对象图</h2><p>对象图则是类图的一个实例，使用的标识几乎与类图一致，但是其生命周期有限，只能在系统中某一时间段内存在。<br>（老记得PPT上这部分知识，一会找一下）</p><h2 id="4-时序图"><a class="header-anchor" href="#4-时序图">¶</a>4. 时序图</h2><p>系统当然还有动态的性质，从两个角度刻画：</p><ul><li>对象内部：状态机图</li><li>对象之间：时序图（顺序图/序列图）、通信图</li></ul><h4 id="4-1-时序图定义"><a class="header-anchor" href="#4-1-时序图定义">¶</a>4.1 时序图定义</h4><p>描述了多个对象之间发送消息的时间顺序，图中的每条消息可以是：</p><ul><li>类的操作</li><li>状态机图中引起状态转换的触发事件</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE255.png" alt=""></p><h4 id="4-2-序列片段"><a class="header-anchor" href="#4-2-序列片段">¶</a>4.2 序列片段</h4><p>其中详解一下序列片段，有四种：</p><ul><li>交互使用（ref标签）：复用已定义的交互场景</li><li>循环（loop标签）：用[get next item]来控制执行</li><li>条件（alt标签）：里面有方括号表示的分支</li><li>并发（par标签）：</li></ul><h2 id="5-通信图"><a class="header-anchor" href="#5-通信图">¶</a>5. 通信图</h2><p>其实可以和时序图互相转换，强调的是发送和接收消息的对象之间的组织结构；而时序图强调的是时间顺序，实际中可以利用两者优势……</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210107001406.png" alt=""></p><h2 id="6-状态机图"><a class="header-anchor" href="#6-状态机图">¶</a>6. 状态机图</h2><p>用于描述类的行为性特征</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE5.png" alt=""></p><h2 id="7-构件图"><a class="header-anchor" href="#7-构件图">¶</a>7. 构件图</h2><p>构件是对类的更高层次的抽象和封装<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE3.png" alt=""></p><h2 id="8-部署图"><a class="header-anchor" href="#8-部署图">¶</a>8. 部署图</h2><p>部署图定义了将软件制品部署到节点上的系统执行架构</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE4.png" alt=""></p><h2 id="9-活动图"><a class="header-anchor" href="#9-活动图">¶</a>9. 活动图</h2><h3 id="9-1-作用"><a class="header-anchor" href="#9-1-作用">¶</a>9.1 作用</h3><ul><li>描述一个系统/子系统的工作流程</li><li>描述用例内部数据流</li></ul><h3 id="9-2-示例"><a class="header-anchor" href="#9-2-示例">¶</a>9.2 示例</h3><p>感觉长的好像流程图，但是在线的处理上有些不一样：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210110132655.png" alt=""></p><ul><li>开始：实心圆</li><li>结束：小灯泡</li><li>条件分支：菱形</li><li>操作：圆角矩形</li></ul><h3 id="9-3-活动图元素分组"><a class="header-anchor" href="#9-3-活动图元素分组">¶</a>9.3 活动图元素分组</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103000550.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件工程原理》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Design Patterns</title>
      <link href="2021/01/10/Design-Patterns/"/>
      <url>2021/01/10/Design-Patterns/</url>
      
        <content type="html"><![CDATA[<p>先来一张总表：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210107215007.png" alt=""></p><h2 id="1-创建型——工厂方法"><a class="header-anchor" href="#1-创建型——工厂方法">¶</a>1. 创建型——工厂方法</h2><p>创建模式专注于如何实例化对象或相关对象组</p><h3 id="1-1-抽象工厂"><a class="header-anchor" href="#1-1-抽象工厂">¶</a>1.1 抽象工厂</h3><h4 id="1-1-1-例子"><a class="header-anchor" href="#1-1-1-例子">¶</a>1.1.1 例子</h4><p>你可以从木门商店买一扇木门，从铁门商店买一扇铁门，或者从相关商店买一扇PVC门。另外，你可能需要一个有不同专长的人来安装门，例如木匠做木门，焊工做铁门等等。正如你所看到的，现在门之间有一种依赖性，木门需要木匠，铁门需要焊工等等。</p><h4 id="1-1-2-简单来说"><a class="header-anchor" href="#1-1-2-简单来说">¶</a>1.1.2 简单来说</h4><p>抽象工厂是工厂的工厂，把独立但是有关联的工厂组合在一起；不指定它们具体的类</p><h4 id="1-1-3-维基百科"><a class="header-anchor" href="#1-1-3-维基百科">¶</a>1.1.3 维基百科</h4><p>抽象工厂模式提供了一种方法来封装一组单独的工厂，这些工厂具有共同的主题，而不需要指定它们的具体类</p><h4 id="1-1-4-代码实例"><a class="header-anchor" href="#1-1-4-代码实例">¶</a>1.1.4 代码实例</h4><p>门是一个接口，我们用此接口实现木门和铁门</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">interface Door </span><br><span class="line">{ </span><br><span class="line">    public function getDescription(); </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">class WoodenDoor implements Door </span><br><span class="line">{ </span><br><span class="line">    public function getDescription() </span><br><span class="line">    { </span><br><span class="line">        echo 'I am a wooden door'; </span><br><span class="line">    } </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">class IronDoor implements Door </span><br><span class="line">{ </span><br><span class="line">    public function getDescription() </span><br><span class="line">    { </span><br><span class="line">        echo 'I am an iron door'; </span><br><span class="line">    } </span><br><span class="line">} </span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">门对应的工匠是一个接口，我们用此接口实现木匠和焊工类</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>interface DoorFittingExpert<br>{<br>public function getDescription();<br>}<br>class Welder implements DoorFittingExpert<br>{<br>public function getDescription()<br>{<br>echo ‘I can only fit iron doors’;<br>}<br>}<br>class Carpenter implements DoorFittingExpert<br>{<br>public function getDescription()<br>{<br>echo ‘I can only fit wooden doors’;<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在我们有一个抽象工厂，可以让我们把有关联的对象放在一起。例如，木门工厂可以造出一扇木门和一名木匠</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>interface DoorFactory<br>{<br>public function makeDoor(): Door;<br>public function makeFittingExpert(): DoorFittingExpert;<br>}</p><p>// Wooden factory to return carpenter and wooden door<br>class WoodenDoorFactory implements DoorFactory<br>{<br>public function makeDoor(): Door<br>{<br>return new WoodenDoor();<br>}<br>public function makeFittingExpert(): DoorFittingExpert<br>{<br>return new Carpenter();<br>}<br>}<br>// Iron door factory to get iron door and the relevant fitting expert<br>class IronDoorFactory implements DoorFactory<br>{<br>public function makeDoor(): Door<br>{<br>return new IronDoor();<br>}<br>public function makeFittingExpert(): DoorFittingExpert<br>{<br>return new Welder();<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用方法</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>$woodenFactory = new WoodenDoorFactory();<br>$door = $woodenFactory-&gt;makeDoor();<br>$expert = $woodenFactory-&gt;makeFittingExpert();<br>$door-&gt;getDescription();  // Output: I am a wooden door<br>$expert-&gt;getDescription(); // Output: I can only fit wooden doors</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如你所见，木门工厂封装了木匠，木门工厂也封装了铁门和焊工。因此，它帮助我们确保每一扇创造出来的门，我们不会找一个错误的安装专家。</span><br><span class="line"></span><br><span class="line">#### 1.1.5 适用场景</span><br><span class="line"></span><br><span class="line">当依赖关系中存在有点复杂的创建逻辑的时</span><br><span class="line"></span><br><span class="line">### 1.2 单例模式</span><br><span class="line"></span><br><span class="line">#### 1.2.1 例子</span><br><span class="line"></span><br><span class="line">一个国家只能有一个总统，总统就是单例</span><br><span class="line"></span><br><span class="line">#### 1.2.2 简单来说</span><br><span class="line"></span><br><span class="line">确保某个特定的类永远只有唯一一个对象被创建</span><br><span class="line"></span><br><span class="line">#### 1.2.3 维基百科</span><br><span class="line"></span><br><span class="line">在软件工程中，单例模式是一种将类的实例化限制为仅实例化一个对象的软件设计模式。当仅需要一个对象来协调整个系统的操作时，这是非常有用的。</span><br><span class="line"></span><br><span class="line">单例模式在应用程序中引入了全局状态，在一个地方对它的更改可能会影响到其他领域，而且调试可能会变得非常困难。它们的另一个缺点是使代码紧密耦合，并且很难模拟单例对象。</span><br><span class="line"></span><br><span class="line">#### 1.2.4 代码示例</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>final class President<br>{<br>private static $instance; //用这个标志位来表示是否该类已经创建有一个对象<br>private function __construct() // 设为私有<br>{<br>// Hide the constructor<br>}<br>public static function getInstance(): President<br>{<br>if (!self::$instance) {<br>self::$instance = new self();<br>}<br>return self::$instance;<br>}<br>private function __clone() // 设为私有，表示禁用<br>{<br>// Disable cloning<br>}<br>private function __wakeup() // 设为私有<br>{<br>// Disable unserialize<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用效果：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>$president1 = President::getInstance();<br>$president2 = President::getInstance();<br>var_dump($president1 === $president2); // true</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 2. 结构型——适配器</span><br><span class="line"></span><br><span class="line">### 2.1 适配器</span><br><span class="line"></span><br><span class="line">#### 2.1.1 例子</span><br><span class="line"></span><br><span class="line">考虑到你的记忆卡里有一些图片，你需要把它们转移到你的电脑里。为了转移它们，你需要某种适配器，与你的计算机端口兼容，这样你就可以把存储卡连接到你的计算机上。在这种情况下，读卡器是一种适配器。另一个例子是著名的电源适配器;一个三脚插头不能连接到两个插座上，它需要使用一个电源适配器使它与两个插座兼容。还有一个例子是翻译人员将一个人说的话翻译给另一个人</span><br><span class="line"></span><br><span class="line">#### 2.1.2 简单来说</span><br><span class="line"></span><br><span class="line">适配器模式允许您将不兼容的对象包装在适配器中，使其与另一个类兼容。</span><br><span class="line"></span><br><span class="line">#### 2.1.3 维基百科</span><br><span class="line"></span><br><span class="line">在软件工程中，适配器模式是一种软件设计模式，它允许将现有类的接口用作另一个接口。它通常用于使现有类与其他类一起工作，而不需要修改它们的源代码。</span><br><span class="line"></span><br><span class="line">#### 2.1.4 代码示例</span><br><span class="line"></span><br><span class="line">考虑一个游戏，其中有一个猎人，他猎杀狮子。</span><br><span class="line">首先，我们有一个所有类型的狮子都必须实现的接口`Lion`</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>interface Lion<br>{<br>public function roar();<br>}<br>class AfricanLion implements Lion<br>{<br>public function roar()<br>{<br>}<br>}<br>class AsianLion implements Lion<br>{<br>public function roar()<br>{<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">猎人希望狩猎所有实现了`Lion`接口的类</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>class Hunter<br>{<br>public function hunt(Lion $lion)<br>{<br>$lion-&gt;roar();<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在，假设我们必须在游戏中添加一只野狗，这样猎人也可以猎杀它。但我们不能直接这样做，因为狗有不同的接口。为了使它与我们的猎人兼容，我们必须创建一个兼容的适配器</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>// This needs to be added to the game<br>class WildDog<br>{<br>public function bark()<br>{<br>}<br>}<br>// Adapter around wild dog to make it compatible with our game<br>class WildDogAdapter implements Lion<br>{<br>protected $dog;<br>public function __construct(WildDog $dog)<br>{<br>$this-&gt;dog = $dog;<br>}<br>public function roar()<br>{<br>$this-&gt;dog-&gt;bark();<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">猎人就可以捕捉它了，这时WildDogAdapter和AfricanLion等对于猎人来说都一样，都是实现了`Lion`接口的猎物：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>$wildDog = new WildDog();<br>$wildDogAdapter = new WildDogAdapter($wildDog);<br>$hunter = new Hunter();<br>$hunter-&gt;hunt($wildDogAdapter);</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.2 组合模式</span><br><span class="line"></span><br><span class="line">#### 2.2.1 例子</span><br><span class="line"></span><br><span class="line">每个组织都是由雇员组成的。每个员工都有相同的特征，比如有薪水，有一些职责，可以或不可以向某人汇报，可以或不可以有一些下属等等。</span><br><span class="line"></span><br><span class="line">#### 2.2.2 简单来说</span><br><span class="line"></span><br><span class="line">组合模式允许客户端以统一的方式处理单个对象，而不在乎它们的区别</span><br><span class="line"></span><br><span class="line">#### 2.2.3 维基百科</span><br><span class="line"></span><br><span class="line">在软件工程中，组合模式是一种划分设计模式。组合模式描述了以与单个对象实例相同的方式对待一组对象。组合的目的是将对象“组合”成**树结构**，以表示部分-整体层次结构。实现组合模式可以让客户端统一地对待单个对象和组合。</span><br><span class="line"></span><br><span class="line">#### 2.2.4 代码示例</span><br><span class="line"></span><br><span class="line">我们有不同类型的员工：</span><br></pre></td></tr></tbody></table></figure><p>interface Employee<br>{<br>public function __construct(string $name, float $salary);<br>public function getName(): string;<br>public function setSalary(float $salary);<br>public function getSalary(): float;<br>public function getRoles(): array;<br>}<br>class Developer implements Employee<br>{<br>protected $salary;<br>protected $name;<br>protected $roles;</p><pre><code>public function __construct(string $name, float $salary) {     $this-&gt;name = $name;     $this-&gt;salary = $salary; } public function getName(): string {     return $this-&gt;name; } public function setSalary(float $salary) {     $this-&gt;salary = $salary; } public function getSalary(): float {     return $this-&gt;salary; } public function getRoles(): array {     return $this-&gt;roles; } </code></pre><p>}<br>class Designer implements Employee<br>{<br>protected $salary;<br>protected $name;<br>protected $roles;<br>public function __construct(string $name, float $salary)<br>{<br>$this-&gt;name = $name;<br>$this-&gt;salary = $salary;<br>}<br>public function getName(): string<br>{<br>return $this-&gt;name;<br>}<br>public function setSalary(float $salary)<br>{<br>$this-&gt;salary = $salary;<br>}<br>public function getSalary(): float<br>{<br>return $this-&gt;salary;<br>}<br>public function getRoles(): array<br>{<br>return $this-&gt;roles;<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后我们有一个由不同类型的员工组成的组织:</span><br></pre></td></tr></tbody></table></figure><p>class Organization<br>{<br>protected $employees; //重点在这个employees<br>public function addEmployee(Employee $employee)<br>{<br>$this-&gt;employees[] = $employee;<br>}<br>public function getNetSalaries(): float<br>{<br>$netSalary = 0;<br>foreach ($this-&gt;employees as $employee) {<br>$netSalary += $employee-&gt;getSalary();<br>}<br>return $netSalary;<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以这样使用：</span><br></pre></td></tr></tbody></table></figure><p>// Prepare the employees<br>$john = new Developer(‘John Doe’, 12000);<br>$jane = new Designer(‘Jane Doe’, 15000);<br>// Add them to organization<br>$organization = new Organization();<br>$organization-&gt;addEmployee($john);<br>$organization-&gt;addEmployee($jane);<br>echo "Net salaries: " . $organization-&gt;getNetSalaries(); // Net Salaries: 27000</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.3 代理模式</span><br><span class="line"></span><br><span class="line">#### 2.3.1 例子</span><br><span class="line"></span><br><span class="line">你用过门禁卡进门吗?打开那扇门有多种选择，即它可以通过使用门禁卡或按下绕过安全按钮来打开。门的主要功能是打开，但在它上面**添加**了一个代理来添加一些功能。</span><br><span class="line"></span><br><span class="line">#### 2.3.2 简单来说</span><br><span class="line"></span><br><span class="line">使用代理，一个类可以表现出其他类的功能。</span><br><span class="line"></span><br><span class="line">#### 2.3.3 维基百科</span><br><span class="line"></span><br><span class="line">从最一般的形式来看，代理是一个类，它的功能是作为其他东西的接口。代理是一个包装器或代理对象，客户端调用它来在幕后访问真实的服务对象。使用代理可以简单地转发到实际对象，或者提供额外的逻辑。在代理中可以**提供额外的功能**，例如，当对真实对象的操作是资源密集型时进行缓存，或者在调用对真实对象的操作之前检查先决条件。</span><br><span class="line"></span><br><span class="line">#### 2.3.4 代码示例</span><br><span class="line"></span><br><span class="line">首先我们有门的接口和一个门的实现：</span><br></pre></td></tr></tbody></table></figure><p>interface Door<br>{<br>public function open();<br>public function close();<br>}<br>class LabDoor implements Door<br>{<br>public function open()<br>{<br>echo “Opening lab door”;<br>}<br>public function close()<br>{<br>echo “Closing the lab door”;<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们可以用代理来保护门：</span><br></pre></td></tr></tbody></table></figure><p>class SecuredDoor<br>{<br>protected $door;<br>public function __construct(Door $door)<br>{<br>$this-&gt;door = $door;<br>}<br>public function open($password)<br>{<br>if ($this-&gt;authenticate($password)) {<br>$this-&gt;door-&gt;open();<br>} else {<br>echo “Big no! It ain’t possible.”;<br>}<br>}<br>public function authenticate($password)<br>{<br>return $password === ‘$ecr@t’;<br>}<br>public function close()<br>{<br>$this-&gt;door-&gt;close();<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用如下：</span><br></pre></td></tr></tbody></table></figure><p>$door = new SecuredDoor(new LabDoor());<br>$door-&gt;open(‘invalid’); // Big no! It ain’t possible.<br>$door-&gt;open(’$ecr@t’); // Opening lab door<br>$door-&gt;close(); // Closing lab door</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.4 外观模式</span><br><span class="line"></span><br><span class="line">#### 2.4.1 例子</span><br><span class="line"></span><br><span class="line">这台电脑是怎么开的?“按下电源按钮”你说!这就是你所相信的，因为你使用的是一个简单的界面，电脑在外部提供的界面，在内部它必须做很多事情来实现它。这个到复杂子系统的简单接口是一个facade。</span><br><span class="line"></span><br><span class="line">#### 2.4.2 简单来说</span><br><span class="line"></span><br><span class="line">Facade模式为复杂的子系统提供了一个简化的接口。</span><br><span class="line"></span><br><span class="line">#### 2.4.3 维基百科</span><br><span class="line"></span><br><span class="line">facade是为更大的代码体(如类库)提供简化接口的对象。</span><br><span class="line"></span><br><span class="line">#### 2.4.4 代码示例</span><br><span class="line"></span><br><span class="line">这里我们有Computer类：</span><br></pre></td></tr></tbody></table></figure><p>class Computer<br>{<br>public function getElectricShock()<br>{<br>echo “Ouch!”;<br>}<br>public function makeSound()<br>{<br>echo “Beep beep!”;<br>}<br>public function showLoadingScreen()<br>{<br>echo “Loading…”;<br>}<br>public function bam()<br>{<br>echo “Ready to be used!”;<br>}<br>public function closeEverything()<br>{<br>echo “Bup bup bup buzzzz!”;<br>}<br>public function sooth()<br>{<br>echo “Zzzzz”;<br>}<br>public function pullCurrent()<br>{<br>echo “Haaah!”;<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这是facade，一些函数把Computer类的动作打包起来了：</span><br></pre></td></tr></tbody></table></figure><p>class ComputerFacade<br>{<br>protected $computer;<br>public function __construct(Computer $computer)<br>{<br>$this-&gt;computer = $computer;<br>}<br>public function turnOn()<br>{<br>$this-&gt;computer-&gt;getElectricShock();<br>$this-&gt;computer-&gt;makeSound();<br>$this-&gt;computer-&gt;showLoadingScreen();<br>$this-&gt;computer-&gt;bam();<br>}<br>public function turnOff()<br>{<br>$this-&gt;computer-&gt;closeEverything();<br>$this-&gt;computer-&gt;pullCurrent();<br>$this-&gt;computer-&gt;sooth();<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用起来：（太佩服了，例子真的有趣）</span><br></pre></td></tr></tbody></table></figure><p>$computer = new ComputerFacade(new Computer());<br>$computer-&gt;turnOn(); // Ouch! Beep beep! Loading… Ready to be used!<br>$computer-&gt;turnOff(); // Bup bup buzzz! Haah! Zzzzz</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 2.5 享元模式</span><br><span class="line"></span><br><span class="line">#### 2.5.1 例子</span><br><span class="line"></span><br><span class="line">你有没有在什么小摊上喝过新鲜的茶?他们通常会按你的要求多做一杯，然后把剩下的留给其他顾客，这样可以节省资源，比如汽油等。Flyweight模式就是关于共享的。</span><br><span class="line"></span><br><span class="line">#### 2.5.2 简单来说</span><br><span class="line"></span><br><span class="line">它通过尽可能多地与类似对象共享，来最小化内存使用或计算开销。</span><br><span class="line"></span><br><span class="line">#### 2.5.3 维基百科</span><br><span class="line"></span><br><span class="line">在计算机程序设计中，享元是一种软件设计模式。享元是一个对象，它通过与其他类似对象共享尽可能多的数据来最小化内存使用;当简单的重复表示会使用不可接受的内存量时，这是一种使用大量对象的方法。</span><br><span class="line"></span><br><span class="line">#### 2.5.4 代码示例</span><br><span class="line"></span><br><span class="line">我们有茶的种类和制茶器，某种茶就是享元：</span><br></pre></td></tr></tbody></table></figure><p>// Anything that will be cached is flyweight.<br>// Types of tea here will be flyweights.<br>class KarakTea<br>{<br>}<br>// Acts as a factory and saves the tea<br>class TeaMaker<br>{<br>protected $availableTea = [];<br>public function make($preference)<br>{<br>if (empty($this-&gt;availableTea[$preference])) {<br>$this-&gt;availableTea[$preference] = new KarakTea();<br>}<br>return $this-&gt;availableTea[$preference];<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后我们有茶馆，它接受订单并为顾客服务：</span><br></pre></td></tr></tbody></table></figure><p>class TeaShop<br>{<br>protected $orders;<br>protected $teaMaker;<br>public function __construct(TeaMaker $teaMaker)<br>{<br>$this-&gt;teaMaker = $teaMaker;<br>}<br>public function takeOrder(string $teaType, int $table)<br>{<br>$this-&gt;orders[$table] = $this-&gt;teaMaker-&gt;make($teaType);<br>}<br>public function serve()<br>{<br>foreach ($this-&gt;orders as $table =&gt; $tea) {<br>echo "Serving tea to table# " . $table;<br>}<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以这样使用：</span><br></pre></td></tr></tbody></table></figure><p>$teaMaker = new TeaMaker();<br>$shop = new TeaShop($teaMaker);<br>$shop-&gt;takeOrder(‘less sugar’, 1);<br>$shop-&gt;takeOrder(‘more milk’, 2);<br>$shop-&gt;takeOrder(‘without sugar’, 5);<br>$shop-&gt;serve();<br>// Serving tea to table# 1<br>// Serving tea to table# 2<br>// Serving tea to table# 5</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 3. 行为型——解释器/模板方法</span><br><span class="line"></span><br><span class="line">它涉及到对象之间的责任分配。它们与结构化模式的不同之处在于，它们不仅指定了结构，而且还概述了它们之间的消息传递/通信模式。或者换句话说，它们帮助回答“如何在软件组件中运行行为?”</span><br><span class="line"></span><br><span class="line">### 3.1 职责链模式</span><br><span class="line"></span><br><span class="line">#### 3.1.1 例子</span><br><span class="line"></span><br><span class="line">例如，你的账户中有三种支付方式(A、B和C);每一种都有不同的量。A有100美元，B有300美元，C有1000美元，付款偏好被选择为A，然后是B，然后是C。你尝试购买价值210美元的东西。使用责任链，首先检查账户A是否可以购买，如果可以，则购买，责任链将被打破。如果没有，请求将向前移动到account B检查金额，如果yes链将被打破，否则请求将继续转发，直到找到合适的处理程序。这里A、B和C是链条上的环节，整个现象就是责任链。</span><br><span class="line"></span><br><span class="line">#### 3.1.2 简单来说</span><br><span class="line"></span><br><span class="line">它有助于构建一系列对象。请求从一端进入，从一个对象进入另一个对象，直到找到合适的处理程序。</span><br><span class="line"></span><br><span class="line">#### 3.1.3 维基百科</span><br><span class="line"></span><br><span class="line">在面向对象的设计中，责任链模式是一种设计模式，由命令对象源和一系列处理对象组成。每个处理对象都包含定义它可以处理的命令对象类型的逻辑;其余的被传递给链中的下一个处理对象。</span><br><span class="line"></span><br><span class="line">#### 3.1.4 代码示例</span><br><span class="line"></span><br><span class="line">首先，我们有一个基本帐户，它具有将帐户和一些帐户链接在一起的逻辑</span><br></pre></td></tr></tbody></table></figure><p>abstract class Account<br>{<br>protected $successor;<br>protected $balance;<br>public function setNext(Account $account)<br>{<br>$this-&gt;successor = $account;<br>}<br>public function pay(float $amountToPay)<br>{<br>if ($this-&gt;canPay($amountToPay)) {<br>echo sprintf(‘Paid %s using %s’ . PHP_EOL, $amountToPay, get_called_class());<br>} elseif ($this-&gt;successor) {<br>echo sprintf(‘Cannot pay using %s. Proceeding …’ . PHP_EOL, get_called_class());<br>$this-&gt;successor-&gt;pay($amountToPay);<br>} else {<br>throw new Exception(‘None of the accounts have enough balance’);<br>}<br>}<br>public function canPay($amount): bool<br>{<br>return $this-&gt;balance &gt;= $amount;<br>}<br>}<br>class Bank extends Account<br>{<br>protected $balance;<br>public function __construct(float $balance)<br>{<br>$this-&gt;balance = $balance;<br>}<br>}<br>class Paypal extends Account<br>{<br>protected $balance;<br>public function __construct(float $balance)<br>{<br>$this-&gt;balance = $balance;<br>}<br>}<br>class Bitcoin extends Account<br>{<br>protected $balance;<br>public function __construct(float $balance)<br>{<br>$this-&gt;balance = $balance;<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在让我们使用上面定义的链接准备链(即银行，Paypal，比特币):</span><br></pre></td></tr></tbody></table></figure><p>// Let’s prepare a chain like below<br>//      $bank-&gt;$paypal-&gt;$bitcoin<br>//<br>// First priority bank<br>//      If bank can’t pay then paypal<br>//      If paypal can’t pay then bit coin<br>$bank = new Bank(100);          // Bank with balance 100<br>$paypal = new Paypal(200);      // Paypal with balance 200<br>$bitcoin = new Bitcoin(300);    // Bitcoin with balance 300<br>$bank-&gt;setNext($paypal);<br>$paypal-&gt;setNext($bitcoin);<br>// Let’s try to pay using the first priority i.e. bank<br>$bank-&gt;pay(259);<br>// Output will be<br>// ==============<br>// Cannot pay using bank. Proceeding …<br>// Cannot pay using paypal. Proceeding …:<br>// Paid 259 using Bitcoin!</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.2 观察者模式</span><br><span class="line"></span><br><span class="line">#### 3.2.1 例子</span><br><span class="line"></span><br><span class="line">一个很好的例子就是求职者，他们订阅了一些招聘网站，只要有匹配的工作机会，他们就会得到通知。</span><br><span class="line"></span><br><span class="line">#### 3.2.2 简单来说</span><br><span class="line"></span><br><span class="line">定义对象之间的依赖关系，以便每当对象更改其状态时，都会通知其所有依赖项。</span><br><span class="line"></span><br><span class="line">#### 3.2.3 维基百科</span><br><span class="line"></span><br><span class="line">观察者模式是一种软件设计模式，在这种模式中，一个对象(称为subject)维护一个被称为观察者的依赖项列表，并通过调用观察者的方法自动通知它们任何状态更改。</span><br><span class="line"></span><br><span class="line">#### 3.2.4 代码示例</span><br><span class="line"></span><br><span class="line">首先，我们有一些求职者，他们需要接到招聘启事的通知:</span><br></pre></td></tr></tbody></table></figure><p>class JobPost<br>{<br>protected $title;<br>public function __construct(string $title)<br>{<br>$this-&gt;title = $title;<br>}<br>public function getTitle()<br>{<br>return $this-&gt;title;<br>}<br>}<br>class JobSeeker implements Observer<br>{<br>protected $name;<br>public function __construct(string $name)<br>{<br>$this-&gt;name = $name;<br>}<br>public function onJobPosted(JobPost $job)<br>{<br>// Do something with the job posting<br>echo 'Hi ’ . $this-&gt;name . '! New job posted: '. $job-&gt;getTitle();<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后我们有了求职者要订阅的工作公告:</span><br></pre></td></tr></tbody></table></figure><p>class EmploymentAgency implements Observable<br>{<br>protected $observers = [];<br>protected function notify(JobPost $jobPosting)<br>{<br>foreach ($this-&gt;observers as $observer) {<br>$observer-&gt;onJobPosted($jobPosting);<br>}<br>}<br>public function attach(Observer $observer)<br>{<br>$this-&gt;observers[] = $observer;<br>}<br>public function addJob(JobPost $jobPosting)<br>{<br>$this-&gt;notify($jobPosting);<br>}<br>}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用如下：</span><br></pre></td></tr></tbody></table></figure><p>// Create subscribers<br>$johnDoe = new JobSeeker(‘John Doe’);<br>$janeDoe = new JobSeeker(‘Jane Doe’);<br>// Create publisher and attach subscribers<br>$jobPostings = new EmploymentAgency();<br>$jobPostings-&gt;attach($johnDoe);<br>$jobPostings-&gt;attach($janeDoe);<br>// Add a new job and see if subscribers get notified<br>$jobPostings-&gt;addJob(new JobPost(‘Software Engineer’));<br>// Output<br>// Hi John Doe! New job posted: Software Engineer<br>// Hi Jane Doe! New job posted: Software Engineer</p><pre><code></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件工程原理》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter12 防火墙</title>
      <link href="2021/01/03/Chapter12-%E9%98%B2%E7%81%AB%E5%A2%99/"/>
      <url>2021/01/03/Chapter12-%E9%98%B2%E7%81%AB%E5%A2%99/</url>
      
        <content type="html"><![CDATA[<h2 id="12-1-防火墙的必要性"><a class="header-anchor" href="#12-1-防火墙的必要性">¶</a>12.1 防火墙的必要性</h2><h2 id="12-2-防火墙特征"><a class="header-anchor" href="#12-2-防火墙特征">¶</a>12.2 防火墙特征</h2><h2 id="12-3-防火墙类型"><a class="header-anchor" href="#12-3-防火墙类型">¶</a>12.3 防火墙类型</h2><h2 id="12-4-防火墙载体"><a class="header-anchor" href="#12-4-防火墙载体">¶</a>12.4 防火墙载体</h2><h2 id="12-5-防火墙的位置和配置"><a class="header-anchor" href="#12-5-防火墙的位置和配置">¶</a>12.5 防火墙的位置和配置</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter11 入侵者</title>
      <link href="2021/01/03/Chapter11-%E5%85%A5%E4%BE%B5%E8%80%85/"/>
      <url>2021/01/03/Chapter11-%E5%85%A5%E4%BE%B5%E8%80%85/</url>
      
        <content type="html"><![CDATA[<h2 id="11-1-入侵者"><a class="header-anchor" href="#11-1-入侵者">¶</a>11.1 入侵者</h2><p>一般把入侵者分为3类：</p><ul><li>假冒用户</li><li>违法用户</li><li>隐秘用户</li></ul><p>入侵攻击有无恶意和恶意之分</p><p>入侵例证（一些行为迹象）：</p><h3 id="11-1-1-入侵者行为模式"><a class="header-anchor" href="#11-1-1-入侵者行为模式">¶</a>11.1.1 入侵者行为模式</h3><p>入侵者一般会遵循许多已知行为模式中的一种</p><h4 id="（1）黑客"><a class="header-anchor" href="#（1）黑客">¶</a>（1）黑客</h4><h4 id="（2）犯罪"><a class="header-anchor" href="#（2）犯罪">¶</a>（2）犯罪</h4><h4 id="（3）内部攻击"><a class="header-anchor" href="#（3）内部攻击">¶</a>（3）内部攻击</h4><h3 id="11-1-2-入侵技术"><a class="header-anchor" href="#11-1-2-入侵技术">¶</a>11.1.2 入侵技术</h3><h4 id="（1）口令保护技术"><a class="header-anchor" href="#（1）口令保护技术">¶</a>（1）口令保护技术</h4><h4 id="（2）获取口令"><a class="header-anchor" href="#（2）获取口令">¶</a>（2）获取口令</h4><h4 id="（3）缓冲区溢出提权"><a class="header-anchor" href="#（3）缓冲区溢出提权">¶</a>（3）缓冲区溢出提权</h4><h4 id="（4）检测和防护"><a class="header-anchor" href="#（4）检测和防护">¶</a>（4）检测和防护</h4><h2 id="11-2-入侵检测"><a class="header-anchor" href="#11-2-入侵检测">¶</a>11.2 入侵检测</h2><p>即是最好的入侵防护也可能失效，这时候就需要入侵检测</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE272.png" alt=""></p><p>入侵检测方法：</p><ul><li>统计异常检测：用统计学方法对用户行为进行测试<ul><li>阈值检测：各种事情出现频率的阈值（？）</li><li>基于行为曲线：为每个用户建立行为曲线，之后看变化</li></ul></li><li>基于规则的检测：定义一套能够判断行为是不是入侵行为的规则<ul><li>异常检测：检测当前行为与历史行为的偏离</li><li>渗透检测：家里一个可以用于搜索可疑行为的行为系统</li></ul></li></ul><p>两种检测方法的区别：</p><table><thead><tr><th>统计异常检测</th><th>基于规则的检测</th></tr></thead><tbody><tr><td>定义普通/期望的用户行为</td><td>定义正确的行为</td></tr><tr><td>检测假冒用户的有效手段</td><td>检测违规用户的有效手段</td></tr></tbody></table><p>实践中，要把这两种结合起来</p><h3 id="11-2-1-审计记录"><a class="header-anchor" href="#11-2-1-审计记录">¶</a>11.2.1 审计记录</h3><p>审计记录是入侵检测的一个基本工具</p><p>审计记录有以下两种分类：</p><ul><li>原始审计记录：操作系统直接自带的</li><li>面向检测的审计记录：另外有软件再将原始审计记录处理了一下，可以包括如下域：<ul><li>见书</li></ul></li></ul><p>用户操作可以分解为一系列基本行为，这样有以下三个好处：</p><ul><li>见书</li></ul><h3 id="11-2-2-统计异常检测"><a class="header-anchor" href="#11-2-2-统计异常检测">¶</a>11.2.2 统计异常检测</h3><h3 id="11-2-3-基于规则的入侵检测"><a class="header-anchor" href="#11-2-3-基于规则的入侵检测">¶</a>11.2.3 基于规则的入侵检测</h3><h3 id="11-2-4-基率谬误"><a class="header-anchor" href="#11-2-4-基率谬误">¶</a>11.2.4 基率谬误</h3><p>很难同时满足高检测率和低误报率</p><h3 id="11-2-5-分布式入侵检测"><a class="header-anchor" href="#11-2-5-分布式入侵检测">¶</a>11.2.5 分布式入侵检测</h3><p>是指对由互联网/LAN连接起来的分布式主机进行安全防护</p><p>设计分布式入侵检测系统的主要问题：</p><ul><li>见书</li></ul><p>一套很好的分布式入侵检测系统：</p><p>组成部分：</p><ul><li>见书</li></ul><h3 id="11-2-6-蜜罐"><a class="header-anchor" href="#11-2-6-蜜罐">¶</a>11.2.6 蜜罐</h3><p>顾名思义，蜜罐是一个诱骗系统，用于把攻击者从重要系统引开</p><p>蜜罐设计目的：</p><ul><li>见书</li></ul><p>蜜罐的设计，使得任何访问蜜罐的行为都非常有可能是攻击者</p><p>最开始蜜罐是一个单一主机，后来可以做一个蜜罐网络</p><p>蜜罐的部署位置：</p><ul><li>见书</li></ul><h3 id="11-2-7-入侵检测交换格式"><a class="header-anchor" href="#11-2-7-入侵检测交换格式">¶</a>11.2.7 入侵检测交换格式</h3><p>指定交换格式，是为了共享入侵检测信息</p><p>有一系列RFC：</p><ul><li>见书</li></ul><p>入侵检测交换方法：</p><ul><li>见书</li></ul><h2 id="11-3-口令管理"><a class="header-anchor" href="#11-3-口令管理">¶</a>11.3 口令管理</h2><p>口令系统是抵御入侵者的第一道防线，用于对登录到系统上的ID进行认证，ID通过一下方案保证安全性：</p><ul><li>确定用户是否被授权</li><li>确定用户访问权限</li><li>用于自主访问控制</li></ul><h3 id="11-3-1-口令的脆弱性"><a class="header-anchor" href="#11-3-1-口令的脆弱性">¶</a>11.3.1 口令的脆弱性</h3><p>一些攻击策略和对应的防护措施：</p><ul><li>见书</li></ul><h3 id="11-3-2-使用散列后的口令"><a class="header-anchor" href="#11-3-2-使用散列后的口令">¶</a>11.3.2 使用散列后的口令</h3><p>有一种使用散列后的口令加盐值的方法，可以实现安全</p><p>把用户的口令和加盐值作为散列函数的输入，口令文件中存储：散列值+明文加盐值</p><p>用户登录时，输入口令，系统把明文加盐值拿出来，处理以后比对，正确则过</p><p>salt的三个目的：</p><ul><li>见书</li></ul><h3 id="11-3-3-用户口令选择"><a class="header-anchor" href="#11-3-3-用户口令选择">¶</a>11.3.3 用户口令选择</h3><p>破译器的关键在于，倾向于猜测用户常用的口令</p><p>实验证明，这种攻击成功率很高；防御方法有：访问控制以限制用户对口令文件的读取，强迫用户使用强密码等等</p><h3 id="11-3-4-口令选择策略"><a class="header-anchor" href="#11-3-4-口令选择策略">¶</a>11.3.4 口令选择策略</h3><p>有一些方法，来实现使口令难以猜测且用户容易记住的目标</p><h3 id="11-3-5-Bloom滤波器"><a class="header-anchor" href="#11-3-5-Bloom滤波器">¶</a>11.3.5 Bloom滤波器</h3><p>一种先验口令检查技术，基于拒绝列表上的口令</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter10 恶意软件</title>
      <link href="2021/01/03/Chapter10-%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/"/>
      <url>2021/01/03/Chapter10-%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="10-10-分布式拒绝服务攻击"><a class="header-anchor" href="#10-10-分布式拒绝服务攻击">¶</a>10.10 分布式拒绝服务攻击</h2><h3 id="10-10-1-DDos攻击描述"><a class="header-anchor" href="#10-10-1-DDos攻击描述">¶</a>10.10.1 DDos攻击描述</h3><h4 id="（1）简单DDos攻击（消耗内部资源）"><a class="header-anchor" href="#（1）简单DDos攻击（消耗内部资源）">¶</a>（1）简单DDos攻击（消耗内部资源）</h4><ul><li>SYN突发流量攻击：也就是SYN Flooding</li></ul><p>SYN Flooding其实是以TCP状态数据结构为目标消耗内部资源的一个例子，我们还可以有其他例子：</p><ul><li>消耗进程相关数据结构</li><li>消耗磁盘空间<ul><li>产生过多的邮件信息</li><li>故意产生必须记录的错误</li><li>在匿名ftp空间或网络共享空间中放置文件</li></ul></li></ul><p>消耗数据传送资源，可以是ICMP攻击：</p><ul><li>ICMP攻击：攻击者发很多请求包，目标路由器会被响应应答封包淹没（？）</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210104100103.png" alt=""></p><h4 id="（2）基于突发流量式DDos攻击"><a class="header-anchor" href="#（2）基于突发流量式DDos攻击">¶</a>（2）基于突发流量式DDos攻击</h4><ul><li>直接DDos攻击</li><li>反射DDos攻击</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE273.png" alt=""></p><h3 id="10-10-2-构造攻击网络"><a class="header-anchor" href="#10-10-2-构造攻击网络">¶</a>10.10.2 构造攻击网络</h3><ul><li>首先要有能在大量机器上运行的DDos软件</li><li>目标要有大量系统漏洞</li><li>DDos软件有定位新机器的策略（扫描），扫描方法有多种</li></ul><h3 id="10-10-3-DDos防护措施"><a class="header-anchor" href="#10-10-3-DDos防护措施">¶</a>10.10.3 DDos防护措施</h3><p>书上写了3条，还可以有如算验证码之类的让Attacker慢下来的操作</p><h3 id="Smurf"><a class="header-anchor" href="#Smurf">¶</a>Smurf</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter2 内存寻址</title>
      <link href="2021/01/02/Chapter2-%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/"/>
      <url>2021/01/02/Chapter2-%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-内存寻址"><a class="header-anchor" href="#2-1-内存寻址">¶</a>2.1 内存寻址</h2><h3 id="2-1-1-Intel-x86-CPU寻址的演变"><a class="header-anchor" href="#2-1-1-Intel-x86-CPU寻址的演变">¶</a>2.1.1 Intel x86 CPU寻址的演变</h3><h3 id="2-1-2-80x86寄存器简介"><a class="header-anchor" href="#2-1-2-80x86寄存器简介">¶</a>2.1.2 80x86寄存器简介</h3><h4 id="（1）8个32位通用寄存器"><a class="header-anchor" href="#（1）8个32位通用寄存器">¶</a>（1）8个32位通用寄存器</h4><p>8个32位通用寄存器指的是：EAX/EBX/ECX/EDX/EBP/ESP/ESI/EDI</p><p>他们低16位可以当做8个寄存器：AX/BX/CX/DX/BP/SP/SI/DI</p><p>其中AX/BX/CX/DX又可以分为8位一组的低字节和高字节两部分，作为8个8位寄存器</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210102161511.png" style="width:800px;height:400px"><h4 id="（2）4个16位段寄存器"><a class="header-anchor" href="#（2）4个16位段寄存器">¶</a>（2）4个16位段寄存器</h4><p>分别用于存放几个段的段地址</p><ul><li>CS：代码段</li><li>DS：数据段</li><li>SS：堆栈段</li><li>ES：其他段</li></ul><p>放的都是基地址</p><h4 id="（3）指令指针寄存器和标志寄存器"><a class="header-anchor" href="#（3）指令指针寄存器和标志寄存器">¶</a>（3）指令指针寄存器和标志寄存器</h4><ul><li>EIP：下一条要执行的指令的offset（相对CS），低16位叫IP寄存器</li><li>EFLAGS：控制等</li></ul><h4 id="（4）控制寄存器"><a class="header-anchor" href="#（4）控制寄存器">¶</a>（4）控制寄存器</h4><p>CR系列，主要用于分页机制；4个32位的控制寄存器：CR0/CR1/CR2/CR3</p><h3 id="2-1-3-物理地址、虚拟地址、线性地址"><a class="header-anchor" href="#2-1-3-物理地址、虚拟地址、线性地址">¶</a>2.1.3 物理地址、虚拟地址、线性地址</h3><p>物理内存条提供的内存空间就是物理内存空间，每个内存单元的实际地址就是物理地址；而程序员看到的内存空间定义为虚拟地址空间，叫虚拟地址或者逻辑地址</p><p>内存管理单元MMU（它是一种硬件电路）负责把虚拟地址映射为物理地址，线性地址是指一段连续不分段的地址空间（大小在0~4GB）</p><h2 id="2-2-段机制"><a class="header-anchor" href="#2-2-段机制">¶</a>2.2 段机制</h2><p><strong>段是虚拟地址空间的基本单位</strong></p><h3 id="2-2-1-段描述符"><a class="header-anchor" href="#2-2-1-段描述符">¶</a>2.2.1 段描述符</h3><p>由于一个段有不少相关信息，所以是一个数据结构，包括：</p><ul><li>基地址</li><li>界限</li><li>保护属性</li></ul><p>可以用下图描述：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210218140252969.png" alt="image-20210218140252969" style="width:500px;height:500px"><p>​每个段可以用下图这样的段描述符来表示，多个段描述符就可以组成段描述符表；存取权字节不同位有不同的作用。</p><p>​我们分实模式和保护模式来考虑，后者会更复杂一些，引入了4个特权级来实现保护</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210218144256015.png" alt="image-20210218144256015" style="width:800px;height:500px"><p>​在保护模式下，段寄存器也叫作选择符，它其中存的数据是这样的：</p><table><thead><tr><th style="text-align:center">索引（3-15位）</th><th style="text-align:center">TI（第2位）</th><th style="text-align:center">RPL（0-1位）</th></tr></thead><tbody><tr><td style="text-align:center">表示对应的段描述符在描述符表中的位置</td><td style="text-align:center">选择域，TI=0表示从全局描述符表中选择，TI=1表示从局部描述符表中选择相应的段描述符</td><td style="text-align:center">表示请求者的特权级，用0/1/2/3表示，0对应内核态，是最高特权级</td></tr></tbody></table><h3 id="2-2-2-地址转换及保护"><a class="header-anchor" href="#2-2-2-地址转换及保护">¶</a>2.2.2 地址转换及保护</h3><p>​通过一些步骤，可以将虚拟地址（表示方式——选择符：偏移量，选择符就是段寄存器）转换为线性地址；其中有两个方面实现了对段的保护</p><h3 id="2-2-3-Linux中的段"><a class="header-anchor" href="#2-2-3-Linux中的段">¶</a>2.2.3 Linux中的段</h3><p>​说明了Linux定义段的方式的内涵（即为什么）</p><h2 id="2-3-分页机制"><a class="header-anchor" href="#2-3-分页机制">¶</a>2.3 分页机制</h2><p>​分页机制在段机制之后进行，实现线性地址$\rightarrow$物理地址的转换；段机制是实现虚拟地址$\rightarrow$线性地址。如果操作系统不支持分页的话，线性地址=物理地址</p><h3 id="2-3-1-页与页表"><a class="header-anchor" href="#2-3-1-页与页表">¶</a>2.3.1 页与页表</h3><h4 id="1-页、物理页面及页大小"><a class="header-anchor" href="#1-页、物理页面及页大小">¶</a>1. 页、物理页面及页大小</h4><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210218170045854.png" alt="image-20210218170045854" style="width:500px;height:500px"><p>​线性地址被分为页，物理地址被分为页面，两者大小相等；标准页大小为4KB</p><h4 id="2-页表"><a class="header-anchor" href="#2-页表">¶</a>2.页表</h4><p>​页表是把线性地址映射成物理地址的一种数据结构，那么页表的每一项需要包含什么内容呢？</p><pre><code>- 物理页面的基地址- 页的属性</code></pre><p>​    根据计算，这些信息只需要32位就足够存放了，即每个页表项占4个字节就足够了。</p><p>​当页数过多导致页表项占用的空间过多，我们可以使用两级页表来解决这个问题。</p><h4 id="3-两级页表"><a class="header-anchor" href="#3-两级页表">¶</a>3. 两级页表</h4><p>​两级页表就是对页表再分页；下图左边是两级页表，右边是两级页表的地址结构：先找到页目录项，看看其中的内容（也就是第二级页表的序号）；找到了第二级页表，根据“页”里面的内容（就是第几页），去找对应的页，然后根据页内偏移量，在此页内偏移找到需要的东西</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210218223210873.png" alt="image-20210218223210873"></p><h4 id="4-页表项结构"><a class="header-anchor" href="#4-页表项结构">¶</a>4. 页表项结构</h4><p>​页表的每一项占4个字节，内容如下图分配：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210218223320249.png" alt="image-20210218223320249" style="width:500px;height:280px"><h4 id="5-硬件保护机制"><a class="header-anchor" href="#5-硬件保护机制">¶</a>5. 硬件保护机制</h4><p>​用一些位来控制存取权限、寻址权限等等</p><h3 id="2-3-2-线性地址到物理地址的转换"><a class="header-anchor" href="#2-3-2-线性地址到物理地址的转换">¶</a>2.3.2 线性地址到物理地址的转换</h3><p>​这个转换，解决的是“如何把32位的线性地址通过分页机制转为32位物理地址”的问题；过程~~如下图所示：~~有亿点点复杂，咱就先不研究了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8">😆</span></p><h3 id="2-3-3-分页举例"><a class="header-anchor" href="#2-3-3-分页举例">¶</a>2.3.3 分页举例</h3><h3 id="2-3-4-页面高速缓存"><a class="header-anchor" href="#2-3-4-页面高速缓存">¶</a>2.3.4 页面高速缓存</h3><p>​页表放在内存中，所以CPU每次取用一个数据，都至少要访问两次内存，大大降低了访问的速度；所以就有了TLB</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210219000620882.png" alt="image-20210219000620882" style="width:500px;height:280px"><h2 id="2-4-Linux中的分页机制"><a class="header-anchor" href="#2-4-Linux中的分页机制">¶</a>2.4 Linux中的分页机制</h2><p>​Linux有分页也有分段；先分段，使得虚拟地址可以转换为线性地址；再分页，使线性地址可以转换为物理地址。Linux采用三级分页地址，如下图：</p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/image-20210219001957454.png" alt="image-20210219001957454" style="width:600px;height:320px"><h2 id="2-5-Linux中的汇编语言"><a class="header-anchor" href="#2-5-Linux中的汇编语言">¶</a>2.5 Linux中的汇编语言</h2><p>​Linux的源代码中，有C语言编写的、汇编语言（AT&amp;T的i386汇编语言）编写的、还有C语言里面嵌汇编语言的</p><p>​这一节就是在介绍汇编语言的语法等等</p><h2 id="2-6-Linux系统地址映射举例"><a class="header-anchor" href="#2-6-Linux系统地址映射举例">¶</a>2.6 Linux系统地址映射举例</h2><p>​拿了一个程序来举例，感觉还挺有意思的（挺有知识的），有空可以回头补一下</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《Linux操作系统原理与应用(E2)》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter8 电子邮件安全</title>
      <link href="2021/01/01/Chapter8-%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
      <url>2021/01/01/Chapter8-%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>由于电子邮件应用太广泛了，所以有了两种安全方案：PGP和S/MIME</p><h2 id="8-1-PGP"><a class="header-anchor" href="#8-1-PGP">¶</a>8.1 PGP</h2><p>PGP可以提供保密和认证</p><h3 id="8-1-1-符号约定"><a class="header-anchor" href="#8-1-1-符号约定">¶</a>8.1.1 符号约定</h3><h3 id="8-1-2-操作描述"><a class="header-anchor" href="#8-1-2-操作描述">¶</a>8.1.2 操作描述</h3><p>PGP的实操包括如下服务：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210101233530.png" alt=""></p><h4 id="（1）认证"><a class="header-anchor" href="#（1）认证">¶</a>（1）认证</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE130.png" alt=""></p><h4 id="（2）保密"><a class="header-anchor" href="#（2）保密">¶</a>（2）保密</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE131.png" alt=""></p><h4 id="（3）保密与认证"><a class="header-anchor" href="#（3）保密与认证">¶</a>（3）保密与认证</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE133.png" alt=""></p><h4 id="（4）压缩"><a class="header-anchor" href="#（4）压缩">¶</a>（4）压缩</h4><h4 id="（5）电子邮件兼容性"><a class="header-anchor" href="#（5）电子邮件兼容性">¶</a>（5）电子邮件兼容性</h4><p>总结一下PGP消息的的接收和发送流程如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210102000654.png" alt=""></p><h2 id="8-2-S-MIME"><a class="header-anchor" href="#8-2-S-MIME">¶</a>8.2 S/MIME</h2><p>S/MIME是对MIME的电子邮件格式做安全性增强</p><h3 id="8-2-1-RFC-5322"><a class="header-anchor" href="#8-2-1-RFC-5322">¶</a>8.2.1 RFC 5322</h3><p>RFC 5322定义了一种电子邮件传输的文本消息格式：报头+空行+正文</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue, 16 Jan 1998 10: 37:17(EST)</span><br><span class="line">From: "william stallings" ws@shore.netSubject: The Syntax in RFC 5322</span><br><span class="line">To: Smith@other-host.com</span><br><span class="line">cc: Jones@Yet-Another-Host.com</span><br><span class="line"></span><br><span class="line">Hello.This section begins the actual message body，which is delimited fromthe message heading by a blank line.</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="8-2-2-MIME"><a class="header-anchor" href="#8-2-2-MIME">¶</a>8.2.2 MIME</h3><p>学名叫：多用途网际邮件扩展，是对RFC 5322的扩展，用于解决这个格式存在的问题、协议存在的问题等……</p><p>MIME定义了：</p><ul><li>5种新报头域</li><li>多种内容格式</li><li>编码转换方式</li></ul><h4 id="（1）5种新报头域"><a class="header-anchor" href="#（1）5种新报头域">¶</a>（1）5种新报头域</h4><p>MIME版本MIME-Version：其参数值必须为1.0，表明该消息符合RFC 2045和2046。<br>内容类型Content-Type：详细描述正文中包含的数据，使得用户代理可以选择合适的代理或机制表示数据或正确处理数据。<br>内容传输编码Content-Transfer-Encoding：将消息正文转换为可传输类型的转换方式。<br>内容ID  Content-ID：在多个上下文中唯一标识MIME实体的标识。<br>内容描述 Content-Description：正文对象的文本描述，在该对象不可读（如音频数据）时使用。</p><h4 id="（2）多种内容格式"><a class="header-anchor" href="#（2）多种内容格式">¶</a>（2）多种内容格式</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210102105630.png" alt=""></p><h4 id="（3）编码转换方式"><a class="header-anchor" href="#（3）编码转换方式">¶</a>（3）编码转换方式</h4><p>提供可靠的传输</p><h3 id="8-2-3-S-MIME的功能"><a class="header-anchor" href="#8-2-3-S-MIME的功能">¶</a>8.2.3 S/MIME的功能</h3><p>可以理解成在MIME的基础上多加了一些类型</p><h4 id="（1）S-MIME的功能"><a class="header-anchor" href="#（1）S-MIME的功能">¶</a>（1）S/MIME的功能</h4><ul><li>封装数据：加密内容+接收方解密需要的密钥</li><li>签名数据：内容—&gt;H—&gt;私钥加密，签名加内容再整个Base-64（没有S/MIME能力的不能看到内容，不能验证签名）</li><li>透明签名数据：内容—&gt;H—&gt;私钥加密，只签名Base-64（没有S/MIME能力的能看到内容，不能验证签名）</li><li>签名并封装数据：签名+加密</li></ul><h4 id="（2）加密算法"><a class="header-anchor" href="#（2）加密算法">¶</a>（2）加密算法</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210102121624.png" alt=""></p><p>如何选择加密算法？<br>书上有一些判断规则之类的</p><h3 id="8-2-4-S-MIME消息"><a class="header-anchor" href="#8-2-4-S-MIME消息">¶</a>8.2.4 S/MIME消息</h3><h4 id="（1）保护MIME实体"><a class="header-anchor" href="#（1）保护MIME实体">¶</a>（1）保护MIME实体</h4><p>这里是要讲S/MIME准备消息的一般操作：</p><ul><li>首先我们用传统的MIME格式来生成MIME实体</li><li>然后把MIME实体和安全相关数据交给S/MIME处理</li><li>S/MIME的处理结果是PKCS对象（？）</li><li>在将PKCS对象封装为MIME消息</li></ul><p>S/MIME的内容类型如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210102123027.png" alt=""></p><p>下面逐一介绍这些类型：</p><h4 id="（2）封装数据"><a class="header-anchor" href="#（2）封装数据">¶</a>（2）封装数据</h4><p>准备封装数据MIME实体的步骤如下：</p><ul><li>对对称算法生成伪随机的会话密钥</li><li>用对方公钥加密会话密钥</li><li>准备信息块</li><li>用会话密钥加密消息</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE129.png" alt=""></p><h4 id="（3）签名数据"><a class="header-anchor" href="#（3）签名数据">¶</a>（3）签名数据</h4><p>MIME实体准备签名数据的步骤如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/22RRV%7B8Y50AF0NZSN@N94R5.png" alt=""></p><h4 id="（4）透明签名"><a class="header-anchor" href="#（4）透明签名">¶</a>（4）透明签名</h4><p>主要用在多部分的，消息与签名分离</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE128.png" alt=""></p><h4 id="（5）注册请求"><a class="header-anchor" href="#（5）注册请求">¶</a>（5）注册请求</h4><p>向CA申请公钥证书</p><h4 id="（6）仅证书消息"><a class="header-anchor" href="#（6）仅证书消息">¶</a>（6）仅证书消息</h4><p>在应答注册请求时发送，仅包含证书/CRL</p><h3 id="8-2-5-S-MIME证书处理过程"><a class="header-anchor" href="#8-2-5-S-MIME证书处理过程">¶</a>8.2.5 S/MIME证书处理过程</h3><p>S/MIME使用公钥证书的方式与X.509v3一致</p><h4 id="（1）用户代理职责"><a class="header-anchor" href="#（1）用户代理职责">¶</a>（1）用户代理职责</h4><p>S/MIME的用户要做的事</p><h4 id="（2）VeriSign证书"><a class="header-anchor" href="#（2）VeriSign证书">¶</a>（2）VeriSign证书</h4><p>VeriSign是提供CA服务的公司之一</p><h3 id="8-2-6-增强的安全服务"><a class="header-anchor" href="#8-2-6-增强的安全服务">¶</a>8.2.6 增强的安全服务</h3><h2 id="8-3-DKIM"><a class="header-anchor" href="#8-3-DKIM">¶</a>8.3 DKIM</h2><p>学名叫：域名密钥识别邮件——是电子邮件信息密钥签名规范</p><p>说人话：<br>受到这种信息的一方，可以查询其中的签名域，获取公钥，并且确定对方的身份可信</p><h3 id="8-3-1-互联网邮件体系结构"><a class="header-anchor" href="#8-3-1-互联网邮件体系结构">¶</a>8.3.1 互联网邮件体系结构</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE125.png" alt=""></p><p>补充一个概念：行政管理域ADMD</p><blockquote><p>每个行政管理域可以用不同的决策，比如，组织内部的邮件交换处理，组织之间的……</p></blockquote><h3 id="8-3-2-E-mail威胁"><a class="header-anchor" href="#8-3-2-E-mail威胁">¶</a>8.3.2 E-mail威胁</h3><h4 id="（1）攻击者的3个威胁等级"><a class="header-anchor" href="#（1）攻击者的3个威胁等级">¶</a>（1）攻击者的3个威胁等级</h4><h4 id="（2）攻击者可能具备的能力"><a class="header-anchor" href="#（2）攻击者可能具备的能力">¶</a>（2）攻击者可能具备的能力</h4><h4 id="（3）定位"><a class="header-anchor" href="#（3）定位">¶</a>（3）定位</h4><p>（？）</p><h3 id="8-3-3-DKIM策略"><a class="header-anchor" href="#8-3-3-DKIM策略">¶</a>8.3.3 DKIM策略</h3><p>提供一种对终端用户透明的E-mail认证技术</p><p>透明到底是啥意思（？）</p><p>DKIM工作流程：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE126.png" alt=""></p><p>基本架构和互联网邮件体系结构是一致的</p><h3 id="8-3-4-DKIM的功能流程"><a class="header-anchor" href="#8-3-4-DKIM的功能流程">¶</a>8.3.4 DKIM的功能流程</h3><p>上面是举了一个例子，现在有一份更详细的描述：</p><p>好复杂，不太懂（？）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter7 无线网络安全</title>
      <link href="2021/01/01/Chapter7-%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
      <url>2021/01/01/Chapter7-%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="7-1-无线安全"><a class="header-anchor" href="#7-1-无线安全">¶</a>7.1 无线安全</h2><p>无线网络有一些有线网络中不会遇到的问题：</p><p>无线网络的构成，三部分都有攻击切入点：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210101172029.png" alt=""></p><h3 id="7-1-1-无线网络安全威胁"><a class="header-anchor" href="#7-1-1-无线网络安全威胁">¶</a>7.1.1 无线网络安全威胁</h3><h3 id="7-1-2-无线安全措施"><a class="header-anchor" href="#7-1-2-无线安全措施">¶</a>7.1.2 无线安全措施</h3><p>根据上面的切入点，对应地，我们可以获得安全措施的三个切入点</p><h4 id="（1）安全无线传输"><a class="header-anchor" href="#（1）安全无线传输">¶</a>（1）安全无线传输</h4><p>对于监听攻击：</p><ul><li>信息隐藏技术：施工记者定位无线接入点变得困难</li><li>加密</li></ul><h4 id="（2）安全的无线接入点"><a class="header-anchor" href="#（2）安全的无线接入点">¶</a>（2）安全的无线接入点</h4><p>防止未认证入侵：对基于端口的网络访问进行控制</p><h4 id="（3）安全的无线网络（路由器-终端）"><a class="header-anchor" href="#（3）安全的无线网络（路由器-终端）">¶</a>（3）安全的无线网络（路由器+终端）</h4><p>加密、杀毒、改路由器密码等等</p><h2 id="7-2-移动设备安全"><a class="header-anchor" href="#7-2-移动设备安全">¶</a>7.2 移动设备安全</h2><p>以前设备少，网络边界很好定，现在太多了……</p><h3 id="7-2-1-安全威胁"><a class="header-anchor" href="#7-2-1-安全威胁">¶</a>7.2.1 安全威胁</h3><h4 id="（1）缺乏物理安全控制"><a class="header-anchor" href="#（1）缺乏物理安全控制">¶</a>（1）缺乏物理安全控制</h4><p>比如手机被偷？</p><h4 id="（2）"><a class="header-anchor" href="#（2）">¶</a>（2）</h4><h3 id="7-2-2-移动设备安全策略"><a class="header-anchor" href="#7-2-2-移动设备安全策略">¶</a>7.2.2 移动设备安全策略</h3><p>移动设备安全策略主要包括以下几种</p><h4 id="（1）设备安全"><a class="header-anchor" href="#（1）设备安全">¶</a>（1）设备安全</h4><p>在员工的个人设备访问企业资源的情况下，保证安全</p><h4 id="（2）数据流安全"><a class="header-anchor" href="#（2）数据流安全">¶</a>（2）数据流安全</h4><p>使用加密服务、认证服务</p><h4 id="（3）屏障安全"><a class="header-anchor" href="#（3）屏障安全">¶</a>（3）屏障安全</h4><p>设防火墙等等</p><h2 id="7-3-IEEE-802-11-无线局域网概述"><a class="header-anchor" href="#7-3-IEEE-802-11-无线局域网概述">¶</a>7.3 IEEE 802.11 无线局域网概述</h2><p>IEEE 802.11是个制定无线局域网协议和传输规范的工作组</p><h3 id="7-3-1-WiFi联盟"><a class="header-anchor" href="#7-3-1-WiFi联盟">¶</a>7.3.1 WiFi联盟</h3><p>WiFi联盟是个组织，为什么会出现这个组织呢？<br>首先就要谈到一个问题：不同供应商的产品之间不能呢个确定是否顺利连接，所以就需要互操作认证<br>WiFi联盟制定了一些认证过程、认证系统</p><h3 id="7-3-2-IEEE-802-协议架构"><a class="header-anchor" href="#7-3-2-IEEE-802-协议架构">¶</a>7.3.2 IEEE 802 协议架构</h3><p>IEEE 802.11协议栈如下图，其实和计算机网络中学到的差不多：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210101195554.png" alt=""></p><h3 id="7-3-3-IEEE-802-11-网络组成与架构模型"><a class="header-anchor" href="#7-3-3-IEEE-802-11-网络组成与架构模型">¶</a>7.3.3 IEEE 802.11 网络组成与架构模型</h3><p>这是这个工作组设计的模型</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE115.png" alt=""></p><h3 id="7-3-4-IEEE-802-11-服务"><a class="header-anchor" href="#7-3-4-IEEE-802-11-服务">¶</a>7.3.4 IEEE 802.11 服务</h3><p>为了实现与有线局域网相同的功能，IEEE 802.11为无线局域网定义了以下9种服务：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE116.png" alt=""></p><h2 id="7-4-IEEE-802-11i-无线局域网安全"><a class="header-anchor" href="#7-4-IEEE-802-11i-无线局域网安全">¶</a>7.4 IEEE 802.11i 无线局域网安全</h2><p><em>突然发现老师的课件没怎么讲这一部分，先略过好了</em></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter11 软件项目估算和计划</title>
      <link href="2020/12/31/Chapter11-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E4%BC%B0%E7%AE%97%E5%92%8C%E8%AE%A1%E5%88%92/"/>
      <url>2020/12/31/Chapter11-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E4%BC%B0%E7%AE%97%E5%92%8C%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter10 软件项目管理</title>
      <link href="2020/12/31/Chapter10-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
      <url>2020/12/31/Chapter10-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter9 软件演化和软件维护</title>
      <link href="2020/12/31/Chapter9-%E8%BD%AF%E4%BB%B6%E6%BC%94%E5%8C%96%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4/"/>
      <url>2020/12/31/Chapter9-%E8%BD%AF%E4%BB%B6%E6%BC%94%E5%8C%96%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter8 软件测试</title>
      <link href="2020/12/31/Chapter8-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
      <url>2020/12/31/Chapter8-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter7 面向对象的设计建模</title>
      <link href="2020/12/31/Chapter7-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%BB%BA%E6%A8%A1/"/>
      <url>2020/12/31/Chapter7-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter6 设计工程</title>
      <link href="2020/12/31/Chapter6-%E8%AE%BE%E8%AE%A1%E5%B7%A5%E7%A8%8B/"/>
      <url>2020/12/31/Chapter6-%E8%AE%BE%E8%AE%A1%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>需求工程解决“做什么”，而设计工程则解决“怎么做”的问题；这章超级重要，有很多设计模式，也有4+1视图</p><p><strong>设计工程的成果是设计模型</strong></p><h2 id="6-1-设计工程概述"><a class="header-anchor" href="#6-1-设计工程概述">¶</a>6.1 设计工程概述</h2><h3 id="6-1-1-软件设计过程"><a class="header-anchor" href="#6-1-1-软件设计过程">¶</a>6.1.1 软件设计过程</h3><p>设计的两个阶段：</p><ul><li>架构设计（概要设计）：高抽象层次，定义模块、接口等等</li><li>详细设计（构件级设计）：低抽象层次，定义数据结构、算法等等</li></ul><h3 id="6-1-2-软件设计模型"><a class="header-anchor" href="#6-1-2-软件设计模型">¶</a>6.1.2 软件设计模型</h3><p>分析模型和设计模型的区别：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210107212316.png" alt=""></p><h2 id="6-2-软件设计原则"><a class="header-anchor" href="#6-2-软件设计原则">¶</a>6.2 软件设计原则</h2><h3 id="6-2-1-抽象"><a class="header-anchor" href="#6-2-1-抽象">¶</a>6.2.1 抽象</h3><p>有三种类别：</p><ul><li>过程抽象：就像写函数</li><li>数据抽象：就像写结构体</li><li>对象抽象：就像写类</li></ul><h3 id="6-2-2-分解和模块化"><a class="header-anchor" href="#6-2-2-分解和模块化">¶</a>6.2.2 分解和模块化</h3><p>把大系统分解成几个模块，这里有个“7±2”的原则</p><h3 id="6-2-3-封装和信息隐藏"><a class="header-anchor" href="#6-2-3-封装和信息隐藏">¶</a>6.2.3 封装和信息隐藏</h3><p>封装和信息隐藏的原则是：一个模块内包含的信息（字段+方法）对于不需要这些信息的模块来说是不能访问的</p><h3 id="6-2-4-高内聚和低耦合"><a class="header-anchor" href="#6-2-4-高内聚和低耦合">¶</a>6.2.4 高内聚和低耦合</h3><ul><li>内聚：一个模块内各元素结合</li><li>耦合：不同模块之间的互连</li></ul><h2 id="6-3-软件质量属性的设计策略"><a class="header-anchor" href="#6-3-软件质量属性的设计策略">¶</a>6.3 软件质量属性的设计策略</h2><p>质量属性包括以下几点：</p><h3 id="6-3-1-可用性设计策略"><a class="header-anchor" href="#6-3-1-可用性设计策略">¶</a>6.3.1 可用性设计策略</h3><h3 id="6-3-2-可修改性设计策略"><a class="header-anchor" href="#6-3-2-可修改性设计策略">¶</a>6.3.2 可修改性设计策略</h3><h3 id="6-3-3-性能设计策略"><a class="header-anchor" href="#6-3-3-性能设计策略">¶</a>6.3.3 性能设计策略</h3><h3 id="6-3-4-安全性设计策略"><a class="header-anchor" href="#6-3-4-安全性设计策略">¶</a>6.3.4 安全性设计策略</h3><h3 id="6-3-5-可测试性设计策略"><a class="header-anchor" href="#6-3-5-可测试性设计策略">¶</a>6.3.5 可测试性设计策略</h3><h3 id="6-3-6-易用性设计策略"><a class="header-anchor" href="#6-3-6-易用性设计策略">¶</a>6.3.6 易用性设计策略</h3><h2 id="6-4-架构风格"><a class="header-anchor" href="#6-4-架构风格">¶</a>6.4 架构风格</h2><p>常见的架构风格如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210107214419.png" alt=""></p><h3 id="6-4-1-通用结构的架构风格"><a class="header-anchor" href="#6-4-1-通用结构的架构风格">¶</a>6.4.1 通用结构的架构风格</h3><h3 id="6-4-2-分布式系统的架构风格"><a class="header-anchor" href="#6-4-2-分布式系统的架构风格">¶</a>6.4.2 分布式系统的架构风格</h3><h3 id="6-4-3-交互式系统的架构风格"><a class="header-anchor" href="#6-4-3-交互式系统的架构风格">¶</a>6.4.3 交互式系统的架构风格</h3><h3 id="6-4-4-自适应系统的架构风格"><a class="header-anchor" href="#6-4-4-自适应系统的架构风格">¶</a>6.4.4 自适应系统的架构风格</h3><h3 id="6-4-5-其他架构风格"><a class="header-anchor" href="#6-4-5-其他架构风格">¶</a>6.4.5 其他架构风格</h3><h2 id="6-5-设计模式"><a class="header-anchor" href="#6-5-设计模式">¶</a>6.5 设计模式</h2><p>设计模式有如下分类：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210107215007.png" alt=""></p><h3 id="6-5-1-创建型设计模式"><a class="header-anchor" href="#6-5-1-创建型设计模式">¶</a>6.5.1 创建型设计模式</h3><h3 id="6-5-2-结构性设计模式"><a class="header-anchor" href="#6-5-2-结构性设计模式">¶</a>6.5.2 结构性设计模式</h3><h3 id="6-5-3-行为型设计模式"><a class="header-anchor" href="#6-5-3-行为型设计模式">¶</a>6.5.3 行为型设计模式</h3><h2 id="6-6-人机界面设计"><a class="header-anchor" href="#6-6-人机界面设计">¶</a>6.6 人机界面设计</h2><h3 id="6-6-1-界面设计原则"><a class="header-anchor" href="#6-6-1-界面设计原则">¶</a>6.6.1 界面设计原则</h3><h3 id="6-6-2-人机交互方式"><a class="header-anchor" href="#6-6-2-人机交互方式">¶</a>6.6.2 人机交互方式</h3><h3 id="6-6-3-界面设计过程"><a class="header-anchor" href="#6-6-3-界面设计过程">¶</a>6.6.3 界面设计过程</h3><h3 id="6-6-4-界面设计问题"><a class="header-anchor" href="#6-6-4-界面设计问题">¶</a>6.6.4 界面设计问题</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件工程原理》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter5 面向对象的分析建模</title>
      <link href="2020/12/31/Chapter5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90%E5%BB%BA%E6%A8%A1/"/>
      <url>2020/12/31/Chapter5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<p>这章好重要！有UML（Unified Modeling Language，统一建模语言）！</p><h2 id="5-1-面向对象的分析模型UML"><a class="header-anchor" href="#5-1-面向对象的分析模型UML">¶</a>5.1 面向对象的分析模型UML</h2><p>先说一下学到这里了，感受到的关于“分析”和“设计”的一些知识：</p><ul><li>分析解决的是What的问题，产生的分析模型是平台无关模型</li><li>设计解决的是How的问题，产生的设计模型是平台相关模型</li></ul><p>面向对象的分析模型是包括许多图的，这些图从不同的角度来描述软件系统要解决的问题</p><h3 id="5-1-1-用例图"><a class="header-anchor" href="#5-1-1-用例图">¶</a>5.1.1 用例图</h3><h4 id="（1）作用"><a class="header-anchor" href="#（1）作用">¶</a>（1）作用</h4><p>描述系统的功能以及交互情况</p><h4 id="（2）示例"><a class="header-anchor" href="#（2）示例">¶</a>（2）示例</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE256.png" alt=""></p><h3 id="5-1-2-活动图"><a class="header-anchor" href="#5-1-2-活动图">¶</a>5.1.2 活动图</h3><h4 id="（1）作用-v2"><a class="header-anchor" href="#（1）作用-v2">¶</a>（1）作用</h4><ul><li>描述一个系统/子系统的工作流程</li><li>描述用例内部数据流</li></ul><h4 id="（2）示例-v2"><a class="header-anchor" href="#（2）示例-v2">¶</a>（2）示例</h4><p>感觉长的好像流程图：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103000434.png" alt=""></p><h4 id="（3）活动图元素分组"><a class="header-anchor" href="#（3）活动图元素分组">¶</a>（3）活动图元素分组</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103000550.png" alt=""></p><h3 id="5-1-3-类图"><a class="header-anchor" href="#5-1-3-类图">¶</a>5.1.3 类图</h3><p>先介绍类，再介绍其各种关系</p><h4 id="（1）类"><a class="header-anchor" href="#（1）类">¶</a>（1）类</h4><p>UML定义了4种类型的可见性：</p><ul><li>public</li><li>protected</li><li>private</li><li>package</li></ul><h4 id="（2）继承-泛化"><a class="header-anchor" href="#（2）继承-泛化">¶</a>（2）继承/泛化</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103002839.png" alt=""></p><p>李氏替换准则：在继承时，子类应该能够替换父类</p><h4 id="（3）关联"><a class="header-anchor" href="#（3）关联">¶</a>（3）关联</h4><p>A类的实例与B类的实例中的特例有固定关系的话，这就叫关联关系<br>就好像圆这个类和点这个类的关系一样</p><p>分析阶段其实不是很在乎关联具体是单向还是双向，设计阶段才需要细化；另外还有一些特殊的关联如聚合、组合</p><h4 id="（4）依赖"><a class="header-anchor" href="#（4）依赖">¶</a>（4）依赖</h4><p>依赖的定义其实比较大，是指两个模型元素之间存在的一种语义关系，被依赖者的某些变化会要求或指示依赖者随之发生变化。其实泛化和依赖都是依赖关系，但是是比较特别的依赖关系</p><p>UML模型中的依赖关系有如下这些：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210106193042.png" alt=""></p><p>要画图的时候就是在箭头上的尖括号里面写上关键词：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210106193147.png" alt=""></p><p>依赖关系与关系关系的不同：</p><ul><li>前者是临时的非结构型的关系</li><li>后者是永久的结构型的关系</li></ul><p>其实依赖关系在分析阶段比较少用</p><h4 id="（5）接口和实现"><a class="header-anchor" href="#（5）接口和实现">¶</a>（5）接口和实现</h4><p>注意：要关注线和箭头的样式，不是乱画的</p><p>有两种表示方法：</p><ul><li>实现关系：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210106193748.png" alt=""></li><li>棒棒糖表示法：<ul><li>需要接口：使用了这个接口提供的服务</li><li>提供接口：完全就是用这个定义的数据结构/行为<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210106193854.png" alt=""></li></ul></li></ul><h3 id="5-1-4-时序图"><a class="header-anchor" href="#5-1-4-时序图">¶</a>5.1.4 时序图</h3><p>系统当然还有动态的性质，从两个角度刻画：</p><ul><li>对象内部：状态机图</li><li>对象之间：时序图、通信图</li></ul><h4 id="（1）时序图定义"><a class="header-anchor" href="#（1）时序图定义">¶</a>（1）时序图定义</h4><p>描述了多个对象之间发送消息的时间顺序，图中的每条消息可以是：</p><ul><li>类的操作</li><li>状态机图中引起状态转换的触发事件</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE255.png" alt=""></p><p>其中详解一下序列片段，有四种：</p><ul><li>交互使用（ref标签）：复用已定义的交互场景</li><li>循环（loop标签）：用[get next item]来控制执行</li><li>条件（alt标签）：</li><li>并发（par标签）：</li></ul><h3 id="5-1-5-通信图"><a class="header-anchor" href="#5-1-5-通信图">¶</a>5.1.5 通信图</h3><p>其实可以和时序图互相转换，强调的是发送和接收消息的对象之间的组织结构；而时序图强调的是时间顺序，实际中可以利用两者优势……</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210107001406.png" alt=""></p><h3 id="5-1-6-包图"><a class="header-anchor" href="#5-1-6-包图">¶</a>5.1.6 包图</h3><p>包就像文件夹，可以更好地管理大型项目</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210107001505.png" alt=""></p><h2 id="5-2-分析建模的步骤"><a class="header-anchor" href="#5-2-分析建模的步骤">¶</a>5.2 分析建模的步骤</h2><p>什么是用例（？）</p><p>分析建模的步骤如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE254.png" alt=""></p><h2 id="5-3-用例建模"><a class="header-anchor" href="#5-3-用例建模">¶</a>5.3 用例建模</h2><p>一般步骤：</p><ul><li>分析项目干系人需求</li><li>识别出执行者和用例</li><li>画用例图</li><li>为每个用例写用例规约</li></ul><h3 id="5-3-1-执行者的识别"><a class="header-anchor" href="#5-3-1-执行者的识别">¶</a>5.3.1 执行者的识别</h3><p>有些帮助识别执行者的方法</p><h3 id="5-3-2-用例的识别"><a class="header-anchor" href="#5-3-2-用例的识别">¶</a>5.3.2 用例的识别</h3><h4 id="（1）用例的定义"><a class="header-anchor" href="#（1）用例的定义">¶</a>（1）用例的定义</h4><p>系统执行的一个动作序列，可以为某个执行者产生可观测的、有价值的结果</p><h4 id="（2）有助于寻找用例的问题"><a class="header-anchor" href="#（2）有助于寻找用例的问题">¶</a>（2）有助于寻找用例的问题</h4><h4 id="（3）识别用例中的一些误区"><a class="header-anchor" href="#（3）识别用例中的一些误区">¶</a>（3）识别用例中的一些误区</h4><ul><li>粒度太小</li><li>以低层次数据来命名</li></ul><h3 id="5-3-3-用例图的构建"><a class="header-anchor" href="#5-3-3-用例图的构建">¶</a>5.3.3 用例图的构建</h3><p>当系统规模变大时，可以用包来管理用例，将它们分组，分组依据有多种<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE253.png" alt=""></p><p>执行者也可以分类<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE252.png" alt=""></p><h3 id="5-3-4-用例规约撰写"><a class="header-anchor" href="#5-3-4-用例规约撰写">¶</a>5.3.4 用例规约撰写</h3><h4 id="（1）用例规约作用"><a class="header-anchor" href="#（1）用例规约作用">¶</a>（1）用例规约作用</h4><p>用文字辅以图形，向外部人员描述一个用例的行为</p><h4 id="（2）用例规约的核心内容——事件流"><a class="header-anchor" href="#（2）用例规约的核心内容——事件流">¶</a>（2）用例规约的核心内容——事件流</h4><p>用例其实是一系列动作组成的，这些动作系列就构成了事件流</p><h4 id="（3）用例规约的可选字段"><a class="header-anchor" href="#（3）用例规约的可选字段">¶</a>（3）用例规约的可选字段</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE251.png" alt=""></p><h4 id="（4）活动图"><a class="header-anchor" href="#（4）活动图">¶</a>（4）活动图</h4><p>如果事件流比较复杂，我们可以考虑用活动图和时序图对它建模，比如活动图可以这样（值得关注的是，这些可以和之前写的用例规约对上号）：</p><h4 id="（5）用例规约的细化"><a class="header-anchor" href="#（5）用例规约的细化">¶</a>（5）用例规约的细化</h4><h3 id="5-3-5-用例模型的优化"><a class="header-anchor" href="#5-3-5-用例模型的优化">¶</a>5.3.5 用例模型的优化</h3><p>可以用包含、扩展和泛化三种关系来优化用例模型</p><h4 id="（1）包含"><a class="header-anchor" href="#（1）包含">¶</a>（1）包含</h4><h4 id="（2）扩展"><a class="header-anchor" href="#（2）扩展">¶</a>（2）扩展</h4><h4 id="（3）泛化"><a class="header-anchor" href="#（3）泛化">¶</a>（3）泛化</h4><h2 id="5-4-建立概念模型"><a class="header-anchor" href="#5-4-建立概念模型">¶</a>5.4 建立概念模型</h2><p>这一步就是让我们确定概念类，画出类图，建立概念模型</p><p>识别概念类的方法：</p><p>识别出概念类后，需要定义这些类之间存在的继承关系或关联关系</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE250.png" alt=""></p><h2 id="5-5-用例实现的识别"><a class="header-anchor" href="#5-5-用例实现的识别">¶</a>5.5 用例实现的识别</h2><p>“用例实现”充当了桥梁：从以需求为中心的活动——&gt;以设计为中心的活动；“用例”与“用例实现”之间的存在&lt;&lt;实现&gt;&gt;的依赖关系</p><h2 id="5-6-分析类的识别"><a class="header-anchor" href="#5-6-分析类的识别">¶</a>5.6 分析类的识别</h2><p>书上的概念也太抽象了……分析类到底是啥？（？）</p><h3 id="5-6-1-3种分析类"><a class="header-anchor" href="#5-6-1-3种分析类">¶</a>5.6.1 3种分析类</h3><p>衍型是什么（？）<br>感觉如果在类上面加一个衍型，好像就是说它具有这个衍型对应的性质</p><p>分析类有三种分类：</p><ul><li>系统边界View：用衍型&lt;<boundary>&gt;表示</boundary></li><li>系统要记录和维护的信息Model：&lt;<entity>&gt;</entity></li><li>系统的控制逻辑Control：&lt;<control>&gt;</control></li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210107204819.png" alt=""></p><h3 id="5-6-2-识别边界类"><a class="header-anchor" href="#5-6-2-识别边界类">¶</a>5.6.2 识别边界类</h3><h4 id="（1）什么是控制类？"><a class="header-anchor" href="#（1）什么是控制类？">¶</a>（1）什么是控制类？</h4><p>边界类就是和外界有交互的那些</p><h4 id="（2）边界类分类"><a class="header-anchor" href="#（2）边界类分类">¶</a>（2）边界类分类</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE249.png" alt=""></p><h3 id="5-6-3-识别控制类"><a class="header-anchor" href="#5-6-3-识别控制类">¶</a>5.6.3 识别控制类</h3><p>控制类一般自己不做事，只是协调其他对象实现用例的功能，比如“事务管理器”、“资源协调器”等等</p><h3 id="5-6-4-识别实体类"><a class="header-anchor" href="#5-6-4-识别实体类">¶</a>5.6.4 识别实体类</h3><p>描述系统必须存储的信息和相关行为</p><p>综上所述，某“用例实现”的分析类可以表示如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210107205925.png" alt=""></p><h2 id="5-7-用例分析"><a class="header-anchor" href="#5-7-用例分析">¶</a>5.7 用例分析</h2><p>好晕QWQ这么多图的顺序到底是什么</p><h3 id="5-7-1-职责分配通用原则"><a class="header-anchor" href="#5-7-1-职责分配通用原则">¶</a>5.7.1 职责分配通用原则</h3><h3 id="5-7-2-时序图和通信图的构建"><a class="header-anchor" href="#5-7-2-时序图和通信图的构建">¶</a>5.7.2 时序图和通信图的构建</h3><h3 id="5-7-3-类图的构建"><a class="header-anchor" href="#5-7-3-类图的构建">¶</a>5.7.3 类图的构建</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件工程原理》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter4 需求工程</title>
      <link href="2020/12/31/Chapter4-%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/"/>
      <url>2020/12/31/Chapter4-%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-软件需求面临的挑战"><a class="header-anchor" href="#4-1-软件需求面临的挑战">¶</a>4.1 软件需求面临的挑战</h2><p>见书P96</p><h2 id="4-2-需求工程的概念"><a class="header-anchor" href="#4-2-需求工程的概念">¶</a>4.2 需求工程的概念</h2><h3 id="4-2-1-软件需求"><a class="header-anchor" href="#4-2-1-软件需求">¶</a>4.2.1 软件需求</h3><p>需求=系统要有的条件+能力</p><p>我们常用FURPS+模型定义软件需求：</p><ul><li>F——Functionality：功能、安全性</li><li>U——Usability：实现“用户友好”的因素</li><li>R——Reliability：保证软件可以无故障运行一段时间</li><li>P——Performance：效率、吞吐量等衡量标准</li><li>S——Supportability：（这个我懂得比较少诶）表明进行系统测试、安装、移植等工作量的大小</li><li>+——一些补充的需求：见书P98</li></ul><p>F为功能性需求，URPS为非功能性需求，+为补充需求</p><h3 id="4-2-2-需求的层次"><a class="header-anchor" href="#4-2-2-需求的层次">¶</a>4.2.2 需求的层次</h3><p>软件需求三个层次：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231205244.png" alt=""></p><h3 id="4-2-3-优秀需求应具有的特性"><a class="header-anchor" href="#4-2-3-优秀需求应具有的特性">¶</a>4.2.3 优秀需求应具有的特性</h3><h4 id="（1）单个需求"><a class="header-anchor" href="#（1）单个需求">¶</a>（1）单个需求</h4><h4 id="（2）多个需求"><a class="header-anchor" href="#（2）多个需求">¶</a>（2）多个需求</h4><h3 id="4-2-4-软件需求工程"><a class="header-anchor" href="#4-2-4-软件需求工程">¶</a>4.2.4 软件需求工程</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231205809.png" alt=""></p><h2 id="4-3-需求获取"><a class="header-anchor" href="#4-3-需求获取">¶</a>4.3 需求获取</h2><h3 id="4-3-1-需求来源"><a class="header-anchor" href="#4-3-1-需求来源">¶</a>4.3.1 需求来源</h3><ul><li>项目干系人</li><li>竞品信息</li><li>（以往版本经验）</li><li>……</li></ul><h3 id="4-3-2-需求获取技术"><a class="header-anchor" href="#4-3-2-需求获取技术">¶</a>4.3.2 需求获取技术</h3><h2 id="4-4-需求分析建模"><a class="header-anchor" href="#4-4-需求分析建模">¶</a>4.4 需求分析建模</h2><h3 id="4-4-1-分析模型"><a class="header-anchor" href="#4-4-1-分析模型">¶</a>4.4.1 分析模型</h3><h4 id="（1）分析模型定义"><a class="header-anchor" href="#（1）分析模型定义">¶</a>（1）分析模型定义</h4><p>问题本质的抽象，What而非How，是平台无关模型（PIM）</p><h4 id="（2）分析模型的元素"><a class="header-anchor" href="#（2）分析模型的元素">¶</a>（2）分析模型的元素</h4><ul><li>结构化分析模型<br>数据字典那个</li><li>面向对象分析模型<br>UML等</li></ul><h3 id="4-4-2-分析建模的准则"><a class="header-anchor" href="#4-4-2-分析建模的准则">¶</a>4.4.2 分析建模的准则</h3><p>5条原则</p><h2 id="4-5-需求定义和验证"><a class="header-anchor" href="#4-5-需求定义和验证">¶</a>4.5 需求定义和验证</h2><h3 id="4-5-1-软件前景文档"><a class="header-anchor" href="#4-5-1-软件前景文档">¶</a>4.5.1 软件前景文档</h3><p>书上有模板</p><h3 id="4-5-2-软件需求归约SRS"><a class="header-anchor" href="#4-5-2-软件需求归约SRS">¶</a>4.5.2 软件需求归约SRS</h3><p>也就是正式的详细的软件需求<br>也有模板</p><h3 id="4-5-3-用户界面原型"><a class="header-anchor" href="#4-5-3-用户界面原型">¶</a>4.5.3 用户界面原型</h3><p>用户界面原型拿给用户看，可以更好地细化需求<br>一般流程：</p><ul><li>设计用户界面原型</li><li>开发……</li><li>获得有关用户界面原型的反馈</li></ul><h3 id="4-5-4-软件需求验证"><a class="header-anchor" href="#4-5-4-软件需求验证">¶</a>4.5.4 软件需求验证</h3><h4 id="（1）需求评审"><a class="header-anchor" href="#（1）需求评审">¶</a>（1）需求评审</h4><p>早期控制和防范风险的有效手段，评审过程：</p><ul><li>准备计划阶段：确定评审人员、评审方法等</li><li>实施阶段</li><li>检查在实施阶段</li><li>总结阶段：定稿需求</li></ul><h4 id="（2）原型确认"><a class="header-anchor" href="#（2）原型确认">¶</a>（2）原型确认</h4><p>因为需求一般复杂、不确定等等，所以原型确认作为需求评审的补充，作用也是早期控制和防范风险</p><p>原型确认分类：</p><p>根据不同目的：</p><table><thead><tr><th>水平原型确认</th><th>垂直原型确认</th></tr></thead><tbody><tr><td>例如用户界面模型</td><td>更多被用于验证设计</td></tr></tbody></table><p>根据不同用途</p><table><thead><tr><th>抛弃型原型确认</th><th>演进型原型确认</th></tr></thead><tbody><tr><td>一次性的</td><td>经过精化作为产品的一部分了</td></tr></tbody></table><h2 id="4-6-需求管理"><a class="header-anchor" href="#4-6-需求管理">¶</a>4.6 需求管理</h2><p>下面介绍需求管理的主要3个活动：</p><h3 id="4-6-1-定义需求基线"><a class="header-anchor" href="#4-6-1-定义需求基线">¶</a>4.6.1 定义需求基线</h3><p>明确需求，定义优先级</p><h3 id="4-6-2-需求变更控制和版本控制"><a class="header-anchor" href="#4-6-2-需求变更控制和版本控制">¶</a>4.6.2 需求变更控制和版本控制</h3><p>6条有效的需求变更控制策略：</p><p>如何使项目反映最新的或变更过的需求：</p><h3 id="4-6-3-需求跟踪"><a class="header-anchor" href="#4-6-3-需求跟踪">¶</a>4.6.3 需求跟踪</h3><p>了解各种情况</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件工程原理》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Modelling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter3 软件建模</title>
      <link href="2020/12/29/Chapter3-%E8%BD%AF%E4%BB%B6%E5%BB%BA%E6%A8%A1/"/>
      <url>2020/12/29/Chapter3-%E8%BD%AF%E4%BB%B6%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-模型和建模"><a class="header-anchor" href="#3-1-模型和建模">¶</a>3.1 模型和建模</h2><h3 id="3-1-1-模型"><a class="header-anchor" href="#3-1-1-模型">¶</a>3.1.1 模型</h3><p>模型可以帮助我们抓住问题本质，按需取用不同的语言来描述，一般有如下作用：</p><ul><li>降低风险</li><li>比较不同方案</li><li>用于交流</li><li>指导工程</li></ul><h3 id="3-1-2-软件模型的3个层次：CIM、PIM和PSM"><a class="header-anchor" href="#3-1-2-软件模型的3个层次：CIM、PIM和PSM">¶</a>3.1.2 软件模型的3个层次：CIM、PIM和PSM</h3><p>它们的关系可以用下图描述：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229150729.png" alt=""></p><h3 id="3-1-3-软件建模方法"><a class="header-anchor" href="#3-1-3-软件建模方法">¶</a>3.1.3 软件建模方法</h3><p>软件越来越大，单打独斗不现实了，我们需要理论和方法论支撑。接下来将分别介绍：</p><ul><li>结构化方法</li><li>面向对象方法</li><li>基于构件的开发方法</li><li>面向服务方法</li><li>模型驱动开发方法</li><li>形式化方法</li><li>敏捷建模方法</li></ul><h2 id="3-2-结构化方法"><a class="header-anchor" href="#3-2-结构化方法">¶</a>3.2 结构化方法</h2><p>结构化方法的核心思想：模块化+“自顶向下，逐步求精”</p><p>其实这是一套方法，包括：</p><ul><li>建模技术<ul><li>结构化分析</li><li>结构化设计</li></ul></li><li>编程技术<ul><li>结构化编程</li></ul></li></ul><h3 id="3-2-1-结构化分析"><a class="header-anchor" href="#3-2-1-结构化分析">¶</a>3.2.1 结构化分析</h3><p>结构化分析可以得到这样的模型：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229154400.png" alt=""></p><h4 id="（1）怎么画分层DFD"><a class="header-anchor" href="#（1）怎么画分层DFD">¶</a>（1）怎么画分层DFD</h4><p>步骤：</p><ul><li>顶层图：以系统为中心，画出所有数据源和目的地，以及之间的数据流向</li><li>0层图：把系统分解一次</li><li>1层图：把上面的再分解</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229160046.png" alt=""></p><p>直到每个加工都足够简单，就可以结束</p><p>分层DFD应该遵循如下原则：</p><ul><li>父图与子图平衡：对应数据流保持一致</li><li>数据守恒：<ul><li>输出的数据流必然来自输入数据流的原样/加工</li><li>没有多余数据流，都是用了的</li></ul></li><li>完整性：<ul><li>每个加工过程至少有一个输入、一个输出数据流</li><li>对于文件，至少有一个加工读它、一个加工写它</li><li>数据流和文件都必须命名，并保持与数据字典一致</li><li>不可再分解的加工过程应该有加工说明（后面有写）</li></ul></li></ul><h4 id="（2）怎么定义数据字典DD"><a class="header-anchor" href="#（2）怎么定义数据字典DD">¶</a>（2）怎么定义数据字典DD</h4><p>有了DFD以后，我们从最低一层看，把所有的数据流（箭头上的）和数据文件（双杠）拎出来，写出其组成，一般都是等式右边用加号连接的形式，如下图：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229161237.png" alt=""></p><p>值得注意的是，这里写出来的组成并不依赖于DFD，并不是从图里读出来的；其中使用到的表达方式如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229161424.png" alt=""></p><p>写出数据组成以后，配合DFD信息，配合其他信息，我们可以为每一项数据流/文件写出如下数据字典：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229161817.png" alt=""></p><h4 id="（3）定义加工说明"><a class="header-anchor" href="#（3）定义加工说明">¶</a>（3）定义加工说明</h4><p>加工说明包括：经典IPO<br>这个P不用太详细，写清楚“What”而不是“How”</p><p>加工说明可以有多种表达方式，下面一一介绍：</p><ul><li><p>结构化语言：感觉有点像伪代码的味道<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229162801.png" alt=""></p></li><li><p>判定表/判定树：都适用于比较复杂的逻辑<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229164224.png" alt=""></p></li></ul><h4 id="（4）画实体-关系图"><a class="header-anchor" href="#（4）画实体-关系图">¶</a>（4）画实体-关系图</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229170652.png" alt=""></p><p>（？）0:m和0:1什么意思？</p><h3 id="3-2-2-结构化设计"><a class="header-anchor" href="#3-2-2-结构化设计">¶</a>3.2.2 结构化设计</h3><p><strong>目的：DFD表示的分析模型——&gt;结构图SC表示的设计模型</strong></p><h4 id="（1）鉴别DFD的类别"><a class="header-anchor" href="#（1）鉴别DFD的类别">¶</a>（1）鉴别DFD的类别</h4><ul><li>变换型结构：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229171907.png" alt=""></li><li>事务型结构：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229201517.png" alt=""></li></ul><h4 id="（2）把DFD映射到SC"><a class="header-anchor" href="#（2）把DFD映射到SC">¶</a>（2）把DFD映射到SC</h4><p>先简单介绍一下SC：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229202147.png" alt=""></p><p>对于上面两种结构，分别有对应的映射方法：<br>（？）有点疑问</p><ul><li><p>变换映射：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE78.png" alt=""></p></li><li><p>事务映射：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE98.png" alt=""></p></li></ul><h4 id="（3）优化结构设计"><a class="header-anchor" href="#（3）优化结构设计">¶</a>（3）优化结构设计</h4><ul><li>降低耦合度，提高内聚度</li><li>低扇出，高扇入</li><li>模块的作用域限制在该模块的控制域范围内</li></ul><h4 id="（4）详细设计"><a class="header-anchor" href="#（4）详细设计">¶</a>（4）详细设计</h4><p>对于SC中的每个模块给出足够详细的过程性描述，表达工具包括：</p><ul><li>程序流程图</li><li>PAD图</li><li>N-S图</li><li>伪代码</li></ul><h2 id="3-3-面向对象方法"><a class="header-anchor" href="#3-3-面向对象方法">¶</a>3.3 面向对象方法</h2><h3 id="3-3-1-面向对象的基本概念"><a class="header-anchor" href="#3-3-1-面向对象的基本概念">¶</a>3.3.1 面向对象的基本概念</h3><ul><li>对象</li><li>类</li><li>继承</li><li>消息：对象预期外界世界相关联的唯一途径</li></ul><h3 id="3-3-2-面向对象的基本原则"><a class="header-anchor" href="#3-3-2-面向对象的基本原则">¶</a>3.3.2 面向对象的基本原则</h3><ul><li>抽象</li><li>封装：将对象特征的实现方式隐藏在一个公共接口之后的黑盒中</li><li>模块化</li><li>层次原则：不同级别的抽象组成树形结构</li></ul><h3 id="3-3-3-面向对象的分析和设计"><a class="header-anchor" href="#3-3-3-面向对象的分析和设计">¶</a>3.3.3 面向对象的分析和设计</h3><p>突然觉得分析=说清楚我们要解决什么问题；设计=基于分析的结果，确定我们要怎么解决问题</p><h4 id="（1）面向对象的分析OOA"><a class="header-anchor" href="#（1）面向对象的分析OOA">¶</a>（1）面向对象的分析OOA</h4><p>OOA方法的基本步骤：</p><ul><li>用例建模</li><li>识别出关键抽象（概念类），采用类图建立概念模型</li><li>类图和交互图</li></ul><h4 id="（2）面向对象的设计OOD"><a class="header-anchor" href="#（2）面向对象的设计OOD">¶</a>（2）面向对象的设计OOD</h4><p>令人开心的一点是，OOD和OOA采用相同的表示法和模型结构，所以从OOA——&gt;OOD不需要太多转换，只要稍作修改即可</p><p>OOD的基本步骤：</p><ul><li>从多个视图设计软件的架构</li><li>确定子系统之间的接口+子系统内部的设计</li><li>类的设计和优化</li></ul><h4 id="（3）面向对象的模型"><a class="header-anchor" href="#（3）面向对象的模型">¶</a>（3）面向对象的模型</h4><p>有14种图，超级全面，不过开发的时候不一定都会用到</p><h3 id="3-3-4-结构化方法和面向对象方法的比较"><a class="header-anchor" href="#3-3-4-结构化方法和面向对象方法的比较">¶</a>3.3.4 结构化方法和面向对象方法的比较</h3><p>见书P66-67</p><h2 id="3-4-基于构件的开发方法"><a class="header-anchor" href="#3-4-基于构件的开发方法">¶</a>3.4 基于构件的开发方法</h2><h2 id="3-5-面向服务方法"><a class="header-anchor" href="#3-5-面向服务方法">¶</a>3.5 面向服务方法</h2><h2 id="3-6-模型驱动开发方法"><a class="header-anchor" href="#3-6-模型驱动开发方法">¶</a>3.6 模型驱动开发方法</h2><h2 id="3-7-形式化方法"><a class="header-anchor" href="#3-7-形式化方法">¶</a>3.7 形式化方法</h2><h2 id="3-8-敏捷建模方法"><a class="header-anchor" href="#3-8-敏捷建模方法">¶</a>3.8 敏捷建模方法</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件工程原理》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Modelling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter2 知识表示</title>
      <link href="2020/12/28/Chapter2-%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/"/>
      <url>2020/12/28/Chapter2-%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1>问题归约</h1><h2 id="描述"><a class="header-anchor" href="#描述">¶</a>描述</h2><p>三元组（G,O,P）</p><ul><li>G：初始问题描述</li><li>O：把问题分解为子问题的操作符</li><li>P：本原问题描述</li></ul><p><strong>问题归约法是更通用、更一般化的状态空间表示方法。</strong>（？？？）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter6 传输层安全</title>
      <link href="2020/12/28/Chapter6-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8/"/>
      <url>2020/12/28/Chapter6-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>本节将讨论到关注于传输层安全的三种标准模式：SSL/TLS、HTTPS、SSH</p><h2 id="6-1-Web安全需求"><a class="header-anchor" href="#6-1-Web安全需求">¶</a>6.1 Web安全需求</h2><p>万维网WWW，其实可以看做是运行在互联网上，并基于TCP/IP的C/S模式的应用系统。相关的安全问题就可以被称为<strong>Web安全问题</strong>。</p><p>Web安全有如下挑战：</p><ul><li>互联网的发布环境是双向的</li><li>Web成为企业商业平台，遭攻击会信誉受损</li><li>Web底层软件复杂，可能隐藏安全缺陷</li><li>Web作为公司核心，一旦出问题容易瘫一整片</li><li>Web用户由于缺乏安全意识……</li></ul><h3 id="6-1-1-Web安全威胁"><a class="header-anchor" href="#6-1-1-Web安全威胁">¶</a>6.1.1 Web安全威胁</h3><h4 id="（1）Web安全威胁分类"><a class="header-anchor" href="#（1）Web安全威胁分类">¶</a>（1）Web安全威胁分类</h4><ul><li>按主被动分类<ul><li>主动攻击</li><li>被动攻击</li></ul></li><li>按威胁发生的位置分类<ul><li>在Web服务器</li><li>浏览器</li><li>浏览器与服务器之间的网络通信</li></ul></li></ul><h4 id="（2）各类Web安全威胁的比较"><a class="header-anchor" href="#（2）各类Web安全威胁的比较">¶</a>（2）各类Web安全威胁的比较</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201227225334.png" alt=""></p><h3 id="6-1-2-Web流量安全方法"><a class="header-anchor" href="#6-1-2-Web流量安全方法">¶</a>6.1.2 Web流量安全方法</h3><p>按照安全设施的实现位置不同，可以分成以下三种：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201227225804.png" alt=""></p><ul><li>网络层：可以用IPSec，之后作详细介绍</li><li>传输层：SSL或TLS</li><li>应用层：有些特定的应用有特定的安全服务</li></ul><h2 id="6-2-安全套接字层SSL和传输层安全TLS"><a class="header-anchor" href="#6-2-安全套接字层SSL和传输层安全TLS">¶</a>6.2 安全套接字层SSL和传输层安全TLS</h2><h3 id="6-2-1-SSL体系结构"><a class="header-anchor" href="#6-2-1-SSL体系结构">¶</a>6.2.1 SSL体系结构</h3><h4 id="（1）SSL协议组成"><a class="header-anchor" href="#（1）SSL协议组成">¶</a>（1）SSL协议组成</h4><p>SSL是用TCP提供的端到端的安全服务，由两层协议组成：</p><h4 id="（2）SSL协议两个重要概念"><a class="header-anchor" href="#（2）SSL协议两个重要概念">¶</a>（2）SSL协议两个重要概念</h4><ul><li>连接：一种提供合适服务类型的传输，每个连接与一个会话关联</li><li>会话：通过握手协议来创建会话</li></ul><p>每个会话有若干个状态</p><p>SSL协议：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE31.png" alt=""></p><h2 id="6-3-传输层安全TLS"><a class="header-anchor" href="#6-3-传输层安全TLS">¶</a>6.3 传输层安全TLS</h2><p>TLS目标是编写SSL的互联网标准版本，RFC 5246中定义的TLS非常接近于SSLv3，这里着重介绍区别</p><h3 id="6-3-1-版本号"><a class="header-anchor" href="#6-3-1-版本号">¶</a>6.3.1 版本号</h3><p>TLS记录格式与SSL记录格式完全相同</p><h3 id="6-3-2-消息认证码"><a class="header-anchor" href="#6-3-2-消息认证码">¶</a>6.3.2 消息认证码</h3><p>SSL和TLS的MAC方案不同在于：</p><ul><li>使用的算法</li><li>MAC值的计算范围</li></ul><h3 id="6-3-3-伪随机函数"><a class="header-anchor" href="#6-3-3-伪随机函数">¶</a>6.3.3 伪随机函数</h3><p>（？）<br>TLS使用伪随机函数的目的：使用相对较小的共享密钥值，生成较长的数据块</p><h3 id="6-3-4-警报码"><a class="header-anchor" href="#6-3-4-警报码">¶</a>6.3.4 警报码</h3><p>TLS支持一些SSLv3以外的警报码</p><h3 id="6-3-5-密码套件"><a class="header-anchor" href="#6-3-5-密码套件">¶</a>6.3.5 密码套件</h3><p>可用的密码套件之间有些小区别</p><h3 id="6-3-6-客户端证书类型"><a class="header-anchor" href="#6-3-6-客户端证书类型">¶</a>6.3.6 客户端证书类型</h3><p>客户端可请求的证书有区别</p><h3 id="6-3-7-certificate-verify和finished消息"><a class="header-anchor" href="#6-3-7-certificate-verify和finished消息">¶</a>6.3.7 certificate_verify和finished消息</h3><h3 id="6-3-8-密码计算"><a class="header-anchor" href="#6-3-8-密码计算">¶</a>6.3.8 密码计算</h3><p>预备主密码的计算</p><h3 id="6-3-9-填充"><a class="header-anchor" href="#6-3-9-填充">¶</a>6.3.9 填充</h3><h2 id="6-4-HTTPS"><a class="header-anchor" href="#6-4-HTTPS">¶</a>6.4 HTTPS</h2><p>HTTPS=HTTP+SSL/TLS，以实现浏览器和服务器之间的安全通信</p><p>HTTPS协议中需要被加密的元素：</p><ul><li>URL</li><li>请求的文件内容</li><li>浏览器表单内容</li><li>（双向）cookie</li><li>HTTP报头内容</li></ul><h3 id="6-4-1-连接初始化"><a class="header-anchor" href="#6-4-1-连接初始化">¶</a>6.4.1 连接初始化</h3><p>HTTPS连接初始化过程：</p><ul><li>用户向服务器请求连接</li><li>交换TLS信息</li><li>发起第一次HTTP请求，是以TLS应用数据的形式发送的</li><li>HTTP的传统操作仍然保持</li></ul><p>HTTPS连接中的三层不同意思：</p><ul><li>对于HTTP的部分来说，它觉得自己是向下一层发送了一个连接请求，下一层帮它连接到服务器了；对HTTP，下层是TCP，对HTTPS，下层是SSL/TLS</li><li>对于SSL/TLS的部分来说，它觉得自己是在TLS用户和TLS服务器之间建立了会话；建立一个SSL/TLS连接=建立了一个TCP连接</li></ul><h3 id="6-4-2-连接关闭"><a class="header-anchor" href="#6-4-2-连接关闭">¶</a>6.4.2 连接关闭</h3><p>HTTPS要求关闭TLS——&gt;关闭TLS要求关闭TCP连接</p><h2 id="6-5-SSH（Secure-Shell）"><a class="header-anchor" href="#6-5-SSH（Secure-Shell）">¶</a>6.5 SSH（Secure Shell）</h2><p>SSH是个简单又安全的通信协议，用于远程登录、隧道等</p><p>SSH协议栈：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210101142842.png" alt=""></p><p>接下来分别介绍SSH传输层协议、SSH用户认证协议、SSH连接协议</p><h3 id="6-5-1-传输层协议"><a class="header-anchor" href="#6-5-1-传输层协议">¶</a>6.5.1 传输层协议</h3><h4 id="（1）主机密钥"><a class="header-anchor" href="#（1）主机密钥">¶</a>（1）主机密钥</h4><p>主机密钥用于服务器认证，也就是让用户在密钥交换后可以确认这个服务器身份的意思<br>那用户拿到服务器讼案例的主机密钥之后又怎么验证呢？两种方式：</p><ul><li>用户有个数据库，存了服务器和主机密钥的映射关系</li><li>用户到CA去认证，那里存了主机名和密钥对</li></ul><h4 id="（2）分组交换"><a class="header-anchor" href="#（2）分组交换">¶</a>（2）分组交换</h4><h4 id="（3）SSH传输层协议流程"><a class="header-anchor" href="#（3）SSH传输层协议流程">¶</a>（3）SSH传输层协议流程</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE77.png" alt=""></p><h3 id="6-5-2-用户身份认证协议"><a class="header-anchor" href="#6-5-2-用户身份认证协议">¶</a>6.5.2 用户身份认证协议</h3><p>是用户向服务器证明自己的身份</p><h4 id="（1）消息类型和格式"><a class="header-anchor" href="#（1）消息类型和格式">¶</a>（1）消息类型和格式</h4><ul><li>用户请求服务器帮自己做个认证的格式</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byte SSH_MSG_USERAUTH_REQUEST (50)</span><br><span class="line">string user name</span><br><span class="line">string server name</span><br><span class="line">string method name</span><br><span class="line">... method specific fields</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>服务器拒绝帮用户做认证或者需要它提供更多信息的话，会发这种格式的</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte SSH_MSG_USERAUTH_FAILURE (51)</span><br><span class="line">name-list authentications that can continue</span><br><span class="line">boolean partial success</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>服务器同意帮你认证</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte SSH_MSG_USERAUTH_SUCEESS（52）</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="（2）消息交换"><a class="header-anchor" href="#（2）消息交换">¶</a>（2）消息交换</h4><p>流程如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210101154055.png" alt=""></p><h4 id="（3）身份认证方式"><a class="header-anchor" href="#（3）身份认证方式">¶</a>（3）身份认证方式</h4><p>说的是上图中认证方法列表的内容？</p><h3 id="6-5-3-连接协议"><a class="header-anchor" href="#6-5-3-连接协议">¶</a>6.5.3 连接协议</h3><p>这里顺带一提：SSH协议栈的三个协议，用法大概是——先做SSH用户身份验证协议，再做SSH连接协议，这两个都是基于SSH传输协议的</p><p>有个前提假设是：使用了安全的认证连接</p><blockquote><p>安全的认证连接：连接协议用一个通道虚拟出多条逻辑通道</p></blockquote><h4 id="（1）信道机制"><a class="header-anchor" href="#（1）信道机制">¶</a>（1）信道机制</h4><p>通过窗口机制进行流控，信道的生命周期有3个阶段：</p><ul><li><p>开启信道：</p><ul><li>某一方想开了，给信道分配一个本地序列号，发这种消息：</li></ul>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">byte SSH_MSG_CHANNEL_OPEN</span><br><span class="line">string channel type</span><br><span class="line">uint32 sender channel</span><br><span class="line">uint32 initial window size</span><br><span class="line">uint32 maximum packet size</span><br><span class="line">... channel type specific data follows</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>另一方同意或不同意，如果同意则开启信道</li></ul></li><li><p>关闭信道：</p><ul><li>任意一方想关闭信道，发消息</li></ul></li></ul><p>过程如下图：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210101161117.png" alt=""></p><h4 id="（2）信道类型"><a class="header-anchor" href="#（2）信道类型">¶</a>（2）信道类型</h4><p>4种</p><h4 id="（3）端口转发（即SSH隧道）"><a class="header-anchor" href="#（3）端口转发（即SSH隧道）">¶</a>（3）端口转发（即SSH隧道）</h4><p>可以将不安全的TCP连接转换为安全的SSH连接，转发可以分为本地的和远程的</p><p>没看懂（？）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Transport Layer Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter2 软件过程</title>
      <link href="2020/12/25/Chapter2-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B/"/>
      <url>2020/12/25/Chapter2-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-软件过程的概念"><a class="header-anchor" href="#2-1-软件过程的概念">¶</a>2.1 软件过程的概念</h2><p>软件（生存周期）过程：</p><blockquote><p>过程=活动的集合<br>活动=任务的集合<br>任务=input-&gt;process-&gt;output</p></blockquote><h3 id="2-1-2-软件过程的分类"><a class="header-anchor" href="#2-1-2-软件过程的分类">¶</a>2.1.2 软件过程的分类</h3><p>软件与系统有很多关系，这里分别阐述“系统过程”和“软件过程”。左三列是系统过程，右两列是软件过程</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%B3%BB%E7%BB%9F%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B.png" alt=""></p><h3 id="2-1-3-软件过程的核心元素"><a class="header-anchor" href="#2-1-3-软件过程的核心元素">¶</a>2.1.3 软件过程的核心元素</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201225171541.png" alt=""></p><h2 id="2-2-软件生命周期模型（软件开发模型）"><a class="header-anchor" href="#2-2-软件生命周期模型（软件开发模型）">¶</a>2.2 软件生命周期模型（软件开发模型）</h2><p>规定了软件<br>开发+运作+维护<br>所需的主要活动和任务</p><h3 id="2-2-1-瀑布模型"><a class="header-anchor" href="#2-2-1-瀑布模型">¶</a>2.2.1 瀑布模型</h3><h4 id="（1）介绍"><a class="header-anchor" href="#（1）介绍">¶</a>（1）介绍</h4><p>著名的<strong>线性顺序模型</strong><br>一路往下滚，对前一阶段只评审，不在实践中检验</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201225172109.png" alt=""></p><h4 id="（2）优点"><a class="header-anchor" href="#（2）优点">¶</a>（2）优点</h4><ul><li>解决复杂问题很有作用</li><li>有效保证软件质量</li></ul><h4 id="（3）缺点"><a class="header-anchor" href="#（3）缺点">¶</a>（3）缺点</h4><ul><li>没在实践中验证</li></ul><h4 id="（4）不适用场景"><a class="header-anchor" href="#（4）不适用场景">¶</a>（4）不适用场景</h4><p>见书</p><h3 id="2-2-2-增量模型"><a class="header-anchor" href="#2-2-2-增量模型">¶</a>2.2.2 增量模型</h3><h4 id="（1）介绍-v2"><a class="header-anchor" href="#（1）介绍-v2">¶</a>（1）介绍</h4><p>版本后推，每次多加一些需求进去</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201225173117.png" alt=""></p><h4 id="（2）优点-v2"><a class="header-anchor" href="#（2）优点-v2">¶</a>（2）优点</h4><ul><li>多个版本可以并行开发</li><li>每个版本都可以独立运行</li><li>可以将功能有计划地分为若干增量来逐步实现</li></ul><h4 id="（3）缺点-v2"><a class="header-anchor" href="#（3）缺点-v2">¶</a>（3）缺点</h4><p>需求不明确的时候，可能影响不止一个版本</p><h4 id="（4）不适用的场景"><a class="header-anchor" href="#（4）不适用的场景">¶</a>（4）不适用的场景</h4><p>见书</p><h4 id="（5）适用的场景"><a class="header-anchor" href="#（5）适用的场景">¶</a>（5）适用的场景</h4><p>见书</p><h3 id="2-2-3-演化模型"><a class="header-anchor" href="#2-2-3-演化模型">¶</a>2.2.3 演化模型</h3><h4 id="（1）介绍-v3"><a class="header-anchor" href="#（1）介绍-v3">¶</a>（1）介绍</h4><ul><li>能很好地适应随时间演化的产品的开发</li><li>是迭代的过程模型</li><li>也支持并行开发</li><li>目前采用最广泛的模型</li><li>用于统一过程和许多敏捷过程</li></ul><p>我觉得演化模型和增量模型的区别在于：</p><ul><li>增量模型感觉是已经知道一些需求，然后有计划地主动地把它划分到不同开发轮次里面</li><li>演化模型，后来加入的需求并不是因为之前没把它排进去，而是因为这个需求是随市场变化而来的</li></ul><h4 id="（2）优点-v3"><a class="header-anchor" href="#（2）优点-v3">¶</a>（2）优点</h4><ul><li>可以先开发一部分已明确的需求</li><li>可以面对需求变更</li></ul><h4 id="（3）缺点-v3"><a class="header-anchor" href="#（3）缺点-v3">¶</a>（3）缺点</h4><ul><li>复杂，迭代的规划和控制是难点</li></ul><h4 id="（4）两种实例：原型模型和螺旋模型"><a class="header-anchor" href="#（4）两种实例：原型模型和螺旋模型">¶</a>（4）两种实例：原型模型和螺旋模型</h4><ul><li>原型模型<ul><li>定义：迭代次数为2的演化模型<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201226215738.png" alt=""></li><li>适用情境：用户说不出详细需求/开发者不能确定一些技术细节</li><li>目标：识别软件需求/分析技术风险</li><li>达到目标后对原型的处理：<ul><li>抛弃式原型</li><li>演化式原型：作为产品的一部分</li></ul></li><li>存在的问题：<ul><li>原型可能带给用户不切实际的期望</li><li>建立原型耗时太长</li><li>原型设计欠佳带坏整个软件开发方向</li></ul></li></ul></li><li>螺旋模型<ul><li>定义：迭代的特征+线性模型的特征+风险分析（每次迭代都有）<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201226224513.png" alt=""><br><em>看这个图，需要意识到，每次迭代其实完成的事情是不一样的，并不是说每一次的内部任务都一样。比如原型2是负责确认软件需求，原型3是负责软件产品设计等等</em></li><li>使用原型来降低风险，并且需要相应的风险评估的专门技术</li></ul></li></ul><p><em>小疑惑：什么是原型？</em>（？）<br>以下是维基百科的定义，虽然不是针对软件工程领域的，但是也能让人了解到一些：</p><blockquote><p>原型（英语：Prototype）是指某种新技术在投入量产之前的所作的模型，用以检测产品质素，保障正常运行。在电子技术、机械工程、车辆工程、航空工程及建筑工程等方面广泛运用，实验产品相应地被称为样机，样车等。广义上来讲，通过计算机模拟技术也可以实现这一目的。<br>一般来说，原型的创建与最终产品的创建有所不同，一些基本的分别方式：</p></blockquote><ul><li>材料：最终产品使用的材料可能是昂贵的或不易制造的，因此，用不同于最终产品的材料来制做原型。有时候甚至最终产品的材料都还在开发中，还没办法用在原型。</li><li>过程：批量生产不适合制造少量零件。因此，原型可能使用与最终产品不同的制程来制作。例如，通过塑料射出成型制成的最终产品，需要昂贵的成型模具。因此，为节省费用，可以通过机械加工或3D打印来制造原型。</li><li>验证：最终产品可能需要进行多项品质测试，以验证是否符合设计或规格。通常假设一些调整或返工，为制造过程的一部分。原型也可以免除适用于最终产品的一些要求。</li></ul><blockquote><p>工程师和原型专家试图尽量减少这些差异对原型的影响。例如，如果视觉原型不能使用与最终产品相同的材料，他们将尝试使用具能模拟最终材料的替代材料。</p></blockquote><h3 id="2-2-4-迭代过程"><a class="header-anchor" href="#2-2-4-迭代过程">¶</a>2.2.4 迭代过程</h3><p>迭代式处理不确定的复杂问题的有效手段<br>后一次迭代受益于前一次的经验</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201226214642.png" alt=""></p><h4 id="（1）原则一"><a class="header-anchor" href="#（1）原则一">¶</a>（1）原则一</h4><blockquote><p>每次迭代都要产生一个可执行软件版本<br>每次迭代=计划+建模+需求+分析+设计+实现+测试+评估</p></blockquote><p>从此原则，我们可以知道迭代过程中的内部某一次，其实和瀑布模型有一定的相似之处；区别在于迭代中的各任务可以并行进行</p><h4 id="（2）原则二"><a class="header-anchor" href="#（2）原则二">¶</a>（2）原则二</h4><blockquote><p>要有计划地迭代</p></blockquote><p>迭代化开发，要求在最开始就确定迭代次数、每次迭代的时间……这样才不会使迭代由于无计划而失控</p><h2 id="2-3-统一软件过程UP"><a class="header-anchor" href="#2-3-统一软件过程UP">¶</a>2.3 统一软件过程UP</h2><p>是目前最广泛接受的<strong>软件过程</strong></p><p>包括三大组成部分：</p><ul><li>开发软件原理+实践</li><li>过程模型+模板库（？）</li><li>过程定义工具</li></ul><p>整体框架如下图所示：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201226225323.png" alt=""></p><ul><li>横着看，是以时间为变量的，软件生命周期</li><li>竖着看，是一个阶段里的过程</li></ul><h3 id="2-3-1-阶段"><a class="header-anchor" href="#2-3-1-阶段">¶</a>2.3.1 阶段</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201226233019.png" alt=""></p><p>由上图可知，UP把软件生命周期分为四个阶段：</p><ul><li>先启：目标里程碑，对项目目标达成共识，以规避某些风险（如需求风险）</li><li>精化：架构里程碑，建立软件架构的基线</li><li>构建：软件初始能力里程碑，基于架构进行开发</li><li>产品化：软件产品发布里程碑，做点小事情以确保用户可用（比如安装、配置等）</li></ul><h3 id="2-3-2-迭代"><a class="header-anchor" href="#2-3-2-迭代">¶</a>2.3.2 迭代</h3><p>UP的每个阶段都可以用多次迭代来实现，迭代有如下策略：</p><ul><li>增量式<ul><li>适用于：项目架构风险较小</li><li>精化1次迭代+构建多次迭代（每次加一部分功能，和增量模型很像）</li></ul></li><li>演进式<ul><li>适用于：项目架构的风险较大</li><li>精化多次+构建1次</li></ul></li><li>增量提交<ul><li>适用于：项目不难，但需求不断变化</li><li>后一次迭代使用前一次迭代+用户反馈来改进</li><li>适应需求变化要求架构稳定，而架构的稳定性可以通过多个原型来评估验证（？）</li></ul></li><li>单次迭代<ul><li>只有一次迭代，即<strong>退化为</strong>瀑布模型</li></ul></li></ul><h3 id="2-3-3-过程规范"><a class="header-anchor" href="#2-3-3-过程规范">¶</a>2.3.3 过程规范</h3><p>UP把软件生命周期分为6个核心规范和3个支持规范：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229085723.png" alt=""></p><h2 id="2-4-敏捷过程"><a class="header-anchor" href="#2-4-敏捷过程">¶</a>2.4 敏捷过程</h2><blockquote><p>敏捷过程=<br>以人为本（？）+<br>快速响应需求和变化+<br>注意力集中到项目的主要目标——做出可用软件+<br>文档、度量适度（前提是保证质量）</p></blockquote><p>敏捷过程比较注重人的沟通，发挥人的能动性和创造性，而不是机械地做事；所以这种软件过程适合如下场景：</p><ul><li>需求不确定、易挥发</li><li>有责任感和积极向上的开发人员</li><li>用户容易沟通并能参与（？）</li><li>团队人数&lt;10</li></ul><h3 id="2-4-1-敏捷过程的价值观和原则"><a class="header-anchor" href="#2-4-1-敏捷过程的价值观和原则">¶</a>2.4.1 敏捷过程的价值观和原则</h3><p>敏捷过程的框架分为四个层次：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229093511.png" alt=""></p><p>下面介绍三种具体的敏捷过程：</p><table><thead><tr><th>XP</th><th>Scrum</th><th>MSF</th></tr></thead><tbody><tr><td>敏捷开发技术</td><td>敏捷开发管理</td><td>敏捷开发过程框架</td></tr></tbody></table><h3 id="2-4-2-极限编程XP"><a class="header-anchor" href="#2-4-2-极限编程XP">¶</a>2.4.2 极限编程XP</h3><p>是一种敏捷过程方法</p><h4 id="（1）4个价值目标"><a class="header-anchor" href="#（1）4个价值目标">¶</a>（1）4个价值目标</h4><ul><li>沟通</li><li>简化</li><li>反馈</li><li>勇气</li></ul><h4 id="（2）XP项目状态变迁图"><a class="header-anchor" href="#（2）XP项目状态变迁图">¶</a>（2）XP项目状态变迁图</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229122726.png" alt=""></p><p>XP项目的大概开发流程是：</p><ul><li>首先探索出架构</li><li>根据用户需求发布规划，并且发布的规划可以根据用户新需求的加入来迭代</li><li>根据规划做软件，做出的软件根据测试结果打回去迭代；测试的场景可以来自用户</li><li>测试完了可以交给用户验收，可以的话就进行小型发布</li></ul><h4 id="（3）XP的一些核心思想"><a class="header-anchor" href="#（3）XP的一些核心思想">¶</a>（3）XP的一些核心思想</h4><ul><li>先开发最重要的特性，只关注当下</li><li>其它新需求和变化靠重构来实现</li><li>不对未来投入过多</li></ul><p>代码重构部分可以用下图表示：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229124026.png" alt=""></p><h4 id="（4）XP的使用条件"><a class="header-anchor" href="#（4）XP的使用条件">¶</a>（4）XP的使用条件</h4><p>根据XP的特点我们可以知道，假如重构比事先充分设计的开销要大，那就不值得用XP了</p><h4 id="（5）XP的核心内容（12条实践做法）"><a class="header-anchor" href="#（5）XP的核心内容（12条实践做法）">¶</a>（5）XP的核心内容（12条实践做法）</h4><p>前面说了XP的一些理论层面的内容，接下来谈谈这些理论在实践中表现为什么。以下是12条准则，<strong>不过并非XP特有</strong>：</p><ul><li>计划博弈：做简短的计划，快速确定下次迭代的发布范围</li><li>小型发布：small releases先投入使用，之后再改</li><li>系统隐喻：（？）太抽象了吧</li><li>简化设计：到恰好满足需求的程度</li><li>测试驱动：<strong>XP要求“先写测试，后编码”，用失败的测试驱动编码（？）</strong></li><li>重构：重构以简化系统</li><li>结对编程：两人一起，一人写一人看——<strong>同级评审</strong></li><li>代码全体拥有：大家都能改</li><li>持续集成：每当完成一个任务，都集成一次成品；可能一天有好几次，并不断回归测试</li><li>每周40小时工作制</li><li>现场客户：加入开发环节</li><li>代码规范：为了减少文档</li></ul><h3 id="2-4-3-Scrum"><a class="header-anchor" href="#2-4-3-Scrum">¶</a>2.4.3 Scrum</h3><h4 id="（1）Scrum特点"><a class="header-anchor" href="#（1）Scrum特点">¶</a>（1）Scrum特点</h4><p>类比于橄榄球争球：</p><ul><li>迅速</li><li>适应性</li><li>自组织</li></ul><h4 id="（2）Scrum核心思想"><a class="header-anchor" href="#（2）Scrum核心思想">¶</a>（2）Scrum核心思想</h4><p>Scrum认为软件更多地是<strong>经验性的过程</strong>，而非确定性的过程</p><ul><li>经验性：中间是黑箱，只定两头输入输出，然后根据经验调控黑箱（黑箱里面是分析、设计、实现这些步骤）</li><li>确定性：如一个具体的软件过程模型</li></ul><p>所以Scrum更有适应性和创造力，没有卡得那么死</p><h4 id="（3）Scrum核心准则"><a class="header-anchor" href="#（3）Scrum核心准则">¶</a>（3）Scrum核心准则</h4><ul><li>自我管理：每个Scrum团队都有3种角色，没有中心，可以自组织，跨职能；十分灵活</li><li>迭代开发：<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229143834.png" alt=""></li></ul><h4 id="4-Scrum的一系列规则"><a class="header-anchor" href="#4-Scrum的一系列规则">¶</a>(4) Scrum的一系列规则</h4><p>书P36-37</p><h3 id="2-4-4-微软解决方案框架MSF-（？）"><a class="header-anchor" href="#2-4-4-微软解决方案框架MSF-（？）">¶</a>2.4.4 微软解决方案框架MSF （？）</h3><p>包括两个过程：</p><ul><li>MSF敏捷开发过程</li><li>MSF for CMMI过程</li></ul><h2 id="2-5-软件过程的选择、裁剪、评估和改进"><a class="header-anchor" href="#2-5-软件过程的选择、裁剪、评估和改进">¶</a>2.5 软件过程的选择、裁剪、评估和改进</h2><h3 id="2-5-1-软件过程的选择和裁剪"><a class="header-anchor" href="#2-5-1-软件过程的选择和裁剪">¶</a>2.5.1 软件过程的选择和裁剪</h3><p><strong>其实可以不止使用一个软件过程，可以融合</strong></p><h4 id="（1）选择"><a class="header-anchor" href="#（1）选择">¶</a>（1）选择</h4><p>书P38，3条考虑</p><h4 id="（2）裁剪"><a class="header-anchor" href="#（2）裁剪">¶</a>（2）裁剪</h4><p>书P38-39，3条考虑</p><h3 id="2-5-2-软件过程的评估"><a class="header-anchor" href="#2-5-2-软件过程的评估">¶</a>2.5.2 软件过程的评估</h3><p>用来考察以下问题：</p><ul><li>用的软件过程适合本团队吗？</li><li>过程绩效如何？</li><li>软件过程能力成熟度为几级？</li><li>做的好与不好之处？</li></ul><h4 id="（1）参考模型"><a class="header-anchor" href="#（1）参考模型">¶</a>（1）参考模型</h4><ul><li>CMM/CMMI</li><li>ISO/IEC 15504</li><li>ISO/IEC 20000</li></ul><h4 id="（2）评估方法"><a class="header-anchor" href="#（2）评估方法">¶</a>（2）评估方法</h4><p>以上模型还提供了配套的评估方法</p><h3 id="2-5-3-软件过程的改进"><a class="header-anchor" href="#2-5-3-软件过程的改进">¶</a>2.5.3 软件过程的改进</h3><p>惊讶的是，软件工程的知识完备到，连软件过程的改进也有一些生命周期模型<br>一般切入点是找要素，比如人、技术、方法等等；<br>软件过程、过程评估、过程改进三者关系如下：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201229145317.png" alt=""></p><h4 id="（1）PDCA循环"><a class="header-anchor" href="#（1）PDCA循环">¶</a>（1）PDCA循环</h4><h4 id="（2）IDEAL模型"><a class="header-anchor" href="#（2）IDEAL模型">¶</a>（2）IDEAL模型</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件工程原理》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Reading Report for Adversarial Roubustness vs. Model Compression, or Both?</title>
      <link href="2020/12/25/Reading-Report-for-Adversarial-Roubustness-vs-Model-Compression-or-Both/"/>
      <url>2020/12/25/Reading-Report-for-Adversarial-Roubustness-vs-Model-Compression-or-Both/</url>
      
        <content type="html"><![CDATA[<h2 id="0-Abstract"><a class="header-anchor" href="#0-Abstract">¶</a>0. Abstract</h2><ul><li>DNN is vulnerable to adversarial attacks</li><li>adversarial robustness requires larger capacity of the network than normal</li><li>This paper proposed a training framework to achieve both model compression and adversarial attacks</li><li>This paper studied 2 hypotheses:<ul><li>under adversarial setting, weight pruning is essential for reducing the model size</li><li>train a small model from scratch cannot achieve neither compression and adversarial robustness</li></ul></li></ul><h2 id="1-Introduction"><a class="header-anchor" href="#1-Introduction">¶</a>1. Introduction</h2><h3 id="1-1-Background"><a class="header-anchor" href="#1-1-Background">¶</a>1.1 Background</h3><ul><li>Listing several bad results brought by DNN’s vulnerability</li><li>brief introduction of adversarial attack and 2 types of it (black and white box)</li></ul><h3 id="1-2-Existing-conclusions"><a class="header-anchor" href="#1-2-Existing-conclusions">¶</a>1.2 Existing conclusions</h3><ul><li>So there are many denfense mechanisms, such as adversarial training using min-max robust optimization</li><li>Increase the capacity of a network may provide a better trade off between  standard accuracy of an adversarially trained model and its adversarial robustness</li><li>But large network capacity required in adversarial training may limit its use in resource constrained application systems.</li><li>Some studies work on the relationship between adversarial robustness and weight sparsity, one of them concludes that moderate spasity can help with adversarial robustness, still vulnerable though.</li></ul><h3 id="1-3-Our-contribution"><a class="header-anchor" href="#1-3-Our-contribution">¶</a>1.3 Our contribution</h3><ul><li>This paper investigated whether and how weight sparsity can facilitate an active defense technique. And got following observations:<ul><li>smaller model size leads to both lower accuarcy and robustness<ul><li>so pre-pruning before training isn’t useful</li></ul></li><li>adversarially trained model is less sparse<ul><li>harder to prune an adversarially trained network</li></ul></li></ul></li><li>Based on above observations, this paper tries to enable <strong>security-critical applications in resource constrained systems</strong> by integrating weight pruning with the adversarial robustness and model compression together.</li><li>We studied 2 hypotheses (mentioned above)</li><li>We build a framework to achieve both, for details:<ul><li>ADMM based pruning (because it’s compatible with adversarial training)</li><li>can switch between different pruning schemes</li></ul></li><li>We find that the irregular pruning is best for achieving both</li></ul><h2 id="2-Related-Work"><a class="header-anchor" href="#2-Related-Work">¶</a>2. Related Work</h2><h3 id="2-1-Adversarial-Trainning"><a class="header-anchor" href="#2-1-Adversarial-Trainning">¶</a>2.1 Adversarial Trainning</h3><h3 id="2-2-Weight-Pruning"><a class="header-anchor" href="#2-2-Weight-Pruning">¶</a>2.2 Weight Pruning</h3><h2 id="3-Concurrent-Adversarial-Training-and-Weight-Pruning"><a class="header-anchor" href="#3-Concurrent-Adversarial-Training-and-Weight-Pruning">¶</a>3. Concurrent Adversarial Training and Weight Pruning</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research Group </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Model Compression </tag>
            
            <tag> Adversarial Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter1 软件工程绪论</title>
      <link href="2020/12/25/Chapter1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%BB%AA%E8%AE%BA/"/>
      <url>2020/12/25/Chapter1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>本章将从软件和工程两个方面来探讨软件工程的<strong>本质</strong>和<strong>基本原理</strong></p><h2 id="1-1-软件"><a class="header-anchor" href="#1-1-软件">¶</a>1.1 软件</h2><h3 id="1-1-1-软件的作用和特性"><a class="header-anchor" href="#1-1-1-软件的作用和特性">¶</a>1.1.1 软件的作用和特性</h3><h4 id="（1）软件定义："><a class="header-anchor" href="#（1）软件定义：">¶</a>（1）软件定义：</h4><blockquote><p>软件是计算机系统中与硬件相互依存的另一部分<br>软件=程序+相关数据+说明文档</p></blockquote><h4 id="（2）软件和硬件区别："><a class="header-anchor" href="#（2）软件和硬件区别：">¶</a>（2）软件和硬件区别：</h4><ul><li>软件开发不同于硬件设计</li><li>软件生产不同于硬件制造</li><li>软件维护不同于硬件维修</li></ul><h3 id="1-1-2-软件的发展和面临的新挑战"><a class="header-anchor" href="#1-1-2-软件的发展和面临的新挑战">¶</a>1.1.2 软件的发展和面临的新挑战</h3><p>挑战：</p><ul><li>软件复杂性增加</li><li>软件规模的扩大</li><li>软件环境的变化</li><li>遗留系统的集成和复用</li><li>软件开发的高质量和敏捷性要求</li><li>分散的开发团队的协同</li></ul><h3 id="1-1-3-软件危机"><a class="header-anchor" href="#1-1-3-软件危机">¶</a>1.1.3 软件危机</h3><h4 id="（1）软件危机定义"><a class="header-anchor" href="#（1）软件危机定义">¶</a>（1）软件危机定义</h4><p>指的是软件开发过程中面临的一系列问题：</p><ul><li>不符合需求</li><li>出错</li><li>鲁棒性差</li><li>使用不方便</li><li>工期超时</li><li>成本超预算</li></ul><h4 id="（2）软件开发不成熟的原因"><a class="header-anchor" href="#（2）软件开发不成熟的原因">¶</a>（2）软件开发不成熟的原因</h4><ul><li>软件本身复杂</li><li>软件开发维护的方法、工具等等不恰当</li></ul><h2 id="1-2-工程"><a class="header-anchor" href="#1-2-工程">¶</a>1.2 工程</h2><h3 id="1-2-1-软件开发与艺术、科学和工程的关系"><a class="header-anchor" href="#1-2-1-软件开发与艺术、科学和工程的关系">¶</a>1.2.1 软件开发与艺术、科学和工程的关系</h3><p>科学（真）、工程（善）、艺术（美），软件开发三者兼备</p><h3 id="1-2-2-工程的定义和特性"><a class="header-anchor" href="#1-2-2-工程的定义和特性">¶</a>1.2.2 工程的定义和特性</h3><h4 id="（1）定义"><a class="header-anchor" href="#（1）定义">¶</a>（1）定义</h4><p><strong>组织</strong>良好+<strong>管理</strong>严密+各类人员协同配合<strong>共同</strong>完成工作<br>的学科</p><h4 id="（2）特性"><a class="header-anchor" href="#（2）特性">¶</a>（2）特性</h4><ul><li>以价值为目标</li><li>高度的组织管理性</li><li>多种学科的综合</li><li>高度的实践性。工程实践一般包括如下步骤：<ul><li>理解问题——需求分析</li><li>规划方案——设计</li><li>实施计划——编码</li><li>验证结果的准确性——测试和质量保证</li></ul></li></ul><h3 id="1-2-3-工程的准则"><a class="header-anchor" href="#1-2-3-工程的准则">¶</a>1.2.3 工程的准则</h3><p>见书</p><h2 id="1-3-软件工程"><a class="header-anchor" href="#1-3-软件工程">¶</a>1.3 软件工程</h2><p>即把工程的方法应用于软件开发<br>是工程师解决“软件危机”的探索</p><h3 id="1-3-1-软件工程的概念和知识域"><a class="header-anchor" href="#1-3-1-软件工程的概念和知识域">¶</a>1.3.1 软件工程的概念和知识域</h3><h4 id="（1）概念"><a class="header-anchor" href="#（1）概念">¶</a>（1）概念</h4><p>为了<strong>经济地</strong>获得<strong>可靠的</strong>且能在实际机器上<strong>高效运行</strong>的软件<br>而建立和使用的<br>工程原理</p><h4 id="（2）软件工程知识域"><a class="header-anchor" href="#（2）软件工程知识域">¶</a>（2）软件工程知识域</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201225144907.png" alt=""></p><h3 id="1-3-2-软件工程的金三角"><a class="header-anchor" href="#1-3-2-软件工程的金三角">¶</a>1.3.2 软件工程的金三角</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201225145134.png" alt=""></p><ul><li>人：软件开发和维护的主体，最重要的因素</li><li>技术：解决“如何做”的问题<br>软件工程核心技术环节：<ul><li>系统工程：了解软件所处系统的方法</li><li>软件需求：确定软件的目标和范围</li><li>软件设计：从需求到代码的桥梁</li><li>软件构造/编码：就是写代码啦</li><li>软件测试：</li><li>软件维护<br>记住上面这个顺序……这个思路很常见</li></ul></li><li>管理：我国大企业不多</li><li>过程：=人+技术+管理</li></ul><h3 id="1-3-3-控制软件开发的复杂性"><a class="header-anchor" href="#1-3-3-控制软件开发的复杂性">¶</a>1.3.3 控制软件开发的复杂性</h3><h4 id="（1）软件复杂在哪？"><a class="header-anchor" href="#（1）软件复杂在哪？">¶</a>（1）软件复杂在哪？</h4><ul><li>技术复杂</li><li>需求复杂</li><li>人复杂</li></ul><h4 id="（2）控制复杂性的方法"><a class="header-anchor" href="#（2）控制复杂性的方法">¶</a>（2）控制复杂性的方法</h4><p>把复杂的问题转变为计算机能处理的简单问题</p><ul><li>抽象：含义你懂的，程序设计中主要用到两种：<ul><li>过程抽象：i.e.类的方法</li><li>数据抽象：i.e.类的属性</li></ul></li><li>分解：复杂问题——&gt;简单子问题</li><li>迭代：比如多次试验以获取足够多的经验</li></ul><h3 id="1-3-4-软件工程经济学"><a class="header-anchor" href="#1-3-4-软件工程经济学">¶</a>1.3.4 软件工程经济学</h3><p>研究软件价值及提高的方法</p><h2 id="1-4-案例概述"><a class="header-anchor" href="#1-4-案例概述">¶</a>1.4 案例概述</h2><p>4S店与软件工程比对</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件工程原理》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter1 人工智能绪论</title>
      <link href="2020/12/24/Chapter1-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%BB%AA%E8%AE%BA/"/>
      <url>2020/12/24/Chapter1-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《人工智能及其应用》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter7 机器学习</title>
      <link href="2020/12/24/Chapter7-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/12/24/Chapter7-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="7-1-机器学习的定义和发展历史"><a class="header-anchor" href="#7-1-机器学习的定义和发展历史">¶</a>7.1 机器学习的定义和发展历史</h2><h3 id="7-1-1-机器学习的定义"><a class="header-anchor" href="#7-1-1-机器学习的定义">¶</a>7.1.1 机器学习的定义</h3><p>书上首先介绍了很多很多大师的定义，最后提出了一个为了便于学科研究的定义：</p><blockquote><p>机器学习是研究机器<strong>模拟人类</strong>的学习活动、<strong>获取知识和技能</strong>的理论和方法，以<strong>改善系统性能</strong>的学科</p></blockquote><h3 id="7-1-2-机器学习的发展史"><a class="header-anchor" href="#7-1-2-机器学习的发展史">¶</a>7.1.2 机器学习的发展史</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201224142728.png" alt=""></p><p>另外书中还提到机器学习进入新阶段的重要表现（6条）</p><h2 id="7-2-机器学习的主要策略与基本结构"><a class="header-anchor" href="#7-2-机器学习的主要策略与基本结构">¶</a>7.2 机器学习的主要策略与基本结构</h2><h3 id="7-2-1-机器学习的主要策略"><a class="header-anchor" href="#7-2-1-机器学习的主要策略">¶</a>7.2.1 机器学习的主要策略</h3><p>分为四种，所需要的推理能力从低到高：</p><ul><li>机械学习：即记忆，外界知识表示方式与系统内部表示方式完全一致，不需要任何处理与转换</li><li>示教学习：表达方式不完全一致，需要一定的推理、翻译和转化工作</li><li>类比学习：去发现已知任务和当前任务的相似之处，由此为当前任务制定解决方案</li><li>示例学习：对具体的工作例子及工作经验进行分析总结和推广，得到完成任务的一般性规律</li></ul><h3 id="7-2-2-机器学习系统的基本结构"><a class="header-anchor" href="#7-2-2-机器学习系统的基本结构">¶</a>7.2.2 机器学习系统的基本结构</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/0E13DC29D62D538FC2881F61451D6AD0.png" alt=""></p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/0E13DC29D62D538FC2881F61451D6AD0.png"><p>注意到知识库中知识的表示多种多样，所以书中提到了四条选择原则：</p><ol><li>表达能力强</li><li>易于推理：学习系统计算代价较低</li><li>容易修改知识库：难点在于——修改某一知识的时候，可能关联到其他的知识，需要全面检查</li><li>知识表示易于扩展：发展以来，一个系统可能变得需要多种知识表示方式</li></ol><h2 id="7-3-归纳学习"><a class="header-anchor" href="#7-3-归纳学习">¶</a>7.3 归纳学习</h2><p>归纳学习定义：</p><blockquote><p>是应用<strong>归纳推理</strong>进行学习的一种方法</p></blockquote><p>分类（根据有无教师指导）：</p><ul><li>示例学习：有师学习</li><li>观察与发现学习：无师学习</li></ul><h3 id="7-3-1-归纳学习的模式和规则"><a class="header-anchor" href="#7-3-1-归纳学习的模式和规则">¶</a>7.3.1 归纳学习的模式和规则</h3><p>归纳学习的一些特点：<br>这里把归纳学习分成有穷归纳、数学归纳和一般归纳<br>除去前两者以外，一般归纳其实推理结论只**“保假”**</p><blockquote><p>保假的意思：当归纳前提是错误时，我们可以肯定地说结论也是错的；但是前提是正确的时候就不一定了</p></blockquote><p>其实人类的知识也是存在很强的<strong>可证伪性</strong></p><h4 id="1-归纳学习的模式"><a class="header-anchor" href="#1-归纳学习的模式">¶</a>1. 归纳学习的模式</h4><p>（从这里开始不讲人话了）</p><h4 id="2-归纳概括规则"><a class="header-anchor" href="#2-归纳概括规则">¶</a>2. 归纳概括规则</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《人工智能及其应用》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter8 恶意代码检测与分析</title>
      <link href="2020/12/21/Chapter8-%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>2020/12/21/Chapter8-%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="8-1-恶意代码分析基础"><a class="header-anchor" href="#8-1-恶意代码分析基础">¶</a>8.1 恶意代码分析基础</h2><h3 id="8-1-1-恶意代码分类"><a class="header-anchor" href="#8-1-1-恶意代码分类">¶</a>8.1.1 恶意代码分类</h3><p>恶意代码分析过程总结</p><ol><li>将exe文件上传至</li></ol><h2 id="8-3-动态分析"><a class="header-anchor" href="#8-3-动态分析">¶</a>8.3 动态分析</h2><p>有效的简单动态分析步骤：</p><ul><li>准备：有效的目标+安全的运行环境+尽量真实的网络环境配置</li><li>运行恶意代码</li><li>使用监视工具</li><li>综合分析</li></ul><h3 id="8-3-1-动态分析环境构建"><a class="header-anchor" href="#8-3-1-动态分析环境构建">¶</a>8.3.1 动态分析环境构建</h3><h4 id="（1）环境构建要考虑的重点问题"><a class="header-anchor" href="#（1）环境构建要考虑的重点问题">¶</a>（1）环境构建要考虑的重点问题</h4><p>不破坏/影响外部环境</p><h4 id="（2）做法"><a class="header-anchor" href="#（2）做法">¶</a>（2）做法</h4><p>在受控的隔离环境里面进行动态分析，可以做到：</p><ul><li>影响限制到一定范围内</li><li>可以快速恢复环境而不影响后续分析</li></ul><h4 id="（3）构建环境的工具"><a class="header-anchor" href="#（3）构建环境的工具">¶</a>（3）构建环境的工具</h4><p>按采用的技术方法的不同，做如下分类:</p><ul><li><p>沙箱程序：</p><ul><li>作用：比如可以按照用户指定的安全策略来限制程序行为等，是一种可以运行在</li><li></li></ul></li><li><p>虚拟化软件（如VMware/VirtualBox）：</p></li><li><p>硬件模拟器：</p></li></ul><h3 id="8-3-2-动态行为分析"><a class="header-anchor" href="#8-3-2-动态行为分析">¶</a>8.3.2 动态行为分析</h3><h3 id="8-3-3-动态调试分析"><a class="header-anchor" href="#8-3-3-动态调试分析">¶</a>8.3.3 动态调试分析</h3><h3 id="8-3-4-反虚拟化分析对抗"><a class="header-anchor" href="#8-3-4-反虚拟化分析对抗">¶</a>8.3.4 反虚拟化分析对抗</h3><h3 id="8-3-5-反自动化分析对抗"><a class="header-anchor" href="#8-3-5-反自动化分析对抗">¶</a>8.3.5 反自动化分析对抗</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件安全分析与应用》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter7 污点传播分析</title>
      <link href="2020/12/21/Chapter7-%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E5%88%86%E6%9E%90/"/>
      <url>2020/12/21/Chapter7-%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>污点分析是属于<strong>数据流分析方法</strong>的一种。<br><strong>主要思想</strong>是：标记程序中的数据为污点，跟踪它的去向，看它是不是到了什么敏感的地方（重要的控制决策变量之类的）等等。<br><strong>应用领域</strong>：恶意代码检测、软件漏洞挖掘、用户隐私保护</p><h2 id="7-1-概述"><a class="header-anchor" href="#7-1-概述">¶</a>7.1 概述</h2><h3 id="7-1-1-发展简史"><a class="header-anchor" href="#7-1-1-发展简史">¶</a>7.1.1 发展简史</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201221152906.png" alt=""></p><h3 id="7-1-2-应用领域"><a class="header-anchor" href="#7-1-2-应用领域">¶</a>7.1.2 应用领域</h3><h4 id="1-恶意代码检测"><a class="header-anchor" href="#1-恶意代码检测">¶</a>1. 恶意代码检测</h4><h4 id="2-软件漏洞挖掘"><a class="header-anchor" href="#2-软件漏洞挖掘">¶</a>2. 软件漏洞挖掘</h4><h4 id="3-敏感数据泄露分析方面"><a class="header-anchor" href="#3-敏感数据泄露分析方面">¶</a>3. 敏感数据泄露分析方面</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件安全分析与应用》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter2 基础知识</title>
      <link href="2020/12/21/Chapter2-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>2020/12/21/Chapter2-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>本章的基础知识是指：在恶意代码分析、软件漏洞分析中需要的基础知识</p><h2 id="2-1-处理器硬件架构基础"><a class="header-anchor" href="#2-1-处理器硬件架构基础">¶</a>2.1 处理器硬件架构基础</h2><p>了解硬件知识有利于了解操作系统原理和软件漏洞</p><h3 id="2-1-1-CPU结构介绍"><a class="header-anchor" href="#2-1-1-CPU结构介绍">¶</a>2.1.1 CPU结构介绍</h3><h4 id="（1）CPU结构示意图"><a class="header-anchor" href="#（1）CPU结构示意图">¶</a>（1）CPU结构示意图</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201228142159.png" alt=""></p><p>包括：寄存器+算术逻辑单元ALU+控制器+内部总线</p><ul><li>寄存器：暂存运算数据与结果</li><li>ALU：多种运算功能</li><li>控制器：取指、译码、执行</li><li>内部总线：连接各部分，提供通信</li></ul><p><strong>由于寄存器记录了操作系统关键数据结构的入口，所以我们重点关注它</strong></p><h4 id="（2）CPU寄存器详解"><a class="header-anchor" href="#（2）CPU寄存器详解">¶</a>（2）CPU寄存器详解</h4><p>以32位系统为例：</p><ul><li>指令指针寄存器EIP：存储当前执行指令的地址；操作系统从根据EIP内容寻址，然后取指、译码、执行</li><li>通用数据寄存器EAX/ECX/EDX/EBX：各自有一些常见用法；16位的表示为AX/CX/DX/BX，8位的表示为AL/CL/DL/BL<ul><li>ECX：存储循环次数</li><li>EAX/EDX：乘除法的隐含操作数</li></ul></li><li>地址指针寄存器ESP/EBP：<ul><li>ESP：当前函数栈顶</li><li>EBP：当前函数栈底</li></ul></li><li>变址指针寄存器ESI/EDI：<ul><li>ESI：操作数源地址</li><li>EDI：操作数目的地址</li></ul></li><li>标志位寄存器EFLAGS，具体见书：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103143555.png" alt=""></li><li>段寄存器：CS/DS/SS/ES/FS/GS</li><li>控制寄存器:CR0/CR1/CR2/CR3/CR4</li></ul><h3 id="2-1-2-保护模式"><a class="header-anchor" href="#2-1-2-保护模式">¶</a>2.1.2 保护模式</h3><h4 id="（1）实模式与保护模式区别"><a class="header-anchor" href="#（1）实模式与保护模式区别">¶</a>（1）实模式与保护模式区别</h4><table><thead><tr><th>实模式</th><th>保护模式</th></tr></thead><tbody><tr><td>不支持多线程；不实现权限分级</td><td>可以多线程、多任务；实现内存分页/分段和权限分级</td></tr></tbody></table><h4 id="（2）分页与分段"><a class="header-anchor" href="#（2）分页与分段">¶</a>（2）分页与分段</h4><ul><li>分页由CR3寄存器支持</li><li>分段由内存管理寄存器支持（GDTR/IDTR/LDTR/TR）</li></ul><h3 id="2-1-3-特权级"><a class="header-anchor" href="#2-1-3-特权级">¶</a>2.1.3 特权级</h3><p>4个特权级：Ring0/1/2/3</p><p>校验代码段、数据段的特权级，需要三种类型的特权级支持：</p><ul><li>当前特权级CPL</li><li>描述符特权级DPL</li><li>请求特权级RPL</li></ul><p>常用特权级指令（只能运行在Ring0）：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103144440.png" alt=""></p><h3 id="2-1-4-中断和异常处理"><a class="header-anchor" href="#2-1-4-中断和异常处理">¶</a>2.1.4 中断和异常处理</h3><ul><li>中断是在程序执行期间发生的，分为<ul><li>硬件中断</li><li>软件中断</li></ul></li><li>异常是在处理器执行指令过程中发生错误了<ul><li>程序错误异常</li><li>软件产生异常</li><li>机器检测异常</li></ul></li></ul><p>异常和中断都有唯一的识别码——中断向量</p><h3 id="2-1-5-调试支持"><a class="header-anchor" href="#2-1-5-调试支持">¶</a>2.1.5 调试支持</h3><p>EFLAGS中的IF、TF用于调试模式的开启</p><p>8个调试寄存器DR0-DR7</p><h3 id="2-1-6-虚拟化支持"><a class="header-anchor" href="#2-1-6-虚拟化支持">¶</a>2.1.6 虚拟化支持</h3><h2 id="2-2-反汇编及对抗技术"><a class="header-anchor" href="#2-2-反汇编及对抗技术">¶</a>2.2 反汇编及对抗技术</h2><h3 id="2-2-1-汇编语言"><a class="header-anchor" href="#2-2-1-汇编语言">¶</a>2.2.1 汇编语言</h3><h4 id="（1）寻址方式"><a class="header-anchor" href="#（1）寻址方式">¶</a>（1）寻址方式</h4><h4 id="（2）常用的汇编指令"><a class="header-anchor" href="#（2）常用的汇编指令">¶</a>（2）常用的汇编指令</h4><h3 id="2-2-2-反汇编"><a class="header-anchor" href="#2-2-2-反汇编">¶</a>2.2.2 反汇编</h3><h4 id="（1）反汇编流程"><a class="header-anchor" href="#（1）反汇编流程">¶</a>（1）反汇编流程</h4><p>基本的反汇编包括4个步骤：</p><ul><li>区分出程序的代码段、数据段</li><li>确定程序的代码入口，解码出所有操作数</li><li>反汇编</li><li>重复上述</li></ul><h4 id="（2）线性扫描算法"><a class="header-anchor" href="#（2）线性扫描算法">¶</a>（2）线性扫描算法</h4><h4 id="（3）递归下降扫描算法"><a class="header-anchor" href="#（3）递归下降扫描算法">¶</a>（3）递归下降扫描算法</h4><h3 id="2-2-3-代码混淆"><a class="header-anchor" href="#2-2-3-代码混淆">¶</a>2.2.3 代码混淆</h3><p>代码混淆是将计算机程序转换成更难读懂的变形</p><p>分类：</p><ul><li>程序源代码混淆</li><li>二进制代码混淆<ul><li>反反汇编的混淆<ul><li>对抗静态反汇编：如混淆和加壳</li><li>对抗动态反汇编</li></ul></li><li>指令控制流混淆</li></ul></li></ul><h3 id="2-2-4-反调试"><a class="header-anchor" href="#2-2-4-反调试">¶</a>2.2.4 反调试</h3><p>由于程序逆向分析行业中有动态调试方法，所以对抗地有了反调试技术</p><h4 id="（1）基于调试特征检测的反调试"><a class="header-anchor" href="#（1）基于调试特征检测的反调试">¶</a>（1）基于调试特征检测的反调试</h4><h4 id="（2）基于调试特征隐藏代码"><a class="header-anchor" href="#（2）基于调试特征隐藏代码">¶</a>（2）基于调试特征隐藏代码</h4><h2 id="2-3-Windows操作系统基础"><a class="header-anchor" href="#2-3-Windows操作系统基础">¶</a>2.3 Windows操作系统基础</h2><h3 id="2-3-1-PE文件结构"><a class="header-anchor" href="#2-3-1-PE文件结构">¶</a>2.3.1 PE文件结构</h3><p>可以把博客打印出来看<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE298.png" alt=""></p><h3 id="2-3-2-进程管理"><a class="header-anchor" href="#2-3-2-进程管理">¶</a>2.3.2 进程管理</h3><p>Windows的进程由一个EPROCESS块来表示，包含了PCB、PEB的<strong>指针</strong>等等<br>EPROCESS位于系统内核空间中，<strong>PEB位于进程地址空间中</strong>，其中有一些需要<strong>用户模式</strong>的代码修改的信息</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE297.png" alt=""></p><h3 id="2-3-3-线程管理"><a class="header-anchor" href="#2-3-3-线程管理">¶</a>2.3.3 线程管理</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE296.png" alt=""></p><h3 id="2-3-4-内存管理"><a class="header-anchor" href="#2-3-4-内存管理">¶</a>2.3.4 内存管理</h3><p>内存分为系统态的和用户态的</p><p>Windows内存管理器对内存进行管理，主要有两个功能：</p><ul><li>虚存地址转实存地址：分页寻址，找页表地址——&gt;找页地址——&gt;取数据</li><li>内存不足时将数据换页到物理磁盘：按需换页，等页错误时，挑一种方法来换页</li></ul><h3 id="2-3-5-对象与句柄管理"><a class="header-anchor" href="#2-3-5-对象与句柄管理">¶</a>2.3.5 对象与句柄管理</h3><h3 id="2-3-6-文件系统"><a class="header-anchor" href="#2-3-6-文件系统">¶</a>2.3.6 文件系统</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件安全分析与应用》 </category>
          
          <category> Courses </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Scraps of Study or Life Skills</title>
      <link href="2020/12/15/Scraps-of-Study-or-Life-Skills/"/>
      <url>2020/12/15/Scraps-of-Study-or-Life-Skills/</url>
      
        <content type="html"><![CDATA[<h1>Convert ppt to pdf automatically</h1><p><a href="https://sspai.com/post/44122">一键批量将PPT/Word文档转为PDF</a></p><h1>你需要来自xxx的权限才能更改……</h1><p><a href="https://blog.csdn.net/lanluyug/article/details/76559748">你需要来自XXX的权限才能对此文件夹进行更改 win10</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Tiny Skills </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter4 程序切片</title>
      <link href="2020/12/14/Chapter-4-%E7%A8%8B%E5%BA%8F%E5%88%87%E7%89%87/"/>
      <url>2020/12/14/Chapter-4-%E7%A8%8B%E5%BA%8F%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-概述"><a class="header-anchor" href="#4-1-概述">¶</a>4.1 概述</h2><h4 id="（1）程序切片定义"><a class="header-anchor" href="#（1）程序切片定义">¶</a>（1）程序切片定义</h4><ul><li>一种重要的程序分解技术</li><li>从程序中提取</li></ul><h4 id="（2）“分解”在软工中的运用"><a class="header-anchor" href="#（2）“分解”在软工中的运用">¶</a>（2）“分解”在软工中的运用</h4><p>见书P99-100</p><h2 id="4-2-程序切片初探"><a class="header-anchor" href="#4-2-程序切片初探">¶</a>4.2 程序切片初探</h2><h3 id="4-2-1-切片相关基础知识"><a class="header-anchor" href="#4-2-1-切片相关基础知识">¶</a>4.2.1 切片相关基础知识</h3><h4 id="（1）控制流"><a class="header-anchor" href="#（1）控制流">¶</a>（1）控制流</h4><p>程序中一系列指令（语句、函数调用）执行的顺序<br>程序指令分类：</p><ul><li>具备一定独立性的<strong>功能性指令</strong></li><li>对指令执行顺序进行<strong>控制的指令</strong>——&gt;形成特定的控制结构</li></ul><h4 id="（2）控制结构"><a class="header-anchor" href="#（2）控制结构">¶</a>（2）控制结构</h4><p>三种基本结构：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201214144554.png" alt=""></p><h4 id="（3）数据流"><a class="header-anchor" href="#（3）数据流">¶</a>（3）数据流</h4><p>数据在指令间变化（产生、传递、复制和消失）的过程</p><h4 id="1-控制流分析"><a class="header-anchor" href="#1-控制流分析">¶</a>1. 控制流分析</h4><h4 id="（1）基本块的定义"><a class="header-anchor" href="#（1）基本块的定义">¶</a>（1）基本块的定义</h4><ul><li>程序只能从第一条指令进入该基本块</li><li>离开该基本块前的最后一条指令必须是基本块的最后一条指令</li></ul><h4 id="（2）基本块的计算方法"><a class="header-anchor" href="#（2）基本块的计算方法">¶</a>（2）基本块的计算方法</h4><ul><li>遍历所有指令，如果指令是：整个程序的入口指令/函数入口指令/跳转指令的目的指令，则纳入“入口指令集合”</li><li>遍历所有指令，如果该指令是：<ul><li>入口指令：为它初始化一个基本块，往后收指令直到遇到的指令是入口指令</li><li>其他指令：纳入当前在扩展的基本块</li></ul></li></ul><h4 id="（3）控制流图CFG构造算法"><a class="header-anchor" href="#（3）控制流图CFG构造算法">¶</a>（3）控制流图CFG构造算法</h4><p>对于每个基本块：</p><ul><li>找到最后一条指令，如果它是：<ul><li>跳转指令：则在此指令所在基本块和它跳往的基本块之间添加边</li><li>非跳转指令：则在此指令所在基本块和它后继的基本块之间添加边</li></ul></li></ul><p>另外说下CFG中几个概念：</p><ul><li>直接前驱/直接后继：有边相连的</li><li>如果从entry到b的所有路径都经过a，那么a支配b，且a为b的前必经结点，若a!=b，还可以说是严格前必经结点……</li><li>后必经结点：</li></ul><h4 id="2-数据流分析"><a class="header-anchor" href="#2-数据流分析">¶</a>2.数据流分析</h4><p>对于一条语句，有两种分析：</p><ul><li>可到达定义分析：该语句中引用的变量是哪些语句定义的</li><li>变量活性定义：该语句定义的变量在后续哪些语句被重新定义/引用</li></ul><h4 id="3-可到达定义"><a class="header-anchor" href="#3-可到达定义">¶</a>3.可到达定义</h4><h4 id="（1）路径的定义"><a class="header-anchor" href="#（1）路径的定义">¶</a>（1）路径的定义</h4><p>给每条语句的前后都标号，直白点说，就是插在各语句之间，然后用P来描述路径<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103185730.png" alt=""></p><h4 id="（2）可到达定义的概念"><a class="header-anchor" href="#（2）可到达定义的概念">¶</a>（2）可到达定义的概念</h4><p>见书</p><h4 id="（3）可到达定义的计算方法"><a class="header-anchor" href="#（3）可到达定义的计算方法">¶</a>（3）可到达定义的计算方法</h4><p>首先，对于语句s，我们有四个概念需要知道，这些集合的元素都是语句：</p><ul><li>Gen(s)：s给出变量定义</li><li>Kill(s)：覆盖了某某语句对某变量的定义，这个某某语句就是被消灭的</li><li>In(s)：在s语句前有效的定义语句集合</li><li>Out(s)：Out(s)=In(s)+s产生的语句-s消灭的语句</li></ul><p>算法：</p><ul><li>遍历所有基本块：In设为空集，Out=Gen</li><li>设置变量Change为true</li><li>while Change：<ul><li>遍历所有基本块，对于b：<ul><li>In(b)=b的前驱基本块的Out集的并集</li><li>记录OldOut=Out(b),OldIn=In(b)</li><li>Out(b)=Gen(b)∪(In(b)-Kill(b))</li><li>如果现在的Out和In与OldOut和OldIn都完全相同<ul><li>设置Change=false //也就是收敛了</li></ul></li><li>否则<ul><li>设置Change=true</li></ul></li></ul></li></ul></li></ul><p>以上流程可以执行很多次，值得注意的是，只有In和Out在变：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103193925.png" alt=""></p><p>注意两个要点：</p><ul><li>计算时用的In、Out都是最新的</li><li>Kill的计算有点迷惑（？）</li></ul><h4 id="4-活性分析"><a class="header-anchor" href="#4-活性分析">¶</a>4.活性分析</h4><h4 id="（1）变量是否活跃"><a class="header-anchor" href="#（1）变量是否活跃">¶</a>（1）变量是否活跃</h4><p>对于语句p中的变量x，如果p所在的路径上的语句有某一条<strong>用</strong>了x，x在p上是活的</p><h4 id="（2）变量在哪个范围内保持活跃——活性范围"><a class="header-anchor" href="#（2）变量在哪个范围内保持活跃——活性范围">¶</a>（2）变量在哪个范围内保持活跃——活性范围</h4><p>不太懂（？）</p><h4 id="5-程序依赖图"><a class="header-anchor" href="#5-程序依赖图">¶</a>5.程序依赖图</h4><p>在介绍之前，我们来辨析一下各种“关系”：</p><ul><li>两个语句之间的依赖关系：控制流分析和数据流分析</li><li>基本块（或者语句）之间的关系：控制依赖关系和数据依赖关系</li></ul><h4 id="（1）控制依赖关系"><a class="header-anchor" href="#（1）控制依赖关系">¶</a>（1）控制依赖关系</h4><h4 id="（2）数据依赖关系"><a class="header-anchor" href="#（2）数据依赖关系">¶</a>（2）数据依赖关系</h4><h2 id="4-2-2-切片的基本原理"><a class="header-anchor" href="#4-2-2-切片的基本原理">¶</a>4.2.2 切片的基本原理</h2><h2 id="切片作用之一"><a class="header-anchor" href="#切片作用之一">¶</a>切片作用之一</h2><p>调试的时候，为了排除不相干的代码的影响，我们需要有一些条件来过滤出我们感兴趣的代码<br>这个条件就叫“切片准则”</p><h3 id="切片准则"><a class="header-anchor" href="#切片准则">¶</a>切片准则</h3><ul><li>切片准则包含两个要素：目标变量和开始切片的代码位置</li><li>所以切片准则用形式化定义可以表示为一个二元组：&lt;n,V&gt;</li><li>针对动态切片，可以是三元组：&lt;n,V,p&gt;；其中p为一个输入序列</li></ul><h3 id="程序切片技术的发展历程"><a class="header-anchor" href="#程序切片技术的发展历程">¶</a>程序切片技术的发展历程</h3><p>见书P100</p><h3 id="程序切片的步骤与细分类"><a class="header-anchor" href="#程序切片的步骤与细分类">¶</a>程序切片的步骤与细分类</h3><ol><li>程序依赖关系提取：考察控制流和数据流信息</li><li>切片规则制定</li><li>切片生成</li></ol><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201214142921.png" alt=""></p><h3 id="程序切片的应用"><a class="header-anchor" href="#程序切片的应用">¶</a>程序切片的应用</h3><h3 id="符号执行"><a class="header-anchor" href="#符号执行">¶</a>符号执行</h3><p>核心思想：用符号指来表示程序的输入数据，并将程序的运算过程逐指令或逐语句地转换为数学表达式；在CFG的基础上构建<strong>符号执行树</strong></p><h3 id="动态污点标记和非法操作检测"><a class="header-anchor" href="#动态污点标记和非法操作检测">¶</a>动态污点标记和非法操作检测</h3><h2 id="4-3-静态程序切片"><a class="header-anchor" href="#4-3-静态程序切片">¶</a>4.3 静态程序切片</h2><p>以下是静态程序切片的主要两种方法：</p><h3 id="4-3-1-基于数据流方程的切片方法"><a class="header-anchor" href="#4-3-1-基于数据流方程的切片方法">¶</a>4.3.1 基于数据流方程的切片方法</h3><h4 id="Mark-Weiser数据流切片算法"><a class="header-anchor" href="#Mark-Weiser数据流切片算法">¶</a><strong>Mark Weiser数据流切片算法</strong></h4><h3 id="4-3-2-基于图可达性算法的切片方法"><a class="header-anchor" href="#4-3-2-基于图可达性算法的切片方法">¶</a>4.3.2 基于图可达性算法的切片方法</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件安全分析与应用》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序切片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning about Caffe</title>
      <link href="2020/12/14/Learning-about-Caffe/"/>
      <url>2020/12/14/Learning-about-Caffe/</url>
      
        <content type="html"><![CDATA[<h1>Learning References</h1><p><a href="https://www.zhihu.com/question/27982282">深度学习caffe的代码怎么读？</a></p><h1>Setup Caffe</h1><p><a href="https://alberthg.github.io/2018/04/12/Caffe-Windows-%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/">Caffe Windows 配置</a></p><p><a href="https://software.intel.com/content/www/cn/zh/develop/articles/installation-and-configuration-of-bvlc-caffe-under-windows-the-caffe-learning-notes-part1.html">里面有各个版本caffe介绍</a></p><p><a href="https://blog.csdn.net/zb1165048017/article/details/51355143?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-5.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-5.control">【caffe-Windows】caffe+VS2013+Windows无GPU快速配置教程</a></p><h1>Several Questions</h1><h2 id="What-is-CUDA"><a class="header-anchor" href="#What-is-CUDA">¶</a>What is CUDA?</h2><blockquote><p>CUDA（Compute Unified Device Architecture），是显卡厂商NVIDIA推出的运算平台。 CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。 它包含了CUDA指令集架构（ISA）以及GPU内部的并行计算引擎。 开发人员可以使用C语言来为CUDA™架构编写程序，C语言是应用最广泛的一种高级编程语言。所编写出的程序可以在支持CUDA™的处理器上以超高性能运行。CUDA3.0已经开始支持C++和FORTRAN。</p></blockquote><p>哦……原来是让GPU解决问题的啊……我这台没有GPU的电脑难怪在安装CUDA的时候会出错了……</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research Group </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Caffe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gradually Build up my own Blog</title>
      <link href="2020/12/14/Gradually-Build-up-my-own-Blog/"/>
      <url>2020/12/14/Gradually-Build-up-my-own-Blog/</url>
      
        <content type="html"><![CDATA[<h1>Turn off the Auto-created Folder</h1><ul><li>find “_config.yml”</li><li>in the file, find “post_asset…”</li><li>set it to be “false”</li></ul><h1>Turn off auto-number</h1><ul><li>find “_config.yml” in /themes/next</li><li>find “number”</li><li>set it to be “false”</li></ul><h2 id="主题"><a class="header-anchor" href="#主题">¶</a>主题</h2><img src="D:\胡可\博客\blog\source\_posts\Gradually-Build-up-my-own-Blog.assets\image-20210904003437540.png" alt="image-20210904003437540" style="zoom:80%;" loading="lazy"><img src="D:\胡可\博客\blog\source\_posts\Gradually-Build-up-my-own-Blog.assets\image-20210904003631159.png" alt="image-20210904003631159" style="zoom:80%;" loading="lazy"><img src="D:\胡可\博客\blog\source\_posts\Gradually-Build-up-my-own-Blog.assets\image-20210904005923260.png" alt="image-20210904005923260" style="zoom:80%;" loading="lazy"><img src="D:\胡可\博客\blog\source\_posts\Gradually-Build-up-my-own-Blog.assets\image-20210904012834209.png" alt="image-20210904012834209" style="zoom:80%;" loading="lazy"><h2 id="References"><a class="header-anchor" href="#References">¶</a>References</h2><p><a href="https://io-oi.me/tech/hexo-next-optimization/">打造个性超赞博客 Hexo + NexT + GitHub Pages 的超深度优化</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Tiny Skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog Settings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning about ResNet</title>
      <link href="2020/12/14/Learning-about-ResNet/"/>
      <url>2020/12/14/Learning-about-ResNet/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Fix My Long-broken Python Environment</title>
      <link href="2020/12/14/Fix-My-Long-broken-Python-Environment/"/>
      <url>2020/12/14/Fix-My-Long-broken-Python-Environment/</url>
      
        <content type="html"><![CDATA[<h1>Use Anaconda to Manage Python Environments</h1><p><a href="https://blog.csdn.net/u014628771/article/details/80066624">Anaconda 查看、创建、管理和使用python环境</a></p><p>If <code>conda activate your-env-name</code> won’t work, we can use <code>activate your-env-name</code></p><h1>Pip install time-out</h1><p><a href="https://blog.csdn.net/sxf1061926959/article/details/54091748">pip和conda安装源更改</a></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pandas</span><br></pre></td></tr></tbody></table></figure><h1>Unable to pip install pickle</h1><p><a href="https://stackoverflow.com/questions/48477949/not-able-to-pip-install-pickle-in-python-3-6/48477988">Not able to pip install pickle in python 3.6</a></p><p>try to add <code>D:\anaconda3\envs\python38</code> to <code>Path</code>.</p><h1>PyCharm远程连接到服务器</h1><p><a href="https://blog.csdn.net/yeler082/article/details/83818771?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-7.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-7.control">https://blog.csdn.net/yeler082/article/details/83818771?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-7.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-7.control</a></p><h1>PyTorch中指定使用的GPU</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.environ["CUDA_VISIBLE_DEVICES"] = "2"</span><br></pre></td></tr></tbody></table></figure><h1>调用另一个python文件中的代码</h1><p><a href="https://blog.csdn.net/u010412719/article/details/47089883">如何调用另一个python文件中的代码</a></p><p><a href="https://blog.csdn.net/weixin_42159393/article/details/107188710">暴力解</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research Group </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Env Setup </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HongYi Lee: Model Compression Lecture</title>
      <link href="2020/11/08/HongYi-Lee-Model-Compression-Lecture/"/>
      <url>2020/11/08/HongYi-Lee-Model-Compression-Lecture/</url>
      
        <content type="html"><![CDATA[<h2 id="Network-Pruning"><a class="header-anchor" href="#Network-Pruning">¶</a>Network Pruning</h2><h5 id="What’s-it-for"><a class="header-anchor" href="#What’s-it-for">¶</a>What’s it for?</h5><p>Deleting some neurons or weights to make the model smaller.</p><h5 id="Why-can-we-do-that-without-affecting-the-accuracy"><a class="header-anchor" href="#Why-can-we-do-that-without-affecting-the-accuracy">¶</a>Why can we do that(without affecting the accuracy)?</h5><p>We usually believe the network is over-parameterized,<br>That is to say, many neurons’ outputs often turn out to be zero.</p><h5 id="How-about-simply-train-a-smaller-network-at-the-beginning"><a class="header-anchor" href="#How-about-simply-train-a-smaller-network-at-the-beginning">¶</a>How about simply train a smaller network at the beginning?</h5><ul><li>It’s proved that larger network is easier to be optimized.(the problem of local minimum and saddle point become less severe)</li><li>Lottery Ticket Hypothesis<br>When we follow these steps, we’ll get a parameterized pruned network.<br>If we want to train it futher, we shouldn’t give it a random initialization, instead, we should copy the weight from the original initialization of the larger network.And start from this.(Because this initialization is proved to be trainable, so we should still use it.)<br>(Though this seems to be reasonable, another paper put forward a contrast idea.)</li></ul><h5 id="To-drop-neuron-or-drop-weight"><a class="header-anchor" href="#To-drop-neuron-or-drop-weight">¶</a>To drop neuron or drop weight?</h5><h6 id="Weight-pruning"><a class="header-anchor" href="#Weight-pruning">¶</a>Weight pruning</h6><p>We may get an irregular network:</p><ul><li>hard to implement</li><li>hard to speedup(Because GPU’s speedup is based on  matrix manipulation.)</li></ul><p>To solve “irregular”, we may remain those weights and set them to be zero rather than drop them out. But this is meaningless from the perspective of storage.</p><h6 id="Neuron-pruning"><a class="header-anchor" href="#Neuron-pruning">¶</a>Neuron pruning</h6><ul><li>regular</li><li>easy to implement</li><li>easy to speedup</li></ul><h2 id="Knowledge-Distillation"><a class="header-anchor" href="#Knowledge-Distillation">¶</a>Knowledge Distillation</h2><h5 id="How-to-do"><a class="header-anchor" href="#How-to-do">¶</a>How to do?</h5><p>Let a student model learn from a teacher model.<br>Note that the student model doesn’t learn from real data, it learns from outputs of the teacher model which may be wrong.</p><h5 id="Why-is-it-useful"><a class="header-anchor" href="#Why-is-it-useful">¶</a>Why is it useful?</h5><p>Because data from the teacher model may be richer than labels, the student model may be able to classify the piture which it has never seen.</p><h5 id="One-application-for-knowledge-distillation"><a class="header-anchor" href="#One-application-for-knowledge-distillation">¶</a>One application for knowledge distillation</h5><p>Sometimes we use ensemble models to get better performance, but the model maybe too large to be deployed on mobile device.<br>So we can use the average of models’ output as a teacher model 's output to train our student network</p><h2 id="Parameter-Quantization"><a class="header-anchor" href="#Parameter-Quantization">¶</a>Parameter Quantization</h2><h5 id="Ways-to-quantize-weights"><a class="header-anchor" href="#Ways-to-quantize-weights">¶</a>Ways to quantize weights</h5><ul><li>using less bits to represnt a value</li><li>Weight clustering<br>divide weights into groups, for each group, we use the average value to represent members.</li><li>Huffman encoding</li></ul><h5 id="Binary-Weights"><a class="header-anchor" href="#Binary-Weights">¶</a>Binary Weights</h5><ul><li>First of all, we have a network with real value weights and a network with binary weights.</li><li>We randomly initialize “real network”</li><li>Choose the closest binary weight, do gradient descent, follow the direction to update our real weight(to another real weight)</li><li>iterative</li><li>finally arrive at a real weight and we’ll choose the closest binary weight as our result.</li></ul><h2 id="Architecture-Design"><a class="header-anchor" href="#Architecture-Design">¶</a>Architecture Design</h2><h5 id="Low-rank-approximation"><a class="header-anchor" href="#Low-rank-approximation">¶</a>Low rank approximation</h5><p>insert a hidden linear layer with K neuron<br>if well-designed, weights will be less<br>（Not so intuitive，we need some computation to prove that）</p><h5 id="Depthwise-Separable-Convolution"><a class="header-anchor" href="#Depthwise-Separable-Convolution">¶</a>Depthwise Separable Convolution</h5><p>Divide convolution into two steps:</p><ol><li><p>Depthwise Convolution<br>——the number of filters=the number of channels<br>——filters is not three-dimensional<br>——each filter considers one channel</p></li><li><p>Pointwise Convolution<br>——just like the normal convolution<br>——filter is 1*1<br>——the height of the filter=the number of channels</p></li></ol><h5 id="The-connections-between-normal-convolution-and-Depthwise-Separable-Convolution"><a class="header-anchor" href="#The-connections-between-normal-convolution-and-Depthwise-Separable-Convolution">¶</a>The connections between normal convolution and Depthwise Separable Convolution</h5><ul><li>Depthwise Separable Convolution has common ground with inserting a hidden linear layer</li><li>After analyzing the origin of each output, we may discover that the first step of DSC has “weights sharing”.(keep the same performance with less parameters)</li></ul><h2 id="Dynamic-Computation"><a class="header-anchor" href="#Dynamic-Computation">¶</a>Dynamic Computation</h2><p>Possible Solutions:</p><ul><li>Train multiple classifiers:<br>from small to large, and choose the suitable one according to the computational power of the device</li><li>Classifiers at the intermedia layer:<br>Instead of using the final output, we use the output at the intermedia layer.(But the performance is not good always &amp;&amp; classifiers near the input layer will decrease the perfomance(it forces layers to learn more complicate features than before))</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research Group </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Model Compression </tag>
            
            <tag> HongYi Lee </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter9 IP安全</title>
      <link href="2020/10/12/Chapter9-IP%E5%AE%89%E5%85%A8/"/>
      <url>2020/10/12/Chapter9-IP%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>防重放攻击，一般通过序列号或者时间戳</p><h2 id="9-1-IP安全概述"><a class="header-anchor" href="#9-1-IP安全概述">¶</a>9.1 IP安全概述</h2><p>之前学的Kerberos、TLS/SSL、S/MIME、PGP，都是用来保护应用安全的，其实协议安全也很重要<br>在IP中加入认证和加密机制来保障终端用户安全，这样的话，即便上层没有安全机制也可以保证安全</p><p>IP层安全包括：</p><ul><li>认证</li><li>保密</li><li>密钥管理机制：保证密钥交换安全</li></ul><h3 id="9-1-1-IPSec的应用"><a class="header-anchor" href="#9-1-1-IPSec的应用">¶</a>9.1.1 IPSec的应用</h3><h4 id="（1）IPSec适用范围"><a class="header-anchor" href="#（1）IPSec适用范围">¶</a>（1）IPSec适用范围</h4><p>LAN、专用和公用WAN、互联网</p><h4 id="（2）用途"><a class="header-anchor" href="#（2）用途">¶</a>（2）用途</h4><ul><li>通过互联网安全分支机构接入：</li><li>通过互联网进行安全远程访问：</li><li>与合作者建立企业间联网和企业内联网接入：</li><li>加强电子商务安全性：</li></ul><h4 id="（3）IPSec典型方案"><a class="header-anchor" href="#（3）IPSec典型方案">¶</a>（3）IPSec典型方案</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210102220557.png" alt=""></p><h3 id="9-1-2-IPSec的好处"><a class="header-anchor" href="#9-1-2-IPSec的好处">¶</a>9.1.2 IPSec的好处</h3><h3 id="9-1-3-路由应用"><a class="header-anchor" href="#9-1-3-路由应用">¶</a>9.1.3 路由应用</h3><p>IPSec其实在互联网的路由结构中也有很重要的作用，例如它可以确保：</p><ul><li>路由器广播来自授权的路由器</li><li>邻居广播来自授权的路由器</li><li>重定向报文</li><li>路由更新未被伪造</li></ul><h3 id="9-1-4-IPSec文档"><a class="header-anchor" href="#9-1-4-IPSec文档">¶</a>9.1.4 IPSec文档</h3><h3 id="9-1-5-IPSec服务"><a class="header-anchor" href="#9-1-5-IPSec服务">¶</a>9.1.5 IPSec服务</h3><p>IPSec提供以下服务：</p><ul><li>访问控制</li><li>无连接完整性</li><li>数据源认证</li><li>拒绝重放包</li><li>保密性</li><li>受限制的流量保密性</li></ul><p>有两种协议可以提供安全性：</p><ul><li>AH：用于提供消息认证的扩展头</li><li>ESP：加密与认证结合的协议</li></ul><h3 id="9-1-6-传输模式和隧道模式"><a class="header-anchor" href="#9-1-6-传输模式和隧道模式">¶</a>9.1.6 传输模式和隧道模式</h3><p>AH和ESP都用两种模式，这里做个简介：</p><ul><li>传输模式：为上层协议提供保护，也就是对IP数据包的载荷进行保护<ul><li>AH：认证IP载荷+IP报头选中的部分</li><li>ESP：加密和认证IP载荷</li></ul></li><li>隧道模式：对整个IP包提供保护，把原来的包+安全域，一起作为载荷套在新的IP包内<ul><li>AH：认证整个内部IP包+外部IP报头被选中的部分</li><li>ESP：加密和认证整个内部IP包</li></ul></li></ul><h2 id="9-2-IP安全策略"><a class="header-anchor" href="#9-2-IP安全策略">¶</a>9.2 IP安全策略</h2><h3 id="9-2-1-安全关联"><a class="header-anchor" href="#9-2-1-安全关联">¶</a>9.2.1 安全关联</h3><p>IPSec安全策略实际上由两个交互的数据库确定：安全关联数据库SAD和安全策略数据库SPD</p><p>那个图看不太懂（？）</p><p>安全关联SA：发送端与接收端之间用于对它们之间传递的<strong>数据流提供安全服务</strong>的一个单向逻辑连接，如果要双向，就要两个SA<br>SA提供的安全服务取决于使用的安全协议AH/ESP</p><p>一个SA由三个参数确定：</p><ul><li>安全参数索引SPI：</li><li>IP目的地址：目的端点地址</li><li>安全协议标识：AH/ESP</li></ul><p>IPSec使用SA协商的参数（密码算法，相关的参数等等），有一部分在ESP数据包中传送，IPSec感觉定义的是一种“工作流程”？</p><h3 id="9-2-2-安全关联数据库SAD"><a class="header-anchor" href="#9-2-2-安全关联数据库SAD">¶</a>9.2.2 安全关联数据库SAD</h3><p>每个IPSec的实现中都有一个名义的SAD，所谓名义，是说：<br>SAD说明IPSec需要具备的功能，不负责定义具体实现，这个由IPSec自己决定</p><p>SAD中的SA用以下参数定义：</p><p>不同SA的不同组合可以使用户获得自己理想的配置</p><h3 id="9-2-3-安全策略数据库SPD"><a class="header-anchor" href="#9-2-3-安全策略数据库SPD">¶</a>9.2.3 安全策略数据库SPD</h3><p>（突然感觉这个好像防火墙啊！）（？）</p><p>SPD中说明了IP流量与什么SA相关联</p><p>如何用SPD处理IP数据包？</p><ul><li>取IP数据包中的信息（字段值）判断，看符合哪个SPD入口</li><li>如果该数据包存在SA，那就根据对应的入口确定SA</li><li>执行所需的IPSec处理（AH或ESP处理）</li></ul><p>判断字段值可以用选择器，一般依据是IP地址、下层协议等等</p><p>某主机上SPD的一个例子：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103125634.png" alt=""></p><h3 id="9-2-4-IP通信进程"><a class="header-anchor" href="#9-2-4-IP通信进程">¶</a>9.2.4 IP通信进程</h3><h4 id="（1）IPSec作用位置"><a class="header-anchor" href="#（1）IPSec作用位置">¶</a>（1）IPSec作用位置</h4><p>IPSec的作用单位：IP包，如果是往外面发的，则发之前要IPSec处理；如果是收进来的，往上层传的时候要处理</p><h4 id="（2）出站报文"><a class="header-anchor" href="#（2）出站报文">¶</a>（2）出站报文</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE278.png" alt=""></p><h4 id="（3）入站报文"><a class="header-anchor" href="#（3）入站报文">¶</a>（3）入站报文</h4><p>和出站报文的处理不太一样，这里是SAD和SPD二者选其一的</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE277.png" alt=""></p><h2 id="9-3-封装安全载荷ESP"><a class="header-anchor" href="#9-3-封装安全载荷ESP">¶</a>9.3 封装安全载荷ESP</h2><p>这章是对ESP的详解</p><p>ESP可以提供的服务包括：</p><ul><li>机密性</li><li>数据源认证</li><li>中断连接后的完整性</li><li>一次抗重放攻击服务</li><li>流量机密性</li></ul><p>具体提供哪些要看SA的选择</p><h3 id="9-3-1-ESP格式"><a class="header-anchor" href="#9-3-1-ESP格式">¶</a>9.3.1 ESP格式</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE276.png" alt=""></p><h3 id="9-3-2-加密和认证算法"><a class="header-anchor" href="#9-3-2-加密和认证算法">¶</a>9.3.2 加密和认证算法</h3><p>IV</p><p>ICV</p><h3 id="9-3-3-填充"><a class="header-anchor" href="#9-3-3-填充">¶</a>9.3.3 填充</h3><p>填充域有如下几个作用：</p><h3 id="9-3-4-防止重放服务"><a class="header-anchor" href="#9-3-4-防止重放服务">¶</a>9.3.4 防止重放服务</h3><p>IPSec规定了一种窗口模式</p><h3 id="9-3-5-传输模式和隧道模式"><a class="header-anchor" href="#9-3-5-传输模式和隧道模式">¶</a>9.3.5 传输模式和隧道模式</h3><h4 id="（1）两种模式的比较"><a class="header-anchor" href="#（1）两种模式的比较">¶</a>（1）两种模式的比较</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103195235.png" alt=""></p><h4 id="（2）传输模式ESP"><a class="header-anchor" href="#（2）传输模式ESP">¶</a>（2）传输模式ESP</h4><p>传输模式操作流程：</p><ul><li>先加密后认证（认证可选）</li><li>数据包路由到目的地，不需要检查密文部分</li><li>目的节点经检查ESP报头中的SPI，解密数据包</li></ul><h4 id="（3）隧道模式ESP"><a class="header-anchor" href="#（3）隧道模式ESP">¶</a>（3）隧道模式ESP</h4><p>新的IP报头中的信息，可以为路由提供足够信息，但不为流量分析提供信息</p><p>隧道模式操作流程：</p><ul><li>对以ESP为前缀的原IP包，进行加密、认证，封装新的IP报头</li><li>将外部IP包路由，中间路由器和防火墙只检查外部的</li><li>目的地节点解密，把明文数据包在内网中传送，送到目的地主机</li></ul><p>总结一下这两种模式：</p><ul><li>传输模式适合保护（支持ESP特性的）主机之间的连接</li><li>隧道模式在含有防火墙的情况下，可以用来让可信数据包穿过防火墙</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE275.png" alt=""></p><h2 id="9-4-安全关联组合"><a class="header-anchor" href="#9-4-安全关联组合">¶</a>9.4 安全关联组合</h2><p>同一个流量，可能要多个SA组合才能得到想要的IPSec服务，这些SA就叫安全关联束</p><p>SA之间怎么组合成安全关联束呢？</p><ul><li>传输邻接：（？）</li><li>隧道迭代：多层嵌套</li></ul><h3 id="9-4-1-认证和加密"><a class="header-anchor" href="#9-4-1-认证和加密">¶</a>9.4.1 认证和加密</h3><p>下面讨论一下几种实现认证加保密的方法：</p><h4 id="（1）带认证选项的ESP"><a class="header-anchor" href="#（1）带认证选项的ESP">¶</a>（1）带认证选项的ESP</h4><p>先用ESP，然后认证</p><p>（？）IPSec、AH、ESP、SAD、SPD之间的关系是什么？</p><p>认证的是密文而不是明文</p><h4 id="（2）传输邻接"><a class="header-anchor" href="#（2）传输邻接">¶</a>（2）传输邻接</h4><p>加密之后，添加两个报头，内部是ESP，外部是AH</p><h4 id="（3）传输-隧道束"><a class="header-anchor" href="#（3）传输-隧道束">¶</a>（3）传输-隧道束</h4><p>加密之后，添加两个报头，内部是AH，外部是ESP</p><h3 id="9-4-2-安全关联的基本组合"><a class="header-anchor" href="#9-4-2-安全关联的基本组合">¶</a>9.4.2 安全关联的基本组合</h3><p>介绍了IPSec文档中要求的主机必须有的4种SA组合</p><h2 id="9-5-因特网密钥交换"><a class="header-anchor" href="#9-5-因特网密钥交换">¶</a>9.5 因特网密钥交换</h2><p>一个典型的要求：4个密钥——发送者公钥私钥+接收者公钥私钥</p><p>IPSec文档要求支持的密钥管理类型：</p><ul><li>手动类型</li><li>自动类型</li></ul><p>IKE是什么——因特网密钥交换协议</p><p>自动类型的密钥管理默认有：</p><ul><li>Oakley协议</li><li>ISAKMP协议</li></ul><h3 id="9-5-1-密钥确定协议"><a class="header-anchor" href="#9-5-1-密钥确定协议">¶</a>9.5.1 密钥确定协议</h3><p>IKE密钥确定是DH密钥交换算法的细化</p><h4 id="（1）DH算法流程"><a class="header-anchor" href="#（1）DH算法流程">¶</a>（1）DH算法流程</h4><ul><li>选定两个全局参数</li><li>A选一个x，传一个y；B也一样</li><li>每一方都可以算出同一个值</li></ul><h4 id="（2）DH算法优点"><a class="header-anchor" href="#（2）DH算法优点">¶</a>（2）DH算法优点</h4><ul><li>仅在需要时生成密钥</li><li>仅需要全局参数一致</li></ul><h4 id="（3）DH算法弱点"><a class="header-anchor" href="#（3）DH算法弱点">¶</a>（3）DH算法弱点</h4><ul><li>没有认证双方</li><li>易受中间人攻击</li><li>密集型计算易受拥塞攻击</li></ul><h4 id="（4）IKE密钥确定"><a class="header-anchor" href="#（4）IKE密钥确定">¶</a>（4）IKE密钥确定</h4><p>有5点特性：</p><p>2点是原来DH的性质：</p><ul><li>双方协商得到一个组</li><li>双方交换公钥</li></ul><p>3点是防攻击：</p><ul><li>Cookie防拥塞</li><li>随机数防重放</li><li>认证，从而阻止中间人攻击</li></ul><p>接下来是一些细节</p><h4 id="（5）IKEv2密钥交换"><a class="header-anchor" href="#（5）IKEv2密钥交换">¶</a>（5）IKEv2密钥交换</h4><p>感觉是先做密钥交换，再开始交换信息</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210103232118.png" alt=""></p><h3 id="9-5-2-报头和载荷格式"><a class="header-anchor" href="#9-5-2-报头和载荷格式">¶</a>9.5.2 报头和载荷格式</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE274.png" alt=""></p><h2 id="9-6-密码套件"><a class="header-anchor" href="#9-6-密码套件">¶</a>9.6 密码套件</h2><p>IPSec和IKE依赖多种密码算法，而且每个算法的参数又多</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter5 网络访问控制和云安全</title>
      <link href="2020/10/12/Chapter5-%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E4%BA%91%E5%AE%89%E5%85%A8/"/>
      <url>2020/10/12/Chapter5-%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E4%BA%91%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-网络访问控制"><a class="header-anchor" href="#5-1-网络访问控制">¶</a>5.1 网络访问控制</h2><p>简称NAC，大概包括：登录认证+决定用户可以访问哪些数据+执行哪些操作+检查用户端设备的安全程度</p><h3 id="5-1-1-网络访问控制系统的组成元素"><a class="header-anchor" href="#5-1-1-网络访问控制系统的组成元素">¶</a>5.1.1 网络访问控制系统的组成元素</h3><h4 id="（1）组成成分"><a class="header-anchor" href="#（1）组成成分">¶</a>（1）组成成分</h4><ul><li>访问请求者AR</li><li>策略服务器</li><li>网络访问服务器NAS</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231195151.png" alt=""></p><h3 id="5-1-2-网络访问强制措施"><a class="header-anchor" href="#5-1-2-网络访问强制措施">¶</a>5.1.2 网络访问强制措施</h3><p>可以对AR使用一种或多种强制措施，以管理其访问</p><p>常用的NAC强制措施见书P114</p><h2 id="5-2-可扩展认证协议EAP"><a class="header-anchor" href="#5-2-可扩展认证协议EAP">¶</a>5.2 可扩展认证协议EAP</h2><p>EAP是网络访问、认证协议的框架，封装了许多认证方法</p><h3 id="5-2-1-认证方法"><a class="header-anchor" href="#5-2-1-认证方法">¶</a>5.2.1 认证方法</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231195844.png" alt=""></p><h3 id="5-2-2-EAP交换协议"><a class="header-anchor" href="#5-2-2-EAP交换协议">¶</a>5.2.2 EAP交换协议</h3><h4 id="（1）EAP目标"><a class="header-anchor" href="#（1）EAP目标">¶</a>（1）EAP目标</h4><p>EAP目标：成功认证</p><p>认证成功标志：EAP信息进行交换，认证者允许被认证者的访问，被认证者同意使用此次访问</p><h4 id="（2）EAP典型布局"><a class="header-anchor" href="#（2）EAP典型布局">¶</a>（2）EAP典型布局</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231201250.png" alt=""></p><h2 id="5-3-IEEE-802-1X基于端口的网络访问控制"><a class="header-anchor" href="#5-3-IEEE-802-1X基于端口的网络访问控制">¶</a>5.3 IEEE 802.1X基于端口的网络访问控制</h2><p>这是为局域网提供访问控制功能的</p><h3 id="5-3-1-802-1X访问控制"><a class="header-anchor" href="#5-3-1-802-1X访问控制">¶</a>5.3.1 802.1X访问控制</h3><h3 id="5-3-2-EAPOL包"><a class="header-anchor" href="#5-3-2-EAPOL包">¶</a>5.3.2 EAPOL包</h3><h2 id="5-4-云计算"><a class="header-anchor" href="#5-4-云计算">¶</a>5.4 云计算</h2><p>将信息技术操作移到联网的基础设施上</p><h3 id="5-4-1-云计算组成元素"><a class="header-anchor" href="#5-4-1-云计算组成元素">¶</a>5.4.1 云计算组成元素</h3><h4 id="（1）云计算定义与组成"><a class="header-anchor" href="#（1）云计算定义与组成">¶</a>（1）云计算定义与组成</h4><h4 id="（2）云计算主要特征"><a class="header-anchor" href="#（2）云计算主要特征">¶</a>（2）云计算主要特征</h4><h4 id="（3）NIST定义的3种服务模型"><a class="header-anchor" href="#（3）NIST定义的3种服务模型">¶</a>（3）NIST定义的3种服务模型</h4><h4 id="（4）NIST定义的4种部署模型"><a class="header-anchor" href="#（4）NIST定义的4种部署模型">¶</a>（4）NIST定义的4种部署模型</h4><h3 id="5-4-2-云计算参考架构"><a class="header-anchor" href="#5-4-2-云计算参考架构">¶</a>5.4.2 云计算参考架构</h3><h2 id="5-5-云安全风险和对策"><a class="header-anchor" href="#5-5-云安全风险和对策">¶</a>5.5 云安全风险和对策</h2><h2 id="5-6-云端数据保护"><a class="header-anchor" href="#5-6-云端数据保护">¶</a>5.6 云端数据保护</h2><h2 id="5-7-云安全即服务"><a class="header-anchor" href="#5-7-云安全即服务">¶</a>5.7 云安全即服务</h2><p>SecaaS——安全服务商提供服务（以前是企业提供）</p><h3 id="5-7-1-SecaaS服务类型"><a class="header-anchor" href="#5-7-1-SecaaS服务类型">¶</a>5.7.1 SecaaS服务类型</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud Securtiy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse Linked List</title>
      <link href="2020/10/09/Reverse-Linked-List/"/>
      <url>2020/10/09/Reverse-Linked-List/</url>
      
        <content type="html"><![CDATA[<h1>Description</h1><p>Reverse a singly linked list.</p><h1>Input&amp;Output</h1><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h1>Analysis</h1><p>感觉二叉树经常会用递归，我们应该一直走到底，将两个叶节点交换，然后再一路往上……<br>妙啊，越写越快了！</p><h1>Code</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() {}</span><br><span class="line"> *     ListNode(int val) { this.val = val; }</span><br><span class="line"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span><br><span class="line"> * }</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">    public ListNode reverseList(ListNode head) {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leetcode Top 100 Liked Questions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Invert Binary Tree</title>
      <link href="2020/09/30/Invert-Binary-Tree/"/>
      <url>2020/09/30/Invert-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h1>Description</h1><p>Invert a binary tree.</p><h1>Input&amp;Output</h1><p><img src="%5CInvert-Binary-Tree%5CIO.png" alt=""></p><h1>Analysis</h1><p>感觉二叉树经常会用递归，我们应该一直走到底，将两个叶节点交换，然后再一路往上……<br>妙啊，越写越快了！</p><h1>Code</h1><pre><code>/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */class Solution {    public TreeNode invertTree(TreeNode root) {        if(root==null){            return null;        }else{            if(root.left==null&amp;&amp;root.right==null){                return root;            }            root.left=invertTree(root.left);            root.right=invertTree(root.right);            TreeNode temp=new TreeNode();            temp=root.left;            root.left=root.right;            root.right=temp;                    return root;        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leetcode Top 100 Liked Questions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Single Number</title>
      <link href="2020/09/30/Single-Number/"/>
      <url>2020/09/30/Single-Number/</url>
      
        <content type="html"><![CDATA[<h1>Description</h1><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p><p><em>NOTE：Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</em></p><h1>Input&amp;Output</h1><p><img src="/2020/09/30/Single-Number/%5CSingle-Number%5CIO.png" alt=""></p><h1>Code</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution {</span><br><span class="line">    public int singleNumber(int[] nums) {</span><br><span class="line">        int i=1;</span><br><span class="line">        </span><br><span class="line">        java.util.Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        if(nums.length==1){</span><br><span class="line">            return nums[0];</span><br><span class="line">        }else if(nums[0]!=nums[1]){</span><br><span class="line">            return nums[0];</span><br><span class="line">        }else if(nums[nums.length-1]!=nums[nums.length-1]){</span><br><span class="line">            return nums[nums.length-1];</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        for(;i&lt;nums.length-1;i++){</span><br><span class="line">            if(nums[i]==nums[i-1]||nums[i]==nums[i+1]){</span><br><span class="line">                continue;</span><br><span class="line">            }else{</span><br><span class="line">                break;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        return nums[i];</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leetcode Top 100 Liked Questions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Depth of Binary Tree</title>
      <link href="2020/09/30/Maximum-Depth-of-Binary-Tree/"/>
      <url>2020/09/30/Maximum-Depth-of-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h1>Description</h1><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><h1>Input&amp;Output</h1><p><img src="/2020/09/30/Maximum-Depth-of-Binary-Tree/%5CMaximum-Depth-of-Binary-Tree%5CIO.png" alt=""></p><h1>Analysis</h1><p>大致的思路是，一直往下，过程中有计数器，到底了就返回数字啥的</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() {}</span><br><span class="line"> *     TreeNode(int val) { this.val = val; }</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     }</span><br><span class="line"> * }</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">    int depth=0;</span><br><span class="line">    </span><br><span class="line">    public int maxDepth(TreeNode root) {</span><br><span class="line">        if(root!=null){</span><br><span class="line">            depth++;</span><br><span class="line">            if(root.left==null&amp;&amp;root.right==null){</span><br><span class="line">                return depth;</span><br><span class="line">            }</span><br><span class="line">            if(root.left!=null&amp;&amp;root.right==null){</span><br><span class="line">                depth=maxDepth(root.left);</span><br><span class="line">            }       </span><br><span class="line">            if(root.left==null&amp;&amp;root.right!=null){</span><br><span class="line">                depth=maxDepth(root.right);</span><br><span class="line">            }</span><br><span class="line">            if(root.left!=null&amp;&amp;root.right!=null){</span><br><span class="line">                int depthTemp=depth;</span><br><span class="line">                int depthLeft=maxDepth(root.left);</span><br><span class="line">                depth=depthTemp;</span><br><span class="line">                int depthRight=maxDepth(root.right);</span><br><span class="line">                depth=depthLeft&gt;depthRight?depthLeft:depthRight;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        return depth;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leetcode Top 100 Liked Questions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter1 Linux操作系统概述</title>
      <link href="2020/09/23/Chapter1-%E6%A6%82%E8%BF%B0/"/>
      <url>2020/09/23/Chapter1-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-认识操作系统"><a class="header-anchor" href="#1-1-认识操作系统">¶</a>1.1 认识操作系统</h2><h3 id="1-1-1-从使用者角度看"><a class="header-anchor" href="#1-1-1-从使用者角度看">¶</a>1.1.1 从使用者角度看</h3><p>不用关心具体实现</p><h3 id="1-1-2-从程序开发者的角度看"><a class="header-anchor" href="#1-1-2-从程序开发者的角度看">¶</a>1.1.2 从程序开发者的角度看</h3><p>不用关心在内存的哪里存放变量，并不需要自己指定</p><h3 id="1-1-3-从操作系统在整个计算机系统所处的位置看"><a class="header-anchor" href="#1-1-3-从操作系统在整个计算机系统所处的位置看">¶</a>1.1.3 从操作系统在整个计算机系统所处的位置看</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE174.png" alt=""></p><h3 id="1-1-4-从操作系统设计者的角度看"><a class="header-anchor" href="#1-1-4-从操作系统设计者的角度看">¶</a>1.1.4 从操作系统设计者的角度看</h3><p>操作系统设计有两个目标：</p><ul><li>方便用户</li><li>资源高效运转</li></ul><p>操作系统必须包含的部分：</p><ul><li>操作系统接口</li><li>CPU管理</li><li>内存管理</li><li>设备管理</li><li>文件管理</li></ul><h3 id="1-1-5-操作系统组成"><a class="header-anchor" href="#1-1-5-操作系统组成">¶</a>1.1.5 操作系统组成</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE173.png" alt=""></p><h2 id="1-2-开放源代码的UNIX-Linux操作系统"><a class="header-anchor" href="#1-2-开放源代码的UNIX-Linux操作系统">¶</a>1.2 开放源代码的UNIX/Linux操作系统</h2><h3 id="1-2-1-UNIX诞生和发展"><a class="header-anchor" href="#1-2-1-UNIX诞生和发展">¶</a>1.2.1 UNIX诞生和发展</h3><p>最开始想开发MULTICS，多年以后成功了……后来又因为想要运行一个游戏，为它重写了一套操作系统UNIX（后来用C语言全部重写了）</p><h3 id="1-2-2-Linux诞生"><a class="header-anchor" href="#1-2-2-Linux诞生">¶</a>1.2.2 Linux诞生</h3><p>UNIX有点贵，芬兰小伙写出了Linux改变了这个局面</p><h3 id="1-2-3-操作系统标准POSIX"><a class="header-anchor" href="#1-2-3-操作系统标准POSIX">¶</a>1.2.3 操作系统标准POSIX</h3><p>POSIX全称叫：可移植操作系统接口；它是一套标准，任何符合POSIX标准的操作系统，就可以运行UNIX程序</p><h3 id="1-2-4-GNU和Linux"><a class="header-anchor" href="#1-2-4-GNU和Linux">¶</a>1.2.4 GNU和Linux</h3><p>Linux系统=Linux内核+GNU工具+一些自由软件</p><h3 id="1-2-5-Linux的开发模式"><a class="header-anchor" href="#1-2-5-Linux的开发模式">¶</a>1.2.5 Linux的开发模式</h3><p>以互联网为纽带，世界各地共同参与</p><h2 id="1-3-Linux内核"><a class="header-anchor" href="#1-3-Linux内核">¶</a>1.3 Linux内核</h2><h3 id="1-3-1-Linux内核的技术特点"><a class="header-anchor" href="#1-3-1-Linux内核的技术特点">¶</a>1.3.1 Linux内核的技术特点</h3><ul><li>单内核：把整个内核作为一个大过程来实现，将进程管理、内存管理等拆成一个个模块（微内核：只实现基本的内存管理、进程间通信机制、I/O操作等等，剩下更高级的功能，通过与文件管理等上层模块的通信来解决）</li><li>支持动态加载内核模块</li><li>被动地提供服务（以用户的请求来驱动）</li><li>用了虚存</li><li>抽象文件模型——虚拟文件系统VFS</li><li>延迟执行机制</li></ul><h3 id="1-3-2-Linux内核的位置"><a class="header-anchor" href="#1-3-2-Linux内核的位置">¶</a>1.3.2 Linux内核的位置</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210102150309.png" alt=""></p><p>​中间括起来的是Linux内核</p><h3 id="1-3-3-Linux内核体系结构"><a class="header-anchor" href="#1-3-3-Linux内核体系结构">¶</a>1.3.3 Linux内核体系结构</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE172.png" alt=""></p><h2 id="1-4-Linux内核源代码"><a class="header-anchor" href="#1-4-Linux内核源代码">¶</a>1.4 Linux内核源代码</h2><h3 id="1-3-1-Linux内核版本"><a class="header-anchor" href="#1-3-1-Linux内核版本">¶</a>1.3.1 Linux内核版本</h3><p>​其实用.分割的三四个数字是各自有含义的！</p><h3 id="1-3-2-Linux内核源代码的结构"><a class="header-anchor" href="#1-3-2-Linux内核源代码的结构">¶</a>1.3.2 Linux内核源代码的结构</h3><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20210102151334.png" alt=""></p><h3 id="1-3-3-Linux内核源代码分析工具"><a class="header-anchor" href="#1-3-3-Linux内核源代码分析工具">¶</a>1.3.3 Linux内核源代码分析工具</h3><ul><li>Linux的LXR</li><li>Windows下的source insight（需要先把Linux的源代码放到Windows系统下，直接把/usr/src下的内容拷贝过来就好了）</li></ul><h2 id="1-5-Linux内核模块编程入门"><a class="header-anchor" href="#1-5-Linux内核模块编程入门">¶</a>1.5 Linux内核模块编程入门</h2><p>内核模块=模块=动态可加载内核模块LKM</p><p>模块机制是一个插口，实现可扩展性，弥补单内核的缺陷</p><h3 id="1-5-1-模块的定义"><a class="header-anchor" href="#1-5-1-模块的定义">¶</a>1.5.1 模块的定义</h3><p>模块可以被单独编译，但是不能单独运行，运行时被链接到内核作为内核的一部分在<strong>内核空间</strong>运行</p><h3 id="1-5-2-编写一个简单的模块"><a class="header-anchor" href="#1-5-2-编写一个简单的模块">¶</a>1.5.2 编写一个简单的模块</h3><h4 id="（1）程序举例"><a class="header-anchor" href="#（1）程序举例">¶</a>（1）程序举例</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE171.png" alt=""></p><h4 id="（2）编译"><a class="header-anchor" href="#（2）编译">¶</a>（2）编译</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#Makefile2.6</span><br><span class="line">obj-m : = hellomod.o #产生hellomod模块的目标文件</span><br><span class="line">CURRENT_PATH : = $ (shell pwd) #模块所在的当前路径，这里直接用shell命令获取</span><br><span class="line">LINUX_KERNEL : = $(shell uname - r) #Linux内核源代码的当前版本</span><br><span class="line">LINUX_KERNEL_PATH : = /usr/src/linux - headers - $ (LINUX_KERNEL)  #Linux内核源代码的绝对路径</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">make -c $ (LINUX_KERNEL_PATH)M = $ ( CURRENT_PATH) modules   #编译模块</span><br><span class="line">clean:</span><br><span class="line">make -c $ (LINUX_KERNEL_PATH)M= $ ( CURRENT_PATH) clean    #井清理</span><br></pre></td></tr></tbody></table></figure><h4 id="（3）运行"><a class="header-anchor" href="#（3）运行">¶</a>（3）运行</h4><p>插入和移除就不说了，说下printk</p><p>可以用tail /var/log/message查看日志</p><h3 id="1-5-3-应用程序与内核模块的比较"><a class="header-anchor" href="#1-5-3-应用程序与内核模块的比较">¶</a>1.5.3 应用程序与内核模块的比较</h3><p>​模块编程属于内核编程。</p><p>​书上有一张应用程序与内核模块程序的比较</p><h2 id="1-6-Linux内核中链表的实现及应用"><a class="header-anchor" href="#1-6-Linux内核中链表的实现及应用">¶</a>1.6 Linux内核中链表的实现及应用</h2><p>链表是Linux内核中最简单、最常用的一种数据结构</p><p><strong>值得注意的是，它们的内存无需占用连续的单元</strong>，每个元素都包含一个指向下一个元素的指针，当有元素加入时，只要改变这个指针即可</p><h3 id="1-6-1-链表的演化"><a class="header-anchor" href="#1-6-1-链表的演化">¶</a>1.6.1 链表的演化</h3><p>C语言中最基本的双向链表结构：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_List</span>{</span></span><br><span class="line">    <span class="keyword">void</span> *mydata;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_List</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_list</span> *<span class="title">prev</span>;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在此基础上做一些变化，可以得到二叉树、循环链表以及更多复杂的树状结构</p><h3 id="1-6-2-链表的定义和操作"><a class="header-anchor" href="#1-6-2-链表的定义和操作">¶</a>1.6.2 链表的定义和操作</h3><p>来看下Linux内核的实现方式​​</p><h4 id="（1）链表的定义"><a class="header-anchor" href="#（1）链表的定义">¶</a>（1）链表的定义</h4><p>首先定义一个不含数据域的链表结点</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span><span class="comment">//注意写的时候prev前面要加*</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们把这个嵌入到别的结构中，来形成具有数据域的链表：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_List</span>{</span></span><br><span class="line">    <span class="keyword">void</span> *mydata;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="（2）链表的声明和初始化宏"><a class="header-anchor" href="#（2）链表的声明和初始化宏">¶</a>（2）链表的声明和初始化宏</h4><p>在list.h中定义了宏来实现声明和初始化的操作，所以我们可以方便地使用<code>LIST_HEAD(my_listhead)</code>来创造一个空链表，头指针就是<code>my_listhead</code></p><h4 id="（3）在链表中增加一个结点"><a class="header-anchor" href="#（3）在链表中增加一个结点">¶</a>（3）在链表中增加一个结点</h4><p><strong>在内核代码中，函数名前加两个下划线表示内部函数</strong></p><p>list.h中增加结点的函数是：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_tail</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="（4）遍历链表"><a class="header-anchor" href="#（4）遍历链表">¶</a>（4）遍历链表</h4><p>有点没看懂，用到的时候再回头看吧</p><h3 id="1-6-3-链表的应用"><a class="header-anchor" href="#1-6-3-链表的应用">¶</a>1.6.3 链表的应用</h3><p>比如，可以利用list.h中的函数，编写用以创建、增加、删除和遍历一个双向链表的Linux内核模块</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《Linux操作系统原理与应用(E2)》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter3 公钥密码和消息认证</title>
      <link href="2020/09/23/Chapter3-%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%92%8C%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81/"/>
      <url>2020/09/23/Chapter3-%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%92%8C%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-消息认证方法"><a class="header-anchor" href="#3-1-消息认证方法">¶</a>3.1 消息认证方法</h2><h3 id="3-1-0-引言"><a class="header-anchor" href="#3-1-0-引言">¶</a>3.1.0 引言</h3><p>加密这个手段，自然的就可以防止被动攻击了；不过我们还需要满足防止主动攻击（伪造数据和业务）的需求————对应的办法就是消息认证。<br>首先，什么是可信？<br>可信就是，数据真实且来自合法来源，消息认证就是认证数据可不可信的。<br>对应着可信的两方面定义，认证要做的就是判断消息被篡改与否+来源合法与否，此外还有可能要验证数据时效性、消息流顺序等等</p><h3 id="3-1-1-利用常规加密的消息认证"><a class="header-anchor" href="#3-1-1-利用常规加密的消息认证">¶</a>3.1.1 利用常规加密的消息认证</h3><p>常规就是说简单的对称加密这样子，但是对于分组对称加密会出现问题。<br>假如攻击者想换动消息流之间的顺序，那么由于是分组的，所以B还是能每组都正常解密……<br>但通常情况下，分组的重排其实还是能算是一种威胁</p><h3 id="3-1-2-非加密的消息认证"><a class="header-anchor" href="#3-1-2-非加密的消息认证">¶</a>3.1.2 非加密的消息认证</h3><h4 id="（1）认证与加密"><a class="header-anchor" href="#（1）认证与加密">¶</a>（1）认证与加密</h4><p>把这两个词放一起的时候，我常常感觉……很迷糊，现在理一理：<br>一般来说认证和加密是两个功能，说一句话可能会让关系更明白：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如我们有一个对消息作处理的算法，这里面可以包含两步操作：先对消息加密，再打上认证标签；这样我们就可以说：把消息的认证和保密结合起来了</span><br></pre></td></tr></tbody></table></figure><p>在满足安全需求这件事上，认证和加密是各有应用场景的</p><h4 id="（2）什么时候可以不加密只认证呢？"><a class="header-anchor" href="#（2）什么时候可以不加密只认证呢？">¶</a>（2）什么时候可以不加密只认证呢？</h4><ol><li>相同消息广播时，只由一端负责监控的系统执行认证（不是很理解，直观是什么样的？）</li><li>交换信息时，某一端负载太大不能全部解密，就会随机抽一些进行认证</li><li>程序可以用明文+认证标签，节省处理器解密的消耗</li></ol><h4 id="（3）消息认证码MAC"><a class="header-anchor" href="#（3）消息认证码MAC">¶</a>（3）消息认证码MAC</h4><p>定义：用私钥产生一小块数据，它可以作为MAC<br>工作流程：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/MAC.png" alt=""></p><ul><li>A和B共享一个密钥K</li><li>A给B发消息的时候，A用(消息+K)生成MAC，再把消息和MAC一起发给B</li><li>B收到以后，算一算MAC对不对</li></ul><p><em>值得注意的是，认证算法不需要可逆，因为B验证的时候和A是一样的操作（与加密相比更不容易被破）</em></p><h4 id="（4）单向散列函数"><a class="header-anchor" href="#（4）单向散列函数">¶</a>（4）单向散列函数</h4><p>这是MAC的一种替代品，不同之处在于：<strong>MAC需要密钥而单向散列不需要</strong>，它只是输入M得到H(M)而已。</p><p>H函数可以有以下三种形式：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/HASH.png" alt=""></p><ul><li>传统加密：先hash再加密</li><li>公钥加密：先hash再用公钥加密</li><li>秘密值加密：原消息与秘密值Secret一起hash，结果和原消息拼接</li></ul><p>（详细见P50-51）</p><h2 id="3-2-安全散列函数"><a class="header-anchor" href="#3-2-安全散列函数">¶</a>3.2 安全散列函数</h2><h3 id="3-2-1-散列函数的要求"><a class="header-anchor" href="#3-2-1-散列函数的要求">¶</a>3.2.1 散列函数的要求</h3><ol><li>输入长度不受限制</li><li>输出长度固定</li><li>从x——&gt;H(x)容易计算</li><li>单向性/抗原像攻击性：从H(x)——&gt;x计算上不可行</li><li>抗弱碰撞攻击性/抗第二原像攻击性：对于x，找一个和它哈希值相同的y从计算上不可行</li><li>抗碰撞性/抗强碰撞性：找到任意一对哈希值相同的x，y计算上不可行（可以防止生日攻击）</li></ol><h3 id="3-2-2-散列函数的安全性"><a class="header-anchor" href="#3-2-2-散列函数的安全性">¶</a>3.2.2 散列函数的安全性</h3><p>攻击方法：密码分析法+蛮力攻击法<br>前者利用密码算法的缺陷，后者是要付出指数级代价的（不过2004年王小云教授破了MD5！）</p><h3 id="3-2-3-简单散列函数"><a class="header-anchor" href="#3-2-3-简单散列函数">¶</a>3.2.3 简单散列函数</h3><h4 id="（1）散列函数基本原理"><a class="header-anchor" href="#（1）散列函数基本原理">¶</a>（1）散列函数基本原理</h4><p>把消息按照n比特每块划分，迭代地每次处理一块，最后生成n比特的散列函数</p><h4 id="（2）一种最简单的散列函数"><a class="header-anchor" href="#（2）一种最简单的散列函数">¶</a>（2）一种最简单的散列函数</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230095511.png" alt=""></p><p>对于随机数据的完整性校验很有效，书上有一些数学推导和改进；但是这些改进并不是很有效……</p><p>举个例子，如果我们想替换一个假消息上去，为了让散列函数不变，我们可以根据需要附加一个n比特的数据块，想怎么调怎么调，非常容易生成相同的散列码……所以我们可以考虑散列码拼在消息后面以后，对整个进行加密</p><h3 id="3-2-4-SHA安全散列函数"><a class="header-anchor" href="#3-2-4-SHA安全散列函数">¶</a>3.2.4 SHA安全散列函数</h3><p>SHA-1有时候也叫加密散列码，码和函数貌似差不多，不要纠结<br>经过一段时间的发展，现在主要是用SHA-2：</p><blockquote><p>SHA-2，名称来自于安全散列算法2（英语：Secure Hash Algorithm 2）的缩写，一种密码散列函数算法标准，由美国国家安全局研发[3]，由美国国家标准与技术研究院（NIST）在2001年发布。属于SHA算法之一，是SHA-1的后继者。其下又可再分为六个不同的算法标准，包括了  ：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。<img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230104252.png" alt=""></p></blockquote><p>这里介绍一下SHA-512：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE2.png" alt=""></p><p>（？）M和K是干嘛的？</p><p>书上有些安全性的数学表达</p><h2 id="3-3-消息认证码MAC"><a class="header-anchor" href="#3-3-消息认证码MAC">¶</a>3.3 消息认证码MAC</h2><h3 id="3-3-1-HMAC"><a class="header-anchor" href="#3-3-1-HMAC">¶</a>3.3.1 HMAC</h3><h4 id="（1）为什么会有HMAC呢？"><a class="header-anchor" href="#（1）为什么会有HMAC呢？">¶</a>（1）为什么会有HMAC呢？</h4><p>首先，由于SHA-1软件实现速度快、有许多共享的Hash函数代码库等优点，人们逐渐将它用于MAC。但是为了<strong>把密钥合并到散列算法</strong>中（本身做散列函数是不需要密钥的），人们开发出了HMAC</p><h4 id="（2）HMAC的设计目标"><a class="header-anchor" href="#（2）HMAC的设计目标">¶</a>（2）HMAC的设计目标</h4><ul><li>不用大改散列函数</li><li>嵌入的散列函数可移植，便于二次开发</li><li>保持性能</li><li>使用、处理密钥简单</li><li>知散列函数强度——&gt;知HMAC强度</li></ul><p><strong>把散列函数模块化是个不错的做法</strong></p><h4 id="（3）HMAC的算法设计"><a class="header-anchor" href="#（3）HMAC的算法设计">¶</a>（3）HMAC的算法设计</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE12.png" alt=""></p><h3 id="3-3-2-基于分组密码的MAC"><a class="header-anchor" href="#3-3-2-基于分组密码的MAC">¶</a>3.3.2 基于分组密码的MAC</h3><h4 id="（1）基于密文的消息认证码CMAC"><a class="header-anchor" href="#（1）基于密文的消息认证码CMAC">¶</a>（1）基于密文的消息认证码CMAC</h4><p>适用于AES和3DES</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230125126.png" alt=""></p><h4 id="（2）具有密码块链式信息认证码的计数器CCM"><a class="header-anchor" href="#（2）具有密码块链式信息认证码的计数器CCM">¶</a>（2）具有密码块链式信息认证码的计数器CCM</h4><p>（？）好迷惑的名字</p><p>又叫认证加密模式<br>CCM=AES+CTR操作模式（2.5节提过）+CMAC认证算法</p><p>认证和加密一直是被设计成两种单独的服务的，前者保证可靠性（完整性），后者保证机密性</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230130735.png" alt=""></p><p>感觉有点改进后的散列算法的味道，最后送出的是加密的消息+加密的标签（由消息生成）</p><h2 id="3-4-公钥密码原理"><a class="header-anchor" href="#3-4-公钥密码原理">¶</a>3.4 公钥密码原理</h2><h3 id="3-4-1-公钥密码思想"><a class="header-anchor" href="#3-4-1-公钥密码思想">¶</a>3.4.1 公钥密码思想</h3><p>公钥密码基于数学函数，可以用于加密、消息认证、密钥分发</p><h4 id="（1）常见误解"><a class="header-anchor" href="#（1）常见误解">¶</a>（1）常见误解</h4><ul><li>公钥比对称密码更安全</li><li>公钥密码淘汰了传统密码</li><li>公钥密码实现的密钥分发比传统密码简单的多</li></ul><p>以上，都是错的</p><h4 id="（2）公钥密码的组成"><a class="header-anchor" href="#（2）公钥密码的组成">¶</a>（2）公钥密码的组成</h4><ul><li>明文、密文</li><li>公钥、私钥</li><li>加密算法、解密算法</li></ul><p>都是成双成对哒~</p><h4 id="（3）公钥密码算法基本流程"><a class="header-anchor" href="#（3）公钥密码算法基本流程">¶</a>（3）公钥密码算法基本流程</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230132126.png" alt=""></p><h3 id="3-4-2-公钥密码系统的应用"><a class="header-anchor" href="#3-4-2-公钥密码系统的应用">¶</a>3.4.2 公钥密码系统的应用</h3><p>发送者用什么，有三种情况：</p><ul><li>用自己私钥：数字签名1</li><li>用对方公钥：加密/解密2</li><li>两者都用</li></ul><p>3密钥交换：双方互换会话密钥</p><p>123是公钥密码的三种应用，不同的算法对这几种应用的支持也不同</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230132641.png" alt=""></p><h3 id="3-4-3-公钥密码的要求"><a class="header-anchor" href="#3-4-3-公钥密码的要求">¶</a>3.4.3 公钥密码的要求</h3><p>见书P63</p><h2 id="3-5-公钥密码算法"><a class="header-anchor" href="#3-5-公钥密码算法">¶</a>3.5 公钥密码算法</h2><p>本节重点介绍RSA+DH，简要介绍DSS+椭圆曲线</p><h3 id="3-5-1-RSA"><a class="header-anchor" href="#3-5-1-RSA">¶</a>3.5.1 RSA</h3><p>基于大数分解的困难</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230140625.png" alt=""></p><h3 id="3-5-2-Diffie-Hellman"><a class="header-anchor" href="#3-5-2-Diffie-Hellman">¶</a>3.5.2 Diffie-Hellman</h3><p>基于离散对数计算的困难</p><p>由于DH只有密钥交换的应用，所以通常被叫做DH密钥交换</p><h4 id="（1）算法"><a class="header-anchor" href="#（1）算法">¶</a>（1）算法</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230141939.png" alt=""></p><p>这种会受到中间人攻击，见（3）</p><h4 id="（2）使用DH的另外一个例子"><a class="header-anchor" href="#（2）使用DH的另外一个例子">¶</a>（2）使用DH的另外一个例子</h4><p>见书P68</p><h4 id="（3）DH的中间人攻击"><a class="header-anchor" href="#（3）DH的中间人攻击">¶</a>（3）DH的中间人攻击</h4><p>见书P68-69</p><h3 id="3-5-3-其他公钥密码算法"><a class="header-anchor" href="#3-5-3-其他公钥密码算法">¶</a>3.5.3 其他公钥密码算法</h3><h4 id="（1）ECC"><a class="header-anchor" href="#（1）ECC">¶</a>（1）ECC</h4><h4 id="（2）DSS"><a class="header-anchor" href="#（2）DSS">¶</a>（2）DSS</h4><h2 id="3-6-数字签名"><a class="header-anchor" href="#3-6-数字签名">¶</a>3.6 数字签名</h2><p>应用场景：Bob希望给Alice发送消息，消息保不保密不重要，但是需要Alice能确认这条消息确实来自于他；所以用Bob的私钥加密的消息就叫做数字签名</p><p>数字签名保证可靠性+完整性（没有Bob的私钥是不能篡改消息的）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Public-key cryptography </tag>
            
            <tag> Message authentication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter4 密钥分配和用户认证</title>
      <link href="2020/09/23/Chapter4-%E5%AF%86%E9%92%A5%E5%88%86%E9%85%8D%E5%92%8C%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/"/>
      <url>2020/09/23/Chapter4-%E5%AF%86%E9%92%A5%E5%88%86%E9%85%8D%E5%92%8C%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-基于对称加密的密钥分配"><a class="header-anchor" href="#4-1-基于对称加密的密钥分配">¶</a>4.1 基于对称加密的密钥分配</h2><p>在对称加密的情境下，双方需要共享同一个密钥，并且只能他两知道。A，B有这几种选择：</p><ol><li>A选密钥，物理方法传给B</li><li>第三方选密钥，物理方法传给A、B</li><li>（A、B不久前用过一个共同密钥）A/B把旧密钥加密的新密钥给B/A</li><li>（A、B各有到达第三方C的加密链路）C在加密链路上传给A、B</li></ol><p>主要讲讲第四种，其中需要两种密钥：</p><ul><li>会话密钥：一次性的，双方想说话的时候才有，用完就销毁</li><li>永久密钥：用于分发会话密钥（注意不是只有一个，是KDC与A之间有一个，KDC与B之间有一个的概念）</li></ul><p>其中提到的第三方C其实有个学名：密钥分发中心KDC，它有如下任务：</p><ul><li>决定哪些系统之间可以通信</li><li>可以的话，负责分发会话密钥</li></ul><p>KDC的操作过程：</p><ol><li>A想和B说话了</li><li>A用主密钥（？）（只有A和KDC共享），给KDC发请求包</li><li>KDC判断允不允许，允许的话则产生一次性会话密钥<ul><li>用永久密钥（KDC与A）加密会话密钥，发给A</li><li>用永久密钥（KDC与B）加密会话密钥，发给A</li></ul></li><li>A、B可以通话了！</li></ol><p>实现了上述操作过程的一种服务是Kerberos</p><h2 id="4-2-Kerberos"><a class="header-anchor" href="#4-2-Kerberos">¶</a>4.2 Kerberos</h2><h3 id="4-2-0-引言"><a class="header-anchor" href="#4-2-0-引言">¶</a>4.2.0 引言</h3><h4 id="（1）要解决的问题"><a class="header-anchor" href="#（1）要解决的问题">¶</a>（1）要解决的问题</h4><p>分布式环境中，控制访问权限，为用户<strong>提供认证服务</strong></p><h4 id="（2）三种威胁"><a class="header-anchor" href="#（2）三种威胁">¶</a>（2）三种威胁</h4><ol><li>用户可以伪装成其他用户</li><li>伪造网络地址发消息</li><li>监听消息/重放攻击</li></ol><p>Kerberos<strong>仅依赖于对称加密</strong>；此外，版本4逐渐被淘汰，现在常用版本5</p><h3 id="4-2-1-Kerberos版本4"><a class="header-anchor" href="#4-2-1-Kerberos版本4">¶</a>4.2.1 Kerberos版本4</h3><p>接下来逐步介绍到协议</p><h4 id="（1）一个简单的认证会话"><a class="header-anchor" href="#（1）一个简单的认证会话">¶</a>（1）一个简单的认证会话</h4><p>来看下面这个会话：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE60.png" alt=""></p><p>书上说明了第（3）步中消息每一部分的必要性</p><h4 id="（2）一个更安全的认证会话"><a class="header-anchor" href="#（2）一个更安全的认证会话">¶</a>（2）一个更安全的认证会话</h4><p>上述方式仍然存在问题：</p><ul><li>用户可能访问不同服务器，甚至多次访问同一服务器时，都要重新输入密码</li><li>消息（1）是明文传送口令的，被窃听了就完了QWQ</li></ul><p>为了解决上述问题，我们作如下改进：</p><ul><li>引入票据服务器TGS</li><li>提出避免明文传口令的方案</li></ul><p>具体流程如下：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201230230940.png" alt=""></p><h4 id="（3）真正的Kerbores认证对话！"><a class="header-anchor" href="#（3）真正的Kerbores认证对话！">¶</a>（3）真正的Kerbores认证对话！</h4><p>没想到吧……上面的图已经那么完备了却还是存在缺陷……那么问题在哪呢？</p><ul><li>票据的有效期太长也不好，太短也不好；根本问题是，服务器要能判断持有票据的是正确的人</li><li>服务器也有被假冒的风险，所以它要向用户证明自己的身份</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE112.png" alt=""></p><h3 id="4-2-1-Kerberos版本5"><a class="header-anchor" href="#4-2-1-Kerberos版本5">¶</a>4.2.1 Kerberos版本5</h3><h4 id="（1）版本4与版本5的不同"><a class="header-anchor" href="#（1）版本4与版本5的不同">¶</a>（1）版本4与版本5的不同</h4><h4 id="（2）版本5的认证对话"><a class="header-anchor" href="#（2）版本5的认证对话">¶</a>（2）版本5的认证对话</h4><h2 id="4-3-基于非对称加密的密钥分配"><a class="header-anchor" href="#4-3-基于非对称加密的密钥分配">¶</a>4.3 基于非对称加密的密钥分配</h2><h3 id="4-3-0-引言"><a class="header-anchor" href="#4-3-0-引言">¶</a>4.3.0 引言</h3><p>公钥加密一个重要作用：处理密钥分发（公钥的分发+使用公钥加密分发私钥）</p><h3 id="4-3-1-公钥证书"><a class="header-anchor" href="#4-3-1-公钥证书">¶</a>4.3.1 公钥证书</h3><ul><li>为什么要有公钥证书？<br>就像邮箱、银行卡号这种公钥，它们是广而告之的；但是你怎么知道他说这是就是呢？万一伪造了呢？所以我们引入第三方、公钥证书这些来验证。</li><li>X.509标准是人们广泛接受的公钥证书格式</li></ul><h3 id="4-3-2-基于公钥密码的秘密密钥分发"><a class="header-anchor" href="#4-3-2-基于公钥密码的秘密密钥分发">¶</a>4.3.2 基于公钥密码的秘密密钥分发</h3><p>对称密钥中，任何一对通信者之间共享唯一密钥是前提，之后才能安全通信<br>我们会想到之前提过的DH密钥交换，但是这不能认证双方；所以这里提出“公钥证书”的概念<br>考虑如下操作步骤（当B想要发消息给A的时候）：</p><ul><li>使用一次性+传统的+会话密钥，加密消息</li><li>用A的公钥加密会话密钥（问题所在：B怎么得到A的公钥的？——&gt;通过A的公钥证书）</li><li>把加密后的会话密钥和加密后的消息放在一起送给A</li></ul><h2 id="4-4-X-509证书"><a class="header-anchor" href="#4-4-X-509证书">¶</a>4.4 X.509证书</h2><h3 id="4-4-0-引言"><a class="header-anchor" href="#4-4-0-引言">¶</a>4.4.0 引言</h3><p>X.500是一个系列推荐标准(?)，定义了一套目录服务：</p><blockquote><p>目录服务就是，有用于维护用户信息数据库的一个或一组分布式服务器。信息包括：用户名到网络地址的映射，以及用户其他信息</p></blockquote><p>X.509是X.500推荐标准系列中的一部分，定义了一个使用X.500目录向用户提供认证服务的框架，</p><ul><li>该目录就可以作为公钥证书存储库（公钥证书=用户的公钥+可信任的认证中心的私钥签名）</li><li>X.509还定义了一个基于公钥证书的认证协议</li></ul><p>下图表示了公钥证书的产生：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231110704.png" alt=""></p><h3 id="4-4-1-证书"><a class="header-anchor" href="#4-4-1-证书">¶</a>4.4.1 证书</h3><h4 id="（1）公钥证书使用步骤"><a class="header-anchor" href="#（1）公钥证书使用步骤">¶</a>（1）公钥证书使用步骤</h4><ul><li>可信任的认证中心CA为用户创建证书</li><li>CA/用户把证书放到目录服务器</li><li>目录服务器提供一个方便访问证书的场所</li></ul><h4 id="（2）X-509定义的公钥证书格式"><a class="header-anchor" href="#（2）X-509定义的公钥证书格式">¶</a>（2）X.509定义的公钥证书格式</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231130854.png" alt=""></p><p><strong>CA用自己的私钥对证书签名，用户知道CA的公钥的话，就可以解密，验证证书是否合法</strong></p><p>这其实是一个典型的数字签名过程，可以如下描述：<br><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231130247.png" alt=""></p><h4 id="（3）CA生成的公钥证书的特征"><a class="header-anchor" href="#（3）CA生成的公钥证书的特征">¶</a>（3）CA生成的公钥证书的特征</h4><ul><li>用户可以用CA的公钥去解密证书，看里面的用户公钥，以验证</li><li>只有CA才可以修改用户证书；证书不可伪造，所以放到目录服务器里不需要采取额外保护措施</li></ul><h4 id="（4）证书链"><a class="header-anchor" href="#（4）证书链">¶</a>（4）证书链</h4><p>先来看一种情境，假如一个CA负责了很多用户的证书，那么它要给所有用户发一个自己的公钥的副本，以便他们可以用这个公钥去解密证书以验证其合法性。<br>那么如果，有一个假CA出来，用自己的私钥签了证书，并给用户自己的公钥；这个私钥和公钥仍然是匹配的，又由于用户只看能不能解密来证明其合法性……所以说，太多用户的时候，可以使用多个CA</p><p>多个CA会是什么情况呢？假如A从X1那里拿了证书，B从X2；然后A去看B的证书，能获取是能获取，但是拿到手上也没用，因为A没有X2的公钥，不能验证里面的签名，也就不能确定这个是B的证书……</p><p>一种解决方案是，X1和X2事先交换过公钥，然后就可以：</p><ol><li>A在目录中拿到X1签名的X2证书（X2的公钥证书，把X2当成一个普通用户的话）,即<code>X1&lt;&lt;X2&gt;&gt;</code></li><li>A有X1的公钥，所以A从<code>X1&lt;&lt;X2&gt;&gt;——&gt;X2</code>，也就是拿到了X2的公钥</li><li>A去拿由X2签名的B的证书，即<code>X2&lt;&lt;B&gt;&gt;</code>，解密拿到B，也就是知道了B的公钥</li></ol><p>A获取B的公钥的过程可以描述为：X1&lt;<x2>&gt;X2&lt;<b>&gt;<br>同理，B获取A的公钥的过程为：<code>X2&lt;&lt;X1&gt;&gt;X1&lt;&lt;A&gt;&gt;</code></b></x2></p><b><p>更普遍的过程可以描述为：</p><pre><code>X1&lt;&lt;X2&gt;&gt;X2&lt;&lt;X3&gt;&gt;...XN&lt;&lt;B&gt;&gt;</code></pre><p>相邻的两个X应该互相生成过证书，为了更明确这个关系，我们用下图来描述：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/%E7%BB%98%E5%9B%BE138.png" alt=""></p><h4 id="（5）证书撤销"><a class="header-anchor" href="#（5）证书撤销">¶</a>（5）证书撤销</h4><p>一般都是自然过期，不过有以下情况需要提前撤销：<br>见书P98</p><p>用户从消息中取得证书的时候，需要确认它是否被取消</p><h3 id="4-4-2-X-509版本3"><a class="header-anchor" href="#4-4-2-X-509版本3">¶</a>4.4.2 X.509版本3</h3><h4 id="（1）X-509版本2没有满足的要求"><a class="header-anchor" href="#（1）X-509版本2没有满足的要求">¶</a>（1）X.509版本2没有满足的要求</h4><p>见书P98</p><h4 id="（2）X-509版本3的改变"><a class="header-anchor" href="#（2）X-509版本3的改变">¶</a>（2）X.509版本3的改变</h4><p>加入扩展部分，更加灵活</p><p>扩展=一个扩展标识+一个危险指示符+一个扩展值<br>危险指示符：标识一个扩展是否可以被安全地忽略，True则可</p><p>证书扩展可以分为三个主要类型：</p><ul><li>密钥和策略信息</li><li>主体和发放者属性</li><li>认证路径约束</li></ul><h4 id="（3）密钥和策略信息"><a class="header-anchor" href="#（3）密钥和策略信息">¶</a>（3）密钥和策略信息</h4><p>用处：指示证书对于（一个特定的具有相同安全需求的团体、应用类别）的适用性</p><p>域的内容见书P99</p><h4 id="（4）主体和发放者属性"><a class="header-anchor" href="#（4）主体和发放者属性">¶</a>（4）主体和发放者属性</h4><p>用处：附加一些属性，让别人更相信这个证书是某个人的</p><p>域的内容见书P99</p><h4 id="（5）认证路径约束"><a class="header-anchor" href="#（5）认证路径约束">¶</a>（5）认证路径约束</h4><p>用处：限制主体CA可以发放的证书类型，或限制在认证链中随后可以出现的证书类型</p><p>域的内容见书P99</p><h2 id="4-5-公钥基础设施KPI"><a class="header-anchor" href="#4-5-公钥基础设施KPI">¶</a>4.5 公钥基础设施KPI</h2><h3 id="4-5-0-引言"><a class="header-anchor" href="#4-5-0-引言">¶</a>4.5.0 引言</h3><ul><li>PKI是什么？<br>之所以叫基础设施：包含了硬件+软件+人员+策略+过程</li><li>那是干什么的基础设施？<br>公钥密码中，用于生成+管理+存储+分配+撤销数字证书</li><li>PKIX是什么？<br>基于X.509的PKI</li><li>所以具体来说，PKIX包括些什么呢？</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231152633.png" alt=""></p><h3 id="4-5-1-PKIX管理功能"><a class="header-anchor" href="#4-5-1-PKIX管理功能">¶</a>4.5.1 PKIX管理功能</h3><ul><li>注册：注册开始了一个PKI中的登记过程</li><li>初始化：客户端安装密钥资料</li><li>认证：CA发证书</li><li>密钥对恢复：</li><li>密钥对更新：</li><li>撤销申请：CA撤销</li><li>交叉认证：两个CA之间</li></ul><p>上图中粉红色部分</p><h3 id="4-5-2-PKIX管理协议"><a class="header-anchor" href="#4-5-2-PKIX管理协议">¶</a>4.5.2 PKIX管理协议</h3><p>用来支持上一节列出的管理功能</p><h2 id="4-6-联合身份管理"><a class="header-anchor" href="#4-6-联合身份管理">¶</a>4.6 联合身份管理</h2><h3 id="4-6-1-身份管理"><a class="header-anchor" href="#4-6-1-身份管理">¶</a>4.6.1 身份管理</h3><h4 id="（1）作用"><a class="header-anchor" href="#（1）作用">¶</a>（1）作用</h4><p>验证身份以后给对应的资源接口，基于单点登录SSO</p><h4 id="（2）基本要素"><a class="header-anchor" href="#（2）基本要素">¶</a>（2）基本要素</h4><p>见书P102</p><p>值得注意的是，Kerberos包含身份管理系统的许多要素</p><h4 id="（3）通用的身份管理系统"><a class="header-anchor" href="#（3）通用的身份管理系统">¶</a>（3）通用的身份管理系统</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231153605.png" alt=""></p><h3 id="4-6-2-身份联合"><a class="header-anchor" href="#4-6-2-身份联合">¶</a>4.6.2 身份联合</h3><p>身份联合就是将身份管理扩展到多个安全域，也就是说，多个域之间共享用户的数字身份，使得用户只要一次认证就可以接入多个域的应用及其资源</p><h4 id="（1）联合身份管理的作用"><a class="header-anchor" href="#（1）联合身份管理的作用">¶</a>（1）联合身份管理的作用</h4><ul><li>单点登录SSO</li><li>表示属性的标准方法：属性可以指口令、生物特征信息、文件所有权等等</li><li>身份映射：同一个用户在不同的域中身份和属性可能不同，身份映射可以将一个域的身份和属性映射到另一个域的要求</li></ul><h4 id="（2）联合身份管理的实体与数据流"><a class="header-anchor" href="#（2）联合身份管理的实体与数据流">¶</a>（2）联合身份管理的实体与数据流</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201231193813.png" alt=""></p><h4 id="（3）标准"><a class="header-anchor" href="#（3）标准">¶</a>（3）标准</h4><p>联合身份管理使用了一些标准，作为系统的构件，实现在不同的域之间进行安全身份交换的要求：</p><ul><li>可扩展标记语言XML</li><li>简单对象访问协议SOAP</li><li>WS-安全</li><li>安全断言标记语言SAML：可以传递用户认证信息</li></ul><p>见书P103-104</p><h4 id="（4）例子"><a class="header-anchor" href="#（4）例子">¶</a>（4）例子</h4><p>见书P104-105</p></b><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter2 对称加密和消息机密性</title>
      <link href="2020/09/21/Chapter2-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E6%B6%88%E6%81%AF%E6%9C%BA%E5%AF%86%E6%80%A7/"/>
      <url>2020/09/21/Chapter2-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E6%B6%88%E6%81%AF%E6%9C%BA%E5%AF%86%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-对称加密原理"><a class="header-anchor" href="#2-1-对称加密原理">¶</a>2.1 对称加密原理</h2><h3 id="2-1-0-对称加密简介"><a class="header-anchor" href="#2-1-0-对称加密简介">¶</a>2.1.0 对称加密简介</h3><h4 id="（1）一个对称加密算法的组成"><a class="header-anchor" href="#（1）一个对称加密算法的组成">¶</a>（1）一个对称加密算法的组成</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/model.png" alt=""></p><h4 id="（2）对称加密算法的安全性"><a class="header-anchor" href="#（2）对称加密算法的安全性">¶</a>（2）对称加密算法的安全性</h4><p>需要达到以下两个要求：</p><ul><li>强加密算法：（一个很强的条件）攻击者知道算法且有很多密文+密文对应的明文，却不能破译密文，或者解出密钥</li><li>密钥安全：Alice和Bob的密钥收发仅两人可得。（因为如果别人得到了他们的密钥，所有使用此密钥的通信都可读）</li></ul><p><strong>注：对称加密的安全取决于密钥的保密性，算法可公开</strong></p><h3 id="2-1-1-密码体制"><a class="header-anchor" href="#2-1-1-密码体制">¶</a>2.1.1 密码体制</h3><p>密码体制有以下三个分类标准：</p><h4 id="1-明文转换成密文的操作类型"><a class="header-anchor" href="#1-明文转换成密文的操作类型">¶</a>1. 明文转换成密文的操作类型</h4><ul><li>替换：明文映射到……</li><li>换位：明文再排列</li></ul><p>（注：上述两种操作可以以比特、字母等等为单位）</p><h4 id="2-使用的密钥数"><a class="header-anchor" href="#2-使用的密钥数">¶</a>2. 使用的密钥数</h4><ul><li>AB同一密钥：对称/单钥/秘密密钥/传统加密</li><li>AB不同密钥：不对称/双钥/公钥加密</li></ul><h4 id="3-明文的处理方式"><a class="header-anchor" href="#3-明文的处理方式">¶</a>3. 明文的处理方式</h4><ul><li>一次处理一个分组：分组密码</li><li>明文输入过程中连续处理：流密码</li></ul><h3 id="2-1-2-密码分析"><a class="header-anchor" href="#2-1-2-密码分析">¶</a>2.1.2 密码分析</h3><p>密码分析或破译：找出明文或密钥</p><p>根据攻击者掌握的信息量，可将攻击类型分类如下：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/attack.png" alt=""></p><h4 id="1-惟密文攻击"><a class="header-anchor" href="#1-惟密文攻击">¶</a>1. 惟密文攻击</h4><p>或许只能穷举……但是也有一些小技巧，比如统计测试（前提是对明文的类型有一个大致的了解）</p><h4 id="2-已知明文攻击"><a class="header-anchor" href="#2-已知明文攻击">¶</a>2. 已知明文攻击</h4><p>比如某种文件可能有些固定的内容……<br><strong>一般密码算法会被设计成能抵挡已知明文攻击的程度</strong></p><h4 id="3-选择明文"><a class="header-anchor" href="#3-选择明文">¶</a>3. 选择明文</h4><p>攻击者能得到源系统，可以插入自己选定的消息（选定明文，查看密文）</p><h4 id="4-选择密文"><a class="header-anchor" href="#4-选择密文">¶</a>4. 选择密文</h4><p>是选择明文的反向，不过不太常见</p><h4 id="5-选择文本"><a class="header-anchor" href="#5-选择文本">¶</a>5. 选择文本</h4><p>选择明文+选择密文的能力，不过不太常见</p><p>计算安全的加密方案（妙啊！）：</p><ul><li>破解密文的代价&gt;明文的价值</li><li>破解密文的时间&gt;信息的有用寿命</li></ul><h3 id="2-1-3-Feistel密码结构"><a class="header-anchor" href="#2-1-3-Feistel密码结构">¶</a>2.1.3 Feistel密码结构</h3><h4 id="可以看做是对称密码算法的通用结构"><a class="header-anchor" href="#可以看做是对称密码算法的通用结构">¶</a>可以看做是对称密码算法的通用结构</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/Fiestel.png" alt=""></p><h4 id="其中有些可以调整的参数："><a class="header-anchor" href="#其中有些可以调整的参数：">¶</a>其中有些可以调整的参数：</h4><ul><li>分组大小：折中128bit一组比较常见</li><li>密钥大小：越长——越安全——加解密越慢</li><li>迭代轮数：典型16</li><li>子密钥产生算法：越复杂越安全</li><li>轮函数：同上</li></ul><h4 id="设计算法还需考虑"><a class="header-anchor" href="#设计算法还需考虑">¶</a>设计算法还需考虑</h4><ul><li>软件执行速度比较快</li><li>容易分析——容易找到弱点——随即加固</li></ul><p><strong>对称密码算法的加解密本质上是相同的过程，不需要实现两个不同的算法</strong></p><h2 id="2-2-对称分组加密算法"><a class="header-anchor" href="#2-2-对称分组加密算法">¶</a>2.2 对称分组加密算法</h2><h3 id="2-2-1-数据加密标准DES"><a class="header-anchor" href="#2-2-1-数据加密标准DES">¶</a>2.2.1 数据加密标准DES</h3><p>说实话，我总是不能把数据加密标准和DES联系在一起，这两个名字，一个像标准，一个像算法哈哈哈哈；但是仔细研究一下发现，其实我的直觉没错<br>DES准确来说是一种标准，数据加密标准；算法本身其实叫做DEA，略感陌生；一般都直接说DES了</p><h4 id="DEA算法描述"><a class="header-anchor" href="#DEA算法描述">¶</a>DEA算法描述</h4><p>基本沿用Fiestel结构，参数如下：</p><ul><li>分组大小：64</li><li>密钥大小：56</li><li>迭代轮数：典型16</li><li>子密钥产生算法：越复杂越安全</li><li>轮函数：同上</li></ul><h4 id="DES的强度"><a class="header-anchor" href="#DES的强度">¶</a>DES的强度</h4><ul><li>算法本身：至今还没人指出弱点</li><li>密钥长度：一定范围内，蛮力攻击还是可行的（所以后来有改进的算法来替代它，如3DES和AES）</li></ul><h3 id="2-2-2-三重DES"><a class="header-anchor" href="#2-2-2-三重DES">¶</a>2.2.2 三重DES</h3><h4 id="3DES流程"><a class="header-anchor" href="#3DES流程">¶</a>3DES流程</h4><p>使用三次DES，加密——解密——加密</p><h4 id="3DES优点"><a class="header-anchor" href="#3DES优点">¶</a>3DES优点</h4><ul><li>底层算法与DES相同，之前说过无弱点了</li><li>密钥长度168bit，解决了被穷举的问题</li></ul><h4 id="3DES缺点"><a class="header-anchor" href="#3DES缺点">¶</a>3DES缺点</h4><p>软件运行慢</p><h3 id="2-2-3-高级加密标准AES"><a class="header-anchor" href="#2-2-3-高级加密标准AES">¶</a>2.2.3 高级加密标准AES</h3><p>替代3DES，安全性&gt;=，效率&gt;=</p><h4 id="AES流程"><a class="header-anchor" href="#AES流程">¶</a>AES流程</h4><p>值得注意的是，它不是Feistel结构<br>（具体可见书30—31页）</p><h2 id="2-3-随机数和伪随机数"><a class="header-anchor" href="#2-3-随机数和伪随机数">¶</a>2.3 随机数和伪随机数</h2><h3 id="2-3-1-随机数的应用"><a class="header-anchor" href="#2-3-1-随机数的应用">¶</a>2.3.1 随机数的应用</h3><h4 id="（1）基于随机数的安全算法"><a class="header-anchor" href="#（1）基于随机数的安全算法">¶</a>（1）基于随机数的安全算法</h4><p>RSA、对称流密码的密钥流的生成、密钥分配方案……</p><h4 id="（2）应用对随机数的需求"><a class="header-anchor" href="#（2）应用对随机数的需求">¶</a>（2）应用对随机数的需求</h4><ol><li>随机性：有两个验证标准<br>（1）均匀分布：一串中，0与1出现概率大致相同<br>（2）独立：统一序列上，没有数字能影响别人</li><li>不可预测性</li></ol><h3 id="2-3-2-真随机数发生器TRNG、伪随机数生成器PRNG和伪随机函数PRF"><a class="header-anchor" href="#2-3-2-真随机数发生器TRNG、伪随机数生成器PRNG和伪随机函数PRF">¶</a>2.3.2 真随机数发生器TRNG、伪随机数生成器PRNG和伪随机函数PRF</h3><p>首先要明白，什么是统计上的随机性？（？）</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/random.png" alt=""></p><p>伪随机数发生器和伪随机函数的区别在于产生的比特数不同</p><h3 id="2-3-3-算法设计"><a class="header-anchor" href="#2-3-3-算法设计">¶</a>2.3.3 算法设计</h3><p>PRNG的算法可以分为两类：</p><h4 id="1-为特定目的构造的算法"><a class="header-anchor" href="#1-为特定目的构造的算法">¶</a>1. 为特定目的构造的算法</h4><ul><li>用于PRNG应用程序</li><li>有些算法专门被设计用在流密码中（如流密码）</li></ul><h4 id="2-基于现存密码算法的算法-、"><a class="header-anchor" href="#2-基于现存密码算法的算法-、">¶</a>2. 基于现存密码算法的算法          、</h4><p>有些密码算法可以嵌在PRNG应用中，作为其核心算法，比如：</p><ul><li>对称的分组密码</li><li>不对称的密码</li><li>散列函数和消息认证码</li></ul><h2 id="2-4-流密码和RC4"><a class="header-anchor" href="#2-4-流密码和RC4">¶</a>2.4 流密码和RC4</h2><p>分组密码更普遍，但对于特定应用还是要用流密码的。<br>流密码就是一次产生一个输出元素，我觉得和分组密码的区别就像：前者是python命令行一句句解释，后者是python IDE一整个程序给个解释<br>最对称的流密码可以说是RC4了哈哈哈哈</p><h3 id="2-4-1-流密码结构"><a class="header-anchor" href="#2-4-1-流密码结构">¶</a>2.4.1 流密码结构</h3><h4 id="（1）流密码结构示意图"><a class="header-anchor" href="#（1）流密码结构示意图">¶</a>（1）流密码结构示意图</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/flow.png" alt=""></p><p>解释一下：首先呢，你要先有个密钥K，把它投入伪随机字节生成器里面得到密钥流k；k和明文异或就得到密文字节流啦。由于是对称的，加密解密用同一个密钥</p><h4 id="2-设计流密码的考虑因素"><a class="header-anchor" href="#2-设计流密码的考虑因素">¶</a>(2)设计流密码的考虑因素</h4><ul><li>加密序列有个长周期：意思是，其实伪随机字节生成器生成的是周期性循环的确定字节流，如果周期太短容易被破</li><li>生成的密钥流最好能通过随机数检测那些</li><li>PRNG的输入要足够长以便不会被穷举</li></ul><h4 id="3-流密码优点"><a class="header-anchor" href="#3-流密码优点">¶</a>(3)流密码优点</h4><ul><li>比分组密码快，代码少</li></ul><h4 id="4-分组密码优点"><a class="header-anchor" href="#4-分组密码优点">¶</a>(4)分组密码优点</h4><ul><li>分组密码可以重复使用密钥，但是流密码的密钥最好不要重复用不然容易被破<br>若已知两个密文流，将它们进行异或，结果=对应两个明文流的异或</li></ul><h3 id="2-4-2-RC4算法"><a class="header-anchor" href="#2-4-2-RC4算法">¶</a>2.4.2 RC4算法</h3><h4 id="1-RC4算法"><a class="header-anchor" href="#1-RC4算法">¶</a>(1)RC4算法</h4><ul><li>初始化<ul><li>S是个状态向量，有256维，刚开始从0-255维依次设为0-255；</li><li>K为密钥（1-256字节可变）；</li><li>T为临时向量（256维），T的赋值即将K循环利用填充进去</li></ul></li><li>S的初始置换：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">j=0;</span><br><span class="line">for(i=0;i&lt;=255;i++){</span><br><span class="line">j=(j+S[i]+T[i])mod 256;</span><br><span class="line">swap(S[i],S[j]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>密钥流产生：感觉只有对S的置换操作，因为一旦完成S向量的初始置换，就不在需要输入密要了</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/a1.png" alt=""></p><h4 id="2-RC4强度"><a class="header-anchor" href="#2-RC4强度">¶</a>(2)RC4强度</h4><p>有些特定的攻击方法，但是当密钥长度&gt;128bit时，没有可以成功的。<br>另外有个有趣的点是：我们发现WEP协议易受攻击从而导致RC4易受攻击，这说明了一条安全系统设计的困难性所在：</p><blockquote><p>密码算法要安全还不够，密码函数所处的协议也要安全，比如考虑输入输出上下游的安全等等</p></blockquote><h2 id="2-5-分组密码工作模式"><a class="header-anchor" href="#2-5-分组密码工作模式">¶</a>2.5 分组密码工作模式</h2><p>NIST提出了五种工作模式，希望覆盖“用分组密码做加密”的所有应用场景，这里列出了以下四种：</p><h3 id="2-5-1-电子密码本ECB模式"><a class="header-anchor" href="#2-5-1-电子密码本ECB模式">¶</a>2.5.1 电子密码本ECB模式</h3><h4 id="1-原理"><a class="header-anchor" href="#1-原理">¶</a>(1)原理</h4><p>假设明文被分成b比特一组，每个分组都是同一密钥加密的。每个分组对于一个给定的密钥会有一个密文（唯一的结果），但是如果一段明文里有两个完全相同的分组……它们对应的密文也是相同的……</p><h4 id="2-不足"><a class="header-anchor" href="#2-不足">¶</a>(2)不足</h4><p>如果明文过长以至于出现两个分组重复，就不安全。所以我们希望有上述情况的话，它们会对应两个不同的密文。</p><h3 id="2-5-2-密码分组链接CBC模式"><a class="header-anchor" href="#2-5-2-密码分组链接CBC模式">¶</a>2.5.2 密码分组链接CBC模式</h3><h4 id="1-原理-v2"><a class="header-anchor" href="#1-原理-v2">¶</a>(1)原理</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/CBC.png" alt=""></p><ul><li>输入：每组明文和上一组密文的异或</li><li>处理：所有分组用同一密钥</li></ul><h4 id="2-数学推导说明的一些东西"><a class="header-anchor" href="#2-数学推导说明的一些东西">¶</a>(2)数学推导说明的一些东西</h4><p>见书P39，说明在接收者收数据准备解密之前，如果Attacker有机会改变初始向量IV，那么P1也会被改变，也就是接收者会解出错误的明文</p><h3 id="2-5-3-密码反馈CFB模式"><a class="header-anchor" href="#2-5-3-密码反馈CFB模式">¶</a>2.5.3 密码反馈CFB模式</h3><h4 id="（1）作用"><a class="header-anchor" href="#（1）作用">¶</a>（1）作用</h4><p>将任意分组密码转化为流密码，为什么要转换呢？是由于有些应用场景下比较适合用流密码：</p><ul><li>流密码不需要将消息填充为分组大小的整数倍</li><li>流密码可以实时操作，也就是说，如果传送字符流，流密码可以使我们及时加密并传送每个字符</li><li>流密码的密文长度=明文长度，由于传输能力是一个比较宝贵的资源，我们用分组密码可能导致密文比明文长，从而浪费传输能力</li></ul><h4 id="（2）原理"><a class="header-anchor" href="#（2）原理">¶</a>（2）原理</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201228130754.png" alt=""></p><h3 id="2-5-4-计数器模式CTR"><a class="header-anchor" href="#2-5-4-计数器模式CTR">¶</a>2.5.4 计数器模式CTR</h3><h4 id="（1）应用"><a class="header-anchor" href="#（1）应用">¶</a>（1）应用</h4><p>（？）</p><ul><li>异步传输模式的网络安全中</li><li>IPSec中</li></ul><h4 id="（2）原理-v2"><a class="header-anchor" href="#（2）原理-v2">¶</a>（2）原理</h4><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201228130708.png" alt=""></p><h4 id="（3）CTR模式优点"><a class="header-anchor" href="#（3）CTR模式优点">¶</a>（3）CTR模式优点</h4><ul><li>硬件效率：各明文单元可以并行计算</li><li>软件效率：由于CTR允许并行计算，所以可以用一些有“并行特征”的指令</li><li>预处理：加密部分可以预处理</li><li>随机访问：对于只需要解密一部分密文的情况，CTR由于无链接，所以各块之间独立，想解密哪一块并不需要之前的信息</li><li>可证明的安全性</li><li>简单性：加解密算法完全相同</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter1 软件安全绪论</title>
      <link href="2020/09/19/Chapter1-%E7%BB%AA%E8%AE%BA-Reading-Notes/"/>
      <url>2020/09/19/Chapter1-%E7%BB%AA%E8%AE%BA-Reading-Notes/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-引言"><a class="header-anchor" href="#1-1-引言">¶</a>1.1 引言</h2><p>为什么会出现安全问题？</p><ul><li>软件变复杂，规模变大</li><li>软件承载的利益，让某些人利用软件安全问题来获取利益</li></ul><h2 id="1-2-典型安全问题"><a class="header-anchor" href="#1-2-典型安全问题">¶</a>1.2 典型安全问题</h2><p>为什么软件安全问题日渐复杂？</p><ul><li>随着科技发展、研究与分析的深入,我们注意到软件安全的问题非常多样化</li><li>试图利用软件安全问题获利的各类组织机构也在不断发展，针对软件安全问题的利用、破坏技术手段，造成软件安全问题日趋复杂</li></ul><h4 id="1-2-1-恶意软件"><a class="header-anchor" href="#1-2-1-恶意软件">¶</a>1.2.1 恶意软件</h4><h4 id="1-传统恶意软件"><a class="header-anchor" href="#1-传统恶意软件">¶</a>1. 传统恶意软件</h4><ul><li>传统的恶意软件包括：病毒、僵木蠕、间谍软件等</li><li>破坏：窃取信息、远程控制、实施破坏等</li><li>传统恶意软件需要发展的能力：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">渗透与扩散：突破防御+感染目标</span><br><span class="line">隐蔽能力：隐蔽特征避免被发现+被发现了能保护操纵者身份</span><br><span class="line">破坏能力：搜集信息+实施破坏</span><br></pre></td></tr></tbody></table></figure><h4 id="2-恶意软件发展历程"><a class="header-anchor" href="#2-恶意软件发展历程">¶</a>2. 恶意软件发展历程</h4><p>单机传播——网络传播——协同攻击<br>APT攻击（高可持续性威胁）：针对特定目标+高技术</p><h4 id="1-2-2-软件漏洞"><a class="header-anchor" href="#1-2-2-软件漏洞">¶</a>1.2.2 软件漏洞</h4><p>说的是程序设计错误导致的</p><h4 id="1-漏洞为什么越来越多？"><a class="header-anchor" href="#1-漏洞为什么越来越多？">¶</a>1. 漏洞为什么越来越多？</h4><ul><li>软件更复杂</li><li>漏洞多样化</li><li>软件开发周期变短</li></ul><h4 id="1-2-3-软件后门"><a class="header-anchor" href="#1-2-3-软件后门">¶</a>1.2.3 软件后门</h4><p>开发人员刻意设计，但对用户隐瞒的功能。为什么算在软件安全问题中呢？因为有的攻击者，开发软件的时候，会留下后门，将其设计为此软件的漏洞。<br>举个栗子：建城墙的人留了个暗道，工程交付以后，保护城墙的人不一定能找出来它，但是工人却一清二楚，可以通过暗道做些坏事。而且，工人更懂怎么利用城墙的设计藏好这个暗道。</p><h4 id="1-将软件后门设计为软件漏洞，此方法优势："><a class="header-anchor" href="#1-将软件后门设计为软件漏洞，此方法优势：">¶</a>1. 将软件后门设计为软件漏洞，此方法优势：</h4><ul><li>难发现</li><li>易利用</li><li>难取证：后门代码其实不在软件的产品代码中，而是攻击者利用漏洞动态加载的（被发现了说成设计错误就完事儿了，不是故意的哈哈哈）</li></ul><h2 id="1-3-软件安全性分析的目标"><a class="header-anchor" href="#1-3-软件安全性分析的目标">¶</a>1.3 软件安全性分析的目标</h2><h3 id="1-3-1-软件安全性分析要解决的问题"><a class="header-anchor" href="#1-3-1-软件安全性分析要解决的问题">¶</a>1.3.1 软件安全性分析要解决的问题</h3><ol><li><p>存在问题<br>“是否”的问题：有恶意功能/漏洞/后门吗？</p></li><li><p>机理问题<br>“为什么”的问题：分析下此问题出现的原因/原理/工作流程之类的，具体问题具体分析</p></li><li><p>对策问题<br>“怎么办”的问题：防御</p></li></ol><h3 id="1-3-2-无源码时对软件逆向分析的挑战"><a class="header-anchor" href="#1-3-2-无源码时对软件逆向分析的挑战">¶</a>1.3.2 无源码时对软件逆向分析的挑战</h3><ol><li><p>指令代码的理解<br>从可执行文件或指令执行序列等，理解到操作语义很困难</p></li><li><p>关联关系的抽取<br>操作之间的数据传递、计算，数据/指令之间的依赖关系，很难有直观的认识</p></li><li><p>对策问题<br>“怎么办”的问题：防御</p></li></ol><h2 id="1-4-主要方法与技术"><a class="header-anchor" href="#1-4-主要方法与技术">¶</a>1.4 主要方法与技术</h2><h3 id="1-4-0-软件逆向分析方法分类"><a class="header-anchor" href="#1-4-0-软件逆向分析方法分类">¶</a>1.4.0 软件逆向分析方法分类</h3><p>主要有两大类：静态分析和动态分析</p><h4 id="1-静态分析"><a class="header-anchor" href="#1-静态分析">¶</a>1. 静态分析</h4><p>感觉就像通过反汇编或反编译的手段，对软件的可执行代码进行分析<br>（1）优点：比较全面、整体<br>（2）缺点：一方面，软件代码规模大了或者复杂了就不好搞；另一方面，如果软件做了加壳保护那就不能反汇编等等</p><h4 id="2-动态分析"><a class="header-anchor" href="#2-动态分析">¶</a>2. 动态分析</h4><p>通过直接运行软件，监测软件运行过程进行分析。<br>（1）优点：分析过程中可根据软件的运行过程直接获得在各个指令执行后的结果数据，减少推理分析<br>（2）缺点：每次分析只能针对动态执行的一条路径执行，整体性较差（所以说，如何构造多条执行路径也是动态分析需要研究的一个重要问题）</p><p><strong>现在一般：动态为主，静态为辅</strong></p><h3 id="1-4-1-反汇编与反编译"><a class="header-anchor" href="#1-4-1-反汇编与反编译">¶</a>1.4.1 反汇编与反编译</h3><p>通常是逆向分析的第一步（静态动态都是）</p><h4 id="作用"><a class="header-anchor" href="#作用">¶</a>作用</h4><p>二进制exe文件（完全不可读）——&gt;汇编代码——&gt;其他高级语言代码（基本可读）<br>第一个箭头是反汇编，第二个是反编译；做到<strong>功能等价</strong>就行</p><h3 id="1-4-2-程序调试"><a class="header-anchor" href="#1-4-2-程序调试">¶</a>1.4.2 程序调试</h3><p>动态分析</p><h4 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h4><p>用一些工具，通过断点、单步执行等方式<br>内核代码的调试需要虚拟化技术+多台设备</p><h4 id="优缺点"><a class="header-anchor" href="#优缺点">¶</a>优缺点</h4><p>优缺点基本同“动态分析”中所写，此外，软件自保护技术可能阻碍调试，且数据量和复杂度都挺恐怖的</p><h3 id="1-4-3-程序切片"><a class="header-anchor" href="#1-4-3-程序切片">¶</a>1.4.3 程序切片</h3><h4 id="作用-v2"><a class="header-anchor" href="#作用-v2">¶</a>作用</h4><p>解决软件代码规模超大带来的理解困难，比如分析出了汇编代码，对汇编代码切片……</p><h4 id="基本思想"><a class="header-anchor" href="#基本思想">¶</a>基本思想</h4><p>分析指令的相关性，从而提取用户“感兴趣”的代码</p><p>主要用于静态分析，也可用于动态分析，有差异：<br>（1）静态分析：通过计算操作数<strong>可能的影响范围</strong>（要考虑各种可能的执行路径）来计算指令的关联关系<br>（2）动态分析：更有针对性，对某条路径某个操作数来分析指令关联</p><h4 id="缺点"><a class="header-anchor" href="#缺点">¶</a>缺点</h4><p>对局部代码还不错，但代码多了照样难受</p><h3 id="1-4-4-污点传播分析"><a class="header-anchor" href="#1-4-4-污点传播分析">¶</a>1.4.4 污点传播分析</h3><p>静态动态都有，<strong>数据流分析方法</strong></p><h4 id="基本思想-v2"><a class="header-anchor" href="#基本思想-v2">¶</a>基本思想</h4><p>将感兴趣的数据标记，根据每条指令的污点传播过程，分析数据的传递关系</p><h4 id="实现方式"><a class="header-anchor" href="#实现方式">¶</a>实现方式</h4><p>按照“如何获得后台执行过程中具体每一条指令和指令执行前后状态”，可以分为：<br>基于插桩/硬件/编译器扩展/硬件模拟器等等</p><h4 id="存在问题"><a class="header-anchor" href="#存在问题">¶</a>存在问题</h4><p>由于控制依赖、查表操作等引入的隐式污点传播无法简单地引入或去除</p><h3 id="1-4-5-符号执行"><a class="header-anchor" href="#1-4-5-符号执行">¶</a>1.4.5 符号执行</h3><p>静态动态都有</p><h3 id="1-4-6-模糊测试"><a class="header-anchor" href="#1-4-6-模糊测试">¶</a>1.4.6 模糊测试</h3><p>动态分析</p><h4 id="作用-v3"><a class="header-anchor" href="#作用-v3">¶</a>作用</h4><p>本来是构造许多奇怪数据来看软件鲁棒性的，但现在是为了触发不同的执行路径</p><h4 id="存在问题-v2"><a class="header-anchor" href="#存在问题-v2">¶</a>存在问题</h4><p>提高测试数据生成的针对性——&gt;提高模糊测试效率</p><h2 id="1-5-主要分析应用"><a class="header-anchor" href="#1-5-主要分析应用">¶</a>1.5 主要分析应用</h2><h3 id="1-5-1-恶意软件分析"><a class="header-anchor" href="#1-5-1-恶意软件分析">¶</a>1.5.1 恶意软件分析</h3><h5 id="对恶意软件的分析目标"><a class="header-anchor" href="#对恶意软件的分析目标">¶</a>对恶意软件的分析目标</h5><ul><li>分析出主要功能</li><li>提取代码或行为特征，更新防御配置</li><li>分析实现机理，研发清除手段</li></ul><h5 id="网络协议逆向分析"><a class="header-anchor" href="#网络协议逆向分析">¶</a>网络协议逆向分析</h5><p>方法：</p><ul><li>基于网络流量统计特征展开分析</li><li>直接通过逆向软件分析<br>优点：准确、分析能力强<br>基本思路：对代码静态+动态逆向分析，提取出协议中的数据包格式/关键字/协议状态机等</li></ul><h5 id="软件漏洞分析与利用"><a class="header-anchor" href="#软件漏洞分析与利用">¶</a>软件漏洞分析与利用</h5><p>如何发现软件漏洞？</p><ul><li>模糊测试工具</li><li>典型漏洞的代码特征</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件安全分析与应用》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Day1 - in_array函数缺陷//PHP Audit</title>
      <link href="2020/09/19/Day1-in-array%E5%87%BD%E6%95%B0%E7%BC%BA%E9%99%B7-PHP-Audit/"/>
      <url>2020/09/19/Day1-in-array%E5%87%BD%E6%95%B0%E7%BC%BA%E9%99%B7-PHP-Audit/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sqlmap Mannal</title>
      <link href="2020/09/19/Sqlmap-Mannal/"/>
      <url>2020/09/19/Sqlmap-Mannal/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>蚁剑 Mannal</title>
      <link href="2020/09/19/%E8%9A%81%E5%89%91-Mannal/"/>
      <url>2020/09/19/%E8%9A%81%E5%89%91-Mannal/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.fujieace.com/hacker/tools/antsword.html">中国蚁剑下载、安装、使用教程</a></p><p><a href="https://www.bilibili.com/video/av86179526/">https://www.bilibili.com/video/av86179526/</a></p><center><h1>Webshell</h1></center>理解 webshell 我们可以从字面上去理解，将其拆分成 web 和 shell 来分别进行理解，web 在百度百科的解释如下：<p>web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和 HTTP 的、全球性的、动态交互的、跨平台的分布式图形信息系统。<br>是建立在 Internet 上的一种网络服务，为浏览者在 Internet 上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将 Internet 上的信息节点组织成一个互为关联的网状结构。</p><p>web 对于我们来说都不陌生，是从事安全行业的同僚接触最多，也是入门必学的基础，为什么会是必学的基础呢？</p><p>因为这个在企业中是应用最广泛，也是最容易暴露在攻击者面前的东西，任何人都能找到任何企业暴露在外面可供入侵者攻击的应用，所以学习 web 安全没有错。</p><p>那么 shell 是什么呢？百度百科的解释如下：</p><p>在计算机科学中，Shell 俗称壳（用来区别于核），是指“提供使用者使用界面”的软件（命令解析器）。它类似于 DOS <a href="http://xn--command-nw3k6121a.com">下的command.com</a> 和后来的 cmd.exe。<br>它接收用户命令，然后调用相应的应用程序。</p><p>对于 shell 的理解，我们也可以理解为一个接口，用来管理某些应用程序。</p><p>webshell 就是两者的集合，合起来的意思可以理解为 web 应用管理工具，正常情况下，运维人员可以通过 webshell 针对 web 服务器进行日常的运维管理以及系统上线更新等，那么攻击者也可以通过 webshell 来管理 web 应用服务器。</p><p><strong>两者在使用上并没有太多区别，但是在叫法上可能就不大一样了，管理员使用可以叫服务器管理工具，而在攻击者手里就可以叫做后门程序了。</strong></p><center><h1>一句话木马</h1></center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php eval($_POST[&quot;kxc&quot;]);?&gt;</span><br></pre></td></tr></table></figure><p>php的eval()函数：eval($str)函数是把$str当做PHP代码执行。</p><p>这是php的一句话后门中最普遍的一种。它的工作原理是：<br>首先存在一个名为shell的变量，shell的取值为HTTP的POST方式。Web服务器对shell取值以后，然后通过eval()函数执行shell里面的内容。</p>]]></content>
      
      
      <categories>
          
          <category> Web Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蚁剑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wireshark Mannal</title>
      <link href="2020/09/19/Wireshark-Mannal/"/>
      <url>2020/09/19/Wireshark-Mannal/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Burpsuite Mannal</title>
      <link href="2020/09/19/Burpsuite-Mannal/"/>
      <url>2020/09/19/Burpsuite-Mannal/</url>
      
        <content type="html"><![CDATA[<h2 id="Proxy"><a class="header-anchor" href="#Proxy">¶</a>Proxy</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">forward：传输本次数据</span><br><span class="line">drop：丢弃本次数据</span><br><span class="line">Intercepton/off：拦截开启/关闭</span><br><span class="line">Action：提供功能选项</span><br></pre></td></tr></tbody></table></figure><p>当Burp Suite拦截的客户端和服务器交互之后，我们可以在Burp Suite的消息分析选项卡中查看这次请求的实体内容、消息头、请求参数等信息。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Raw：视图主要显示web请求的raw格式，包含请求地址、http协议版本、主机头、浏览器信息、Accept可接受的内容类型、字符集、编码方式、cookie等。我们可以通过手工修改这些信息，对服务器端进行渗透测试。</span><br><span class="line"></span><br><span class="line">params ：视图主要显示客户端请求的参数信息、包括GET或者POST请求的参数、Cookie参数。渗透人员可以通过修改这些请求参数来完成对服务器端的渗透测试。</span><br><span class="line"></span><br><span class="line">headers：视图显示的信息和Raw的信息类似，只不过在这个视图中，展示得更直观、友好。</span><br><span class="line"></span><br><span class="line">Hex ：视图显示Raw的二进制内容，你可以通过hex编辑器对请求的内容进行修改。</span><br></pre></td></tr></tbody></table></figure><p>Burpproxy所拦截的消息可在Fitter（过滤器）中根据需要进行修改</p><p>所有流经burpproxy的消息都会在 http history中记录下来，我们可以通过历史选项卡，查看传输的数据内容，对交互的数据进行测试和验证，同时，我们可以通过右击来弹出菜单，发送内容到burp的其他组件进行处理（类似于Action的功能）</p><p>comment：对拦截的消息添加备注，在一次渗透测试中，你通常会遇到一连串的请求消息，为了便于区分，在某个关键的请求消息上，你可以添加备注信息。</p><p>Highlight的功能与Comment功能有点类似，即对当前拦截的消息设置高亮，以便于其他的请求消息相区分。</p><p>可选项配置Options</p><p>从界面上看，主要有以下几大板块</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">▪客户端请求消息拦截（Interceptclient requests）</span><br><span class="line"></span><br><span class="line">▪服务器端返回消息拦截（intercept server responses）</span><br><span class="line"></span><br><span class="line">▪服务器返回消息修改（response modification）</span><br><span class="line"></span><br><span class="line">▪正则表达式配置（match and replace）</span><br><span class="line"></span><br><span class="line">▪其他配置项（miscellaneous）</span><br></pre></td></tr></tbody></table></figure><h2 id="Intruder"><a class="header-anchor" href="#Intruder">¶</a>Intruder</h2><p>工作原理：<br>Intruder在原始请求数据的基础上，通过修改各种请求参数，以获取不同的请求应答。每一次请求中，Intruder通常会携带一个或多个有效攻击载荷（Payload),在不同的位置进行攻击重放，通过应答数据的比对分析来获得需要的特征数据。<br>(在我的使用经验中，主要用于爆破)</p><p>应用场景：</p><ol><li>标识符枚举 Web应用程序经常使用标识符来引用用户、账户、资产等数据信息。例如，用户名，文件ID和账户号码。</li><li>提取有用的数据在某些场景下，而不是简单地识别有效标识符，你需要通过简单标识符提取一些其他的数据。比如说，你想通过用户的个人空间id，获取所有用户在个人空间标准的昵称和年龄。</li><li>模糊测试很多输入型的漏洞，如SQL注入，跨站点脚本和文件路径遍历可以通过请求参数提交各种测试字符串，并分析错误消息和其他异常情况，来对应用程序进行检测。由于的应用程序的大小和复杂性，手动执行这个测试是一个耗时且繁琐的过程。这样的场景，您可以设置Payload，通过Burp Intruder自动化地对Web应用程序进行模糊测试。</li></ol><p>测试步骤：</p><ol><li>确认Burp Suite安装正确并正常启动，且完成了浏览器的代理设置。</li><li>进入Burp Proxy选项卡，关闭代理拦截功能。</li><li>进行历史日志（History）子选项卡，查找可能存在问题的请求日志，并通过右击菜单，发送到Intruder。</li><li>进行Intruder选项卡，打开Target和Positions子选项卡。这时，你会看到上一步发送过来的请求消息。</li><li>因为我们了解到Burp Intruder攻击的基础是围绕刚刚发送过来的原始请求信息，在原始信息指定的位置上设置一定数量的攻击载荷Payload，通过Payload来发送请求获取应答消息。在默认情况下，所有的请求参数和cookie参数都会被设置为添加载荷<br>6.点击clear清除默认载荷（如果需要），圈定需要设置载荷的参数，点击add</li><li>当我们打开Payload子选项卡，选择Payload的生成或者选择策略，默认情况下选择“Simplelist",当然你也可以通过下拉选择其他Payload类型或者手工添加。</li><li>之后点击start attack发动攻击，此时burp 会自动打开一个新的界面，包含执行攻击的情况，http状态码、长度等信息的结果。我们还可以选择其中某一次通信消息，查看请求消息和应答消息的详细</li></ol><p>在很多时候，为了更好的标明应答消息中是否包含有我们需要的信息，通常在进行攻击前，会进行Options选项的相关配置，使用最多的为正则表达式匹配（Grep - Match）。</p><p>或者我们选择结果选项卡中的过滤器，对结果进行过滤筛选。同时，结果选项卡中所展示的列我们是可以进行指定的，我们可以在菜单columns进行设置。</p><p>最后选择我们需要的列，点击save按钮，对攻击结果进行保存。（也可以对保存对的内容进行设置</p><h2 id="Repeater"><a class="header-anchor" href="#Repeater">¶</a>Repeater</h2><p>Repeater是一个重放攻击器。<br>我们可以在这里对数据包的参数进行修改，以此来进行请求与响应的消息验证分析。<br><img src="https://img-blog.csdn.net/20170805164656913?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU1NDQzNzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web Sercurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Burpsuite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Understanding HTTP Deeply</title>
      <link href="2020/09/19/Understanding-HTTP-Deeply/"/>
      <url>2020/09/19/Understanding-HTTP-Deeply/</url>
      
        <content type="html"><![CDATA[<center><h1>简介</h1></center>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</p><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><p><img src="https://upload-images.jianshu.io/upload_images/2964446-5a35e17f298a48e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/551/format/webp" alt></p><center><h1>特点</h1></center>HTTP协议的主要特点可概括如下：1.支持客户/服务器模式。2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<center><h1>URL</h1></center>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息<p>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.aspxfans.com:8080&#x2F;news&#x2F;index.asp?boardID&#x3D;5&amp;ID&#x3D;24618&amp;page&#x3D;1#name</span><br></pre></td></tr></table></figure><p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p><ol><li><p>协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在&quot;HTTP&quot;后面的“//”为分隔符</p></li><li><p>域名部分：该URL的域名部分为“<a href="http://www.aspxfans.com">www.aspxfans.com</a>”。一个URL中，也可以使用IP地址作为域名使用</p></li><li><p>端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p></li><li><p>虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p></li><li><p>文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p></li><li><p>锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p></li><li><p>参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p></li></ol><center><h1>URI和URL的区别</h1></center><h2>URI</h2>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般由三部组成：①访问资源的命名机制②存放资源的主机名③资源自身的名称，由路径表示，着重强调于资源。<h2>URL</h2>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等<h2>URN</h2>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。<p>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。<br>在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。<br>相反的是，URL类可以打开一个到达资源的流。</p><center><h1>请求消息Request</h1></center>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：**请求行（request line）**、**请求头部（header）**、**空行**和**请求数据**四个部分。<p><img src="https://upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/466/format/webp" alt></p><h2>GET请求例子</h2><pre>GET /562f25980001b1b106000338.jpg HTTP/1.1Host    img.mukewang.comUser-Agent  Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept  image/webp,image/*,*/(为了让后面不要变成斜体，此处删去了一个星号);q=0.8Referer http://www.imooc.com/Accept-Encoding gzip, deflate, sdchAccept-Language zh-CN,zh;q=0.8</pre><h3>第一部分：请求行</h3>用来说明请求类型,要访问的资源以及所使用的HTTP版本.GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。<h3>第二部分：请求头部</h3>紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等<h3>第三部分：空行</h3>请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。(注意此例中是有空行的)<h3>第四部分：请求数据</h3>也叫主体，可以添加任意的其他数据。这个例子的请求数据为空。<h2>POST请求例子</h2><pre>POST / HTTP1.1Host:www.wrox.comUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type:application/x-www-form-urlencodedContent-Length:40Connection: Keep-Alivename=Professional%20Ajax&publisher=Wiley</pre><p>第一部分：请求行，第一行明了是post请求，以及http1.1版本。<br>第二部分：请求头部，第二行至第六行。<br>第三部分：空行，第七行的空行。<br>第四部分：请求数据，第八行。</p><center><h1>响应消息Response</h1></center>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。HTTP响应也由四个部分组成，分别是：**状态行**、**消息报头**、**空行**和**响应正文**。<p><img src="https://upload-images.jianshu.io/upload_images/2964446-1c4cab46f270d8ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/683/format/webp" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">      &lt;head&gt;&lt;&#x2F;head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">            &lt;!--body goes here--&gt;</span><br><span class="line">      &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3>第一部分：状态行</h3>由HTTP协议版本号， 状态码， 状态消息 三部分组成。第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）<h3>第二部分：消息报头</h3>用来说明客户端要使用的一些附加信息第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8<h3>第三部分：空行</h3>消息报头后面的空行是必须的<h3>第四部分：响应正文</h3>服务器返回给客户端的文本信息。空行后面的html部分为响应正文。<center><h1>状态码</h1></center>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:<p>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见状态码：</span><br><span class="line">200 OK                        &#x2F;&#x2F;客户端请求成功</span><br><span class="line">400 Bad Request               &#x2F;&#x2F;客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized              &#x2F;&#x2F;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span><br><span class="line">403 Forbidden                 &#x2F;&#x2F;服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found                 &#x2F;&#x2F;请求资源不存在，eg：输入了错误的URL</span><br><span class="line">500 Internal Server Error     &#x2F;&#x2F;服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable        &#x2F;&#x2F;服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure><center><h1>请求方法</h1></center>根据HTTP标准，HTTP请求可以使用多种请求方法。HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET  请求指定的页面信息，并返回实体主体。</span><br><span class="line">HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</span><br><span class="line">POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</span><br><span class="line">PUT  从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">DELETE   请求服务器删除指定的页面。</span><br><span class="line">CONNECT  HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。</span><br><span class="line">OPTIONS  允许客户端查看服务器的性能。</span><br><span class="line">TRACE    回显服务器收到的请求，主要用于测试或诊断。</span><br></pre></td></tr></table></figure><center><h1>工作原理</h1></center>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。<p><strong>以下是 HTTP 请求/响应的步骤：</strong><br>1、客户端连接到Web服务器<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn">http://www.oakcms.cn</a>。</p><p>2、发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p><p>3、服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p><p>4、释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p><p>5、客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p><p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p><ol><li><p>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p></li><li><p>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</p></li><li><p>浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</p></li><li><p>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p></li><li><p>释放 TCP连接;</p></li><li><p>浏览器将该 html 文本并显示内容;</p></li></ol><center><h1>GET和POST请求的区别</h1></center><p>GET请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;books&#x2F;?sex&#x3D;man&amp;name&#x3D;Professional HTTP&#x2F;1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko&#x2F;20050225 Firefox&#x2F;1.0.1</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure><p>POST请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko&#x2F;20050225 Firefox&#x2F;1.0.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name&#x3D;Professional%20Ajax&amp;publisher&#x3D;Wiley</span><br></pre></td></tr></table></figure><h3>提交数据的位置</h3>- GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&连接；例 如：`login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0 %E5%A5%BD`如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。<ul><li>POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据</li></ul><p><strong>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</strong></p><h3>传输数据的大小</h3>首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。而在实际开发中存在的限制主要有：<ul><li><p>GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。因此对于GET提交时，传输数据就会受到URL长度的限制。</p></li><li><p>POST:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p></li></ul><h3>安全性</h3><p>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击</p><h3>Http get,post,soap协议都是在http上运行的</h3><ul><li><p>get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的<br>查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全</p></li><li><p>post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。<br>但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。</p></li><li><p>soap：是http post的一个专用版本，遵循一种特殊的xml消息格式<br>Content-type设置为: text/xml 任何数据都可以xml化。</p></li></ul><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。<strong>GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</strong></p><h3>GET和POST的区别总结</h3><ul><li><p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</p></li><li><p>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p></li><li><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p></li><li><p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p></li></ul><center><h1>Cookie</h1></center>Cookie（复数形态Cookies），又称为“小甜饼”。类型为“小型文本文件”[1]，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。由网景公司的前雇员卢·蒙特利在1993年3月发明[2]。最初定义于RFC 2109。目前使用最广泛的 Cookie标准却不是RFC中定义的任何一个，而是在网景公司制定的标准上进行扩展后的产物。<p>因为HTTP协议是无状态的，即服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。</p><p>在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。</p><p>Cookie另一个典型的应用是当登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器<strong>发送了包含登录凭据（用户名加密码的某种加密形式）的Cookie到用户的硬盘上</strong>。第二次登录时，如果该Cookie尚未到期，浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。</p><center><h1>Session</h1></center>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session]]></content>
      
      
      <categories>
          
          <category> Web Sercurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Common Web Vulnerabilities: Causes, Damage and Defense</title>
      <link href="2020/09/18/Common-Web-Vulnerabilities-Causes-Damage-and-Defense/"/>
      <url>2020/09/18/Common-Web-Vulnerabilities-Causes-Damage-and-Defense/</url>
      
        <content type="html"><![CDATA[<h2 id="注入Injection"><a class="header-anchor" href="#注入Injection">¶</a>注入Injection</h2><p>Injection flaws, such as <strong>SQL</strong>, <strong>NoSQL</strong>, <strong>OS</strong>, and <strong>LDAP</strong> injection, occur when untrusted data is sent to an interpreter as part of a command or query. The attacker’s hostile(怀有敌意的) data can trick the interpreter into <strong>executing unintended commands</strong> or <strong>accessing data without proper authorization</strong>.</p><h3 id="Causes"><a class="header-anchor" href="#Causes">¶</a>Causes</h3><p>刚刚讲过当我们访问动态网页时, Web 服务器会向数据访问层发起 Sql 查询请求，如果权限验证通过就会执行 Sql 语句。<br>这种网站<strong>内部直接发送的Sql请求一般不会有危险</strong>，但实际情况是很多时候需要<strong>结合用户的输入数据动态构造 Sql 语句</strong>，如果用户输入的数据被构造成恶意 Sql 代码，Web 应用又未对动态构造的 Sql 语句使用的参数进行审查，则会带来意想不到的危险。<br>程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。</p><p>具体可阐述如下：</p><ol><li>WEB开发人员无法保证所有的输入都已经过滤</li><li>攻击者利用发送给SQL服务器的输入参数构造可执行的SQL代码（可加入到get请求、post请求、http头信息、cookie中）</li><li>数据库未做相应的安全配置</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">个人总结：</span><br><span class="line">网页需要根据用户输入动态构造SQL语句的时候，如果过滤之类的安全工作没做好，就会导致恶意代码执行、绕过认证、数据泄露等危害。</span><br></pre></td></tr></tbody></table></figure><h3 id="Damage"><a class="header-anchor" href="#Damage">¶</a>Damage</h3><ul><li>数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息。</li><li>绕过认证，列如绕过验证登录网站后台。</li><li>注入可以借助数据库的存储过程进行提权等操作</li><li>网页篡改：通过操作数据库对特定网页进行篡改。</li><li>网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。</li><li>数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。</li><li>服务器被远程控制，被安装后门。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。</li><li>破坏硬盘数据，瘫痪全系统。</li></ul><h3 id="Defense"><a class="header-anchor" href="#Defense">¶</a>Defense</h3><p>是开发人员应该思考的问题，作为测试人员，了解如何预防SQL注入，可以在发现注入攻击bug时，对bug产生原因进行定位。</p><ol><li><p>严格检查输入变量的类型和格式<br>对于整数参数，加判断条件：不能为空、参数类型必须为数字<br>对于字符串参数，可以使用正则表达式进行过滤：如：必须为[0-9a-zA-Z]范围内的字符串</p></li><li><p>过滤和转义特殊字符<br>例如：引号、双引号、斜杠、反斜杠、冒号、 空字符等的字符<br>过滤的对象: 用户的输入 | 提交的URL请求中的参数部分 | 从cookie中得到的数据<br>在username这个变量前进行转义，对’、"、\等特殊字符进行转义，如：php中的addslashes()函数对username参数进行转义</p></li><li><p>利用mysql的预编译机制<br>把sql语句的模板（变量采用占位符进行占位）发送给mysql服务器，mysql服务器对sql语句的模板进行编译，编译之后根据语句的优化分析对相应的索引进行优化，在最终绑定参数时把相应的参数传送给mysql服务器，直接进行执行，节省了sql查询时间，以及mysql服务器的资源，达到一次编译、多次执行的目的，除此之外，还可以防止SQL注入。具体是怎样防止SQL注入的呢？实际上当将绑定的参数传到mysql服务器，mysql服务器对参数进行编译，即填充到相应的占位符的过程中，做了转义操作。</p></li><li><p>监测方面目前大多都是日志监控+WAF（统一的filter）,部署防SQL注入系统或脚本</p></li><li><p>数据库日志容易解析,语法出错的、语法读Info表的建立黑白名单机制</p></li></ol><h3 id="References"><a class="header-anchor" href="#References">¶</a>References</h3><p><a href="https://blog.csdn.net/github_36032947/article/details/78442189?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160042717419195162113454%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160042717419195162113454&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_blog_v1-1-78442189.pc_v2_rank_blog_v1&amp;utm_term=SQL%E6%B3%A8%E5%85%A5&amp;spm=1018.2118.3001.4187">SQL注入攻击常见方式及测试方法</a><br><a href=""></a></p><h2 id="失效的身份认证Broken-Authentication"><a class="header-anchor" href="#失效的身份认证Broken-Authentication">¶</a>失效的身份认证Broken Authentication</h2><p>Application functions related to authentication and session management are often implemented incorrectly, allowing attackers to compromise passwords, keys, or session tokens, or to exploit other implementation flaws to assume(篡夺) other users’ identities temporarily or permanently.</p><h3 id="前言：名词解释"><a class="header-anchor" href="#前言：名词解释">¶</a>前言：名词解释</h3><p>Web应用程序使用的HTTP协议是一种<strong>无连接</strong>，<strong>无状态</strong>协议。</p><p>无连接是指限制每次连接只处理一个请求，服务器处理完成客户的请求，收到客户的应答之后，即断开连接，可以节省传输时间</p><p>无状态是指对于事物处理没有记忆功能，服务器不知道客户端是什么状态。即用户给服务器发送HTTP请求之后，服务器根据请求，将数据发送给用户，但是发送完成之后，不会记录任何信息。</p><p>也就是说，服务器无法保留连接到网站的每个客户端（用户）的身份/活动的内存。那么试想，每次我们登录一个网站，如果意外关闭了，就得重新登录，使用起来会非常不便。<strong>Cookie和Session因此诞生，解决无记录状态的问题</strong>。</p><h4 id="Session"><a class="header-anchor" href="#Session">¶</a>Session</h4><p>Session负责在<strong>服务器端</strong>记录用户信息，在一个用户完成身份认证之后，存储所需要的用户资料，用于持久保存网站的活动。<strong>服务器使用唯一的会话令牌产生对应的会话ID</strong></p><h4 id="Cookie"><a class="header-anchor" href="#Cookie">¶</a>Cookie</h4><p>Cookie由服务器发送并存储在<strong>客户端</strong>，在用户访问网站的时候创建，<strong>用以跟踪用户在网站中的活动</strong>，每次请求客户端都需要把它发送给服务器。当用户意外中断后，由于Cookie的存在就可以从中断的地方继续。</p><h4 id="身份认证"><a class="header-anchor" href="#身份认证">¶</a>身份认证</h4><p>身份认证最常用于系统登录，形式一般为<strong>用户名和密码登录</strong>方式，在安全性要求较高的情况下，还有验证码、客户端证书、Ukey等</p><h4 id="会话管理"><a class="header-anchor" href="#会话管理">¶</a>会话管理</h4><p><strong>HTTP利用会话机制来实现身份认证</strong>，HTTP身份认证的结果往往是<strong>获得一个令牌并放在cookie中，之后的身份识别只需读授权令牌，而无需再次进行登录认证</strong></p><h3 id="Causes-v2"><a class="header-anchor" href="#Causes-v2">¶</a>Causes</h3><ul><li>用户身份验证凭据在存储时不受保护</li><li>登录凭证可以被猜测或重写</li><li>会话ID直接暴露在URL中</li><li>会话ID容易收到会话固定攻击</li><li>会话ID不会超时失效，或者用户会话或身份验证令牌在注销时未失效</li><li>会话ID在登录成功之后不会轮换</li><li>密码，会话ID或者其他的登录凭据未经过加密传输</li></ul><h3 id="Attack"><a class="header-anchor" href="#Attack">¶</a>Attack</h3><ul><li><p>弱口令：弱口令的危害不言而喻，通常指的是仅包含简单的数字和字母组合的口令</p></li><li><p>口令破解：掌握了口令的组合方式或是加密细节</p></li><li><p>Cookie窃取&amp;伪造&amp;绕过：因为Cookie是存储在客户端的，相对而言容易被攻击者窃取</p></li><li><p>越权访问：分为垂直越权访问和水平越权访问，垂直越前访问是指不同用户级别之间的越权，比如普通用户能够执行管理员用户的权限。水平越权即同一级别用户之间的越权操作</p></li><li><p>会话固定：一种诱骗受害者使用攻击者拟定的Session ID的攻击手段，通过让合法用户使用攻击者设置的Session ID进行登录，使得web应用不在生成新的Session ID</p></li><li><p>会话劫持：就是在一次正常的通信过程中，攻击者作为第三方参与到其中，或者是在数据里加入其他信息，甚至将双方的通信模式暗中改变，即从直接联系变成有攻击者参与的联系。简单的说，就是攻击者把自己插入到受害者和目标机器之间，并设法让受害者和目标机器之间的数据通道变为受害者和目标机器之间存在一个看起来像“中转站”的代理机器（攻击者的机器）的数据通道，从而干涉两台机器之间的数据传输，例如监听敏感数据、替换数据等。由于攻击者已经介入其中，他能轻易知道双方传输的数据内容，还能根据自己的意愿去左右它。这个“中转站”可以是逻辑上的，也可以是物理上的，关键在于它能否获取到通信双方的数据。</p></li></ul><h3 id="Damage-v2"><a class="header-anchor" href="#Damage-v2">¶</a>Damage</h3><ul><li>窃取用户凭证和会话信息</li><li>恶意用户冒充用户身份查看或者变更记录，甚至执行事务</li><li>访问未授权的页面和资源</li><li>执行超越权限操作</li></ul><h3 id="Defense-v2"><a class="header-anchor" href="#Defense-v2">¶</a>Defense</h3><ul><li>在可能的情况下，实现多因素身份验证，以防止自动、凭证填充、暴力破解和被盗凭据再利用攻击。</li><li>不要使用发送或部署默认的凭证，特别是管理员用户。</li><li>执行弱密码检查，例如测试新或变更的密码，以纠正“排名前10000个弱密码” 列表。</li><li>将密码长度、复杂性和循环策略与NIST-800-63 B的指导方针的5.1.1章节-记住秘密，或其他现代的基于证据的密码策略相一致。</li><li>确认注册、凭据恢复和API路径，通过对所有输出结果使用相同的消息，用以抵御账户枚举攻击。</li><li>限制或逐渐延迟失败的登录尝试。记录所有失败信息并在凭据填充、暴力破解或其他攻击被检测时提醒管理员。</li><li>使用服务器端安全的内置会话管理器，在登录后生成高度复杂的新随机会话ID。会话ID不能在URL中，可以安全地存储和当登出、闲置、绝对超时后使其失效。</li></ul><h3 id="References-v2"><a class="header-anchor" href="#References-v2">¶</a>References</h3><p><a href="https://www.cnblogs.com/CH42e/p/13162177.html">A2 失效的身份认证和会话管理</a></p><h2 id="敏感数据泄露Sensitive-Data-Exposure"><a class="header-anchor" href="#敏感数据泄露Sensitive-Data-Exposure">¶</a>敏感数据泄露Sensitive Data Exposure</h2><p>Many web applications and APIs do not properly protect sensitive data, such as financial, healthcare, and PII. Attackers may steal or modify such weakly protected data to conduct credit card fraud, identity theft, or other crimes. Sensitive data may be compromised without extra protection, such as encryption at rest or in transit, and requires special precautions when exchanged with the browser.</p><h3 id="Causes-v3"><a class="header-anchor" href="#Causes-v3">¶</a>Causes</h3><p>对敏感数据的弱保护，具体原因如：</p><ul><li>错误的云存储配置</li><li>未受保护的代码存储库</li><li>易受攻击的开源软件</li></ul><h3 id="Damage-v3"><a class="header-anchor" href="#Damage-v3">¶</a>Damage</h3><p>利用敏感信息可以：</p><ul><li>信用卡欺诈</li><li>身份偷窃</li><li>等等</li></ul><h3 id="Defense-v3"><a class="header-anchor" href="#Defense-v3">¶</a>Defense</h3><p>对一些需要加密的敏感数据，应该起码做到以下几点：</p><ul><li>对系统处理、存储或传输的数据分类，并根据分类进行访问控制。</li><li>熟悉与敏感数据保护相关的法律和条例，并根据每项法规要求保护敏感数据。</li><li>对于没必要存放的、重要的敏感数据，应当尽快清除，或者通过PCI DSS标记或拦截。未存储的数据不能被窃取。</li><li>确保存储的所有敏感数据被加密。</li><li>确保使用了最新的、强大的标准算法或密码、参数、协议和密匙，并且密钥管理到位。</li><li>确保传输过程中的数据被加密，如：使用TLS。确保数据加密被强制执行，如：使用HTTP严格安全传输协议（HSTS ）。</li><li>禁止缓存对包含敏感数据的响应。</li><li>确保使用密码专用算法存储密码，如：Argon2 、 scrypt 、bcrypt 或者PBKDF2 。将工作因素（延迟因素）设置在可接受范围。</li><li>单独验证每个安全配置项的有效性。</li></ul><h2 id="XML外部实体-XML-External-Entities-XXE"><a class="header-anchor" href="#XML外部实体-XML-External-Entities-XXE">¶</a>XML外部实体 XML External Entities (XXE)</h2><p>Many older or poorly configured XML processors evaluate external entity references within XML documents. External entities can be used to disclose internal files using the file URI handler, internal file shares, internal port scanning, remote code execution, and denial of service attacks.<br>XML外部实体攻击是一种针对解析XML格式应用程序的攻击类型之一。此类攻击发生在当配置不当的XML解析器处理指向外部实体的文档时，可能会导致敏感文件泄露、拒绝服务攻击、服务器端请求伪造、端口扫描（解析器所在域）和其他系统影响。</p><h3 id="What-is-XML？"><a class="header-anchor" href="#What-is-XML？">¶</a>What is XML？</h3><p>XML由3个部分构成，它们分别是：文档类型定义（Document Type Definition，DTD），即XML的布局语言；可扩展的样式语言（Extensible Style Language，XSL），即XML的样式表语言；以及可扩展链接语言（Extensible Link Language，XLL）。</p><p>XML:可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。它被设计用来传输和存储数据(而不是储存数据),可扩展标记语言是一种很像超文本标记语言的标记语言。它的设计宗旨是传输数据，而不是显示数据。它的标签没有被预定义。您需要自行定义标签。它被设计为具有自我描述性。它是W3C的推荐标准。</p><p>可扩展标记语言(XML)和超文本标记语言(HTML)为不同的目的而设计</p><p>它被设计用来传输和存储数据，其<strong>焦点是数据的内容</strong>。</p><p>超文本标记语言被设计用来显示数据，其焦点是数据的外观</p><p>XML使用元素和属性来描述数据。在数据传送过程中，XML始终保留了诸如父/子关系这样的数据结构。几个应用程序 可以共享和解析同一个XML文件，不必使用传统的字符串解析或拆解过程。 相反，普通文件不对每个数据段做描述(除了在头文件中)，也不保留数据关系结构。使用XML做数据交换可以使应用程序更具有弹性，因为可以用位置(与普通文件一样)或用元素名(从数据库)来存取XML数据。</p><h3 id="XML的实体"><a class="header-anchor" href="#XML的实体">¶</a>XML的实体</h3><p>XML 中的实体分为以下五种：字符实体，命名实体，外部实体，参数实体，内部实体，普通实体和参数实体都分为内部实体和外部实体两种，外部实体定义需要加上** SYSTEM关键字**，其内容是URL所指向的外部文件实际的内容。如果不加SYSTEM关键字，则为内部实体，表示实体指代内容为字符串。</p><h3 id="Causes-v4"><a class="header-anchor" href="#Causes-v4">¶</a>Causes</h3><p>XXE注入，即XML External Entity，XML外部实体注入。通过 XML 实体，”SYSTEM”关键词导致 XML 解析器可以从本地文件或者远程 URI 中读取数据。所以攻击者可以通过 XML 实体传递自己构造的恶意值，是处理程序解析它。当引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。</p><p>既然XML可以从外部读取DTD文件，那我们就自然地想到了如果将路径换成另一个文件的路径，那么服务器在解析这个XML的时候就会把那个文件的内容赋值给SYSTEM前面的根元素中，只要我们在XML中让前面的根元素的内容显示出来，不就可以读取那个文件的内容了。这就造成了一个任意文件读取的漏洞。</p><p>那如果我们指向的是一个内网主机的端口呢？是否会给出错误信息，我们是不是可以从错误信息上来判断内网主机这个端口是否开放，这就造成了一个内部端口被探测的问题。另外，一般来说，服务器解析XML有两种方式，一种是一次性将整个XML加载进内存中，进行解析；另一种是一部分一部分的、“流式”地加载、解析。如果我们递归地调用XML定义，一次性调用巨量的定义，那么服务器的内存就会被消耗完，造成了拒绝服务攻击。</p><h3 id="Damage-v4"><a class="header-anchor" href="#Damage-v4">¶</a>Damage</h3><ul><li><p>检索文件，其中定义了包含文件内容的外部实体，并在应用程序的响应中返回。</p></li><li><p>执行SSRF攻击，其中外部实体是基于后端系统的URL定义的，如：</p></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY xxe SYSTEM "http://127.0.0.1:8080" &gt;探测端口；</span><br><span class="line"></span><br><span class="line"> &lt;!ENTITY xxe SYSTEM "expect://id" &gt;执行命令；</span><br></pre></td></tr></tbody></table></figure><ul><li><p>敏感文件泄露:无回显读取本地敏感文件(Blind OOB XXE)，敏感数据从应用服务器传输到攻击者的服务器上。</p></li><li><p>通过Blind XXE错误消息检索数据是否存在，攻击者可以触发包含敏感数据的解析错误消息。<br>具体的攻击手段和场景在案例中说明。</p></li><li><p>拒绝服务攻击</p></li><li><p>服务器端请求伪造</p></li><li><p>端口扫描（解析器所在域）</p></li></ul><h3 id="Defense-v4"><a class="header-anchor" href="#Defense-v4">¶</a>Defense</h3><p>开发人员培训是识别和减少XXE缺陷的关键，此外，防止XXE 缺陷还需要：</p><ul><li>尽可能使用简单的数据格式（如：JSON），避免对敏感数据进行序列化。</li><li>及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。同时，通过依赖项检测，将SOAP更新到1.2版本或更高版本。</li><li>参考《 OWASP Cheat Sheet ‘XXE Prevention‘ 》，在应用程序的所有XML解析器中禁用XML外部实体和DTD进程。</li><li>在服务器端实施积极的（“白名单”）输入验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据。</li><li>验证XML或XSL文件上传功能是否使用XSD验证或其他类似验证方法来验证上传的XML文件。</li><li>尽管在许多集成环境中，手动代码审查是大型、复杂应用程序的最佳选择，但是SAST 工具可以检测源代码中的XXE漏洞。</li><li>如果无法实现这些控制，请考虑使用虚拟修复程序、API安全网关或Web应用程序防火墙（ WAF ）来检测、监控和防止XXE攻击。</li></ul><h3 id="References-v3"><a class="header-anchor" href="#References-v3">¶</a>References</h3><p><a href="https://www.cnblogs.com/backlion/p/9302528.html">https://www.cnblogs.com/backlion/p/9302528.html</a></p><h2 id="失效的访问控制Broken-Access-Control"><a class="header-anchor" href="#失效的访问控制Broken-Access-Control">¶</a>失效的访问控制Broken Access Control</h2><p>Restrictions on what authenticated users are allowed to do are often not properly enforced. Attackers can exploit these flaws to access unauthorized functionality and/or data, such as access other users’ accounts, view sensitive files, modify other users’ data, change access rights, etc.</p><h3 id="Causes-v5"><a class="header-anchor" href="#Causes-v5">¶</a>Causes</h3><p>大多数Web页面需要验证功能级别的访问权限。但是，服务器需要在每个功能被访问时在服务器端执行相同的访问控制检查。如果请求没有被验证，攻击者能够伪造请求以在未经适当授权时访问某些页面。</p><h3 id="Damage-v5"><a class="header-anchor" href="#Damage-v5">¶</a>Damage</h3><ul><li>访问其他用户的账号</li><li>浏览敏感文件：文件包含/目录遍历<br>许多web应用使用文件管理作为它们日常操作的一部分。但他们使用没有被好好设计的输入验证方法，攻击者可以利用（这个漏洞）来修改或写入文件，甚至执行任意代码。</li><li>修改其他用户数据</li><li>改变访问权限、权限绕过（水平越权）<br>用户未经过身份验证访问资源，或注销后仍可访问资源，对不同用户访问的资源没有做很好的校验，如标准用户可访问管理员资源，或访问其他用户私有资源等。</li><li>权限提升（垂直越权）<br>权限提升是指用户权限从一个阶段提升到另一个阶段的问题，当用户访问的资源比通常情况下访问到的资源更多时，就发生了权限提示漏洞，应用程序应该阻止该权限提升或更改。权限提升一般是由于应用程序自身的缺陷引起的，最后导致程序执行的操作拥有比开发人员或系统管理员预期更多的权限。</li><li>不安全直接对象的引用<br>当应用程序根据用户提供的输入提供对对象的直接访问时，会发生不安全的直接对象引用。 攻击者可以直接绕过授权并访问系统中的资源，例如数据库记录或文件。</li></ul><p>由于应用程序获取用户提供的输入并使用它来检索对象而不执行足够的授权检查。不安全的直接对象引用允许攻击者通过修改用于直接指向对象的参数值来直接绕过授权和访问资源。这些资源可以是属于其他用户的数据库条目，系统中的文件等。</p><h3 id="Defense-v5"><a class="header-anchor" href="#Defense-v5">¶</a>Defense</h3><p>访问控制只有在受信服务器端代码或没有服务器的 API 中有效，这样这样攻击者才无法修改访问控制检查或元数据。</p><ul><li>除公有资源外，默认情况下拒绝访问。</li><li>使用一次性的访问控制机制，并在整个应用程序中不断重用它们，包括最小化CORS使用。</li><li>建立访问控制模型以强制执行所有权记录，而不是接受用户创建、读取、更新或删除的任何记录。</li><li>域访问控制对每个应用程序都是唯一的，但业务限制要求应由域模型强制执行。</li><li>禁用 Web服务器目录列表，并确保文件元数据（如：git）不存在于 Web的根目录中。</li><li>记录失败的访问控制，并在适当时向管理员告警（如：重复故障）。</li><li>对API和控制器的访问进行速率限制，以最大限度地降低自动化攻击工具的危害。</li><li>当用户注销后，服务器上的JWT令牌应失效。开发人员和 QA人员应包括功能访问控制单元和集成测试人员。</li><li>基于角色的访问控制（RBAC）<br>在基于角色的访问控制（RBAC）中，访问决策基于个人在组织或用户群中的角色和职责。<br>定义角色的过程通常基于分析组织的基本目标和结构，并且通常与安全策略相关联。例如，在医疗机构中，用户的不同角色可能包括医生，护士，服务员，护士，患者等等。显然，这些成员需要不同级别的访问才能执行其功能，但也需要根据安全政策和任何相关法规（HIPAA，Gramm-Leach-Bliley等）。<br>RBAC访问控制框架应该为Web应用程序安全管理员提供确定的“谁可以执行哪些操作，何时，从何处，以何种顺序以及在某些情况下在什么关系环境下“执行操作的能力。</li></ul><h2 id="安全配置错误Security-Misconfiguration"><a class="header-anchor" href="#安全配置错误Security-Misconfiguration">¶</a>安全配置错误Security Misconfiguration</h2><p>Security misconfiguration is the most commonly seen issue. This is commonly a result of insecure default configurations, incomplete or ad hoc configurations, open cloud storage, misconfigured HTTP headers, and verbose error messages containing sensitive information. Not only must all operating systems, frameworks, libraries, and applications be securely configured, but they must be patched/upgraded in a timely fashion.</p><h3 id="Causes-v6"><a class="header-anchor" href="#Causes-v6">¶</a>Causes</h3><ul><li>不安全的默认配置</li><li>不完整的或自组织配置</li><li>开放云存储</li><li>HTTP头的错误配置</li><li>包含敏感信息的冗余错误信息</li></ul><h3 id="Damage-v6"><a class="header-anchor" href="#Damage-v6">¶</a>Damage</h3><p>这些漏洞使攻击者能经常访问一些未授权的系统数据或功能。有时，这些漏洞导致系统的完全攻破。业务影响取决于应用程序和数据的保护需求。</p><h3 id="Defense-v6"><a class="header-anchor" href="#Defense-v6">¶</a>Defense</h3><p>应实施安全的安装过程，包括：</p><ul><li>一个可以快速且易于部署在另一个锁定环境的可重复的加固过程。开发、质量保证和生产环境都应该进行相同配置，并且，在每个环境中使用不同的密码。这个过程应该是自动化的，以尽量减少<br>安装一个新安全环境的耗费。</li><li>搭建最小化平台，该平台不包含任何不必要的功能、组件、文档和示例。移除或不安装不适用的功能和框架。</li><li>检查和修复安全配置项来适应最新的安全说明、更新和补丁，并将其作为更新管理过程的一部分，（参见A9：2017-使用含有已知漏洞的组件）。在检查过程中，应特别注意云存储权限（如：S3桶权限）。</li><li>一个能在组件和用户间提供有效的分离和安全性的分段应用程序架构，包括：分段、容器化和云安全组。</li><li>向客户端发送安全指令，如：安全标头。</li><li>在所有环境中能够进行正确安全配置和设置的自动化过程。</li></ul><h2 id="跨站脚本Cross-Site-Scripting（XSS）"><a class="header-anchor" href="#跨站脚本Cross-Site-Scripting（XSS）">¶</a>跨站脚本Cross-Site Scripting（XSS）</h2><p>XSS flaws occur whenever an application <strong>includes untrusted data in a new web page without proper validation or escaping</strong>, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. XSS allows attackers to execute scripts in the victim’s browser which can hijack（劫持） user sessions, deface web sites, or redirect the user to malicious sites.</p><h3 id="Causes-v7"><a class="header-anchor" href="#Causes-v7">¶</a>Causes</h3><p>在一个新网页中不带验证和绕过地包含不信任的数据，或者用用户提供的数据通过浏览器接口来更新已有网页（可以创建HTML或JS）</p><h3 id="Damage-v7"><a class="header-anchor" href="#Damage-v7">¶</a>Damage</h3><ul><li>劫持用户会话</li><li>毁坏网站</li><li>将用户重定向到恶意网站</li></ul><h3 id="Defense-v7"><a class="header-anchor" href="#Defense-v7">¶</a>Defense</h3><p>防止XSS需要将不可信数据与动态的浏览器内容区分开。这可以通过如下步骤实现：</p><ul><li>使用设计上就会自动编码来解决XSS问题的框架，如：Ruby 3.0或 React JS。了解每个框架的XSS保护的局限性，并适当地处理未覆盖的用例。</li><li>为了避免反射式或存储式的XSS漏洞，最好的办法是根据HTML输出的上下文（包括：主体、属性、JavaScript、CSS或URL）</li><li>对所有不可信的HTTP请求数据进行恰当的转义 。更多关于数据转义技术的信息见：《OWASP Cheat Sheet ‘XSS Prevention’》</li><li>在客户端修改浏览器文档时，为了避免DOM XSS攻击，最好的选择是实施上下文敏感数据编码。如果这种情况不能避免，可以采用《OWASP Cheat Sheet ‘DOM based XSS Prevention ‘》描述的类似上下文敏感的转义技术应用于浏览器API。</li><li>使用内容安全策略（CSP）是对抗XSS的深度防御策略。如果不存在可以通过本地文件放置恶意代码的其他漏洞（例如：路径遍历覆盖和允许在网络中传输的易受攻击的库），则该策略是有效的。</li></ul><h2 id="不安全的反序列化Insecure-Deserialization"><a class="header-anchor" href="#不安全的反序列化Insecure-Deserialization">¶</a>不安全的反序列化Insecure Deserialization</h2><p>Insecure deserialization often leads to remote code execution. Even if deserialization flaws do not result in remote code execution, they can be used to perform attacks, including replay attacks, injection attacks, and privilege escalation attacks.</p><h3 id="什么是序列化-反序列化？"><a class="header-anchor" href="#什么是序列化-反序列化？">¶</a>什么是序列化/反序列化？</h3><p>序列化（serialization）在计算机科学的资料处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">个人理解：</span><br><span class="line">序列化：对象到字节流；反序列化：字节流到对象</span><br></pre></td></tr></tbody></table></figure><h3 id="Causes-v8"><a class="header-anchor" href="#Causes-v8">¶</a>Causes</h3><p>PHP 的反序列化漏洞也叫PHP 对象注⼊，是⼀个⾮常常⻅的漏洞，这种漏洞充某些场景下虽然有些难以利⽤，但是⼀旦利⽤成功就会造成⾮常危险的后果。</p><p>漏洞形成的根本原因就是程序没有对⽤户输⼊的反序列化字符串进⾏检测，导致反序列化过程可以被恶意控制，进⽽造成代码执⾏、GetShell 等⼀系列不可控的后果。反序列化漏洞并不是PHP 特有的，也存在与Java、Python 语⾔中。其原理基本相同。在Java反序列化中，会调用被反序列化的readObject方法，当readObject方法书写不当时就会引发漏洞</p><h3 id="Damage-v8"><a class="header-anchor" href="#Damage-v8">¶</a>Damage</h3><ul><li>远程代码执行</li><li>重放攻击</li><li>注入攻击</li><li>提权攻击</li></ul><h3 id="Defense-v8"><a class="header-anchor" href="#Defense-v8">¶</a>Defense</h3><p>唯一安全的架构模式是不接受来自不受信源的序列化对象，或使用只允许原始数据类型的序列化媒体。<br>如果上述不可能的话，考虑使用下述方法：</p><ul><li>执行完整性检查，如：任何序列化对象的数字签名，以防止恶意对象创建或数据篡改。</li><li>在创建对象之前强制执行严格的类型约束，因为代码通常被期望成一组可定义的类。绕过这种技术的方法已经被证明，所以完全依赖于它是不可取的。</li><li>如果可能，隔离运行那些在低特权环境中反序列化的代码。</li><li>记录反序列化的例外情况和失败信息，如：传入的类型不是预期的类型，或者反序列处理引发的例外情况。</li><li>限制或监视来自于容器或服务器传入和传出的反序列化网络连接。</li><li>监控反序列化，当用户持续进行反序列化时，对用户进行警告。</li></ul><h2 id="使用含有已知漏洞的组件"><a class="header-anchor" href="#使用含有已知漏洞的组件">¶</a>使用含有已知漏洞的组件</h2><p>Using Components with Known Vulnerabilities<br>Using Components with Known Vulnerabilities<br>Using Components with Known Vulnerabilities<br>Using Components with Known Vulnerabilities</p><p>Components, such as libraries, frameworks, and other software modules, run with the same privileges as the application. If a vulnerable component is exploited, such an attack can facilitate serious data loss or server takeover. Applications and APIs using components with known vulnerabilities may undermine application defenses and enable various attacks and impacts.</p><h3 id="Causes-v9"><a class="header-anchor" href="#Causes-v9">¶</a>Causes</h3><p>用了含有漏洞的库、框架、软件模块等等</p><h3 id="Damage-v9"><a class="header-anchor" href="#Damage-v9">¶</a>Damage</h3><p>破坏应用程序的安全防护，让各种攻击得以执行</p><h3 id="Defense-v9"><a class="header-anchor" href="#Defense-v9">¶</a>Defense</h3><p>应该制定一个补丁管理流程：</p><ol><li>移除不使用的依赖、不需要的功能、组件、文件和文档。</li><li>利用如 versions、DependencyCheck 、retire.js等工具来持续的记录客户端和服务器端以及它们的依赖库的版本信息。持续监控如CVE 和 NVD等是否发布已使用组件的漏洞信息，可以使用软件分析工具来自动完成此功能。订阅关于使用组件安全漏洞的警告邮件。</li><li>仅从官方渠道安全的获取组件，并使用签名机制来降低组件被篡改或加入恶意漏洞的风险</li><li>监控那些不再维护或者不发布安全补丁的库和组件。如果不能打补丁，可以考虑部署虚拟补丁来监控、检测或保护。</li><li>每个组织都应该制定相应的计划，对整个软件生命周期进行监控、评审、升级或更改配置。</li></ol><h2 id="不足的日志记录和监控Insufficient-Logging-Monitoring"><a class="header-anchor" href="#不足的日志记录和监控Insufficient-Logging-Monitoring">¶</a>不足的日志记录和监控Insufficient Logging &amp; Monitoring</h2><p>Insufficient logging and monitoring, coupled with missing or ineffective integration with incident response, allows attackers to further attack systems, maintain persistence, pivot（以……为中心旋转） to more systems, and tamper, extract, or destroy data. Most breach studies show time to detect a breach is over 200 days, typically detected by external parties rather than internal processes or monitoring.</p><h3 id="Causes-v10"><a class="header-anchor" href="#Causes-v10">¶</a>Causes</h3><p>不足的日志和监控系统，缺失的或无效的事件相应</p><h3 id="Damage-v10"><a class="header-anchor" href="#Damage-v10">¶</a>Damage</h3><p>让攻击者可以更深入地攻击系统，毁坏数据</p><h3 id="Defense-v10"><a class="header-anchor" href="#Defense-v10">¶</a>Defense</h3><p>根据应用程序存储或处理的数据的风险：:</p><ul><li>确保所有登录、访问控制失败、输入验证失败能够被记录到日志中去，并保留足够的用户上下文信息，以识别可疑或恶意帐户，并为后期取证预留足够时间。</li><li>确保日志以一种能被集中日志管理解决方案使用的形式生成</li><li>确保高额交易有完整性控制的审计信息，以防止篡改或删除，例如审计信息保存在只能进行记录增加的数据库表中。</li><li>建立有效的监控和告警机制，使可疑活动在可接受的时间内被发现和应对。</li><li>建立或采取一个应急响应机制和恢复计划，例如：NIST 800-61 rev 2或更新版本。</li></ul><p>目前已有商业的和开源的应用程序防护框架（例如：OWASP AppSensor）、Web应用防火墙（例如 ：Modsecurity with the OWASP Core Rule Set）、带有自定义仪表盘和告警功能的日志关联软件。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web Vulnerabilities </tag>
            
            <tag> Flaw </tag>
            
            <tag> OWASP TOP 10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Software Security First Class</title>
      <link href="2020/09/14/Software-Security-First-Class/"/>
      <url>2020/09/14/Software-Security-First-Class/</url>
      
        <content type="html"><![CDATA[<h4>课外小说与视频</h4>零日<h4>调研报告</h4>暗网]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter1 网络安全引言</title>
      <link href="2020/09/14/Chapter1-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%BC%95%E8%A8%80/"/>
      <url>2020/09/14/Chapter1-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%BC%95%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-计算机安全概念"><a class="header-anchor" href="#1-1-计算机安全概念">¶</a>1.1 计算机安全概念</h2><h4 id="（1）计算机安全"><a class="header-anchor" href="#（1）计算机安全">¶</a>（1）计算机安全</h4><p><strong>用于保护数据安全和防范黑客的工具集合的通用名称</strong></p><p>为什么会出现计算机安全呢？<br>是因为引入了计算机，人们需要保护信息的自动工具了，而不是原始的物理保护（指保险箱hhh）</p><h4 id="（2）网络（互联网）安全"><a class="header-anchor" href="#（2）网络（互联网）安全">¶</a>（2）网络（互联网）安全</h4><p><strong>分布式系统的引入</strong>、网络以及在计算机终端用户与计算机之间、计算机与计算机之间进行通信的工具应用，其中都包含<strong>数据传输</strong>，需要网络安全措施来保护数据。<br><em>（其实更专业的术语叫互联网安全）</em></p><h3 id="1-1-1-计算机安全定义"><a class="header-anchor" href="#1-1-1-计算机安全定义">¶</a>1.1.1 计算机安全定义</h3><p>这是NIST对计算机安全的定义：</p><p>对某个自动化信息系统的保护措施，其目的在于实现信息系统资源的<strong>完整性</strong>、<strong>可用性</strong>以及<strong>机密性</strong>（包括硬件、软件、固件、信息/数据、电信）。</p><h5 id="（1）完整性"><a class="header-anchor" href="#（1）完整性">¶</a>（1）完整性</h5><ol><li>数据完整性：<strong>只能通过已授权的方式</strong>来更改数据</li><li>系统完整性：保证系统<strong>只做它被期待做的事</strong>，不会被奇怪的东西控制</li></ol><p>总结：有种感觉是完整性就是关于只能按照预期的什么什么……</p><h5 id="（2）机密性"><a class="header-anchor" href="#（2）机密性">¶</a>（2）机密性</h5><ol><li>数据机密性：隐私数据不泄漏给未授权的个体</li><li>隐私性：每个人可以控制自己的信息</li></ol><h5 id="（3）可用性"><a class="header-anchor" href="#（3）可用性">¶</a>（3）可用性</h5><p>服务不会拒绝已授权的用户</p><p>这三者取英文首字母组成CIA三元组。</p><p>从损失的角度，可以作如下描述：</p><ul><li>机密性：非授权的信息泄露</li><li>完整性：未经授权的信息修改和破坏</li><li>可用性：访问或使用的中断</li></ul><p>另外，也有人说可以加入真实性（信息是否来自可靠的信息源）、可计量性（能够追踪安全违规的责任方）的概念。</p><p>书P4-5有例子，说明了低、中、高三种级别的损失，以及具体实例下的数据机密性、完整性和可用性的具体内容。</p><h3 id="1-1-2-计算机安全挑战"><a class="header-anchor" href="#1-1-2-计算机安全挑战">¶</a>1.1.2 计算机安全挑战</h3><p>见书P5-6，说明了为什么计算机安全和网络安全复杂且多变。</p><h2 id="1-2-OSI安全体系结构"><a class="header-anchor" href="#1-2-OSI安全体系结构">¶</a>1.2 OSI安全体系结构</h2><p>OSI模型关注的包括以下三个方面：</p><ol><li>安全攻击</li><li>安全机制：检测、防范与恢复</li><li>安全服务：加强安全性，防范攻击</li></ol><p>关于威胁和攻击的辨析：个人觉得威胁是潜在危险，攻击是破坏手段</p><h2 id="1-3-安全攻击"><a class="header-anchor" href="#1-3-安全攻击">¶</a>1.3 安全攻击</h2><p>可以分为两大类：主动和被动攻击</p><ul><li>主动：试图改变系统资源或影响系统操作</li><li>被动：企图了解或利用系统信息<strong>但不影响系统资源</strong></li></ul><h3 id="1-3-1-被动攻击"><a class="header-anchor" href="#1-3-1-被动攻击">¶</a>1.3.1 被动攻击</h3><h4 id="（1）内容"><a class="header-anchor" href="#（1）内容">¶</a>（1）内容</h4><ul><li>本质：窃听或监视</li><li>目标：获取传输的数据信息</li><li>两种形式：消息内容泄露（传输的文件中包含机密信息）和流量分析攻击（观察交换信息的频率和长度来猜测相关通信性质）</li></ul><h4 id="（2）防范"><a class="header-anchor" href="#（2）防范">¶</a>（2）防范</h4><p>由于不改变数据，所以很难检测；一般都是防范为主（如加密），检测为次</p><h3 id="1-3-2-主动攻击"><a class="header-anchor" href="#1-3-2-主动攻击">¶</a>1.3.2 主动攻击</h3><h4 id="（1）内容-v2"><a class="header-anchor" href="#（1）内容-v2">¶</a>（1）内容</h4><ul><li>本质：数据流的改写、错误数据流的添加</li></ul><h4 id="（2）分类"><a class="header-anchor" href="#（2）分类">¶</a>（2）分类</h4><ol><li>假冒：比如可以让某个实体冒充别人后获得更多特权</li><li>重放：=被动捕获数据+主动重新传输</li><li>改写消息：合法消息被篡改——被延迟、重排、被改内容等等</li><li>拒绝服务：</li></ol><h4 id="（3）特点"><a class="header-anchor" href="#（3）特点">¶</a>（3）特点</h4><p>与被动攻击相反，主动攻击不好防范</p><h2 id="1-4-安全服务"><a class="header-anchor" href="#1-4-安全服务">¶</a>1.4 安全服务</h2><p>安全服务定义：</p><blockquote><p>对系统资源或通信的保护处理</p></blockquote><p>安全策略由安全服务实现，安全服务由安全机制实现</p><h3 id="1-4-1-认证"><a class="header-anchor" href="#1-4-1-认证">¶</a>1.4.1 认证</h3><h4 id="1-功能"><a class="header-anchor" href="#1-功能">¶</a>1. 功能</h4><ul><li>确保每个实体都是对方所要求连接的那一方</li><li>确保不会受非法第三方干扰（若被干扰，有可能实体被假冒）</li></ul><h4 id="2-两种特定认证服务"><a class="header-anchor" href="#2-两种特定认证服务">¶</a>2. 两种特定认证服务</h4><ul><li>对等实体认证：如TCP中</li><li>数据源认证：帮助确保数据来源</li></ul><h3 id="1-4-2-访问控制"><a class="header-anchor" href="#1-4-2-访问控制">¶</a>1.4.2 访问控制</h3><h4 id="1-功能-v2"><a class="header-anchor" href="#1-功能-v2">¶</a>1. 功能</h4><p>限制via通信链路访问主机系统和应用程序</p><p>那么问题来了，我们怎么知道限制哪些呢？<br>——可以基于认证，限制那些不该获得访问权限的实体</p><h3 id="1-4-3-数据机密性"><a class="header-anchor" href="#1-4-3-数据机密性">¶</a>1.4.3 数据机密性</h3><h4 id="1-功能-v3"><a class="header-anchor" href="#1-功能-v3">¶</a>1. 功能</h4><p>保护被传输的数据不遭受被动攻击（窃听+流量分析）</p><h4 id="2-两种服务层次"><a class="header-anchor" href="#2-两种服务层次">¶</a>2. 两种服务层次</h4><ul><li>广义：一定时期内两者传输的所有数据</li><li>狭义：对单个消息或者消息的某个字段</li></ul><h3 id="1-4-4-数据完整性"><a class="header-anchor" href="#1-4-4-数据完整性">¶</a>1.4.4 数据完整性</h3><h4 id="1-功能-v4"><a class="header-anchor" href="#1-功能-v4">¶</a>1. 功能</h4><p>保证数据收发一致，有的在检测到数据被篡改以后还会自动恢复</p><h3 id="1-4-5-不可抵赖性"><a class="header-anchor" href="#1-4-5-不可抵赖性">¶</a>1.4.5 不可抵赖性</h3><p>不能否认自己传输过某个消息</p><h3 id="1-4-6-可用性服务"><a class="header-anchor" href="#1-4-6-可用性服务">¶</a>1.4.6 可用性服务</h3><p>主要是为了解决DOS攻击引起的安全问题</p><h2 id="1-5-安全服务"><a class="header-anchor" href="#1-5-安全服务">¶</a>1.5 安全服务</h2><p>安全机制被分为两类：</p><ul><li>特定安全机制：可以合并到特定的协议层</li><li>普适安全机制：没有指定特定的协议层</li></ul><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201224232709.png" alt=""></p><p>安全服务与机制之间的关系：（竖着为服务）</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201224232854.png" alt=""></p><h2 id="1-6-网络安全模型"><a class="header-anchor" href="#1-6-网络安全模型">¶</a>1.6 网络安全模型</h2><p>首先咱们了解一个概念——逻辑信息通道：</p><blockquote><p>可由两个信息主体，src与dst之间的路由、使用的协议来确定</p></blockquote><h3 id="1-6-1-通用安全模型"><a class="header-anchor" href="#1-6-1-通用安全模型">¶</a>1.6.1 通用安全模型</h3><p>网络安全模型如下图：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201224233728.png" alt=""></p><p>注意上图圈圈处，显示着安全技术的主要两个部分：</p><ul><li>安全相关的转换：比如加密算法</li><li>秘密信息：比如加密密钥</li></ul><p>两者共同作用，将原始消息转换为秘密消息</p><p>对于图中的可信第三方，它一般承担如下任务：</p><ul><li>负责分发秘密信息，并对攻击者隐藏</li><li>仲裁两者之间的纷争</li></ul><p>设计安全服务要做到的四个基本任务：</p><ul><li>设计“安全相关的转换”算法</li><li>生成秘密信息</li><li>设计“分发和共享秘密信息”的方法</li><li>指定两者之间的协议</li></ul><h3 id="1-6-2-网络访问安全模型"><a class="header-anchor" href="#1-6-2-网络访问安全模型">¶</a>1.6.2 网络访问安全模型</h3><p>除了1.6.1中提到的通用模型，其他可以用网络访问安全模型来描述<br>这种模型是为了保护系统免遭有害访问所做，可用下图表示：</p><p><img src="https://raw.githubusercontent.com/Crestiny/BlogImgBed/main/img/20201225002542.png" alt=""></p><h4 id="1-两种有害访问"><a class="header-anchor" href="#1-两种有害访问">¶</a>1. 两种有害访问</h4><ul><li>入侵到通过网络能访问的系统</li><li>利用计算机系统逻辑上的弱点，能影响应用程序，这种情况下，程序面临两种威胁:<ul><li>信息访问威胁：没访问权限的用户<strong>干了不该干的事</strong></li><li>服务威胁：合法用户<strong>不能干该干的事</strong></li></ul></li></ul><h4 id="2-解决有害访问的安全机制"><a class="header-anchor" href="#2-解决有害访问的安全机制">¶</a>2. 解决有害访问的安全机制</h4><p>有两大范畴：</p><ul><li>看门人功能：用口令登录，拒绝未授权用户</li><li>屏蔽逻辑：检测蠕虫等攻击，并拒绝它们</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problems during Solving 2020CUMCM-A</title>
      <link href="2020/09/10/Problems-during-Solving-2020CUMCM-A/"/>
      <url>2020/09/10/Problems-during-Solving-2020CUMCM-A/</url>
      
        <content type="html"><![CDATA[<center><h1>待查问题</h1></center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">怎么根据相邻温区之间的温度求温区间隙和边缘的温度？</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">什么关系？怎么预测？</span><br></pre></td></tr></table></figure><center><h1>可参考网址</h1></center><p><a href="https://zh.wikipedia.org/wiki/%E7%86%B1%E5%82%B3%E5%B0%8E%E6%96%B9%E7%A8%8B%E5%BC%8F">热传导方程式简介</a><br><a href="https://www.youtube.com/watch?v=Zw53kxy7yL0">回流炉视频</a><br><a href="https://www.youtube.com/watch?v=xn_oN8ZMaMk">回流炉原理更清晰</a><br><a href="https://www.youtube.com/watch?v=NQiAcJxYfAs">回流炉视频2</a><br><a href="https://www.youtube.com/watch?v=q37g3RflFQ0">物体走过对应温度曲线变化</a><br><a href="https://www.youtube.com/watch?v=4pVUMda2prQ">物体走过对应温度曲线变化2-best oven setup</a><br><a href="https://blog.51cto.com/9269309/1865554">牛顿冷却定律</a><br><a href></a><br><a href></a><br><a href></a><br><a href></a></p><center><h1>名词解释</h1></center><h3>PCB</h3>印刷电路板，又称印制电路板，印刷线路板，常用英文缩写PCB（Printed circuit board）或PWB（Printed wire board），是电子元件的支撑体，在这其中有金属导体作为连接电子元器件的线路。<p>reflow oven</p><p>reflow profile</p><p>soldering  焊接</p><p>SMT<br>SMT贴片指的是在PCB基础上进行加工的系列工艺流程的简称，PCB（Printed Circuit Board)为印刷电路板。SMT是表面组装技术（表面贴装技术）（Surface Mounted Technology的缩写），是电子组装行业里最流行的一种技术和工艺。</p><p>非稳态导热</p><p>导热和热传导的区别<br>材料直接传导热量的能力称为热传导率,或称热导率.热导率定义为单位截面、长度的材料在单位温差下和单位时间内直接传导的热量.热导率的单位为瓦每米每开尔文((W/m.K)). 导热率:物体传导热量的能力,又称为热导率 . 所以,我感觉你提出这两个概念没有区别</p><h3>辨析几个概念</h3>这些公式的适用范围？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">牛顿冷却定律</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">傅里叶导热定律</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">热传导与导热</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">牛顿冷却定律</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">稳态导热</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">非稳态导热</span><br></pre></td></tr></table></figure><center><h1>或许可用的公式</h1></center><p>热传导方程</p><p>牛顿冷却定律</p><p>傅里叶定律</p><p>Crank − Nicholson 方法</p><center><h1>一些假设</h1></center>1. 只考虑热对流、热传导2. 是从炉前区域就开始的3. 假设是热风回流焊炉，热对流传热为主<center><h1>一些想法</h1></center>]]></content>
      
      
      <categories>
          
          <category> Contest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math Modelling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Database Trigger</title>
      <link href="2020/09/07/Database-Trigger/"/>
      <url>2020/09/07/Database-Trigger/</url>
      
        <content type="html"><![CDATA[<p>触发器类似于约束，但比约束更灵活</p><h3 id="定义触发器"><a class="header-anchor" href="#定义触发器">¶</a>定义触发器</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER &lt;触发器名&gt;</span><br><span class="line">  BEFORE|AFTER &lt;触发事件&gt; ON &lt;表名&gt;</span><br><span class="line">  FOR EACH ROW|STATEMENT</span><br><span class="line">  [WHEN &lt;触发条件&gt;]</span><br><span class="line">  &lt;触发动作体&gt;</span><br></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li>表的创建者才能建立触发器，而且一个表上不是无限个</li><li>触发事件：SQL语句动词，另外如UPDATE还可以加上 OF &lt;触发列，…&gt;</li><li>触发器类型：行级：有多少行做多少次；语句级：有多少相关语句做多少次</li><li>触发动作体：可以是AS + PL/SQL块</li></ul><h3 id="激活触发器"><a class="header-anchor" href="#激活触发器">¶</a>激活触发器</h3><p>搞清楚触发器的激活顺序（定义时间先后）</p><h3 id="删除触发器"><a class="header-anchor" href="#删除触发器">¶</a>删除触发器</h3><pre><code>DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Clauses for Database Security</title>
      <link href="2020/09/07/SQL-Clauses-for-Database-Security/"/>
      <url>2020/09/07/SQL-Clauses-for-Database-Security/</url>
      
        <content type="html"><![CDATA[<center><h1>对数据的操作权限</h1></center><h2>授权</h2>GRANT语句：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GRANT &lt;权限&gt; [,&lt;权限&gt;]...</span><br><span class="line">ON &lt;对象类型&gt; &lt;对象名&gt; [,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line">TO &lt;用户&gt; [,&lt;用户&gt;]...</span><br><span class="line">[WITH GRANT OPTION];</span><br><span class="line"></span><br><span class="line">参数解释：</span><br><span class="line">- 权限：SQL语句动词、如UPDATE(Sno)、特定ALL PRIVILEGES......</span><br><span class="line">- 对象：其实一般就是写TABLE table-name这样子，也有直接“视图名”的</span><br><span class="line">- 用户：如U1、特定的PUBLIC.......</span><br><span class="line">- 最后一个可选子句：加上代表获得此权限的用户同时也有给别人授予它的权利</span><br></pre></td></tr></table></figure><h2>回收权限</h2>REVOKE语句：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REVOKE &lt;权限&gt; [,&lt;权限&gt;]...</span><br><span class="line">ON &lt;对象类型&gt; &lt;对象名&gt; [,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line">FROM &lt;用户&gt; [,&lt;用户&gt;]...[CASCADE|RESTRICT];</span><br><span class="line"></span><br><span class="line">参数说明：最后可选的是级联收回或限制操作</span><br></pre></td></tr></table></figure><center><h1>关于数据库模式的权限</h1></center>在DBA创建用户时实现<p>创建用户语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &lt;user-name&gt;</span><br><span class="line">[WITH] [DBA|RESOURCE|CONNECT];</span><br><span class="line"></span><br><span class="line">参数说明：最后括号里的是三种权限，默认最后一个，它们对应的可执行操作见下表</span><br></pre></td></tr></table></figure><p><img src="/2020/09/07/SQL-Clauses-for-Database-Security/%5CSQL-Clauses-for-Database-Security%5Cquan.png" alt></p><center><h1>数据库角色</h1></center>很神奇的是，角色居然是权限的集合（而非用户的集合）可以为拥有相同权限的一组用户创建一个角色<h2>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE ROLE &lt;角色名&gt;；</span><br></pre></td></tr></table></figure><h2>授权</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT &lt;权限&gt; [,&lt;权限&gt;]...</span><br><span class="line">ON &lt;对象类型&gt; &lt;对象名&gt; [,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line">TO &lt;角色&gt; [,&lt;角色&gt;]...</span><br></pre></td></tr></table></figure><h2>用角色授权</h2>因为角色本质是权限，所以我们可以：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT &lt;角色1&gt; [,&lt;角色2&gt;]...</span><br><span class="line">TO &lt;角色3&gt; [,&lt;角色4&gt;]...</span><br><span class="line">[WITH GRANT OPTION]</span><br></pre></td></tr></table></figure><h2>收回角色权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REVOKE &lt;权限&gt; [,&lt;权限&gt;]...</span><br><span class="line">ON &lt;对象类型&gt; &lt;对象名&gt; [,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line">FROM &lt;角色1&gt; [,&lt;角色2&gt;]...;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Database Important&amp;Difficult Exercises Collection</title>
      <link href="2020/09/06/Database-Important-Difficult-Exercises-Collection/"/>
      <url>2020/09/06/Database-Important-Difficult-Exercises-Collection/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a class="header-anchor" href="#题目">¶</a>题目</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">证明：任何一个二目关系都是3NF的</span><br></pre></td></tr></tbody></table></figure><p>正确。因为关系模式中只有两个属性，所以无传递。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">证明：任何一个二目关系都是BCNF的</span><br></pre></td></tr></tbody></table></figure><p>正确。按BCNF的定义，若X-&gt;Y,且Y不是X的子集时，<strong>每个决定因素都包含码</strong>（如果不包含，那就有属性依赖于非码属性啦！就是存在传递依赖咯），对于二目关系决定因素必然包含码。详细证明如下：（任何二元关系模式必定是BCNF）。<br>证明：设R为一个二目关系R(A1，A2)，则属性A1和A2之间可能存在以下几种依赖关系：<br>A、A1-&gt;A2，但A2不-&gt;A1，则关系R的码为A1，决定因素都包含码，所以，R是BCNF。<br>B、A1不-&gt;A2，但A2-&gt;A1，则关系R的码为A2，所以决定因素都包含码，R是BCNF。<br>C、R的码为(A1，A2)（即A1-&gt;A2，A2-&gt;A1），决定因素都包含码，为BCNF</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">证明：任何一个二目关系都是4NF的</span><br></pre></td></tr></tbody></table></figure><p>正确。因为只有两个属性，所以无非平凡的多值依赖。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">判断：</span><br><span class="line">（1）若 R.B→R.A，R.C→R.A，则 R.(B, C)→R.A</span><br><span class="line">（2）若 R.(B, C)→R.A，则 R.B→R.A，R.C→R.A </span><br></pre></td></tr></tbody></table></figure><p>（1）正确，貌似还是可以反证的<br>（2）反例：关系模式 SC（S#，C#，G） 其中有（S#，C#）→G，但是S# 不→ G，C#不→G，也就是说少了一些决定因素就不行了</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">指出下列关系模式是第几范式？并说明理由。</span><br><span class="line">① R（X，Y，Z） F={XY→Z}</span><br><span class="line">② R（X，Y，Z） F={Y→Z，XZ→Y}</span><br><span class="line">③ R（X，Y，Z） F={Y→Z，Y→X，X→Y ， X→ Z}</span><br><span class="line">④ R（X，Y，Z） F={X→Y，X→Z}</span><br><span class="line">⑤ R（W，X，Y，Z） F={X→Z，WX→Y}</span><br><span class="line">``` </span><br><span class="line">（1）码：（X，Y），主属性：X，Y，非主属性：Z</span><br><span class="line">不存在非主对码的部分函数依赖——2NF</span><br><span class="line">不存在非主对码的传递函数依赖——3NF</span><br><span class="line">每个决定因素都包含码——BCNF</span><br><span class="line">除了平凡的、函数依赖的，没有其他多值依赖——4NF</span><br><span class="line">4NF</span><br><span class="line">（2）码：（X，Z），主属性：X，Z，非主属性：Y</span><br><span class="line">不存在非主对码的部分函数依赖——2NF</span><br><span class="line">不存在非主对码的传递函数依赖——3NF</span><br><span class="line">不是每个决定因素都包含码</span><br><span class="line">3NF</span><br><span class="line">（3）码：X，Y，主属性：X，Y，非主属性：Z</span><br><span class="line">不存在非主对码的部分函数依赖——2NF</span><br><span class="line">不存在非主对码的传递函数依赖——3NF</span><br><span class="line">每个决定因素都包含码——BCNF</span><br><span class="line">除了平凡的、函数依赖的，没有其他多值依赖——4NF</span><br><span class="line">4NF</span><br><span class="line">（4）码：X，主属性：X，非主属性：Y，Z</span><br><span class="line">不存在非主对码的部分函数依赖——2NF</span><br><span class="line">不存在非主对码的传递函数依赖——3NF</span><br><span class="line">每个决定因素都包含码——BCNF</span><br><span class="line">除了平凡的、函数依赖的，没有其他多值依赖——4NF</span><br><span class="line">4NF</span><br><span class="line">（5）码：（W，X），主属性：W，X，非主属性：Y，Z</span><br><span class="line">存在非主对码的部分函数依赖</span><br><span class="line">1NF</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>设有关系模式 R(U,F)，其中 U＝ABC，F＝｛A→B，B→C｝，求 F 的闭包 F＋</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">（注：K表示空集）</span><br><span class="line">（1）自反：</span><br><span class="line">k-&gt;K,</span><br><span class="line">A-&gt;K,B-&gt;K,C-&gt;K,</span><br><span class="line">A-&gt;A,B-&gt;B,C-&gt;C,</span><br><span class="line">AB-&gt;K,BC-&gt;K,AC-&gt;K,</span><br><span class="line">AB-&gt;A,AB-&gt;B,BC-&gt;B,BC-&gt;C,AC-&gt;A,AC-&gt;C,</span><br><span class="line">AB-&gt;AB,BC-&gt;BC,AC-&gt;AC,</span><br><span class="line">ABC-&gt;K,</span><br><span class="line">ABC-&gt;A,ABC-&gt;B,ABC-&gt;C,</span><br><span class="line">ABC-&gt;AB,ABC-&gt;BC,ABC-&gt;AC,</span><br><span class="line">ABC-&gt;ABC</span><br><span class="line">（2）增广：</span><br><span class="line">（对于A→B）：A→AB,AB→B,AC→BC</span><br><span class="line">（对于B→C）：AB→AC,B→BC,BC→C</span><br><span class="line">（对于A→C）：A→AC,AB→BC,AC→C</span><br><span class="line">（3）传递：</span><br><span class="line">A-&gt;C,AC-&gt;B,AB-&gt;C</span><br><span class="line"></span><br><span class="line">**如何不重不漏？**</span><br><span class="line">这好像是个NP问题啊....</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>对题 6 的关系模式R，求其候选键并判断A→C和B→A是否属于F＋。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">候选键：A</span><br><span class="line">传递律所以A→C属于</span><br><span class="line">B→A不属于</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>对于关系模式R(ABC)，F={A→BC,BC→A}，求其候选键。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">候选键：A，（B，C）</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>设有关系模式 R(U,F)，其中 U＝ABC，F＝｛A→{B,C},B→C, A→B, {A, B}→C｝，求 Fmin。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一步：分解右边得到F＝｛A→B,A→C,B→C,{A, B}→C｝</span><br><span class="line">第二步：</span><br><span class="line">对于A→B：A在G上的闭包为{A,C}，不含B，可以保留</span><br><span class="line">对于A→C：A在G上的闭包为{A,B,C},含C，不保留</span><br><span class="line">对于B→C：B在G上的闭包为{B},不含C，保留</span><br><span class="line">对于{A, B}→C：AB在G上的闭包为{A,B,C},含C，不保留</span><br><span class="line">F＝｛A→B,B→C｝</span><br><span class="line"></span><br><span class="line">## 一些小疑问</span><br></pre></td></tr></tbody></table></figure><p>定义SQL表时，各种数据类型怎么用？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="https://www.runoob.com/sql/sql-datatypes-general.html"&gt;是一个比较全面的整理&lt;/a&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>SQL语句和用户权限相关的那部分内容？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">见博客“SQL Clauses for Database Security”</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>SQL编程这块我感觉还有好多没见过的词？？？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其实那些是PL/SQL来的</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>数据字典和数据库的关系？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据字典实际上是“关于系统数据的数据库”</span><br><span class="line">感觉有点像**元数据**的意思</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>有些复杂的引理记不清楚</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>几种等价的表达：</p><ol><li>元组表达式</li><li>汉语查询句子</li><li>关系代数表达式（语言）</li><li>域演算表达式（语言）</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 集合</span><br><span class="line">2. 中文</span><br><span class="line">3. π、ρ</span><br><span class="line">4. 基于屏幕表格的查询语言</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>触发器</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">见博客“Database Trigger”</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>证明的规范写法</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>模式分解算法要背啊</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">背了！分成两组即可！</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>怎么从求一个函数依赖集在某属性集上的投影？怎么根据属性集求对应的函数依赖集（应该是一个意思）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">![](\Database-Important-Difficult-Exercises-Collection\p.png)</span><br><span class="line">说人话：</span><br><span class="line">假如我们要求F在U上的投影</span><br><span class="line">可以首先在F中剔掉那些左边X或右边Y不包含于U的函数依赖式，余下的应该就可以</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>复杂的查询用SQL有点绕不来</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">其实有时候，多层嵌套也可以用简单粗暴的自然连接连所有来代替，只是后者显然效率不好</span><br><span class="line">除法虽然还是不懂，但是背下来了！</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>几个连接</p><pre><code>笛卡尔积：简单粗暴的排列组合，一个X等值连接：下面有条件自然连接：下面没有条件## 一句话知识点1. 数据库系统中，数据独立性是指：应用程序与数据库的结构之间相互独立2. 关系数据库包含：内模式、模式、外模式三级模式；分别对应数据库的存储文件、基表、视图(外模式也就是：子模式/用户模式，是用户看到的数据视图)## 要背的知识点1. 数据库系统的特点（物理独立性、逻辑独立性）2. 数据库系统的三级结构模式3. 完整性约束条件4. DBMS主要功能5. 数据管理技术发展过程6. 视图和基表的区别7. SQL特点8. SQL四种语言（?DQMC）9. 数据库设计的基本步骤10. 数据库的维护方法11. 查询处理步骤12. 启发式规则13. 视图的优点## 要注意的名词解释## 要熟悉的算法1. 判别无损连接性2. 判别保持函数依赖性</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Database Programming</title>
      <link href="2020/09/06/Database-Programming/"/>
      <url>2020/09/06/Database-Programming/</url>
      
        <content type="html"><![CDATA[<h2 id="静态嵌入式SQL（ESQL）"><a class="header-anchor" href="#静态嵌入式SQL（ESQL）">¶</a>静态嵌入式SQL（ESQL）</h2><h3 id="ESQL的通用使用过程"><a class="header-anchor" href="#ESQL的通用使用过程">¶</a>ESQL的通用使用过程</h3><h3 id="基本结构"><a class="header-anchor" href="#基本结构">¶</a>基本结构</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL &lt;SQL语句&gt;;</span><br></pre></td></tr></tbody></table></figure><h3 id="ESQL和主语言的通信"><a class="header-anchor" href="#ESQL和主语言的通信">¶</a>ESQL和主语言的通信</h3><ol><li>传递SQL语句执行状态：SQL通信区（SQLCA）</li><li>主语言向SQL语句传参：主变量</li><li>SQL返回结果：主变量+游标</li></ol><h3 id="SQL通信区"><a class="header-anchor" href="#SQL通信区">¶</a>SQL通信区</h3><p>SQLCA中有一个SQLCODE变量<br>为SUCCESS代表执行成功，否则就是错误代码</p><p>定义SQLCA</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL INCLUDE SQLCA;</span><br></pre></td></tr></tbody></table></figure><h3 id="主变量"><a class="header-anchor" href="#主变量">¶</a>主变量</h3><p>SQL语句中用了主程序中的变量就叫做主变量<br>分为输入主变量（主程序输入到SQL）和输出主变量<br>主变量可以附带一个指示变量，对主变量的值加以说明（比如指示主变量是否为空值）</p><p>声明：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">声明主变量、指示变量/*变量的定义就和主程序变量一样*/</span><br><span class="line">char HSno[9];/*比如这样*/</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br></pre></td></tr></tbody></table></figure><p>使用：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:主/指示变量名/*前面加冒号！*/</span><br></pre></td></tr></tbody></table></figure><h3 id="游标"><a class="header-anchor" href="#游标">¶</a>游标</h3><p>游标可以看做一个数据缓冲区<br>SQL语句输出-&gt;游标-&gt;主变量-&gt;主程序</p><p>定义游标（为了一个SQL语句）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL DECLARE [cursor-name] CURSOR FOR</span><br><span class="line">&lt;SQL语句&gt;；</span><br></pre></td></tr></tbody></table></figure><p>打开和关闭游标：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL OPEN [cursor-name]；</span><br><span class="line"></span><br><span class="line">EXEC SQL CLOSE [cursor-name]；</span><br></pre></td></tr></tbody></table></figure><p>从游标中取数据到主变量：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ( ; ; ){</span><br><span class="line">EXEC SQL FETCH [cursor-name] INTO :主变量1, :主变量2, ......</span><br><span class="line">其他操作</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="建立和关闭数据库连接"><a class="header-anchor" href="#建立和关闭数据库连接">¶</a>建立和关闭数据库连接</h3><h4 id="建立连接"><a class="header-anchor" href="#建立连接">¶</a>建立连接</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL CONNECT TO target[AS connection-name][USER user-name]；</span><br><span class="line">参数解释：</span><br><span class="line">- target:要连接的数据库服务器，标识方法有几种</span><br><span class="line">如：&lt;dbname&gt;@&lt;hostname&gt;:&lt;port&gt;</span><br><span class="line">- connection-name：应该就是按标识符的命名规矩来</span><br><span class="line">- </span><br></pre></td></tr></tbody></table></figure><h4 id="修改连接"><a class="header-anchor" href="#修改连接">¶</a>修改连接</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL SET CONNECTION connection-name;</span><br></pre></td></tr></tbody></table></figure><h4 id="关闭连接"><a class="header-anchor" href="#关闭连接">¶</a>关闭连接</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL DISCONNECT [connection];/*这个方括号里的应该就用数据库的名字dbname*/</span><br></pre></td></tr></tbody></table></figure><h4 id="关闭连接前可以来个“提交数据库更新”"><a class="header-anchor" href="#关闭连接前可以来个“提交数据库更新”">¶</a>关闭连接前可以来个“提交数据库更新”</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL COMMIT WORK;</span><br></pre></td></tr></tbody></table></figure><h3 id="不用游标的ESQL"><a class="header-anchor" href="#不用游标的ESQL">¶</a>不用游标的ESQL</h3><h4 id="查询结果为单记录的SELECT语句"><a class="header-anchor" href="#查询结果为单记录的SELECT语句">¶</a>查询结果为单记录的SELECT语句</h4><p>单记录通俗点就是：查询结果只有一行<br>所以我们既不用循环，也不用游标，用一组主变量就可以了</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL SELECT x,x,x,x</span><br><span class="line"> INTO :主变量1, :主变量2; :主变量3, :主变量4</span><br><span class="line"> FROM </span><br><span class="line"> WHERE</span><br></pre></td></tr></tbody></table></figure><h4 id="增删改语句"><a class="header-anchor" href="#增删改语句">¶</a>增删改语句</h4><p>UPDATE/DELETE/INSERT INTO</p><p>关于指示变量：</p><h3 id="用游标的ESQL"><a class="header-anchor" href="#用游标的ESQL">¶</a>用游标的ESQL</h3><h4 id="查询结果为多条记录的SELECT语句"><a class="header-anchor" href="#查询结果为多条记录的SELECT语句">¶</a>查询结果为多条记录的SELECT语句</h4><p>说明游标、打开游标、循环读记录、关闭游标</p><h4 id="CURRENT形式的UPDATE和DELETE语句"><a class="header-anchor" href="#CURRENT形式的UPDATE和DELETE语句">¶</a>CURRENT形式的UPDATE和DELETE语句</h4><h4 id="补充：什么是CURRENT形式？"><a class="header-anchor" href="#补充：什么是CURRENT形式？">¶</a>补充：什么是CURRENT形式？</h4><h2 id="动态嵌入式SQL（ESQL）"><a class="header-anchor" href="#动态嵌入式SQL（ESQL）">¶</a>动态嵌入式SQL（ESQL）</h2><p>包括动态组装SQL语句和动态参数两种形式</p><h3 id="使用SQL语句主变量"><a class="header-anchor" href="#使用SQL语句主变量">¶</a>使用SQL语句主变量</h3><p>程序主变量：就是输入输出主变量那些<br>SQL语句主变量：内容是一句SQL语句</p><p>使用方法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">const char *stmt="SQL语句;";/*SQL语句主变量，注意有两个分号*/</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br><span class="line"></span><br><span class="line">EXEC SQL EXECUTE IMMEDIATE :stmt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="动态参数"><a class="header-anchor" href="#动态参数">¶</a>动态参数</h3><ul><li>第一步：声明SQL语句主变量</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">const char *stmt="SQL语句;";/*SQL语句主变量，注意这里面不确定的参数用？代表*/</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br></pre></td></tr></tbody></table></figure><ul><li>第二步：准备语句</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL PREPARE [语句名] FROM :[SQL语句主变量];</span><br></pre></td></tr></tbody></table></figure><ul><li>第三步：执行语句</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL EXECUTE [语句名] &lt;INTO 主变量表&gt;&lt;USING 主变量或常量&gt;;</span><br></pre></td></tr></tbody></table></figure><h2 id="存储过程"><a class="header-anchor" href="#存储过程">¶</a>存储过程</h2><p>PL/SQL语言：是SQL的过程化扩展，是编写数据库存储过程的一种过程语言</p><h3 id="PL-SQL的块结构"><a class="header-anchor" href="#PL-SQL的块结构">¶</a>PL/SQL的块结构</h3><p>PL/SQL程序的基本结构是块<br>分为匿名块和命名块<br>这里是匿名的，存储过程和函数是命名块</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*定义部分*/</span><br><span class="line">DECLARE</span><br><span class="line">变量、常量、游标、异常etc</span><br><span class="line"></span><br><span class="line">/*执行部分*/</span><br><span class="line">BEGIN</span><br><span class="line">语句</span><br><span class="line">EXCEPTION</span><br><span class="line">异常处理</span><br><span class="line">END;</span><br></pre></td></tr></tbody></table></figure><h3 id="变量常量的定义"><a class="header-anchor" href="#变量常量的定义">¶</a>变量常量的定义</h3><p><em>注：方括号内的内容表示可选</em><br>变量：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 数据类型 [[NOT NULL]:=初值表达式];</span><br></pre></td></tr></tbody></table></figure><p>常量：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常量名 数据类型 CONSTANT:=常量表达式;</span><br></pre></td></tr></tbody></table></figure><p>赋值：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名称:=表达式;</span><br></pre></td></tr></tbody></table></figure><h3 id="控制结构"><a class="header-anchor" href="#控制结构">¶</a>控制结构</h3><h4 id="条件控制语句"><a class="header-anchor" href="#条件控制语句">¶</a>条件控制语句</h4><p>第一种</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IF condition THEN</span><br><span class="line">语句;</span><br><span class="line">END IF</span><br></pre></td></tr></tbody></table></figure><p>第二种</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IF condition THEN</span><br><span class="line">语句;</span><br><span class="line">ELSE</span><br><span class="line">语句;</span><br><span class="line">END IF</span><br></pre></td></tr></tbody></table></figure><p>第三种:THEN和ELSE里面可以再嵌套IF语句</p><h4 id="循环控制语句"><a class="header-anchor" href="#循环控制语句">¶</a>循环控制语句</h4><p>第一种</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOOP</span><br><span class="line">语句；</span><br><span class="line">END LOOP;</span><br></pre></td></tr></tbody></table></figure><p>第二种</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE condition LOOP</span><br><span class="line">语句；</span><br><span class="line">END LOOP;</span><br></pre></td></tr></tbody></table></figure><p>第三种</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR count IN [REVERSE] bound1,...,bound2 LOOP</span><br><span class="line">语句；</span><br><span class="line">END LOOP;</span><br></pre></td></tr></tbody></table></figure><h3 id="存储过程-v2"><a class="header-anchor" href="#存储过程-v2">¶</a>存储过程</h3><h4 id="创建存储过程"><a class="header-anchor" href="#创建存储过程">¶</a>创建存储过程</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE Procedure 过程名([参数1 数据类型，参数2 数据类型，...])/*存储过程首部*/</span><br><span class="line">AS</span><br><span class="line">&lt;PL/SQL块&gt;;/*存储过程体*/</span><br></pre></td></tr></tbody></table></figure><h4 id="重命名存储过程"><a class="header-anchor" href="#重命名存储过程">¶</a>重命名存储过程</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER Procedure 旧过程名 RENAME TO 新过程名;</span><br></pre></td></tr></tbody></table></figure><h4 id="执行存储过程"><a class="header-anchor" href="#执行存储过程">¶</a>执行存储过程</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL/PERFORM Procedure 过程名([参数1，参数2，...]);</span><br></pre></td></tr></tbody></table></figure><h4 id="删除存储过程"><a class="header-anchor" href="#删除存储过程">¶</a>删除存储过程</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP Procedure 过程名();</span><br></pre></td></tr></tbody></table></figure><h3 id="游标-v2"><a class="header-anchor" href="#游标-v2">¶</a>游标</h3><p>PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标PL/SQL中也可以用游标</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to do E-R Design</title>
      <link href="2020/09/05/How-to-do-E-R-Design/"/>
      <url>2020/09/05/How-to-do-E-R-Design/</url>
      
        <content type="html"><![CDATA[<h2 id="区分实体和属性"><a class="header-anchor" href="#区分实体和属性">¶</a>区分实体和属性</h2><h3 id="什么能叫属性？"><a class="header-anchor" href="#什么能叫属性？">¶</a>什么能叫属性？</h3><p>两条准则：<br><img src="%5CHow-to-do-E-R-Design%5Catt.png" alt=""></p><p><img src="%5CHow-to-do-E-R-Design%5Cexample.png" alt=""></p><h3 id="数据库设计过程"><a class="header-anchor" href="#数据库设计过程">¶</a>数据库设计过程</h3><h4 id="从数据流图到E-R图（概念模型）"><a class="header-anchor" href="#从数据流图到E-R图（概念模型）">¶</a>从数据流图到E-R图（概念模型）</h4><ul><li><p>第一步：最开始我们有的是一个系统图，表示各个子系统之间的关系（子系统在这里也可以叫“局部应用”），例如这种：<br><img src="%5CHow-to-do-E-R-Design%5Csystem.png" alt=""></p></li><li><p>第二步：开一个循环（？）遍历所有子系统（局部应用），为每一个设计一个E-R图。</p></li><li><p>第三步：针对一个子系统我们怎么设计它的E-R图呢？</p><ol><li>首先从该子系统的数据流图找到设计E-R图的灵感<br><strong>第一层数据流图</strong>（整个子系统的）：<br><img src="%5CHow-to-do-E-R-Design%5Cfirst.png" alt=""><br><strong>第二层数据流图</strong>（再将这个子系统细分为几个）：这里分别是接受订单、处理订单、开发票、支付过账四个<br><img src="%5CHow-to-do-E-R-Design%5C1.png" alt=""><br><img src="%5CHow-to-do-E-R-Design%5C2.png" alt=""><br><img src="%5CHow-to-do-E-R-Design%5C3.png" alt=""><br><img src="%5CHow-to-do-E-R-Design%5C4.png" alt=""></li><li>根据这些数据流图，我们可以搭一个E-R图框架<br><img src="%5CHow-to-do-E-R-Design%5Cframe.png" alt=""></li><li>现在我们可以划分关系+定义属性了<br>说得明白点，其实一个关系的名字应该就对应一个实体型，关系里的属性就对应实体型的属性。得到这样的结果：<br><img src="%5CHow-to-do-E-R-Design%5Centity.png" alt=""></li><li>根据语义，确定实体型之间的关系（1：1/1:n/m:n）</li><li>最后就可以画E-R图啦！<br>完整版本应该是带属性的<br><img src="%5CHow-to-do-E-R-Design%5CER.png" alt=""></li></ol></li><li><p>第四步：当我们把每个子系统的E-R图设计好，就可以开始合并了！</p><ol><li>合并有两种方法，一种一步到位，另一种两两合并到最后（后一种方便些）——其实核心问题都集中在合并两个E-R图的时候怎么操作了</li><li>合并两个E-R图需要两步工作：<br>（1）解决E-R图之间的冲突+合并为初步E-R图</li></ol><blockquote><p>冲突类型及解决方法详见Mindmap</p></blockquote><p>（2）消除冗余+生成基本E-R图</p><blockquote><p>消除冗余见Mindmap</p></blockquote></li></ul><h4 id="例子"><a class="header-anchor" href="#例子">¶</a>例子</h4><p><a href="https://blog.csdn.net/csdn_blog_lcl/article/details/78609119">一个完整的E-R模型设计过程</a><br>有一说一……感觉这个比书上的好懂door了！！！</p><h4 id="从E-R图（概念模型）到关系模型（逻辑模型）"><a class="header-anchor" href="#从E-R图（概念模型）到关系模型（逻辑模型）">¶</a>从E-R图（概念模型）到关系模型（逻辑模型）</h4><p>对于实体型：一个实体型——一个关系模式，属性就是属性，码就是码</p><p>对于联系：<br>1:1的关系<br>（1）成为独立的关系模式：U=与联系相连的各实体的码+联系本身属性；候选码=各实体的码<br>（2）与任意一端合并：被合并的那个加入另一端的码和联系的属性</p><p>1:n关系：<br>（1）成为独立的关系模式：U=与联系相连的各实体的码+联系本身属性；候选码=n端实体的码<br>（2）与n端合并</p><p>m:n关系与多元联系：<br>（1）成为独立的关系模式：U=与联系相连的各实体的码+联系本身属性；各实体的码为关系的码的子集</p><p>注：相同码的关系模式可以合并</p><h3 id="E-R图设计的一些练习题"><a class="header-anchor" href="#E-R图设计的一些练习题">¶</a>E-R图设计的一些练习题</h3><p><a href="https://blog.csdn.net/zxq1138634642/article/details/9121363">一些练习题</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skills for Database Exercises</title>
      <link href="2020/09/04/Skills-for-Database-Exercises/"/>
      <url>2020/09/04/Skills-for-Database-Exercises/</url>
      
        <content type="html"><![CDATA[<center><h1>如何求最小函数依赖集</h1></center><h2>教科书式的定理</h2>![](\Skills-for-Database-Exercises\min.png)<h2>说人话</h2>- 第一步：看到函数依赖式右边有多个属性的，用分解规则拆开- 第二步：考察F中的每个函数依赖，对于其中一个，令一个新的函数依赖集G，这个G就是在F中把这个函数依赖去掉所形成的。接下来，对于这个函数依赖的左边X，考察它在G上的闭包是什么，如果这个闭包包含了函数依赖的右边Y，那么就从F中去掉这个函数依赖；反之保留- 第三步：对于F中每一个左端包含多个属性的函数依赖式，选择左边X的每个子集Z,如果右边Y属于Z的在F上的闭包,则用Z->Y代替X->Y<h2>练练手</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关系模式R(U，F)中，U&#x3D;ABCDEG，F&#x3D;&#123;B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B,ADG-&gt;BC&#125;，求F的最小函数依赖集</span><br></pre></td></tr></table></figure>- 第一步：用分解规则拆右边，得到新的F={B->D，DG->C,BD->E,AG->B,ADG->B,ADG->C}- 第二步：对于B->D，B在G中的闭包是{B},不包含D，所以可以保留对于DG->C，DG在G中的闭包是{D，G}，不包含C，所以可以保留对于BD->E，BD在G中的闭包是{B，D}，不包含E，所以可以保留对于AG->B，AG在G中的闭包是{A，G}，不包含B，所以可以保留对于ADG->B，ADG在G中的闭包是{A，D，G，B，C，E}，包含B，所以丢弃对于ADG->C，ADG在G中的闭包是{A，D，G，B，C，E}，包含C，所以丢弃*注：这里每一步考察完，到下一步时用的还是原来那个F，一次考察就是一次考察，不会动态变化的，不然就很奇怪了。*好，现在的F={B->D，DG->C,BD->E,AG->B}- 第三步：对于DG->C，D在F上的闭包是{D}，没啥替换的；G在F上的闭包是{G}，同样没啥对于BD->E，B在F上的闭包是{B，D，E}，包含E，可用B->E替换BD->E对于AG->B，A在F上的闭包是{A}....所以现在的F={B->D，DG->C,B->E,AG->B}<center><h1>如何求一个属性(组)在某函数依赖集上的闭包</h1></center><h2>教科书式的定理</h2>![](\Skills-for-Database-Exercises\algorithm.png)<h2>说人话</h2>通过一个多次迭代的方法求。![](\Skills-for-Database-Exercises\algorithm1.png)*注：改正一下，应该是“在F中找到一些函数依赖式——它们的左边应该是**包含于**X(i)的”*<center><h1>如何求某函数依赖集的闭包</h1></center>其实就是用那些公理、推理规则之类的开始造作！**如何不重不漏？**这好像是个NP问题啊....<center><h1>如何判断一个函数依赖FD是否属于某函数依赖集F的闭包</h1></center>用公理+推理规则，能推导出来就是属于<center><h1>如何设计E-R图并转换</h1></center><center><h1>如何写好SQL查询</h1></center><center><h1>如何判断关系所属范式</h1></center>我觉得在实际判断中，下面这些判断方法应该一个个往后用，就像过五关斩六将一样<h2>准备工作</h2>- 第一步：找出数据表中所有的候选码。首先考察包含一个属性的所有属性组，看它们能否唯一确定别的所有属性；接下来看包含两个属性的、三个的...以此类推*Tips:假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是候选码了（因为作为码的要求里有一个“完全函数依赖”）*- 第二步：根据第一步所得到的候选码，找出所有的主属性。也就是其中用到的所有属性（候选码的并集）- 第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。<h2>判断是否为2NF</h2>**在关系模式中若没有非主属性对码的部分函数依赖即可称为2NF**<pre>考虑关系模式R（A,B,C,D），已知函数依赖有{B->D,AB->C}，关系模式R的码是（    ），R属于（    ）范式首先找码 码是AB，然后又有D依赖于B，而B属于AB，所以存在D部分函数依赖于AB，所以不是第二范式</pre><h2>判断是否为3NF</h2>**在关系模式中若没有非主属性对码的传递函数依赖即可称为3NF**<h2>判断是否为BCNF</h2>**在关系模式中，如果每一个决定因素都包含码，则属于BCNF**<h2>判断是否为4NF</h2><center><h1>如何将关系规范化（各种模式分解算法）</h1></center><center><h1>SQL语句转查询树</h1></center>给个例子你就懂了，叶子应该是关系。原SQL语句：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname</span><br><span class="line">FROM Student，SC</span><br><span class="line">WHERE Student.Sno&#x3D;SC.Sno AND SC.Cno&#x3D;&#39;2&#39;;</span><br></pre></td></tr></table></figure>优化后：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Student.Sno in (</span><br><span class="line">SELECT Sno</span><br><span class="line">FROM SC</span><br><span class="line">WHERE SC.Cno&#x3D;&#39;2&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>![](\Skills-for-Database-Exercises\tree.png)]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Model Decomposition</title>
      <link href="2020/09/03/Model-Decomposition/"/>
      <url>2020/09/03/Model-Decomposition/</url>
      
        <content type="html"><![CDATA[<h2>关系的一个分解</h2>![](\Model-Decomposition\definition.png)说人话：分解以后的关系，它们的属性集合并起来应该和原关系的属性集相等，此外呢，分解出来的各子关系，它们的属性集之间不能有包含关系那么如何确定某个子关系上的函数依赖呢？在原关系函数依赖的闭包上找，要左右两边的属性合并起来在此子关系的属性集内就可以纳入这个子关系的函数依赖中~<h2>模式分解的三种等价形式</h2>![](\Model-Decomposition\3.png)<h3>什么是“无损连接性”？</h3>个人理解：要从分解后的子关系恢复到原关系，一般是通过自然连接来实现的；假如分解后再用自然连接得到的关系并非原关系，而是一个“元组增加了，信息丢失了”的关系，这种就是有损连接性的分解<h3>什么是“保持函数依赖”？</h3>个人理解：原关系的各种函数依赖，每个应该在某子关系中出现至少一次<h2>引理</h2><h3>记号定义</h3>![](\Model-Decomposition\ydefinition.png)<h3>相关性质</h3>![](\Model-Decomposition\p.png)<h2>无损连接性</h2><h3>定义</h3>![](\Model-Decomposition\wdefinition.png)<h3>判别算法</h3>![](\Model-Decomposition\algorithm.png)<h3>说人话</h3>- 第一步：画一张初始表，所有属性按列排开，分解的有几个关系就几行- 第二步：填初始数据，一行行看，在每个关系模式的U包含的属性列那里写上a(j)，否则写b(ij)- 第三步：遍历所有FD，对于每个，左边X所在的那些列里面，找出填了相同值的那些行；这些行里面，再去看右边Y对应的属性下标对应的列，看里面是否有a(li)这个元素，有的话，全部改为a(li)注：假如有b相关的值在上一句的操作里被改掉了，那这一列所有这个值都要被改- 第四步：知道有一行是a1，a2，a3.....，就说明是无损连接性的<h3>特殊地</h3>![](\Model-Decomposition\adefinition.png)<h3>说人话</h3>如果是分解成两个关系要判别是否无损连接性，写出“U1交U2->U1-U2(谁先谁后看情况)”，看看这个函数依赖是否在F的闭包内，在的话就……<h2>保持函数依赖</h2><h3>定义</h3>![](\Model-Decomposition\depend.png)根据这个定义，我们再加上判断两个函数依赖集是否相等就可以完整地作为一个“保持函数依赖”的判别算法了！即：（原F的闭包）要和（分解后F们的并集的闭包）相等<h2>模式分解的算法</h2><h3>关于模式分解结果的几种情况</h3>1. 如果保持了“无损连接性”，则分解后的关系一定是4NF的2. 如果保持了“保持函数依赖性”，则分解后的关系一定是3NF的，不一定能到BCNF3. 如果保持了“无损连接性”和“保持函数依赖性”，则分解后的关系一定是3NF的，不一定能到BCNF（？？？）<h3>“保持函数依赖性”+3NF&emsp;模式分解算法</h3><h4>教科书式定义</h4>![](\Model-Decomposition\a1.png)<h4>说人话</h4>- 第一步：极小化F- 第二步：在U中去掉F中不包含的属性*注：接下来讨论的都是处理后的F和U了！！！*- 第三步：假如F中有函数依赖能使左右两边合并起来恰好是U，那没事了，R不用作分解，算法终止；不是的话就转第四步- 第四步：把F按照相同左边X的规则分组成几个小的函数依赖集F'(i)，对应地有它的U(i)，再用U(i)在F上找到对应的F(i)，R就这样被分解了<h3>“保持函数依赖性”+“无损连接性”+3NF&emsp;模式分解算法</h3><h4>教科书式定义</h4>![](\Model-Decomposition\a2.png)<h4>说人话</h4>- 第一步：先做算法6.3，也就是先让分解后的模式“保持函数依赖性”。- 第二步：找到原关系R的码X，和它在F上的闭包，形成一个对应关系R(x)- 第三步：在先前得到的几个子关系R(i)中，寻找一下有没有对应的U(i)包含了X的，要是有，那么这个R(x)就不用加到分解出的子关系里面了，反之是需要的<h3>“无损连接性”+BCNF&emsp;模式分解算法</h3><h4>教科书式定义</h4>![](\Model-Decomposition\a3.png)<h4>说人话</h4><ul><li>第一步：初始的状态就是从原关系R开始，</li><li>第二步：检查一下当前分解中是不是每个关系都符合BCNF了，如果是，就可以终止了；如果不是，跳第三步</li><li>第三步：对于那些不符合BCNF的关系，我们找到某个函数依赖——它的左边X并非此关系的码。我们把这个函数依赖的左右两边合并，这是一个属性集；然后在此关系属性集里面剔除“此函数依赖的右边Y”就形成另一个属性集。有了分解后的两个属性集，根据它们生成对应的F就好啦。这样就把这个关系分解好了。跳第二步</li></ul><h3>“无损连接性”+4NF&emsp;模式分解算法</h3><h4>教科书式定义</h4>![](\Model-Decomposition\a4.png)<h4>说人话</h4>- 第一步：用算法6.5做到“无损连接性”+BCNF- 第二步：考察分解中那些不符合4NF的关系，用定理6.6的方法分解- 第三步：分解中的每个子关系都属于4NF即可终止<h4>补充：什么是传说中的定理6.6呢？</h4>![](\Model-Decomposition\d1.png)这个定理的意思就是，既然这个关系不符合4NF吧，那就是有非平凡非函数依赖的多值依赖，也就是X-->Y。有了它我们把关系分成（X,Y）和（X,Z），有点奇怪的是，为什么关系可以这样表示啊？<h2>完整版数据依赖的公理系统</h2><h3>8条公理</h3>![](\Model-Decomposition\g1.png)<h3>4条推理规则</h3>![](\Model-Decomposition\g2.png)]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/09/02/Axiom-System-of-Data-Dependency/"/>
      <url>2020/09/02/Axiom-System-of-Data-Dependency/</url>
      
        <content type="html"><![CDATA[<p>—title: Axiom System of Data Dependencydate: 2020-09-02 14:33:49tags:- Databasecategories:- Courses—## Armstrong公理系统### 什么是逻辑蕴含？<img src="%5CAxiom-System-of-Data-Dependency%5Clogical.png" alt=""><br><br>### 如何确定一个函数依赖是否为F所蕴含？<img src="%5CAxiom-System-of-Data-Dependency%5CArmstrong.png" alt=""><em>注：XZ表示X并Z</em>对于Armstrong公理的简要说明：1. 自反律：其实这个和F无关，我们只要有一个大集合X和它的子集Y，就会有X-&gt;Y2. 增广率：需要推出XZ-&gt;YZ，也就是证明，如果有两个元组在XZ上的值相等，那么在YZ上的值也会相等；对于前半句：这个条件就给出两个元组在X上值相等，且在Z上值相等；根据X-&gt;Y，它们在Y上的值相等，和Z的一合并，就推出了这两个元组在YZ上的值也会相等3. 传递率：你懂的顺带导出了3条推理规则：1. 合并规则：X-&gt;Y与X-&gt;Z可得X-&gt;YZ2. 伪传递规则：X-&gt;Y与WY-&gt;Z可得XW-&gt;Z3. 分解规则：X-&gt;Y与Z包含于Y可得X-&gt;Z还顺带有个小引理：就是X-&gt;ABCDEF…与右边的分开写，是互为充要条件的<br><br>### 关于闭包函数依赖集F的闭包：是指运用Armstrong公理系统推导出来的所有F可蕴含的函数依赖，结果形式应该是一个函数依赖组成的集合属性集X关于函数依赖集F的闭包：有个推导算法可以用，结果形式应该是一个属性组成的集合算法如下：<img src="%5CAxiom-System-of-Data-Dependency%5Calgorithm.png" alt="">### 极小函数依赖集#### 定义<img src="%5CAxiom-System-of-Data-Dependency%5Cdefinition.png" alt=""><em>注：两个函数依赖集等价，就是函数依赖集的闭包相等</em>#### 化简为极小函数依赖集（亦为判定）<img src="%5CAxiom-System-of-Data-Dependency%5Cmin.png" alt=""><br><br><br><br><br></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Without Faith</title>
      <link href="2020/08/27/Without-Faith/"/>
      <url>2020/08/27/Without-Faith/</url>
      
        <content type="html"><![CDATA[<p>我的孤独像一座花园<br>里面只有没有灵魂的美</p><p>我希望<br>自己能像<br>夜晚梦到白日那样<br>充满信念</p><p>在话语里有野火<br>灵魂憔悴不堪<br>头颅在黑暗中沉默</p>]]></content>
      
      
      <categories>
          
          <category> Insights on Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Faith </tag>
            
            <tag> Life </tag>
            
            <tag> Emotion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hard-to-Understand Concepts in Database</title>
      <link href="2020/08/26/Hard-to-Understand-Concepts-in-Database/"/>
      <url>2020/08/26/Hard-to-Understand-Concepts-in-Database/</url>
      
        <content type="html"><![CDATA[<h2 id="About-Keys"><a class="header-anchor" href="#About-Keys">¶</a>About Keys</h2><p>  码、主码、候选码的关系:<br><img src="https://img-blog.csdnimg.cn/20190625173457198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bWFsaXFpbmdodWE=,size_16,color_FFFFFF,t_70" alt=""></p><p>貌似码=超键<br><a href="https://blog.csdn.net/sumaliqinghua/article/details/85872446">一篇不错的博客</a><br>全码：整个属性组是码</p><h2 id="About-Dependencies"><a class="header-anchor" href="#About-Dependencies">¶</a>About Dependencies</h2><h3 id="完全函数依赖"><a class="header-anchor" href="#完全函数依赖">¶</a>完全函数依赖</h3><p>  设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。<br>  <em>举个例子</em>：通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB.</p><h3 id="部分函数依赖"><a class="header-anchor" href="#部分函数依赖">¶</a>部分函数依赖</h3><p>  设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。<br>  <em>举个例子</em>：通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。</p><h3 id="传递函数依赖"><a class="header-anchor" href="#传递函数依赖">¶</a>传递函数依赖</h3><p>  传递函数依赖：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。<br>  <em>举个例子</em>：通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么成C传递依赖于A</p><h3 id="多值依赖"><a class="header-anchor" href="#多值依赖">¶</a>多值依赖</h3><p>设R(U)是一个属性集合U上的一个关系模式，X, Y, 和Z是U的子集，并且Z=U-X-Y，多值依赖X-&gt;-&gt;Y成立当且仅当对R的任一个关系r，r在(X,Z)上的每个值对应一组Y的值，这组值仅仅决定于X值而与Z值无关。<br>注：我突然觉得，这个与Z值无关，貌似不是什么很特别的言论。其实吧，我的理解就是，有一个X，有一个Y，一个X值对应多个Y值。（啊不过！Z的有无还是会决定这个多值依赖是非平凡/平凡的！）</p><p>若X-&gt;-&gt;Y，而Z=空集，则称X-&gt;-&gt;Y为平凡的多值依赖。否则，称X-&gt;-&gt;Y为非平凡的多值依赖。</p><p>平凡多值依赖就是，属性集合中分为两个真子集，每一个X对应一组Y的取值<br><img src="%5CHard-to-Understand-Concepts-in-Database%5Cpingdepend.png" alt=""><br>**<br>可以看出，如果把上面的一组改为一个，那么多值依赖就变成了函数依赖。当然一个值组成的组也是组，所以说，函数依赖是多值依赖的特殊情况。<br>（首先函数依赖和多值依赖的X、Y应该都可以是属性组吧，函数依赖是一个x值决定一个y值，多值依赖是一个x值决定多个y值）**<br><img src="%5CHard-to-Understand-Concepts-in-Database%5Cdepen.png" alt=""></p><h4 id="多值依赖的性质"><a class="header-anchor" href="#多值依赖的性质">¶</a>多值依赖的性质</h4><p><img src="%5CHard-to-Understand-Concepts-in-Database%5Cmdependp.png" alt=""></p><h4 id="多值依赖与函数依赖区别"><a class="header-anchor" href="#多值依赖与函数依赖区别">¶</a>多值依赖与函数依赖区别</h4><p><img src="%5CHard-to-Understand-Concepts-in-Database%5Cdifference1.png" alt=""></p><h3 id="连接依赖"><a class="header-anchor" href="#连接依赖">¶</a>连接依赖</h3><h3 id="函数依赖图"><a class="header-anchor" href="#函数依赖图">¶</a>函数依赖图</h3><p>看了这个你就懂怎么操作了<br><img src="%5CHard-to-Understand-Concepts-in-Database%5Cfdepend.png" alt=""><br>还有涉及到部分函数依赖时，可以用虚线表示<br><img src="%5CHard-to-Understand-Concepts-in-Database%5Cpdepend.png" alt=""><br>多值依赖<br><img src="%5CHard-to-Understand-Concepts-in-Database%5Cmdepend.png" alt=""></p><h2 id="零散小知识"><a class="header-anchor" href="#零散小知识">¶</a>零散小知识</h2><h3 id="二目关系"><a class="header-anchor" href="#二目关系">¶</a>二目关系</h3><p>其实<strong>目</strong>或者说<strong>度</strong>，就是一个关系中有多少个属性而已…<br>所以二目关系就是有两列的那种啦</p><h3 id="数据流图"><a class="header-anchor" href="#数据流图">¶</a>数据流图</h3><p>数据流程图（DFD）是一种能全面地描述信息系统逻辑模型的主要工具，它可以用少数几种符号综合地反映出信息在系统中的流动、处理和存储情况。数据流程图是表示<strong>操作或数据的方向</strong>。<br><img src="%5CHard-to-Understand-Concepts-in-Database%5CDFD.png" alt=""><br>数据流图有四种基本图形符号：</p><ul><li>箭头：表示数据流；</li><li>圆或椭圆：表示加工；</li><li>双杠：表示数据存储；</li><li>方框：表示数据的源点或终点。</li></ul><h3 id="决定因素"><a class="header-anchor" href="#决定因素">¶</a>决定因素</h3><p>貌似说的就是一个函数依赖的左边</p><h3 id="函数依赖集的覆盖"><a class="header-anchor" href="#函数依赖集的覆盖">¶</a>函数依赖集的覆盖</h3><p>F的最小覆盖其实就是它的极小函数依赖集</p><h3 id="表达查询的一堆语句形式"><a class="header-anchor" href="#表达查询的一堆语句形式">¶</a>表达查询的一堆语句形式</h3><h4 id="关系代数表达式"><a class="header-anchor" href="#关系代数表达式">¶</a>关系代数表达式</h4><p>应该就是π、ρ那些吧</p><h4 id="元组关系演算表达式"><a class="header-anchor" href="#元组关系演算表达式">¶</a>元组关系演算表达式</h4><p>就是那些集合的形式</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Understanding Paradigm in Database Design</title>
      <link href="2020/08/26/Understanding-Paradigm-in-Database-Design/"/>
      <url>2020/08/26/Understanding-Paradigm-in-Database-Design/</url>
      
        <content type="html"><![CDATA[<center><h1>1NF</h1></center>&emsp;&emsp;1NF的定义为：符合1NF的关系中的每个属性都不可再分，要求属性具有**原子性**，不可再分解;<p>  不符合的关系：<br><img src="https://pic4.zhimg.com/80/24afd11455ac34a280fa83e4e8d75ccc_1440w.jpg?source=1940ef5c" alt><br>  符合的关系：<br><img src="https://pic3.zhimg.com/80/6b735fb9503b0930e741faa474fed28e_1440w.jpg?source=1940ef5c" alt></p><center><h1>2NF</h1></center>2NF是对记录的**惟一性**，要求记录有惟一标识，即实体的惟一性，即不存在部分依赖；2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖，简而言之，第二范式就是非主属性完全依赖于主关键字。<h3>如何确定一个关系是否为2NF</h3>- 第一步：找出数据表中所有的候选码。首先考察包含一个属性的所有属性组，看它们能否唯一确定别的属性；接下来看包含两个属性的、三个的...以此类推*Tips:假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是候选码了（因为作为码的要求里有一个“完全函数依赖”）*- 第二步：根据第一步所得到的候选码，找出所有的主属性。也就是其中用到的所有属性（候选码的并集）- 第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。- 第四步：查看是否存在非主属性对码的部分函数依赖。![](\Understanding-Paradigm-in-Database-Design\2NF.png)<h3>如何把一个关系改造成2NF</h3>投影分解，把存在部分依赖的地方拆开<center><h1>3NF</h1></center>3NF是对字段的**冗余性**，它要求字段没有冗余，即不存在传递依赖；要求任何字段不能由其他字段派生出来每个**非主属性**都不传递依赖于R的候选键**简而言之，第三范式就是属性不依赖于其它非主属性。**> 表: 学号, 姓名, 年龄, 学院名称, 学院电话<h3>如何把一个关系改造成3NF</h3>投影分解，把存在传递依赖的地方拆开<center><h1>BCNF</h1></center>在 3NF 的基础上消除主属性对于码的部分与传递函数依赖（是修正的/扩充的第三范式），就是属性不依赖于其它非主属性（不能存在关键字段决定关键字段的情况）每个**属性**都不传递依赖于R的候选键一个满足BCNF的关系模式：- 所有非主属性对每一个码都是完全函数依赖（满足2NF）- 所有的主属性对每一个不包含它的码，是完全函数依赖（让主属性对码不存在部分函数依赖）- 没有任何属性完全函数依赖于非码的任何一组属性（主属性和非主属性都不能完全依赖于非码的任何一组属性，因为这样就存在属性对码的传递函数依赖）<p><em>Tips:全码的关系一定属于BCNF</em></p><center><h1>4NF</h1></center>![](Understanding-Paradigm-in-Database-Design\2.png)<center><h1>To put it Simple</h1></center>1、第一范式（1NF）：一个关系模式R的所有属性都是不可分的基本数据项。2、第二范式（2NF）：满足第一范式，然后消除部分依赖。（消除-非主-部分）3、第三范式（3NF）： 满足第二范式，消除传递依赖。（消除-非主-传递）4、BC范式（BCNF）：满足第三范式（消除-主与非主-部分与传递）5、第四范式（4NF）：满足BC范式，在多值依赖中，去掉了属于函数依赖的，也去掉了非平凡的（消除-非平凡与非函数依赖-多值依赖）![](https://img-blog.csdn.net/20170508213333607?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRG92ZV9Lbm93bGVkZ2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)<center><h1>规范化过程</h1></center>![](Understanding-Paradigm-in-Database-Design\1.png)<center><h1>可参考资料</h1></center><a href="https://zhuanlan.zhihu.com/p/20028672">有讲解有习题的讲范式的博客</a>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Understanding &#39;division&#39; and Its Implementation in SQL</title>
      <link href="2020/08/24/Understanding-division-and-Its-Implementation-in-SQL/"/>
      <url>2020/08/24/Understanding-division-and-Its-Implementation-in-SQL/</url>
      
        <content type="html"><![CDATA[<center><h1>What does Division really do</h1></center><h2>Process</h2>2. The result of Division of R/S, contains columns which are in R but not in S. (In other words, R's columns except which also in S.)3. Define T=R/S and T's columns is C.4. For each c in C, find their “象集” in R.5. Find S's projection on its common columns with R.6. If c's “象集” includes the result in 5, then add it to T.<h2>Example</h2>1. <br>![](https://img-blog.csdn.net/20161221185506785)2. 在R关系中A属性的值可以取{ a1，a2，a3，a4 }a1值对应的象集为 {  (b1,c2)  , (b2,c1) ,  (b2,c3)  }a2值对应的象集为 {  (b3,c7)  , (b2,c3) }a3值对应的象集为 {  (b4,c6)  }a4值对应的象集为 {  (b6,c6)  }3. 关系S在B、C上的投影为 {  (b1,c2)  , (b2,c1) ,  (b2,c3)  }4. 只有a1值对应的象集包含关系S的投影集，所以只有a1应该包含在A属性中5. R/S=<table><thead><tr><th>A</th></tr></thead><tbody><tr><td>a1</td></tr></tbody></table><center><h1>Implementation in SQL</h1></center><h2>How to do</h2>1. R(X，Y)÷S(Y，Z)的运算用结构化语言SQL 语句可表达为下列形式:2.  ![](/Understanding-division-and-Its-Implementation-in-SQL/division.png)3. 用双重`not exists`来实现，- 第一层：选出R表中，Y属性上的值和S中有相等的那些元组- 第二层：从S中排除这些元组，余下的都是在Y上S有但R没有的Y值- 第三层：<p><em>补充</em>：什么是not exists？<br>  exists，强调的是是否有返回集，不需知道具体返回的是什么,只要exists引导的子句有结果集返回，这个条件就算成立。</p>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summary for =Learn SQL= //Codecademy</title>
      <link href="2020/08/23/Summary-for-Learn-SQL-Codecademy/"/>
      <url>2020/08/23/Summary-for-Learn-SQL-Codecademy/</url>
      
        <content type="html"><![CDATA[<center><h1>Manipulation</h1></center>We’ve learned six commands commonly used to manage data stored in a relational database and how to set constraints on such data. What can we generalize so far?<ul><li>SQL is a programming language designed to manipulate and manage data stored in relational databases.</li><li>A relational database is a database that organizes information into one or more tables.</li><li>A table is a collection of data organized into rows and columns.</li><li>A statement is a string of characters that the database recognizes as a valid command.</li></ul><p>creates a new table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name(</span><br><span class="line">attribute1 type constraint,</span><br><span class="line">attribute1 type constraint</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>constraint:</p><ol><li><p><code>PRIMARY KEY</code> columns can be used to uniquely identify the row. Attempts to insert a row with an identical value to a row already in the table will result in a constraint violation which will not allow you to insert the new row.</p></li><li><p><code>UNIQUE</code> columns have a different value for every row. This is similar to PRIMARY KEY except a table can have many different UNIQUE columns.</p></li><li><p><code>NOT NULL</code> columns must have a value. Attempts to insert a row without a value for a NOT NULL column will result in a constraint violation and the new row will not be inserted.</p></li><li><p><code>DEFAULT</code> columns take an additional argument that will be the assumed value for an inserted row if the new row does not specify a value for that column.</p></li><li><p>关于外码（主码也可放最后）</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Orders</span><br><span class="line">(</span><br><span class="line">O_Id int NOT NULL,</span><br><span class="line">OrderNo int NOT NULL,</span><br><span class="line">P_Id int,</span><br><span class="line">PRIMARY KEY (O_Id),</span><br><span class="line">FOREIGN KEY (P_Id) REFERENCES Persons(P_Id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="6"><li>关于自定义约束</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">P_Id int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">CHECK (P_Id&gt;0)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;*可以给约束命名*&#x2F;</span><br><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">P_Id int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City&#x3D;&#39;Sandnes&#39;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注：如果建表时忘记加了，之后加也是可以的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City&#x3D;&#39;Sandnes&#39;)</span><br></pre></td></tr></table></figure><p>adds a new row to a table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name(a1,a2,a3) </span><br><span class="line">VALUES(v1,v2,v3);</span><br></pre></td></tr></table></figure><p>queries data from a table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT attributes</span><br><span class="line">FROM table_name </span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><p>changes an existing table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">ADD COLUMN c1_name type; </span><br></pre></td></tr></table></figure><p>edits a row in a table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line">SET .....</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><p>deletes rows from a table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><h1><center>Queries</center></h1><p><code>AS</code> is a keyword in SQL that allows you to rename a column or table using an alias. The new name can be anything you want as long as you put it inside of single quotes.</p><p>Some important things to note:</p><ul><li>Although it’s not always necessary, it’s best practice to surround your aliases with single quotes.</li><li>When using <code>AS</code>, the columns are not being renamed in the table. The aliases only appear in the result.</li><li><code>SELECT</code> is the clause we use every time we want to query information from a database.</li><li><code>AS</code> renames a column or table.</li><li><code>DISTINCT</code> return unique values.</li><li><code>WHERE</code> is a popular command that lets you filter the results of the query based on conditions that you specify.</li><li><code>LIKE</code> and <code>BETWEEN</code> are special operators.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIKE:</span><br><span class="line">The _ means you can substitute any individual character here without breaking the pattern.(一个对一个字符，汉字的话要用两个空空)</span><br><span class="line">% is a wildcard character that matches zero or more missing letters in the pattern. </span><br></pre></td></tr></table></figure><ul><li><code>AND</code> and <code>OR</code> combines multiple conditions.</li><li><code>ORDER BY</code> sorts the result.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认asc，降序是desc</span><br></pre></td></tr></table></figure><ul><li><code>LIMIT</code> specifies the maximum number of rows that the query will return.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT 数字 &#x2F;*数字就是最后显示的结果有多少行*&#x2F;</span><br></pre></td></tr></table></figure><ul><li><code>CASE</code> creates different outputs.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT name,</span><br><span class="line"> CASE</span><br><span class="line">  WHEN imdb_rating &gt; 8 THEN &#39;Fantastic&#39;</span><br><span class="line">  WHEN imdb_rating &gt; 6 THEN &#39;Poorly Received&#39;</span><br><span class="line">  ELSE &#39;Avoid at All Costs&#39;</span><br><span class="line"> END AS &#39;Review&#39;%表示新增的这一列的命名，没有貌似也可</span><br><span class="line">FROM movies;</span><br></pre></td></tr></table></figure><h1><center>Aggregate Functions</center></h1><ul><li><code>COUNT()</code>: count the number of rows</li><li><code>SUM()</code>: the sum of the values in a column</li><li><code>MAX()/MIN()</code>: the largest/smallest value</li><li><code>AVG()</code>: the average of the values in a column</li><li><code>ROUND()</code>: round the values in the column</li></ul><p>Aggregate functions combine multiple rows together to form a single value of more meaningful information.</p><ul><li><code>GROUP BY</code> is a clause used with aggregate functions to combine data from one or more columns.</li><li><code>HAVING</code> limit the results of a query based on an aggregate property.</li></ul><p>关于SQL语句的执行顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(1) from </span><br><span class="line">(3) join </span><br><span class="line">(2) on </span><br><span class="line">(4) where </span><br><span class="line">(5) group by(开始使用select中的别名，后面的语句中都可以使用)</span><br><span class="line">(6) avg,sum.... </span><br><span class="line">(7) having </span><br><span class="line">(8) select </span><br><span class="line">(9) distinct </span><br><span class="line">(10) order by</span><br><span class="line">(11) limit </span><br></pre></td></tr></table></figure><p>从这个顺序中我们不难发现，所有的查询语句都是从from开始执行的，在执行过程中，每个步骤都会为下一个步骤<strong>生成一个虚拟表</strong>，这个虚拟表将作为下一个执行步骤的输入。<br>第一步：首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 vt1（选择相对小的表做基础表）</p><p>第二步：接下来便是应用on筛选器，on 中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足on逻辑表达式的行，生成虚拟表 vt2</p><p>第三步：如果是outer join 那么这一步就将添加外部行，left outer jion 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 vt3</p><p>第四步：如果 from 子句中的表数目多余两个表，那么就将vt3和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3。</p><p>第五步：应用where筛选器，对上一步生产的虚拟表引用where筛选器，生成虚拟表vt4，在这有个比较重要的细节不得不说一下，对于包含outer join子句的查询，就有一个让人感到困惑的问题，到底在on筛选器还是用where筛选器指定逻辑表达式呢？on和where的最大区别在于，如果在on应用逻辑表达式那么在第三步outer join中还可以把移除的行再次添加回来，而where的移除的最终的。举个简单的例子，有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名=成绩.姓名）那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了,但是我们用left outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生，如果在on中应用学生.班级='x’的话，left outer join会把x班级的所有学生记录找回（感谢网友康钦谋__康钦苗的指正），所以只能在where筛选器中应用学生.班级=‘x’ 因为它的过滤是最终的。</p><p>第六步：group by 子句将中的唯一的值组合成为一组，得到虚拟表vt5。如果应用了group by，那么后面的所有步骤都只能得到的vt5的列或者是聚合函数（count、sum、avg等）。原因在于最终的结果集中只为每个组包含一行。这一点请牢记。</p><p>第七步：应用cube或者rollup选项，为vt5生成超组，生成vt6.</p><p>第八步：应用having筛选器，生成vt7。having筛选器是第一个也是为唯一一个应用到已分组数据的筛选器。</p><p>第九步：处理select子句。将vt7中的在select中出现的列筛选出来。生成vt8.</p><p>第十步：应用distinct子句，vt8中移除相同的行，生成vt9。事实上如果应用了group by子句那么distinct是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。</p><p>第十一步：应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表。sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定order by，最后，在这一步中是第一个也是唯一一个可以使用select列表中别名的步骤。</p><p>第十二步：应用top选项。此时才返回结果给请求者即用户。</p><h1><center>Multiple Tables</center></h1><p>Why is this important? The most common types of joins will be joining a foreign key from one table with the primary key from another table. For instance, when we join orders and customers, we join on customer_id, which is a foreign key in orders and the primary key in customers.</p><p>SQL has strict rules for appending data:<br>Tables must have the same number of columns.<br>The columns must have the same data types in the same order as the first table.</p><ul><li><p><code>JOIN</code> will combine rows from different tables if the join condition is true.</p></li><li><p><code>LEFT JOIN</code> will return every row in the left table, and if the join condition is not met, NULL values are used to fill in the columns from the right table.</p></li><li><p>Primary key is a column that serves a unique identifier for the rows in the table.</p></li><li><p>Foreign key is a column that contains the primary key to another table.</p></li><li><p><code>CROSS JOIN</code> lets us combine all rows of one table with all rows of another table.</p></li><li><p><code>UNION</code> stacks one dataset on top of another.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM table1</span><br><span class="line">UNION</span><br><span class="line">SELECT *</span><br><span class="line">FROM table2;</span><br></pre></td></tr></table></figure><ul><li><code>WITH</code> allows us to define one or more temporary tables that can be used in the final query.</li></ul><p>关于SQL语句的写法顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">WITH [临时表名] AS(</span><br><span class="line">&#x2F;*一段查询*&#x2F;</span><br><span class="line">)</span><br><span class="line">SELECT [列名称 *代表所有的列]</span><br><span class="line">CASE</span><br><span class="line">  WHEN [条件] THEN [对应的新属性上的值]</span><br><span class="line">  WHEN [条件] THEN [对应的新属性上的值]</span><br><span class="line">  ......</span><br><span class="line">  ELSE [对应的新属性上的值]</span><br><span class="line"> END AS [新属性名字]%表示新增的这一列的命名，没有貌似也可</span><br><span class="line">FROM [表名称]</span><br><span class="line">join_type JOIN [表名称]</span><br><span class="line">ON [join条件]</span><br><span class="line">WHERE [过滤条件]</span><br><span class="line">GROUP BY [分组字段]&#x2F;*可用select中的“列号”代表，就是直接写数字*&#x2F;</span><br><span class="line">HAVING [分组条件]</span><br><span class="line">ORDER BY [排序字段] [ASC&#x2F;DESC]</span><br><span class="line">LIMIT [输出组数]</span><br></pre></td></tr></table></figure><h1><center>小感想</center></h1><p>这门小小的SQL语句课程就结束了，虽然内容十分少，但是用SQL语句解决实际需求时，还是需要很好的逻辑和语句熟练度的！<br>过几天就要考试了，加油吧小可可！</p>]]></content>
      
      
      <categories>
          
          <category> Codecademy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summary for =Learn JavaScript= //Codecademy</title>
      <link href="2020/08/23/Summary-for-Learn-JavaScript-Codecademy/"/>
      <url>2020/08/23/Summary-for-Learn-JavaScript-Codecademy/</url>
      
        <content type="html"><![CDATA[<center><h1>Introduction</h1></center><h2>Introduction to JavaScript</h2>- Data is printed, or logged, to the console, a panel that displays messages, with `console.log()`.- We can write single-line comments with `//` and multi-line comments between `/*` and `*/`.- There are 7 fundamental data types in JavaScript: strings, numbers, booleans, null, undefined, symbol, and object.- Numbers are any number without quotes: 23.8879- Strings are characters wrapped in single or double quotes: 'Sample String'- The built-in arithmetic operators include `+`, `-`, `*`, `/`, and `%`.- Objects, including instances of data types, can have properties, stored information. The properties are denoted with a . after the name of the object, for example: `'Hello'.length`.- Objects, including instances of data types, can have methods which perform actions. Methods are called by appending the object or instance with a period, the method name, and parentheses. For example: `'hello'.toUpperCase()`.- We can access properties and methods by using the ., dot operator.- Built-in objects, including Math, are collections of **methods and properties** that JavaScript provides.<h2>Variables</h2>- Variables hold reusable data in a program and associate it with a name.- Variables are stored in memory.- The `var` keyword is used in *pre-ES6* versions of JS.- `let` is the preferred way to declare a variable when it can be **reassigned**, and `const` is the preferred way to declare a variable with a **constant** value.- Variables that have not been initialized store the primitive data type **undefined**.- Mathematical assignment operators make it easy to calculate a new value and assign it to the same variable.- The `+` operator is used to concatenate strings including string values held in variables- In ES6, template literals use `backticks` and `${}` to interpolate values into a string.- The `typeof` keyword returns the data type (as a string) of a value.<center><h1>Conditions</h1></center><h2>Conditional Statements</h2>- An `if` statement checks a condition and will execute a task if that condition evaluates to true.- `if...else` statements make binary decisions and execute different code blocks based on a provided condition.- We can add more conditions using `else if` statements.- Comparison operators, including `<`, `>`, `<=`, `>=`, `===`, and `!==` can compare two values.&emsp;*P.S. Mention that we use `===` rather than `==` in JS.*  - The logical and operator, `&&`, or “`and`”, checks if both provided expressions are truthy.- The logical operator `||`, or “`or`”, checks if either provided expression is truthy.- The bang operator, `!`, switches the truthiness and falsiness of a value.- The **ternary** operator is shorthand to simplify concise `if...else` statements.- A `switch` statement can be used to simplify the process of writing multiple else if statements. The **break** keyword stops the remaining cases from being checked and executed in a switch statement.<center><h1>Functions</h1></center><h2>Functions</h2></=`,></`,>]]></content>
      
      
      <categories>
          
          <category> Codecademy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summmary for =Learn CSS= //Codecademy</title>
      <link href="2020/08/22/Summmary-for-Learn-CSS-Codecademy/"/>
      <url>2020/08/22/Summmary-for-Learn-CSS-Codecademy/</url>
      
        <content type="html"><![CDATA[<h1>Selectors and Visual Rules</h1><h2> CSS Setup and Selectors </h2>- CSS can change the look of HTML elements. In order to do this, CSS must select HTML elements, then apply styles to them.- CSS can select HTML elements by **tag**, **class**, **or ID**.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   tag: p</span><br><span class="line">class: .</span><br><span class="line">ID: #</span><br></pre></td></tr></table></figure>- Multiple CSS classes can be applied to one HTML element.- Classes can be reusable, while IDs can only be used once.- IDs are more specific than classes, and classes are more specific than tags. That means IDs will override any styles from a class, and classes will override any styles from a tag selector.- Multiple selectors can be **chained** together to select an element. This raises the specificity, but can be necessary.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h5.description</span><br></pre></td></tr></table></figure>- Nested elements can be selected by separating selectors with a space.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.class li</span><br></pre></td></tr></table></figure>- Multiple unrelated selectors can receive the same styles by separating the selector names with **commas**.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p,</span><br><span class="line">h5</span><br></pre></td></tr></table></figure><h2>CSS Visual Rules</h2>I've learned concepts including:<ul><li>CSS declarations are structured into property and value pairs.</li><li>The <code>font-family</code> property defines the typeface of an element.</li><li><code>font-size</code> controls the size of text displayed.</li><li><code>font-weight</code> defines how thin or thick text is displayed.</li><li>The <code>text-align</code> property places text in the left, right, or center of its parent container.</li><li>Text can have two different color attributes: <code>color</code> and <code>background-color</code>. color defines the color of the text, while background-color defines the color behind the text.</li><li>CSS can make an element transparent with the <code>opacity</code> property.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opacity: 0.75;</span><br><span class="line">&#x2F;&#x2F;From 0 to 1, 0 means invisible;</span><br></pre></td></tr></table></figure><ul><li>CSS can also set the background of an element to an image with the <code>background-image</code> property.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image:url(&quot;http:&#x2F;&#x2F;....&quot;);</span><br></pre></td></tr></table></figure><ul><li>The <code>!important</code> flag will override any style, however it should almost never be used, as it is extremely difficult to override.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color: #FFF !important;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Codecademy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summary for =Learn HTML= //Codecademy</title>
      <link href="2020/08/21/A-Summary-for-Learn-HTML-Codecademy/"/>
      <url>2020/08/21/A-Summary-for-Learn-HTML-Codecademy/</url>
      
        <content type="html"><![CDATA[<h1>Learn HTML</h1><h1>Elements and Structure</h1><h2 id="1-Introduction-to-HTML"><a class="header-anchor" href="#1-Introduction-to-HTML">¶</a>1. Introduction to HTML</h2><h3 id="1-1-Summary"><a class="header-anchor" href="#1-1-Summary">¶</a>1.1 Summary</h3><ul><li>HTML stands for <strong>HyperText Markup Language</strong> and is used to create the structure and content of a webpage.</li><li>Most HTML elements contain opening and closing tags with raw text or other HTML tags between them.</li><li>HTML elements can be nested inside other elements. The enclosed element is <strong>the child of</strong> the enclosing parent element.</li><li>Any visible content should be placed within the opening and closing  tags.</li><li>Headings and sub-headings, <code>## </code> to <code>&lt;h6&gt;</code> tags, are used to enlarge text.</li><li><code>&lt;p&gt;</code>, <code>&lt;span&gt;</code> and <code>&lt;div&gt;</code> tags specify text or blocks.</li><li>The <code>&lt;em&gt;</code> and <code>&lt;strong&gt;</code> tags are used to emphasize text.</li><li>Line breaks are created with the <code>&lt;br&gt;</code> tag.</li><li>Ordered lists (<code>&lt;ol&gt;</code>) are numbered and unordered lists (<code>&lt;ul&gt;</code>) are bulleted.</li><li>Images (<code>&lt;img&gt;</code>) and videos (<code>&lt;video&gt;</code>) can be added by linking to an existing source.</li></ul><aside>*P.S. `<img>` is a single tag.*</aside><h2 id="2-HTML-Document-Standards"><a class="header-anchor" href="#2-HTML-Document-Standards">¶</a>2. HTML Document Standards</h2><h3 id="2-1-Summary"><a class="header-anchor" href="#2-1-Summary">¶</a>2.1 Summary</h3><p><em>HTML Tags</em><br> While some tags have a very specific purpose, such as image and video tags, most tags are used to describe the content that they surround, which helps us modify and style our content later. There are seemingly infinite numbers of tags to use (many more than we’ve taught). Knowing when to use each one is based on how you want to describe the content of your HTML. Descriptive, well-chosen tags are one key to high-quality web development. A full list of available HTML tags can be found in Mozilla documentation.</p><ul><li>The <code>&lt;!DOCTYPE html&gt;</code> declaration should always be the first line of code in your HTML files. This lets the browser know what version of HTML to expect.</li><li>The <code>&lt;html&gt;</code> element will contain all of your HTML code.</li><li>Information about the web page, like the title, belongs within the <code>&lt;head&gt;</code> of the page.</li><li>You can add a title to your web page by using the <code>&lt;title&gt;</code> element, inside of the head.A webpage’s title appears in a browser’s tab.</li><li>Anchor tags (<code>&lt;a&gt;</code>) are used to link to internal pages, external pages or content on the same page.You can create sections on a webpage and jump to them using <code>&lt;a&gt;</code> tags and adding ids to the elements you wish to jump to.</li><li>Whitespace between HTML elements helps make code easier to read while not changing how elements appear in the browser.Indentation also helps make code easier to read. It makes parent-child relationships visible.</li><li>Comments are written in HTML using the following syntax: <code>&lt;!-- comment --&gt;</code>.<br></li></ul><h4 id="2-2-Demo"><a class="header-anchor" href="#2-2-Demo">¶</a>2.2 Demo</h4><pre>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;Brown Bears&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;nav&gt;    &lt;a href="./index.html"&gt;Brown Bear&lt;/a&gt;    &lt;a href="./aboutme.html"&gt;About Me&lt;/a&gt;  &lt;/nav&gt;  &lt;h1&gt;The Brown Bear&lt;/h1&gt;  &lt;nav&gt;    &lt;ul&gt;      &lt;li&gt;&lt;a href="#introduction"&gt;Introduction&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href="#habitat"&gt;Habitat&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href="#media"&gt;Media&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;  &lt;/nav&gt;  &lt;div id="introduction"&gt;    &lt;h2&gt;About Brown Bears&lt;/h2&gt;    &lt;p&gt;The brown bear (&lt;em&gt;Ursus arctos&lt;/em&gt;) is native to parts of northern Eurasia and North America. Its conservation status is currently &lt;strong&gt;Least Concern&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt; There are many subspecies within the brown bear species, including the      Atlas bear and the Himalayan brown bear.&lt;/p&gt;    &lt;a href="https://en.wikipedia.org/wiki/Brown_bear" target="_blank"&gt;Learn More&lt;/a&gt;    &lt;h3&gt;Species&lt;/h3&gt;    &lt;ul&gt;      &lt;li&gt;Arctos&lt;/li&gt;      &lt;li&gt;Collarus&lt;/li&gt;      &lt;li&gt;Horribilis&lt;/li&gt;      &lt;li&gt;Nelsoni (extinct)&lt;/li&gt;    &lt;/ul&gt;    &lt;h3&gt;Features&lt;/h3&gt;    &lt;p&gt;Brown bears are not always completely brown. Some can be reddish or yellowish. They have very large, curved claws and huge paws. Male brown bears are often 30% larger than female brown bears. They can range from 5 feet to 9 feet from head to toe.&lt;/p&gt;  &lt;/div&gt;  &lt;div id="habitat"&gt;    &lt;h2&gt;Habitat&lt;/h2&gt;    &lt;h3&gt;Countries with Large Brown Bear Populations&lt;/h3&gt;    &lt;ol&gt;      &lt;li&gt;Russia&lt;/li&gt;      &lt;li&gt;United States&lt;/li&gt;      &lt;li&gt;Canada&lt;/li&gt;    &lt;/ol&gt;    &lt;h3&gt;Countries with Small Brown Bear Populations&lt;/h3&gt;    &lt;p&gt;Some countries with smaller brown bear populations include Armenia, Belarus, Bulgaria, China, Finland, France, Greece, India, Japan, Nepal, Poland, Romania, Slovenia, Turkmenistan, and Uzbekistan.&lt;/p&gt;  &lt;/div&gt;  &lt;div id="media"&gt;    &lt;h2&gt;Media&lt;/h2&gt;    &lt;img src="https://s3.amazonaws.com/codecademy-content/courses/web-101/web101-image_brownbear.jpg" /&gt;    &lt;video src="https://s3.amazonaws.com/codecademy-content/courses/freelance-1/unit-1/lesson-2/htmlcss1-vid_brown-bear.mp4" height="240" width="320" controls&gt;Video not supported&lt;/video&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</pre><p> Let’ see what it looks like in a browser:<br><img src="%5CA-Summary-for-Learn-HTML-Codecademy%5Cwebsite1.png" alt=""><br><img src="%5CA-Summary-for-Learn-HTML-Codecademy%5Cwebsite2.png" alt=""></p><h2 id="2-Tables"><a class="header-anchor" href="#2-Tables">¶</a>2. Tables</h2><h3 id="2-1-Summary-v2"><a class="header-anchor" href="#2-1-Summary-v2">¶</a>2.1  Summary</h3><p> In this lesson, we learned how to create a table, add data to it, and section the table into smaller parts that make it easier to read.</p><ul><li>The <code>&lt;table&gt;</code> element creates a table.</li><li>The <code>&lt;tr&gt;</code> element adds rows to a table.</li><li>To add data to a row, you can use the <code>&lt;td&gt;</code> element.</li><li>Table headings clarify the meaning of data. Headings are added with the <code>&lt;th&gt;</code> element.</li><li>Table data can span columns using the colspan attribute; Table data can span rows using the rowspan attribute.</li><li>Tables can be split into three main sections: a head, a body, and a footer.<br>  A table’s head is created with the <code>&lt;thead&gt;</code> element.<br>  A table’s body is created with the <code>&lt;tbody&gt;</code> element.<br>  A table’s footer is created with the <code>&lt;tfoot&gt;</code> element.</li><li>All the CSS properties you learned about in this course can be applied to tables and their data.</li></ul><h3 id="2-2-Demo-v2"><a class="header-anchor" href="#2-2-Demo-v2">¶</a>2.2 Demo</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;thead&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;th&gt;Company Name&lt;/th&gt;</span><br><span class="line">    &lt;th&gt;Number of Items to Ship&lt;/th&gt;</span><br><span class="line">    &lt;th&gt;Next Action&lt;/th&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;/thead&gt;</span><br><span class="line">  &lt;tbody&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td colspan="2"&gt;Adam’s Greenworks&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;14&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Package Items&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Davie's Burgers&lt;/td&gt;</span><br><span class="line">    &lt;td rowspan="2"&gt;2&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Send Invoice&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Baker's Bike Shop&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;3&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Send Invoice&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Miss Sally's Southern&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;4&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Ship&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Summit Resort Rentals&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;4&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Ship&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Strike Fitness&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;1&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Enter Order&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tfoot&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;td&gt;Total&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;28&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">  &lt;/tfoot&gt;</span><br><span class="line">  &lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></tbody></table></figure><p>This is what it looks like:<br><img src="%5CA-Summary-for-Learn-HTML-Codecademy%5Ctable.png" alt=""><br><br></p><h2 id="To-be-continued…"><a class="header-anchor" href="#To-be-continued…">¶</a>To be continued…</h2><hr><h2 id="0x03-Forms"><a class="header-anchor" href="#0x03-Forms">¶</a>0x03 Forms</h2><h2 id="0x04-Semantic-HTML"><a class="header-anchor" href="#0x04-Semantic-HTML">¶</a>0x04 Semantic HTML</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Codecademy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Merge Two Binary Trees //Leetcode</title>
      <link href="2020/08/21/Merge-Two-Binary-Trees-Leetcode/"/>
      <url>2020/08/21/Merge-Two-Binary-Trees-Leetcode/</url>
      
        <content type="html"><![CDATA[<h1>Description</h1><blockquote><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p><p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p></blockquote><h1>Input</h1><p><img src="/2020/08/21/Merge-Two-Binary-Trees-Leetcode/%5CMerge-Two-Binary-Trees-Leetcode%5Cinput.png" alt=""></p><h1>Output</h1><p><img src="/2020/08/21/Merge-Two-Binary-Trees-Leetcode/%5CMerge-Two-Binary-Trees-Leetcode%5Coutput.png" alt=""></p><h1>Analysis</h1><h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>默认代码中给出了“TreeNode”数据结构的定义。每个节点有一个值，这个值可以通过两种函数给出，之后就把它们叫函数1和函数2。<br>我们先来想想不用代码自己手动合并的话会怎么做——核心问题在于怎么算出一个结点的值，以及确定结果树的结构（哪里有结点哪里没有）。<br>好的，先考虑第一个问题，对于一个结点，假如它没有左右孩子，那么它的值应该用函数1计算，也就是直接赋值——因此，我们应该对那些叶节点直接赋值；除这种情况以外，剩下的用函数2计算结点值。说得程序化一点会是什么样呢？处理树可以用递归与循环两种方式来考虑。</p><h1>WAY1：Recursion</h1><h2 id="Explanation"><a class="header-anchor" href="#Explanation">¶</a>Explanation</h2><p>既然用递归，我们可以想象这个调用过程大概是：从两棵树的头部开始，一直往下往下，到叶子节点开始向上返回，两两合并组在一起。<br>编写一个mergeTrees函数，输入是两个结点。<br>假如其中一个是空的，合并结果就是另一个，直接返回就好了<br>假如两者都不空，就应该此处结点的值赋为两个相加，然后此结点的左子树等于参数1的左子树+参数2的左子树，右子树等于参数1的右子树+参数2的右子树。这个+其实就是在调用mergeTrees函数，所以是递归。</p><h2 id="Code"><a class="header-anchor" href="#Code">¶</a>Code</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() {}</span><br><span class="line"> *     TreeNode(int val) { this.val = val; }</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     }</span><br><span class="line"> * }</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {</span><br><span class="line">        if (t1==null){</span><br><span class="line">            return t2;</span><br><span class="line">        }</span><br><span class="line">        if (t2==null){</span><br><span class="line">            return t1;</span><br><span class="line">        }</span><br><span class="line">        t1.val+=t2.val;</span><br><span class="line">        t1.left=mergeTrees(t1.left,t2.left);</span><br><span class="line">        t1.right=mergeTrees(t1.right,t2.right);</span><br><span class="line">return t1;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Complexity"><a class="header-anchor" href="#Complexity">¶</a>Complexity</h2><h2 id="Attention"><a class="header-anchor" href="#Attention">¶</a>Attention</h2><ol><li>一个函数如果作为主要的递归函数，应该在每个条件分支处都有return</li><li>多画图还是很有帮助的</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leetcode Top 100 Liked Questions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to start Markdown</title>
      <link href="2020/08/18/How-to-start-Markdown/"/>
      <url>2020/08/18/How-to-start-Markdown/</url>
      
        <content type="html"><![CDATA[<p>#一、快捷键</p><p><strong>加粗ctrl+B</strong></p><p><em>斜体</em></p><blockquote><p>引用</p></blockquote><p><a href="https://blog.csdn.net/u014061630/article/details/81359144">链接</a></p><pre><code>代码</code></pre><p>图片</p><p>提升标题</p><p>有序列表</p><hr><p>#二、基本语法</p><p>#一级标题</p><h1>一级标题</h1><p>##二级标题</p><h2 id="二级标题"><a class="header-anchor" href="#二级标题">¶</a>二级标题</h2><p>本地图片</p><p><img src="/%E5%9B%BE%E7%89%87.png" alt="链接"></p><p>互联网图片</p><p><img src="https://img-blog.csdn.net/20180802154402427?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQwNjE2MzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="链接"></p><p><a href="https://www.jianshu.com/p/10aa8ba19802">https://www.jianshu.com/p/10aa8ba19802</a></p><hr><hr><hr><p>行内代码：<code>code</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code here</span><br></pre></td></tr></tbody></table></figure><pre><code>code here</code></pre><ul><li><p>无序列表1</p></li><li><p>无序列表2</p></li></ul><p>1</p><ol><li>为什么没有1</li><li>原来中间要隔字</li></ol><p>对策<br>我</p><table><thead><tr><th>学号</th><th>姓名</th></tr></thead><tbody><tr><td>820810203</td><td>胡可</td></tr></tbody></table><p>#三、常用技巧</p><p>换行是要在后面加两个空格的！</p><font color="#87CEFA" size="7" face="楷体">很漂亮</font>  <script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/08/13/hello-world/"/>
      <url>2020/08/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
