<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Chapter9 IP安全</title>
      <link href="2020/10/12/Chapter9-IP%E5%AE%89%E5%85%A8/"/>
      <url>2020/10/12/Chapter9-IP%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>防重放攻击，一般通过序列号或者时间戳</p><h1>9.1 IP安全概述</h1><p>在IP中加入认证和加密机制来保障终端用户安全</p><h2 id="9-1-1-IPSec的应用"><a class="header-anchor" href="#9-1-1-IPSec的应用">¶</a>9.1.1 IPSec的应用</h2><h5 id="IPSec适用范围"><a class="header-anchor" href="#IPSec适用范围">¶</a>IPSec适用范围</h5><p>LAN、专用和公用WAN、互联网</p><h5 id="用途"><a class="header-anchor" href="#用途">¶</a>用途</h5><ul><li>通过互联网安全分支机构接入：</li><li>通过互联网进行安全远程访问：</li><li>与合作者建立企业间联网和企业内联网接入：</li><li>加强电子商务安全性：</li></ul><h2 id="9-1-2-IPSec的好处"><a class="header-anchor" href="#9-1-2-IPSec的好处">¶</a>9.1.2 IPSec的好处</h2><h2 id="9-1-3-路由应用"><a class="header-anchor" href="#9-1-3-路由应用">¶</a>9.1.3 路由应用</h2><p>IPSec其实在互联网的路由结构中也有很重要的作用，例如它可以确保：</p><ul><li>路由器广播来自授权的路由器</li><li>邻居广播来自授权的路由器</li><li>重定向报文</li><li>路由更新未被伪造</li></ul><h1>9.2 IP安全策略</h1><h2 id="9-2-1-安全关联"><a class="header-anchor" href="#9-2-1-安全关联">¶</a>9.2.1 安全关联</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter5 网络访问控制和云安全</title>
      <link href="2020/10/12/Chapter5-%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E4%BA%91%E5%AE%89%E5%85%A8/"/>
      <url>2020/10/12/Chapter5-%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E4%BA%91%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1>5.1 网络访问协议</h1><p>简称NAC，大概包括：登录认证+决定用户可以访问哪些数据+执行哪些操作+检查用户端设备的安全程度</p><h2 id="5-1-1-网络访问控制系统的组成元素"><a class="header-anchor" href="#5-1-1-网络访问控制系统的组成元素">¶</a>5.1.1 网络访问控制系统的组成元素</h2><h5 id="组成成分"><a class="header-anchor" href="#组成成分">¶</a>组成成分</h5><p>（1）访问请求者AR<br>（2）策略服务器<br>（3）网络访问服务器NAS</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud Securtiy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse Linked List</title>
      <link href="2020/10/09/Reverse-Linked-List/"/>
      <url>2020/10/09/Reverse-Linked-List/</url>
      
        <content type="html"><![CDATA[<h1>Description</h1><p>Reverse a singly linked list.</p><h1>Input&amp;Output</h1><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h1>Analysis</h1><p>感觉二叉树经常会用递归，我们应该一直走到底，将两个叶节点交换，然后再一路往上……<br>妙啊，越写越快了！</p><h1>Code</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() {}</span><br><span class="line"> *     ListNode(int val) { this.val = val; }</span><br><span class="line"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span><br><span class="line"> * }</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">    public ListNode reverseList(ListNode head) {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leetcode Top 100 Liked Questions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Invert Binary Tree</title>
      <link href="2020/09/30/Invert-Binary-Tree/"/>
      <url>2020/09/30/Invert-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h1>Description</h1><p>Invert a binary tree.</p><h1>Input&amp;Output</h1><p><img src="/2020/09/30/Invert-Binary-Tree/%5CInvert-Binary-Tree%5CIO.png" alt=""></p><h1>Analysis</h1><p>感觉二叉树经常会用递归，我们应该一直走到底，将两个叶节点交换，然后再一路往上……<br>妙啊，越写越快了！</p><h1>Code</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() {}</span><br><span class="line"> *     TreeNode(int val) { this.val = val; }</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     }</span><br><span class="line"> * }</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">    public TreeNode invertTree(TreeNode root) {</span><br><span class="line"></span><br><span class="line">        if(root==null){</span><br><span class="line">            return null;</span><br><span class="line">        }else{</span><br><span class="line">            if(root.left==null&amp;&amp;root.right==null){</span><br><span class="line">                return root;</span><br><span class="line">            }</span><br><span class="line">            root.left=invertTree(root.left);</span><br><span class="line">            root.right=invertTree(root.right);</span><br><span class="line">            TreeNode temp=new TreeNode();</span><br><span class="line">            temp=root.left;</span><br><span class="line">            root.left=root.right;</span><br><span class="line">            root.right=temp;</span><br><span class="line">        </span><br><span class="line">            return root;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leetcode Top 100 Liked Questions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Single Number</title>
      <link href="2020/09/30/Single-Number/"/>
      <url>2020/09/30/Single-Number/</url>
      
        <content type="html"><![CDATA[<h1>Description</h1><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p><p><em>NOTE：Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</em></p><h1>Input&amp;Output</h1><p><img src="/2020/09/30/Single-Number/%5CSingle-Number%5CIO.png" alt=""></p><h1>Code</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution {</span><br><span class="line">    public int singleNumber(int[] nums) {</span><br><span class="line">        int i=1;</span><br><span class="line">        </span><br><span class="line">        java.util.Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        if(nums.length==1){</span><br><span class="line">            return nums[0];</span><br><span class="line">        }else if(nums[0]!=nums[1]){</span><br><span class="line">            return nums[0];</span><br><span class="line">        }else if(nums[nums.length-1]!=nums[nums.length-1]){</span><br><span class="line">            return nums[nums.length-1];</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        for(;i&lt;nums.length-1;i++){</span><br><span class="line">            if(nums[i]==nums[i-1]||nums[i]==nums[i+1]){</span><br><span class="line">                continue;</span><br><span class="line">            }else{</span><br><span class="line">                break;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        return nums[i];</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leetcode Top 100 Liked Questions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Depth of Binary Tree</title>
      <link href="2020/09/30/Maximum-Depth-of-Binary-Tree/"/>
      <url>2020/09/30/Maximum-Depth-of-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h1>Description</h1><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><h1>Input&amp;Output</h1><p><img src="/2020/09/30/Maximum-Depth-of-Binary-Tree/%5CMaximum-Depth-of-Binary-Tree%5CIO.png" alt=""></p><h1>Analysis</h1><p>大致的思路是，一直往下，过程中有计数器，到底了就返回数字啥的</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() {}</span><br><span class="line"> *     TreeNode(int val) { this.val = val; }</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     }</span><br><span class="line"> * }</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">    int depth=0;</span><br><span class="line">    </span><br><span class="line">    public int maxDepth(TreeNode root) {</span><br><span class="line">        if(root!=null){</span><br><span class="line">            depth++;</span><br><span class="line">            if(root.left==null&amp;&amp;root.right==null){</span><br><span class="line">                return depth;</span><br><span class="line">            }</span><br><span class="line">            if(root.left!=null&amp;&amp;root.right==null){</span><br><span class="line">                depth=maxDepth(root.left);</span><br><span class="line">            }       </span><br><span class="line">            if(root.left==null&amp;&amp;root.right!=null){</span><br><span class="line">                depth=maxDepth(root.right);</span><br><span class="line">            }</span><br><span class="line">            if(root.left!=null&amp;&amp;root.right!=null){</span><br><span class="line">                int depthTemp=depth;</span><br><span class="line">                int depthLeft=maxDepth(root.left);</span><br><span class="line">                depth=depthTemp;</span><br><span class="line">                int depthRight=maxDepth(root.right);</span><br><span class="line">                depth=depthLeft&gt;depthRight?depthLeft:depthRight;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        return depth;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leetcode Top 100 Liked Questions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter1 概述</title>
      <link href="2020/09/23/Chapter1-%E6%A6%82%E8%BF%B0/"/>
      <url>2020/09/23/Chapter1-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<center><h1>1.1 认识操作系统</h1></center><h2>1.1.1 从使用者角度看</h2><h2>1.1.2 从程序开发者的角度看</h2><h2>1.1.3 从操作系统在整个计算机系统所处的位置看</h2><h2>1.1.4 从操作系统设计者的角度看</h2><h2>1.1.5 操作系统组成</h2><center><h1>1.2 开放源代码的UNIX/Linux操作系统</h1></center><h2>1.2.1 UNIX诞生和发展</h2><h2>1.2.2 Linux诞生</h2><h2>1.2.3 操作系统标准POSIX</h2><h2>1.2.4 GNU和Linux</h2><h2>1.2.5 Linux的开发模式</h2><center><h1>1.3 Linux内核</h1></center><h2>1.3.1 Linux内核的技术特点</h2><h2>1.3.2 Linux内核的位置</h2><h2>1.3.3 Linux内核体系结构</h2><center><h1>1.4 Linux内核源代码</h1></center><h2>1.3.1 Linux内核版本</h2><h2>1.3.2 Linux内核源代码的结构</h2><h2>1.3.3 Linux内核源代码分析工具</h2><center><h1>1.5 Linux内核模块编程入门</h1></center><h2>1.5.1 模块的定义</h2><h2>1.5.2 编写一个简单的模块</h2><h2>1.5.3 应用程序与内核模块的比较</h2><center><h1>1.6 Linux内核中链表的实现及应用</h1></center><h2>1.5.1 模块的定义</h2><h2>1.5.2 编写一个简单的模块</h2><h2>1.5.3 应用程序与内核模块的比较</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《Linux操作系统原理与应用(E2)》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter3 公钥密码和消息认证</title>
      <link href="2020/09/23/Chapter3-%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%92%8C%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81/"/>
      <url>2020/09/23/Chapter3-%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%92%8C%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<center><h1>3.1 消息认证方法</h1></center><h2>3.1.0 引言</h2>加密这个手段，自然的就可以防止被动攻击了；不过我们还需要满足防止主动攻击（伪造数据和业务）的需求————对应的办法就是消息认证。首先，什么是可信？可信就是，数据真实且来自合法来源，消息认证就是认证数据可不可信的。对应着可信的两方面定义，认证要做的就是判断消息被篡改与否+来源合法与否，此外还有可能要验证数据时效性、消息流顺序等等<h2>3.1.1 利用常规加密的消息认证</h2>常规就是说简单的对称加密这样子，但是对于分组对称加密会出现问题。假如攻击者想换动消息流之间的顺序，那么由于是分组的，所以B还是能每组都正常解密……<h2>3.1.2 非加密的消息认证</h2><h5>认证与加密</h5>把这两个词放一起的时候，我常常感觉……很迷糊，现在理一理：一般来说认证和加密是两个功能，说一句话可能会让关系更明白：<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如我们有一个对消息作处理的算法，这里面可以包含两步操作：先对消息加密，再打上认证标签；这样我们就可以说：把消息的认证和保密结合起来了</span><br></pre></td></tr></tbody></table></figure><h5>什么时候可以不加密只认证呢？</h5>1. 相同消息广播时，只由一端负责监控的系统执行认证（不是很理解，直观是什么样的？）2. 交换信息时，某一端负载太大不能全部解密，就会随机抽一些进行认证3. 程序可以用明文+认证标签，节省处理器解密的消耗<h5>消息认证码MAC</h5>定义：用私钥产生一小块数据，它可以作为MAC工作流程：![](\Chapter3-公钥密码和消息认证\MAC.png)A和B共享一个密钥K，A给B发消息的时候，A用消息+K生成MAC，再把消息和MAC一起发给B；B收到以后，算一算MAC对不对值得注意的是，认证算法不需要可逆，因为B验证的时候和A是一样的操作（与加密相比更不容易被破）<h5>单向散列函数</h5>这是MAC的一种替代品，不同之处在于：MAC需要密钥而单向散列不需要，它只是输入M得到H(M)而已。H函数可以有以下三种形式：![](\Chapter3-公钥密码和消息认证\HASH.png)（详细见P50-51）<center><h1>3.2 安全散列函数</h1></center><h2>3.2.1 散列函数的要求</h2>1. 输入长度不受限制2. 输出长度固定3. 从x——&gt;H(x)容易计算4. 单向性/抗原像攻击性：从H(x)——&gt;x计算上不可行5. 抗弱碰撞攻击性/抗第二原像攻击性：对于x，找一个和它哈希值相同的y从计算上不可行6. 抗碰撞性/抗强碰撞性：找到任意一对哈希值相同的x，y计算上不可行（可以防止生日攻击）<h2>3.2.2 散列函数的安全性</h2>攻击方法：密码分析法+蛮力攻击法前者利用密码算法的缺陷，后者是要付出指数级代价的（不过2004年王小云教授破了MD5！）<h2>3.2.3 简单散列函数</h2><h2>3.2.4 SHA安全散列函数</h2><center><h1>3.3 消息认证码</h1></center><h2>3.3.1 HMAC</h2><h5>为什么会有HMAC呢？</h5>首先，由于SHA-1软件实现速度快、有许多共享的Hash函数代码库等优点，人们逐渐将它用于MAC。但是为了把密钥合并到散列算法中，人们开发出了HMAC<h5>HMAC的设计目标</h5><h5>HMAC的算法设计</h5><h2>3.3.2 基于分组密码的MAC</h2><h5>基于密文的消息认证码CMAC</h5><h5>具有密码块链式信息认证码的计数器</h5><center><h1>3.4 公钥密码原理</h1></center><h2>3.4.1 公钥密码思想</h2>公钥密码基于数学函数，可以用于消息认证、密钥分发<h5>常见误解</h5>公钥比对称密码更安全<center><h1>3.5 公钥密码算法</h1></center><center><h1>3.6 数字签名</h1></center><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Public-key cryptography </tag>
            
            <tag> Message authentication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter4 密钥分配和用户认证</title>
      <link href="2020/09/23/Chapter4-%E5%AF%86%E9%92%A5%E5%88%86%E9%85%8D%E5%92%8C%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/"/>
      <url>2020/09/23/Chapter4-%E5%AF%86%E9%92%A5%E5%88%86%E9%85%8D%E5%92%8C%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<center><h1>4.1 基于对称加密的密钥分配</h1></center><center><h1>4.2 Kerberos</h1></center><h2>4.2.0 引言</h2><h5>要解决的问题</h5>分布式环境中，控制访问权限，为用户提供认证服务<h5>三种威胁</h5>1. 用户可以伪装成其他用户2. 伪造网络地址发消息3. 监听消息/重放攻击<p>Kerberos仅依赖于对称加密；此外，版本4逐渐被淘汰，现在常用版本5</p><h2>4.2.1 Kerberos版本4</h2>啊好复杂……之后慢慢啃<h2>4.2.1 Kerberos版本5</h2><center><h1>4.3 基于非对称加密的密钥分配</h1></center><h2>4.3.0 引言</h2>公钥加密一个重要作用：处理密钥分发（公钥的分发+使用公钥加密分发私钥）<h2>4.3.1 公钥证书</h2><ul><li>为什么要有公钥证书？<br>就像邮箱、银行卡号这种公钥，它们是广而告之的；但是你怎么知道他说这是就是呢？万一伪造了呢？所以我们引入第三方、公钥证书这些来验证。</li><li>X.509标准是人们广泛接受的公钥证书格式</li></ul><h2>4.3.2 基于公钥密码的秘密密钥分发</h2>对称密钥中，共享密钥是前提，之后才能安全通信<h5></h5><center><h1>4.4 X.509证书</h1></center><h2>4.4.0 引言</h2>公钥加密一个重要作用：处理密钥分发（公钥的分发+使用公钥加密分发私钥）<h2>4.4.1 证书</h2><h2>4.4.2 X.509版本3</h2><center><h1>4.5 公钥基础设施KPI</h1></center><h2>4.5.0 引言</h2><ul><li>PKI是什么？<br>之所以叫基础设施：包含了硬件+软件+人员+策略+过程</li><li>那是干什么的基础设施？<br>公钥密码中，用于生成+管理+存储+分配+撤销数字证书</li><li>PKIX是什么？<br>基于X.509的PKI</li><li>所以具体来说，PKIX包括些什么呢？</li></ul><h2>4.5.1 PKIX管理功能</h2><ul><li>注册：注册开始了一个PKI中的登记过程</li><li>初始化：客户端安装密钥资料</li><li>认证：CA发证书</li><li>密钥对恢复：</li><li>密钥对更新：</li><li>撤销申请：CA撤销</li><li>交叉认证：两个CA之间</li></ul><h2>4.5.2 PKIX管理协议</h2><center><h1>4.6 联合身份管理</h1></center><h2>4.6.1 身份管理</h2><h5>作用</h5>验证身份以后给对应的资源接口，基于单点登录SSO<h5>基本要素</h5><h2>4.6.2 身份联合</h2>身份联合就是将身份管理扩展到多个安全域<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter2 对称加密和消息机密性</title>
      <link href="2020/09/21/Chapter2-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E6%B6%88%E6%81%AF%E6%9C%BA%E5%AF%86%E6%80%A7/"/>
      <url>2020/09/21/Chapter2-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E6%B6%88%E6%81%AF%E6%9C%BA%E5%AF%86%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<center><h1>2.1 对称加密原理</h1></center><h2>2.1.0 对称加密简介</h2><h3>一个对称加密算法的组成</h3>![](\Chapter2-对称加密和消息机密性\model.png)<h3>对称加密算法的安全性</h3>需要达到以下两个要求：- 强加密算法：（一个很强的条件）攻击者有很多（算法）+密文+密文对应的明文，却不能解出全部明文|密钥- 密钥安全：Alice和Bob的密钥收发仅两人可得<p><strong>注：对称加密的安全取决于密钥的保密性，算法可公开</strong></p><h2>2.1.1 密码体制</h2>密码体制有以下三个分类标准：<h3>1. 明文转换成密文的操作类型</h3><ul><li>替换：明文映射到……</li><li>换位：明文再排列</li></ul><p>（注：上述两种操作可以以比特、字母等等为单位）</p><h3>2. 使用的密钥数</h3><ul><li>AB同一密钥：对称/单钥/秘密密钥/传统加密</li><li>AB不同密钥：不对称/双钥/公钥加密</li></ul><h3>3. 明文的处理方式</h3><ul><li>一次处理一个分组：分组密码</li><li>明文输入过程中连续处理：流密码</li></ul><h2>2.1.2 密码分析</h2>密码分析或破译：找出明文或密钥<p>根据攻击者掌握的信息量，可将攻击类型分类如下：<br><img src="/2020/09/21/Chapter2-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E6%B6%88%E6%81%AF%E6%9C%BA%E5%AF%86%E6%80%A7/%5CChapter2-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E6%B6%88%E6%81%AF%E6%9C%BA%E5%AF%86%E6%80%A7%5Cattack.png" alt=""></p><h3>1. 惟密文攻击</h3>或许只能穷举……但是也有一些小技巧，比如统计测试（前提是对明文的类型有一个大致的了解）<h3>2. 已知明文攻击</h3>比如某种文件可能有些固定的内容……**一般密码算法会被设计成能抵挡已知明文攻击的程度**<h3>3. 选择明文</h3>攻击者能得到源系统，可以插入自己选定的消息<h3>4. 选择密文</h3>不太常见<h3>5. 选择文本</h3>不太常见<p>计算安全的加密方案：</p><ul><li>破解密文的代价&gt;明文的价值</li><li>破解密文的时间&gt;信息的有用寿命</li></ul><h2>2.1.3 Feistel密码结构</h2><h5>可以看做是对称密码算法的通用结构</h5>![](\Chapter2-对称加密和消息机密性\Fiestel.png)<h5>其中有些可以调整的参数：</h5>- 分组大小：折中128bit一组比较常见- 密钥大小：越长——越安全——加解密越慢- 迭代轮数：典型16- 子密钥产生算法：越复杂越安全- 轮函数：同上<h5>设计算法还需考虑</h5>- 软件执行速度比较快- 容易分析——容易找到弱点——随即加固<p><strong>对称密码算法的加解密本质上是相同的过程，不需要实现两个不同的算法</strong></p><center><h1>2.2 对称分组加密算法</h1></center><h2>2.2.1 数据加密标准DES</h2>说实话，我总是不能把数据加密标准和DES联系在一起，这两个名字，一个像标准，一个像算法哈哈哈哈；但是仔细研究一下发现，其实我的直觉没错DES准确来说是一种标准，数据加密标准；算法本身其实叫做DEA，略感陌生；一般都直接说DES了<h5>DEA算法描述</h5>基本沿用Fiestel结构，参数如下：- 分组大小：64- 密钥大小：56- 迭代轮数：典型16- 子密钥产生算法：越复杂越安全- 轮函数：同上<h5>DES的强度</h5>- 算法本身：至今还没人指出弱点- 密钥长度：一定范围内，蛮力攻击还是可行的（所以后来有改进的算法来替代它，如3DES和AES）<h2>2.2.2 三重DES</h2><h5>3DES流程</h5>使用三次DES，加密——解密——加密<h5>3DES优点</h5><ul><li>底层算法与DES相同，之前说过无弱点了</li><li>密钥长度168bit，解决了被穷举的问题</li></ul><h5>3DES缺点</h5>软件运行慢<h2>2.2.3 高级加密标准AES</h2>替代3DES，安全性&gt;=，效率&gt;=<h5>AES流程</h5>值得注意的是，它不是Feistel结构（具体可见书30—31页）<center><h1>2.3 随机数和伪随机数</h1></center><h2>2.3.1 随机数的应用</h2><h5>基于随机数的安全算法</h5>RSA、对称流密码的密钥流的生成、密钥分配方案……<h5>应用对随机数的需求</h5><ol><li>随机性：有两个验证标准<br>（1）均匀分布：一串中，0与1出现概率大致相同<br>（2）独立：统一序列上，没有数字能影响别人</li><li>不可预测性</li></ol><h2>2.3.2 真随机数发生器TRNG、伪随机数生成器PRNG和伪随机函数PRF</h2>首先要明白，什么是统计上的随机性？不太懂……也没查到![](\Chapter2-对称加密和消息机密性\random.png)伪随机数发生器和伪随机函数的区别在于产生的比特数不同<h2>2.3.3 算法设计</h2>PRNG的算法可以分为两类：<h5>1. 为特定目的构造的算法</h5><h5>2. 基于现存密码算法的算法</h5>不太懂这是什么意思……<center><h1>2.4 流密码和RC4</h1></center>分组密码更普遍，但对于特定应用还是要用流密码的。最对称的流密码可以说是RC4了哈哈哈哈<h2>2.4.1 流密码结构</h2><h5>流密码结构示意图</h5>![](\Chapter2-对称加密和消息机密性\flow.png)解释一下：首先呢，你要先有个密钥K，把它投入伪随机字节生成器里面得到密钥流k；k和明文异或就得到密文字节流啦。由于是对称的，加密解密用同一个密钥<h5>设计流密码的考虑因素</h5><ul><li>加密序列有个长周期：意思是，其实伪随机字节生成器生成的是周期性循环的确定字节流，如果周期太短容易被破</li><li>生成的密钥流最好能通过随机数检测那些</li><li>PRNG的输入要足够长以便不会被穷举</li></ul><h5>流密码优点</h5><ul><li>比分组密码快，代码少</li></ul><h5>分组密码优点</h5><ul><li>分组密码可以重复使用密钥，但是流密码的密钥最好不要重复用不然容易被破</li></ul><h2>2.4.2 RC4算法</h2><h5>RC4算法</h5><ul><li>初始化S：S是个状态向量，有256维，刚开始从0-255维依次设为0-255；K为密钥（1-256字节可变）；T为临时向量（256维）<br>T的赋值：将K循环利用填充进去<br>S的初始置换：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">j=0;</span><br><span class="line">for(i=0;i&lt;=255;i++){</span><br><span class="line">j=(j+S[i]+T[i])mod 256;</span><br><span class="line">swap(S[i],S[j]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>密钥流产生：感觉只有对S的置换操作<br><img src="/2020/09/21/Chapter2-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E6%B6%88%E6%81%AF%E6%9C%BA%E5%AF%86%E6%80%A7/%5CChapter2-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E6%B6%88%E6%81%AF%E6%9C%BA%E5%AF%86%E6%80%A7%5Ca1.png" alt=""></li></ul><h5>RC4强度</h5>有些特定的攻击方法、<center><h1>2.5 分组密码工作模式</h1></center>NIST定义了以下五种工作模式：<h2>2.5.1 电子密码本ECB模式</h2><h5>原理</h5>假设明文被分成b比特一组，每个分组都是同一密钥加密的。每个分组对于一个给定的密钥会有一个密文（唯一的结果），但是如果一段明文里有两个完全相同的分组……它们对应的密文也是相同的……<h5>不足</h5>如果明文过长以至于出现两个分组重复，就不安全。所以我们希望有上述情况的话，它们会对应两个不同的密文。<h2>2.5.2 密码分组链接CBC模式</h2><h5>原理</h5>![](\Chapter2-对称加密和消息机密性\CBC.png)如图所示，输入：每组明文和上一组密文的异或；处理：所有分组用同一密钥；<h5>数学推导说明的一些东西</h5>见书P39<h2>2.5.3 密码反馈CFB模式</h2><h5>作用</h5>将任意分组密码转化为流密码<h5>原理</h5>不想整了hai，之后有需要再补吧，P39-40<h2>2.5.4 计数器模式</h2><h5>原理</h5>不想整了hai，之后有需要再补吧，P39-40<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter1 绪论 | Reading Notes</title>
      <link href="2020/09/19/Chapter1-%E7%BB%AA%E8%AE%BA-Reading-Notes/"/>
      <url>2020/09/19/Chapter1-%E7%BB%AA%E8%AE%BA-Reading-Notes/</url>
      
        <content type="html"><![CDATA[<h2>为什么软件安全问题日渐复杂？</h2>- 随着科技发展、研究与分析的深入,我们注意到软件安全的问题非常多样化- 试图利用软件安全问题获利的各类组织机构也在不断发展，针对软件安全问题的利用、破坏技术手段，造成软件安全问题日趋复杂<h2>软件安全问题分类</h2><h3>（一）恶意软件</h3><h5>1. 传统恶意软件</h5><ul><li>传统的恶意软件包括：病毒、僵木蠕、间谍软件等</li><li>破坏：窃取信息、远程控制、实施破坏等</li><li>传统恶意软件需要发展的能力：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">渗透与扩散：突破防御+感染目标</span><br><span class="line">隐蔽能力：隐蔽特征避免被发现+被发现了能保护操纵者身份</span><br><span class="line">破坏能力：搜集信息+实施破坏</span><br></pre></td></tr></tbody></table></figure><h5>2. 恶意软件发展历程</h5>单机传播——网络传播——协同攻击APT攻击（高可持续性威胁）：针对特定目标+高技术<h3>（二）软件漏洞</h3>说的是程序设计错误导致的<h5>1. 漏洞为什么越来越多？</h5>- 软件更复杂- 漏洞多样化- 软件开发周期变短<h3>（三）软件后门</h3>开发人员刻意设计，但对用户隐瞒的功能。为什么算在软件安全问题中呢？因为有的攻击者，开发软件的时候，会留下后门，将其设计为此软件的漏洞。举个栗子：建城墙的人留了个暗道，工程交付以后，保护城墙的人不一定能找出来它，但是工人却一清二楚，可以通过暗道做些坏事。而且，工人更懂怎么利用城墙的设计藏好这个暗道。<h5>1. 将软件后门设计为软件漏洞，此方法优势：</h5>- 难发现- 易利用- 难取证：后门代码其实不在软件的产品代码中，而是攻击者利用漏洞动态加载的（被发现了说成设计错误就完事儿了，不是故意的哈哈哈）<h2>软件安全性分析要解决的问题</h2><h3>1. 存在问题</h3>“是否”的问题：有恶意功能/漏洞/后门吗？<h3>2. 机理问题</h3>“为什么”的问题：分析下此问题出现的原因/原理/工作流程之类的，具体问题具体分析<h3>3. 对策问题</h3>“怎么办”的问题：防御<h2>无源码时对软件逆向分析的挑战</h2><h3>1. 指令代码的理解</h3>从可执行文件或指令执行序列等，理解到操作语义很困难<h3>2. 关联关系的抽取</h3>操作之间的数据传递、计算，数据/指令之间的依赖关系，很难有直观的认识<h3>3. 对策问题</h3>“怎么办”的问题：防御<center><h1>1.4 主要方法与技术</h1></center><h2>1.4.0 软件逆向分析方法分类</h2>主要有两大类：静态分析和动态分析<h5>1. 静态分析</h5>感觉就像通过反汇编或反编译的手段，对软件的可执行代码进行分析（1）优点：比较全面、整体（2）缺点：一方面，软件代码规模大了或者复杂了就不好搞；另一方面，如果软件做了加壳保护那就不能反汇编等等<h5>2. 动态分析</h5>通过直接运行软件，监测软件运行过程进行分析。（1）优点：分析过程中可根据软件的运行过程直接获得在各个指令执行后的结果数据，减少推理分析（2）缺点：每次分析只能针对动态执行的一条路径执行，整体性较差（所以说，如何构造多条执行路径也是动态分析需要研究的一个重要问题）<p><strong>现在一般：动态为主，静态为辅</strong></p><h2>1.4.1 反汇编与反编译</h2>通常是逆向分析的第一步（静态动态都是）<h5>作用</h5>二进制exe文件（完全不可读）——&gt;汇编代码——&gt;其他高级语言代码（基本可读）第一个箭头是反汇编，第二个是反编译；做到**功能等价**就行<h2>1.4.2 程序调试</h2>动态分析<h5>定义</h5>用一些工具，通过断点、单步执行等方式内核代码的调试需要虚拟化技术+多台设备<h5>优缺点</h5>优缺点基本同“动态分析”中所写，此外，软件自保护技术可能阻碍调试，且数据量和复杂度都挺恐怖的<h2>1.4.3 程序切片</h2><h5>作用</h5>解决软件代码规模超大带来的理解困难，比如分析出了汇编代码，对汇编代码切片……<h5>基本思想</h5>分析指令的相关性，从而提取用户“感兴趣”的代码<p>主要用于静态分析，也可用于动态分析，有差异：<br>（1）静态分析：通过计算操作数<strong>可能的影响范围</strong>（要考虑各种可能的执行路径）来计算指令的关联关系<br>（2）动态分析：更有针对性，对某条路径某个操作数来分析指令关联</p><h5>缺点</h5>对局部代码还不错，但代码多了照样难受<h2>1.4.4 污点传播分析</h2>静态动态都有，**数据流分析方法**<h5>基本思想</h5>将感兴趣的数据标记，根据每条指令的污点传播过程，分析数据的传递关系<h5>实现方式</h5>按照“如何获得后台执行过程中具体每一条指令和指令执行前后状态”，可以分为：基于插桩/硬件/编译器扩展/硬件模拟器等等<h5>存在问题</h5>由于控制依赖、查表操作等引入的隐式污点传播无法简单地引入或去除<h2>1.4.5 符号执行</h2>静态动态都有<h2>1.4.6 模糊测试</h2>动态分析<h5>作用</h5>本来是构造许多奇怪数据来看软件鲁棒性的，但现在是为了触发不同的执行路径<h5>存在问题</h5>提高测试数据生成的针对性——&gt;提高模糊测试效率<center><h1>1.5 主要分析应用</h1></center><h2 id="恶意软件分析"><a class="header-anchor" href="#恶意软件分析">¶</a>恶意软件分析</h2><h5 id="对恶意软件的分析目标"><a class="header-anchor" href="#对恶意软件的分析目标">¶</a>对恶意软件的分析目标</h5><ul><li>分析出主要功能</li><li>提取代码或行为特征，更新防御配置</li><li>分析实现机理，研发清除手段</li></ul><h5 id="网络协议逆向分析"><a class="header-anchor" href="#网络协议逆向分析">¶</a>网络协议逆向分析</h5><p>方法：</p><ul><li>基于网络流量统计特征展开分析</li><li>直接通过逆向软件分析<br>优点：准确、分析能力强<br>基本思路：对代码静态+动态逆向分析，提取出协议中的数据包格式/关键字/协议状态机等</li></ul><h5 id="软件漏洞分析与利用"><a class="header-anchor" href="#软件漏洞分析与利用">¶</a>软件漏洞分析与利用</h5><p>如何发现软件漏洞？</p><ul><li>模糊测试工具</li><li>典型漏洞的代码特征</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 《软件安全分析与应用》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Day1 - in_array函数缺陷//PHP Audit</title>
      <link href="2020/09/19/Day1-in-array%E5%87%BD%E6%95%B0%E7%BC%BA%E9%99%B7-PHP-Audit/"/>
      <url>2020/09/19/Day1-in-array%E5%87%BD%E6%95%B0%E7%BC%BA%E9%99%B7-PHP-Audit/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sqlmap Mannal</title>
      <link href="2020/09/19/Sqlmap-Mannal/"/>
      <url>2020/09/19/Sqlmap-Mannal/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>蚁剑 Mannal</title>
      <link href="2020/09/19/%E8%9A%81%E5%89%91-Mannal/"/>
      <url>2020/09/19/%E8%9A%81%E5%89%91-Mannal/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.fujieace.com/hacker/tools/antsword.html">中国蚁剑下载、安装、使用教程</a></p><p><a href="https://www.bilibili.com/video/av86179526/">https://www.bilibili.com/video/av86179526/</a></p><center><h1>Webshell</h1></center>理解 webshell 我们可以从字面上去理解，将其拆分成 web 和 shell 来分别进行理解，web 在百度百科的解释如下：<p>web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和 HTTP 的、全球性的、动态交互的、跨平台的分布式图形信息系统。<br>是建立在 Internet 上的一种网络服务，为浏览者在 Internet 上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将 Internet 上的信息节点组织成一个互为关联的网状结构。</p><p>web 对于我们来说都不陌生，是从事安全行业的同僚接触最多，也是入门必学的基础，为什么会是必学的基础呢？</p><p>因为这个在企业中是应用最广泛，也是最容易暴露在攻击者面前的东西，任何人都能找到任何企业暴露在外面可供入侵者攻击的应用，所以学习 web 安全没有错。</p><p>那么 shell 是什么呢？百度百科的解释如下：</p><p>在计算机科学中，Shell 俗称壳（用来区别于核），是指“提供使用者使用界面”的软件（命令解析器）。它类似于 DOS <a href="http://xn--command-nw3k6121a.com">下的command.com</a> 和后来的 cmd.exe。<br>它接收用户命令，然后调用相应的应用程序。</p><p>对于 shell 的理解，我们也可以理解为一个接口，用来管理某些应用程序。</p><p>webshell 就是两者的集合，合起来的意思可以理解为 web 应用管理工具，正常情况下，运维人员可以通过 webshell 针对 web 服务器进行日常的运维管理以及系统上线更新等，那么攻击者也可以通过 webshell 来管理 web 应用服务器。</p><p><strong>两者在使用上并没有太多区别，但是在叫法上可能就不大一样了，管理员使用可以叫服务器管理工具，而在攻击者手里就可以叫做后门程序了。</strong></p><center><h1>一句话木马</h1></center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php eval($_POST[&quot;kxc&quot;]);?&gt;</span><br></pre></td></tr></table></figure><p>php的eval()函数：eval($str)函数是把$str当做PHP代码执行。</p><p>这是php的一句话后门中最普遍的一种。它的工作原理是：<br>首先存在一个名为shell的变量，shell的取值为HTTP的POST方式。Web服务器对shell取值以后，然后通过eval()函数执行shell里面的内容。</p>]]></content>
      
      
      <categories>
          
          <category> Web Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蚁剑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wireshark Mannal</title>
      <link href="2020/09/19/Wireshark-Mannal/"/>
      <url>2020/09/19/Wireshark-Mannal/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Burpsuite Mannal</title>
      <link href="2020/09/19/Burpsuite-Mannal/"/>
      <url>2020/09/19/Burpsuite-Mannal/</url>
      
        <content type="html"><![CDATA[<center><h1>Proxy</h1></center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">forward：传输本次数据</span><br><span class="line">drop：丢弃本次数据</span><br><span class="line">Intercepton&#x2F;off：拦截开启&#x2F;关闭</span><br><span class="line">Action：提供功能选项</span><br></pre></td></tr></table></figure><p>当Burp Suite拦截的客户端和服务器交互之后，我们可以在Burp Suite的消息分析选项卡中查看这次请求的实体内容、消息头、请求参数等信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Raw：视图主要显示web请求的raw格式，包含请求地址、http协议版本、主机头、浏览器信息、Accept可接受的内容类型、字符集、编码方式、cookie等。我们可以通过手工修改这些信息，对服务器端进行渗透测试。</span><br><span class="line"></span><br><span class="line">params ：视图主要显示客户端请求的参数信息、包括GET或者POST请求的参数、Cookie参数。渗透人员可以通过修改这些请求参数来完成对服务器端的渗透测试。</span><br><span class="line"></span><br><span class="line">headers：视图显示的信息和Raw的信息类似，只不过在这个视图中，展示得更直观、友好。</span><br><span class="line"></span><br><span class="line">Hex ：视图显示Raw的二进制内容，你可以通过hex编辑器对请求的内容进行修改。</span><br></pre></td></tr></table></figure><p>Burpproxy所拦截的消息可在Fitter（过滤器）中根据需要进行修改</p><p>所有流经burpproxy的消息都会在 http history中记录下来，我们可以通过历史选项卡，查看传输的数据内容，对交互的数据进行测试和验证，同时，我们可以通过右击来弹出菜单，发送内容到burp的其他组件进行处理（类似于Action的功能）</p><p>comment：对拦截的消息添加备注，在一次渗透测试中，你通常会遇到一连串的请求消息，为了便于区分，在某个关键的请求消息上，你可以添加备注信息。</p><p>Highlight的功能与Comment功能有点类似，即对当前拦截的消息设置高亮，以便于其他的请求消息相区分。</p><p>可选项配置Options</p><p>从界面上看，主要有以下几大板块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">▪客户端请求消息拦截（Interceptclient requests）</span><br><span class="line"></span><br><span class="line">▪服务器端返回消息拦截（intercept server responses）</span><br><span class="line"></span><br><span class="line">▪服务器返回消息修改（response modification）</span><br><span class="line"></span><br><span class="line">▪正则表达式配置（match and replace）</span><br><span class="line"></span><br><span class="line">▪其他配置项（miscellaneous）</span><br></pre></td></tr></table></figure><center><h1>Intruder</h1></center>工作原理：Intruder在原始请求数据的基础上，通过修改各种请求参数，以获取不同的请求应答。每一次请求中，Intruder通常会携带一个或多个有效攻击载荷（Payload),在不同的位置进行攻击重放，通过应答数据的比对分析来获得需要的特征数据。(在我的使用经验中，主要用于爆破)<p>应用场景：</p><ol><li>标识符枚举 Web应用程序经常使用标识符来引用用户、账户、资产等数据信息。例如，用户名，文件ID和账户号码。</li><li>提取有用的数据在某些场景下，而不是简单地识别有效标识符，你需要通过简单标识符提取一些其他的数据。比如说，你想通过用户的个人空间id，获取所有用户在个人空间标准的昵称和年龄。</li><li>模糊测试很多输入型的漏洞，如SQL注入，跨站点脚本和文件路径遍历可以通过请求参数提交各种测试字符串，并分析错误消息和其他异常情况，来对应用程序进行检测。由于的应用程序的大小和复杂性，手动执行这个测试是一个耗时且繁琐的过程。这样的场景，您可以设置Payload，通过Burp Intruder自动化地对Web应用程序进行模糊测试。</li></ol><p>测试步骤：</p><ol><li>确认Burp Suite安装正确并正常启动，且完成了浏览器的代理设置。</li><li>进入Burp Proxy选项卡，关闭代理拦截功能。</li><li>进行历史日志（History）子选项卡，查找可能存在问题的请求日志，并通过右击菜单，发送到Intruder。</li><li>进行Intruder选项卡，打开Target和Positions子选项卡。这时，你会看到上一步发送过来的请求消息。</li><li>因为我们了解到Burp Intruder攻击的基础是围绕刚刚发送过来的原始请求信息，在原始信息指定的位置上设置一定数量的攻击载荷Payload，通过Payload来发送请求获取应答消息。在默认情况下，所有的请求参数和cookie参数都会被设置为添加载荷<br>6.点击clear清除默认载荷（如果需要），圈定需要设置载荷的参数，点击add</li><li>当我们打开Payload子选项卡，选择Payload的生成或者选择策略，默认情况下选择“Simplelist&quot;,当然你也可以通过下拉选择其他Payload类型或者手工添加。</li><li>之后点击start attack发动攻击，此时burp 会自动打开一个新的界面，包含执行攻击的情况，http状态码、长度等信息的结果。我们还可以选择其中某一次通信消息，查看请求消息和应答消息的详细</li></ol><p>在很多时候，为了更好的标明应答消息中是否包含有我们需要的信息，通常在进行攻击前，会进行Options选项的相关配置，使用最多的为正则表达式匹配（Grep - Match）。</p><p>或者我们选择结果选项卡中的过滤器，对结果进行过滤筛选。同时，结果选项卡中所展示的列我们是可以进行指定的，我们可以在菜单columns进行设置。</p><p>最后选择我们需要的列，点击save按钮，对攻击结果进行保存。（也可以对保存对的内容进行设置</p><center><h1>Repeater</h1></center>Repeater是一个重放攻击器。我们可以在这里对数据包的参数进行修改，以此来进行请求与响应的消息验证分析。![](https://img-blog.csdn.net/20170805164656913?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU1NDQzNzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)]]></content>
      
      
      <categories>
          
          <category> Web Sercurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Burpsuite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Understanding HTTP Deeply</title>
      <link href="2020/09/19/Understanding-HTTP-Deeply/"/>
      <url>2020/09/19/Understanding-HTTP-Deeply/</url>
      
        <content type="html"><![CDATA[<center><h1>简介</h1></center>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</p><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><p><img src="https://upload-images.jianshu.io/upload_images/2964446-5a35e17f298a48e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/551/format/webp" alt></p><center><h1>特点</h1></center>HTTP协议的主要特点可概括如下：1.支持客户/服务器模式。2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<center><h1>URL</h1></center>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息<p>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.aspxfans.com:8080&#x2F;news&#x2F;index.asp?boardID&#x3D;5&amp;ID&#x3D;24618&amp;page&#x3D;1#name</span><br></pre></td></tr></table></figure><p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p><ol><li><p>协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在&quot;HTTP&quot;后面的“//”为分隔符</p></li><li><p>域名部分：该URL的域名部分为“<a href="http://www.aspxfans.com">www.aspxfans.com</a>”。一个URL中，也可以使用IP地址作为域名使用</p></li><li><p>端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p></li><li><p>虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p></li><li><p>文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p></li><li><p>锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p></li><li><p>参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p></li></ol><center><h1>URI和URL的区别</h1></center><h2>URI</h2>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般由三部组成：①访问资源的命名机制②存放资源的主机名③资源自身的名称，由路径表示，着重强调于资源。<h2>URL</h2>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等<h2>URN</h2>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。<p>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。<br>在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。<br>相反的是，URL类可以打开一个到达资源的流。</p><center><h1>请求消息Request</h1></center>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：**请求行（request line）**、**请求头部（header）**、**空行**和**请求数据**四个部分。<p><img src="https://upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/466/format/webp" alt></p><h2>GET请求例子</h2><pre>GET /562f25980001b1b106000338.jpg HTTP/1.1Host    img.mukewang.comUser-Agent  Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept  image/webp,image/*,*/(为了让后面不要变成斜体，此处删去了一个星号);q=0.8Referer http://www.imooc.com/Accept-Encoding gzip, deflate, sdchAccept-Language zh-CN,zh;q=0.8</pre><h3>第一部分：请求行</h3>用来说明请求类型,要访问的资源以及所使用的HTTP版本.GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。<h3>第二部分：请求头部</h3>紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等<h3>第三部分：空行</h3>请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。(注意此例中是有空行的)<h3>第四部分：请求数据</h3>也叫主体，可以添加任意的其他数据。这个例子的请求数据为空。<h2>POST请求例子</h2><pre>POST / HTTP1.1Host:www.wrox.comUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type:application/x-www-form-urlencodedContent-Length:40Connection: Keep-Alivename=Professional%20Ajax&publisher=Wiley</pre><p>第一部分：请求行，第一行明了是post请求，以及http1.1版本。<br>第二部分：请求头部，第二行至第六行。<br>第三部分：空行，第七行的空行。<br>第四部分：请求数据，第八行。</p><center><h1>响应消息Response</h1></center>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。HTTP响应也由四个部分组成，分别是：**状态行**、**消息报头**、**空行**和**响应正文**。<p><img src="https://upload-images.jianshu.io/upload_images/2964446-1c4cab46f270d8ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/683/format/webp" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">      &lt;head&gt;&lt;&#x2F;head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">            &lt;!--body goes here--&gt;</span><br><span class="line">      &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3>第一部分：状态行</h3>由HTTP协议版本号， 状态码， 状态消息 三部分组成。第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）<h3>第二部分：消息报头</h3>用来说明客户端要使用的一些附加信息第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8<h3>第三部分：空行</h3>消息报头后面的空行是必须的<h3>第四部分：响应正文</h3>服务器返回给客户端的文本信息。空行后面的html部分为响应正文。<center><h1>状态码</h1></center>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:<p>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见状态码：</span><br><span class="line">200 OK                        &#x2F;&#x2F;客户端请求成功</span><br><span class="line">400 Bad Request               &#x2F;&#x2F;客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized              &#x2F;&#x2F;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span><br><span class="line">403 Forbidden                 &#x2F;&#x2F;服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found                 &#x2F;&#x2F;请求资源不存在，eg：输入了错误的URL</span><br><span class="line">500 Internal Server Error     &#x2F;&#x2F;服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable        &#x2F;&#x2F;服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure><center><h1>请求方法</h1></center>根据HTTP标准，HTTP请求可以使用多种请求方法。HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET  请求指定的页面信息，并返回实体主体。</span><br><span class="line">HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</span><br><span class="line">POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</span><br><span class="line">PUT  从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">DELETE   请求服务器删除指定的页面。</span><br><span class="line">CONNECT  HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。</span><br><span class="line">OPTIONS  允许客户端查看服务器的性能。</span><br><span class="line">TRACE    回显服务器收到的请求，主要用于测试或诊断。</span><br></pre></td></tr></table></figure><center><h1>工作原理</h1></center>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。<p><strong>以下是 HTTP 请求/响应的步骤：</strong><br>1、客户端连接到Web服务器<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn">http://www.oakcms.cn</a>。</p><p>2、发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p><p>3、服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p><p>4、释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p><p>5、客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p><p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p><ol><li><p>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p></li><li><p>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</p></li><li><p>浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</p></li><li><p>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p></li><li><p>释放 TCP连接;</p></li><li><p>浏览器将该 html 文本并显示内容;</p></li></ol><center><h1>GET和POST请求的区别</h1></center><p>GET请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;books&#x2F;?sex&#x3D;man&amp;name&#x3D;Professional HTTP&#x2F;1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko&#x2F;20050225 Firefox&#x2F;1.0.1</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure><p>POST请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko&#x2F;20050225 Firefox&#x2F;1.0.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name&#x3D;Professional%20Ajax&amp;publisher&#x3D;Wiley</span><br></pre></td></tr></table></figure><h3>提交数据的位置</h3>- GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&连接；例 如：`login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0 %E5%A5%BD`如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。<ul><li>POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据</li></ul><p><strong>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</strong></p><h3>传输数据的大小</h3>首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。而在实际开发中存在的限制主要有：<ul><li><p>GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。因此对于GET提交时，传输数据就会受到URL长度的限制。</p></li><li><p>POST:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p></li></ul><h3>安全性</h3><p>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击</p><h3>Http get,post,soap协议都是在http上运行的</h3><ul><li><p>get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的<br>查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全</p></li><li><p>post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。<br>但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。</p></li><li><p>soap：是http post的一个专用版本，遵循一种特殊的xml消息格式<br>Content-type设置为: text/xml 任何数据都可以xml化。</p></li></ul><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。<strong>GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</strong></p><h3>GET和POST的区别总结</h3><ul><li><p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</p></li><li><p>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p></li><li><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p></li><li><p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p></li></ul><center><h1>Cookie</h1></center>Cookie（复数形态Cookies），又称为“小甜饼”。类型为“小型文本文件”[1]，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。由网景公司的前雇员卢·蒙特利在1993年3月发明[2]。最初定义于RFC 2109。目前使用最广泛的 Cookie标准却不是RFC中定义的任何一个，而是在网景公司制定的标准上进行扩展后的产物。<p>因为HTTP协议是无状态的，即服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。</p><p>在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。</p><p>Cookie另一个典型的应用是当登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器<strong>发送了包含登录凭据（用户名加密码的某种加密形式）的Cookie到用户的硬盘上</strong>。第二次登录时，如果该Cookie尚未到期，浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。</p><center><h1>Session</h1></center>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session]]></content>
      
      
      <categories>
          
          <category> Web Sercurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Common Web Vulnerabilities: Causes, Damage and Defense</title>
      <link href="2020/09/18/Common-Web-Vulnerabilities-Causes-Damage-and-Defense/"/>
      <url>2020/09/18/Common-Web-Vulnerabilities-Causes-Damage-and-Defense/</url>
      
        <content type="html"><![CDATA[<center><h1>注入Injection</h1></center>Injection flaws, such as **SQL**, **NoSQL**, **OS**, and **LDAP** injection, occur when untrusted data is sent to an interpreter as part of a command or query. The attacker’s hostile(怀有敌意的) data can trick the interpreter into **executing unintended commands** or **accessing data without proper authorization**.<h2>Causes</h2>刚刚讲过当我们访问动态网页时, Web 服务器会向数据访问层发起 Sql 查询请求，如果权限验证通过就会执行 Sql 语句。这种网站**内部直接发送的Sql请求一般不会有危险**，但实际情况是很多时候需要**结合用户的输入数据动态构造 Sql 语句**，如果用户输入的数据被构造成恶意 Sql 代码，Web 应用又未对动态构造的 Sql 语句使用的参数进行审查，则会带来意想不到的危险。程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。<p>具体可阐述如下：</p><ol><li>WEB开发人员无法保证所有的输入都已经过滤</li><li>攻击者利用发送给SQL服务器的输入参数构造可执行的SQL代码（可加入到get请求、post请求、http头信息、cookie中）</li><li>数据库未做相应的安全配置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">个人总结：</span><br><span class="line">网页需要根据用户输入动态构造SQL语句的时候，如果过滤之类的安全工作没做好，就会导致恶意代码执行、绕过认证、数据泄露等危害。</span><br></pre></td></tr></table></figure><h2>Damage</h2><ul><li>数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息。</li><li>绕过认证，列如绕过验证登录网站后台。</li><li>注入可以借助数据库的存储过程进行提权等操作</li><li>网页篡改：通过操作数据库对特定网页进行篡改。</li><li>网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。</li><li>数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。</li><li>服务器被远程控制，被安装后门。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。</li><li>破坏硬盘数据，瘫痪全系统。</li></ul><h2>Defense</h2>是开发人员应该思考的问题，作为测试人员，了解如何预防SQL注入，可以在发现注入攻击bug时，对bug产生原因进行定位。<ol><li><p>严格检查输入变量的类型和格式<br>对于整数参数，加判断条件：不能为空、参数类型必须为数字<br>对于字符串参数，可以使用正则表达式进行过滤：如：必须为[0-9a-zA-Z]范围内的字符串</p></li><li><p>过滤和转义特殊字符<br>例如：引号、双引号、斜杠、反斜杠、冒号、 空字符等的字符<br>过滤的对象: 用户的输入 | 提交的URL请求中的参数部分 | 从cookie中得到的数据<br>在username这个变量前进行转义，对’、&quot;、\等特殊字符进行转义，如：php中的addslashes()函数对username参数进行转义</p></li><li><p>利用mysql的预编译机制<br>把sql语句的模板（变量采用占位符进行占位）发送给mysql服务器，mysql服务器对sql语句的模板进行编译，编译之后根据语句的优化分析对相应的索引进行优化，在最终绑定参数时把相应的参数传送给mysql服务器，直接进行执行，节省了sql查询时间，以及mysql服务器的资源，达到一次编译、多次执行的目的，除此之外，还可以防止SQL注入。具体是怎样防止SQL注入的呢？实际上当将绑定的参数传到mysql服务器，mysql服务器对参数进行编译，即填充到相应的占位符的过程中，做了转义操作。</p></li><li><p>监测方面目前大多都是日志监控+WAF（统一的filter）,部署防SQL注入系统或脚本</p></li><li><p>数据库日志容易解析,语法出错的、语法读Info表的建立黑白名单机制</p></li></ol><h2>References</h2><a href="https://blog.csdn.net/github_36032947/article/details/78442189?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160042717419195162113454%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160042717419195162113454&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_blog_v1-1-78442189.pc_v2_rank_blog_v1&utm_term=SQL%E6%B3%A8%E5%85%A5&spm=1018.2118.3001.4187">SQL注入攻击常见方式及测试方法</a><a href></a><center><h1>失效的身份认证Broken Authentication</h1></center>Application functions related to authentication and session management are often implemented incorrectly, allowing attackers to compromise passwords, keys, or session tokens, or to exploit other implementation flaws to assume(篡夺) other users’ identities temporarily or permanently.<h2>前言：名词解释</h2>Web应用程序使用的HTTP协议是一种**无连接**，**无状态**协议。<p>无连接是指限制每次连接只处理一个请求，服务器处理完成客户的请求，收到客户的应答之后，即断开连接，可以节省传输时间</p><p>无状态是指对于事物处理没有记忆功能，服务器不知道客户端是什么状态。即用户给服务器发送HTTP请求之后，服务器根据请求，将数据发送给用户，但是发送完成之后，不会记录任何信息。</p><p>也就是说，服务器无法保留连接到网站的每个客户端（用户）的身份/活动的内存。那么试想，每次我们登录一个网站，如果意外关闭了，就得重新登录，使用起来会非常不便。<strong>Cookie和Session因此诞生，解决无记录状态的问题</strong>。</p><h3>Session</h3>Session负责在**服务器端**记录用户信息，在一个用户完成身份认证之后，存储所需要的用户资料，用于持久保存网站的活动。**服务器使用唯一的会话令牌产生对应的会话ID**<h3>Cookie</h3>Cookie由服务器发送并存储在**客户端**，在用户访问网站的时候创建，**用以跟踪用户在网站中的活动**，每次请求客户端都需要把它发送给服务器。当用户意外中断后，由于Cookie的存在就可以从中断的地方继续。<h3>身份认证</h3>身份认证最常用于系统登录，形式一般为**用户名和密码登录**方式，在安全性要求较高的情况下，还有验证码、客户端证书、Ukey等<h3>会话管理</h3>**HTTP利用会话机制来实现身份认证**，HTTP身份认证的结果往往是**获得一个令牌并放在cookie中，之后的身份识别只需读授权令牌，而无需再次进行登录认证**<h2>Causes</h2><ul><li>用户身份验证凭据在存储时不受保护</li><li>登录凭证可以被猜测或重写</li><li>会话ID直接暴露在URL中</li><li>会话ID容易收到会话固定攻击</li><li>会话ID不会超时失效，或者用户会话或身份验证令牌在注销时未失效</li><li>会话ID在登录成功之后不会轮换</li><li>密码，会话ID或者其他的登录凭据未经过加密传输</li></ul><h2>Attack</h2><ul><li><p>弱口令：弱口令的危害不言而喻，通常指的是仅包含简单的数字和字母组合的口令</p></li><li><p>口令破解：掌握了口令的组合方式或是加密细节</p></li><li><p>Cookie窃取&amp;伪造&amp;绕过：因为Cookie是存储在客户端的，相对而言容易被攻击者窃取</p></li><li><p>越权访问：分为垂直越权访问和水平越权访问，垂直越前访问是指不同用户级别之间的越权，比如普通用户能够执行管理员用户的权限。水平越权即同一级别用户之间的越权操作</p></li><li><p>会话固定：一种诱骗受害者使用攻击者拟定的Session ID的攻击手段，通过让合法用户使用攻击者设置的Session ID进行登录，使得web应用不在生成新的Session ID</p></li><li><p>会话劫持：就是在一次正常的通信过程中，攻击者作为第三方参与到其中，或者是在数据里加入其他信息，甚至将双方的通信模式暗中改变，即从直接联系变成有攻击者参与的联系。简单的说，就是攻击者把自己插入到受害者和目标机器之间，并设法让受害者和目标机器之间的数据通道变为受害者和目标机器之间存在一个看起来像“中转站”的代理机器（攻击者的机器）的数据通道，从而干涉两台机器之间的数据传输，例如监听敏感数据、替换数据等。由于攻击者已经介入其中，他能轻易知道双方传输的数据内容，还能根据自己的意愿去左右它。这个“中转站”可以是逻辑上的，也可以是物理上的，关键在于它能否获取到通信双方的数据。</p></li></ul><h2>Damage</h2><ul><li>窃取用户凭证和会话信息</li><li>恶意用户冒充用户身份查看或者变更记录，甚至执行事务</li><li>访问未授权的页面和资源</li><li>执行超越权限操作</li></ul><h2>Defense</h2><ul><li>在可能的情况下，实现多因素身份验证，以防止自动、凭证填充、暴力破解和被盗凭据再利用攻击。</li><li>不要使用发送或部署默认的凭证，特别是管理员用户。</li><li>执行弱密码检查，例如测试新或变更的密码，以纠正“排名前10000个弱密码” 列表。</li><li>将密码长度、复杂性和循环策略与NIST-800-63 B的指导方针的5.1.1章节-记住秘密，或其他现代的基于证据的密码策略相一致。</li><li>确认注册、凭据恢复和API路径，通过对所有输出结果使用相同的消息，用以抵御账户枚举攻击。</li><li>限制或逐渐延迟失败的登录尝试。记录所有失败信息并在凭据填充、暴力破解或其他攻击被检测时提醒管理员。</li><li>使用服务器端安全的内置会话管理器，在登录后生成高度复杂的新随机会话ID。会话ID不能在URL中，可以安全地存储和当登出、闲置、绝对超时后使其失效。</li></ul><h2>References</h2><a href="https://www.cnblogs.com/CH42e/p/13162177.html">A2 失效的身份认证和会话管理</a><center><h1>敏感数据泄露Sensitive Data Exposure</h1></center>Many web applications and APIs do not properly protect sensitive data, such as financial, healthcare, and PII. Attackers may steal or modify such weakly protected data to conduct credit card fraud, identity theft, or other crimes. Sensitive data may be compromised without extra protection, such as encryption at rest or in transit, and requires special precautions when exchanged with the browser.<h2>Causes</h2><p>对敏感数据的弱保护，具体原因如：</p><ul><li>错误的云存储配置</li><li>未受保护的代码存储库</li><li>易受攻击的开源软件</li></ul><h2>Damage</h2><p>利用敏感信息可以：</p><ul><li>信用卡欺诈</li><li>身份偷窃</li><li>等等</li></ul><h2>Defense</h2>对一些需要加密的敏感数据，应该起码做到以下几点：- 对系统处理、存储或传输的数据分类，并根据分类进行访问控制。- 熟悉与敏感数据保护相关的法律和条例，并根据每项法规要求保护敏感数据。- 对于没必要存放的、重要的敏感数据，应当尽快清除，或者通过PCI DSS标记或拦截。未存储的数据不能被窃取。- 确保存储的所有敏感数据被加密。- 确保使用了最新的、强大的标准算法或密码、参数、协议和密匙，并且密钥管理到位。- 确保传输过程中的数据被加密，如：使用TLS。确保数据加密被强制执行，如：使用HTTP严格安全传输协议（HSTS ）。- 禁止缓存对包含敏感数据的响应。- 确保使用密码专用算法存储密码，如：Argon2 、 scrypt 、bcrypt 或者PBKDF2 。将工作因素（延迟因素）设置在可接受范围。- 单独验证每个安全配置项的有效性。<center><h1>XML外部实体 XML External Entities (XXE)</h1></center>Many older or poorly configured XML processors evaluate external entity references within XML documents. External entities can be used to disclose internal files using the file URI handler, internal file shares, internal port scanning, remote code execution, and denial of service attacks.XML外部实体攻击是一种针对解析XML格式应用程序的攻击类型之一。此类攻击发生在当配置不当的XML解析器处理指向外部实体的文档时，可能会导致敏感文件泄露、拒绝服务攻击、服务器端请求伪造、端口扫描（解析器所在域）和其他系统影响。<h2>What is XML？</h2>XML由3个部分构成，它们分别是：文档类型定义（Document Type Definition，DTD），即XML的布局语言；可扩展的样式语言（Extensible Style Language，XSL），即XML的样式表语言；以及可扩展链接语言（Extensible Link Language，XLL）。<p>XML:可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。它被设计用来传输和存储数据(而不是储存数据),可扩展标记语言是一种很像超文本标记语言的标记语言。它的设计宗旨是传输数据，而不是显示数据。它的标签没有被预定义。您需要自行定义标签。它被设计为具有自我描述性。它是W3C的推荐标准。</p><p>可扩展标记语言(XML)和超文本标记语言(HTML)为不同的目的而设计</p><p>它被设计用来传输和存储数据，其<strong>焦点是数据的内容</strong>。</p><p>超文本标记语言被设计用来显示数据，其焦点是数据的外观</p><p>XML使用元素和属性来描述数据。在数据传送过程中，XML始终保留了诸如父/子关系这样的数据结构。几个应用程序 可以共享和解析同一个XML文件，不必使用传统的字符串解析或拆解过程。 相反，普通文件不对每个数据段做描述(除了在头文件中)，也不保留数据关系结构。使用XML做数据交换可以使应用程序更具有弹性，因为可以用位置(与普通文件一样)或用元素名(从数据库)来存取XML数据。</p><h2>XML的实体</h2>XML 中的实体分为以下五种：字符实体，命名实体，外部实体，参数实体，内部实体，普通实体和参数实体都分为内部实体和外部实体两种，外部实体定义需要加上** SYSTEM关键字**，其内容是URL所指向的外部文件实际的内容。如果不加SYSTEM关键字，则为内部实体，表示实体指代内容为字符串。<h2>Causes</h2>XXE注入，即XML External Entity，XML外部实体注入。通过 XML 实体，”SYSTEM”关键词导致 XML 解析器可以从本地文件或者远程 URI 中读取数据。所以攻击者可以通过 XML 实体传递自己构造的恶意值，是处理程序解析它。当引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。<p>既然XML可以从外部读取DTD文件，那我们就自然地想到了如果将路径换成另一个文件的路径，那么服务器在解析这个XML的时候就会把那个文件的内容赋值给SYSTEM前面的根元素中，只要我们在XML中让前面的根元素的内容显示出来，不就可以读取那个文件的内容了。这就造成了一个任意文件读取的漏洞。</p><p>那如果我们指向的是一个内网主机的端口呢？是否会给出错误信息，我们是不是可以从错误信息上来判断内网主机这个端口是否开放，这就造成了一个内部端口被探测的问题。另外，一般来说，服务器解析XML有两种方式，一种是一次性将整个XML加载进内存中，进行解析；另一种是一部分一部分的、“流式”地加载、解析。如果我们递归地调用XML定义，一次性调用巨量的定义，那么服务器的内存就会被消耗完，造成了拒绝服务攻击。</p><h2>Damage</h2><ul><li><p>检索文件，其中定义了包含文件内容的外部实体，并在应用程序的响应中返回。</p></li><li><p>执行SSRF攻击，其中外部实体是基于后端系统的URL定义的，如：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY xxe SYSTEM &quot;http:&#x2F;&#x2F;127.0.0.1:8080&quot; &gt;探测端口；</span><br><span class="line"></span><br><span class="line"> &lt;!ENTITY xxe SYSTEM &quot;expect:&#x2F;&#x2F;id&quot; &gt;执行命令；</span><br></pre></td></tr></table></figure><ul><li><p>敏感文件泄露:无回显读取本地敏感文件(Blind OOB XXE)，敏感数据从应用服务器传输到攻击者的服务器上。</p></li><li><p>通过Blind XXE错误消息检索数据是否存在，攻击者可以触发包含敏感数据的解析错误消息。<br>具体的攻击手段和场景在案例中说明。</p></li><li><p>拒绝服务攻击</p></li><li><p>服务器端请求伪造</p></li><li><p>端口扫描（解析器所在域）</p></li></ul><h2>Defense</h2><p>开发人员培训是识别和减少XXE缺陷的关键，此外，防止XXE 缺陷还需要：</p><ul><li>尽可能使用简单的数据格式（如：JSON），避免对敏感数据进行序列化。</li><li>及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。同时，通过依赖项检测，将SOAP更新到1.2版本或更高版本。</li><li>参考《 OWASP Cheat Sheet ‘XXE Prevention‘ 》，在应用程序的所有XML解析器中禁用XML外部实体和DTD进程。</li><li>在服务器端实施积极的（“白名单”）输入验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据。</li><li>验证XML或XSL文件上传功能是否使用XSD验证或其他类似验证方法来验证上传的XML文件。</li><li>尽管在许多集成环境中，手动代码审查是大型、复杂应用程序的最佳选择，但是SAST 工具可以检测源代码中的XXE漏洞。</li><li>如果无法实现这些控制，请考虑使用虚拟修复程序、API安全网关或Web应用程序防火墙（ WAF ）来检测、监控和防止XXE攻击。</li></ul><h2>References</h2>https://www.cnblogs.com/backlion/p/9302528.html<center><h1>失效的访问控制Broken Access Control</h1></center>Restrictions on what authenticated users are allowed to do are often not properly enforced. Attackers can exploit these flaws to access unauthorized functionality and/or data, such as access other users’ accounts, view sensitive files, modify other users’ data, change access rights, etc.<h2>Causes</h2>大多数Web页面需要验证功能级别的访问权限。但是，服务器需要在每个功能被访问时在服务器端执行相同的访问控制检查。如果请求没有被验证，攻击者能够伪造请求以在未经适当授权时访问某些页面。<h2>Damage</h2><ul><li>访问其他用户的账号</li><li>浏览敏感文件：文件包含/目录遍历<br>许多web应用使用文件管理作为它们日常操作的一部分。但他们使用没有被好好设计的输入验证方法，攻击者可以利用（这个漏洞）来修改或写入文件，甚至执行任意代码。</li><li>修改其他用户数据</li><li>改变访问权限、权限绕过（水平越权）<br>用户未经过身份验证访问资源，或注销后仍可访问资源，对不同用户访问的资源没有做很好的校验，如标准用户可访问管理员资源，或访问其他用户私有资源等。</li><li>权限提升（垂直越权）<br>权限提升是指用户权限从一个阶段提升到另一个阶段的问题，当用户访问的资源比通常情况下访问到的资源更多时，就发生了权限提示漏洞，应用程序应该阻止该权限提升或更改。权限提升一般是由于应用程序自身的缺陷引起的，最后导致程序执行的操作拥有比开发人员或系统管理员预期更多的权限。</li><li>不安全直接对象的引用<br>当应用程序根据用户提供的输入提供对对象的直接访问时，会发生不安全的直接对象引用。 攻击者可以直接绕过授权并访问系统中的资源，例如数据库记录或文件。</li></ul><p>由于应用程序获取用户提供的输入并使用它来检索对象而不执行足够的授权检查。不安全的直接对象引用允许攻击者通过修改用于直接指向对象的参数值来直接绕过授权和访问资源。这些资源可以是属于其他用户的数据库条目，系统中的文件等。</p><h2>Defense</h2><p>访问控制只有在受信服务器端代码或没有服务器的 API 中有效，这样这样攻击者才无法修改访问控制检查或元数据。</p><ul><li>除公有资源外，默认情况下拒绝访问。</li><li>使用一次性的访问控制机制，并在整个应用程序中不断重用它们，包括最小化CORS使用。</li><li>建立访问控制模型以强制执行所有权记录，而不是接受用户创建、读取、更新或删除的任何记录。</li><li>域访问控制对每个应用程序都是唯一的，但业务限制要求应由域模型强制执行。</li><li>禁用 Web服务器目录列表，并确保文件元数据（如：git）不存在于 Web的根目录中。</li><li>记录失败的访问控制，并在适当时向管理员告警（如：重复故障）。</li><li>对API和控制器的访问进行速率限制，以最大限度地降低自动化攻击工具的危害。</li><li>当用户注销后，服务器上的JWT令牌应失效。开发人员和 QA人员应包括功能访问控制单元和集成测试人员。</li><li>基于角色的访问控制（RBAC）<br>在基于角色的访问控制（RBAC）中，访问决策基于个人在组织或用户群中的角色和职责。<br>定义角色的过程通常基于分析组织的基本目标和结构，并且通常与安全策略相关联。例如，在医疗机构中，用户的不同角色可能包括医生，护士，服务员，护士，患者等等。显然，这些成员需要不同级别的访问才能执行其功能，但也需要根据安全政策和任何相关法规（HIPAA，Gramm-Leach-Bliley等）。<br>RBAC访问控制框架应该为Web应用程序安全管理员提供确定的“谁可以执行哪些操作，何时，从何处，以何种顺序以及在某些情况下在什么关系环境下“执行操作的能力。</li></ul><center><h1>安全配置错误Security Misconfiguration</h1></center>Security misconfiguration is the most commonly seen issue. This is commonly a result of insecure default configurations, incomplete or ad hoc configurations, open cloud storage, misconfigured HTTP headers, and verbose error messages containing sensitive information. Not only must all operating systems, frameworks, libraries, and applications be securely configured, but they must be patched/upgraded in a timely fashion.<h2>Causes</h2><ul><li>不安全的默认配置</li><li>不完整的或自组织配置</li><li>开放云存储</li><li>HTTP头的错误配置</li><li>包含敏感信息的冗余错误信息</li></ul><h2>Damage</h2><p>这些漏洞使攻击者能经常访问一些未授权的系统数据或功能。有时，这些漏洞导致系统的完全攻破。业务影响取决于应用程序和数据的保护需求。</p><h2>Defense</h2><p>应实施安全的安装过程，包括：</p><ul><li>一个可以快速且易于部署在另一个锁定环境的可重复的加固过程。开发、质量保证和生产环境都应该进行相同配置，并且，在每个环境中使用不同的密码。这个过程应该是自动化的，以尽量减少<br>安装一个新安全环境的耗费。</li><li>搭建最小化平台，该平台不包含任何不必要的功能、组件、文档和示例。移除或不安装不适用的功能和框架。</li><li>检查和修复安全配置项来适应最新的安全说明、更新和补丁，并将其作为更新管理过程的一部分，（参见A9：2017-使用含有已知漏洞的组件）。在检查过程中，应特别注意云存储权限（如：S3桶权限）。</li><li>一个能在组件和用户间提供有效的分离和安全性的分段应用程序架构，包括：分段、容器化和云安全组。</li><li>向客户端发送安全指令，如：安全标头。</li><li>在所有环境中能够进行正确安全配置和设置的自动化过程。</li></ul><center><h1>跨站脚本Cross-Site Scripting（XSS）</h1></center>XSS flaws occur whenever an application **includes untrusted data in a new web page without proper validation or escaping**, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. XSS allows attackers to execute scripts in the victim’s browser which can hijack（劫持） user sessions, deface web sites, or redirect the user to malicious sites.<h2>Causes</h2><p>在一个新网页中不带验证和绕过地包含不信任的数据，或者用用户提供的数据通过浏览器接口来更新已有网页（可以创建HTML或JS）</p><h2>Damage</h2><ul><li>劫持用户会话</li><li>毁坏网站</li><li>将用户重定向到恶意网站</li></ul><h2>Defense</h2><p>防止XSS需要将不可信数据与动态的浏览器内容区分开。这可以通过如下步骤实现：</p><ul><li>使用设计上就会自动编码来解决XSS问题的框架，如：Ruby 3.0或 React JS。了解每个框架的XSS保护的局限性，并适当地处理未覆盖的用例。</li><li>为了避免反射式或存储式的XSS漏洞，最好的办法是根据HTML输出的上下文（包括：主体、属性、JavaScript、CSS或URL）</li><li>对所有不可信的HTTP请求数据进行恰当的转义 。更多关于数据转义技术的信息见：《OWASP Cheat Sheet ‘XSS Prevention’》</li><li>在客户端修改浏览器文档时，为了避免DOM XSS攻击，最好的选择是实施上下文敏感数据编码。如果这种情况不能避免，可以采用《OWASP Cheat Sheet ‘DOM based XSS Prevention ‘》描述的类似上下文敏感的转义技术应用于浏览器API。</li><li>使用内容安全策略（CSP）是对抗XSS的深度防御策略。如果不存在可以通过本地文件放置恶意代码的其他漏洞（例如：路径遍历覆盖和允许在网络中传输的易受攻击的库），则该策略是有效的。</li></ul><center><h1>不安全的反序列化Insecure Deserialization</h1></center>Insecure deserialization often leads to remote code execution. Even if deserialization flaws do not result in remote code execution, they can be used to perform attacks, including replay attacks, injection attacks, and privilege escalation attacks.<h2>什么是序列化/反序列化？</h2>序列化（serialization）在计算机科学的资料处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">个人理解：</span><br><span class="line">序列化：对象到字节流；反序列化：字节流到对象</span><br></pre></td></tr></table></figure><h2>Causes</h2>PHP 的反序列化漏洞也叫PHP 对象注⼊，是⼀个⾮常常⻅的漏洞，这种漏洞充某些场景下虽然有些难以利⽤，但是⼀旦利⽤成功就会造成⾮常危险的后果。<p>漏洞形成的根本原因就是程序没有对⽤户输⼊的反序列化字符串进⾏检测，导致反序列化过程可以被恶意控制，进⽽造成代码执⾏、GetShell 等⼀系列不可控的后果。反序列化漏洞并不是PHP 特有的，也存在与Java、Python 语⾔中。其原理基本相同。在Java反序列化中，会调用被反序列化的readObject方法，当readObject方法书写不当时就会引发漏洞</p><h2>Damage</h2><ul><li>远程代码执行</li><li>重放攻击</li><li>注入攻击</li><li>提权攻击</li></ul><h2>Defense</h2><p>唯一安全的架构模式是不接受来自不受信源的序列化对象，或使用只允许原始数据类型的序列化媒体。<br>如果上述不可能的话，考虑使用下述方法：</p><ul><li>执行完整性检查，如：任何序列化对象的数字签名，以防止恶意对象创建或数据篡改。</li><li>在创建对象之前强制执行严格的类型约束，因为代码通常被期望成一组可定义的类。绕过这种技术的方法已经被证明，所以完全依赖于它是不可取的。</li><li>如果可能，隔离运行那些在低特权环境中反序列化的代码。</li><li>记录反序列化的例外情况和失败信息，如：传入的类型不是预期的类型，或者反序列处理引发的例外情况。</li><li>限制或监视来自于容器或服务器传入和传出的反序列化网络连接。</li><li>监控反序列化，当用户持续进行反序列化时，对用户进行警告。</li></ul><center><h1>使用含有已知漏洞的组件Using Components with Known Vulnerabilities</h1></center><p>Components, such as libraries, frameworks, and other software modules, run with the same privileges as the application. If a vulnerable component is exploited, such an attack can facilitate serious data loss or server takeover. Applications and APIs using components with known vulnerabilities may undermine application defenses and enable various attacks and impacts.</p><h2>Causes</h2>用了含有漏洞的库、框架、软件模块等等<h2>Damage</h2>破坏应用程序的安全防护，让各种攻击得以执行<h2>Defense</h2>应该制定一个补丁管理流程：1. 移除不使用的依赖、不需要的功能、组件、文件和文档。2. 利用如 versions、DependencyCheck 、retire.js等工具来持续的记录客户端和服务器端以及它们的依赖库的版本信息。持续监控如CVE 和 NVD等是否发布已使用组件的漏洞信息，可以使用软件分析工具来自动完成此功能。订阅关于使用组件安全漏洞的警告邮件。3. 仅从官方渠道安全的获取组件，并使用签名机制来降低组件被篡改或加入恶意漏洞的风险4. 监控那些不再维护或者不发布安全补丁的库和组件。如果不能打补丁，可以考虑部署虚拟补丁来监控、检测或保护。5. 每个组织都应该制定相应的计划，对整个软件生命周期进行监控、评审、升级或更改配置。<center><h1>不足的日志记录和监控Insufficient Logging & Monitoring</h1></center>Insufficient logging and monitoring, coupled with missing or ineffective integration with incident response, allows attackers to further attack systems, maintain persistence, pivot（以……为中心旋转） to more systems, and tamper, extract, or destroy data. Most breach studies show time to detect a breach is over 200 days, typically detected by external parties rather than internal processes or monitoring.<h2>Causes</h2>不足的日志和监控系统，缺失的或无效的事件相应<h2>Damage</h2>让攻击者可以更深入地攻击系统，毁坏数据<h2>Defense</h2>根据应用程序存储或处理的数据的风险：:- 确保所有登录、访问控制失败、输入验证失败能够被记录到日志中去，并保留足够的用户上下文信息，以识别可疑或恶意帐户，并为后期取证预留足够时间。- 确保日志以一种能被集中日志管理解决方案使用的形式生成- 确保高额交易有完整性控制的审计信息，以防止篡改或删除，例如审计信息保存在只能进行记录增加的数据库表中。- 建立有效的监控和告警机制，使可疑活动在可接受的时间内被发现和应对。- 建立或采取一个应急响应机制和恢复计划，例如：NIST 800-61 rev 2或更新版本。<p>目前已有商业的和开源的应用程序防护框架（例如：OWASP AppSensor）、Web应用防火墙（例如 ：Modsecurity with the OWASP Core Rule Set）、带有自定义仪表盘和告警功能的日志关联软件。</p>]]></content>
      
      
      <categories>
          
          <category> Web Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web Vulnerabilities </tag>
            
            <tag> Flaw </tag>
            
            <tag> OWASP TOP 10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Software Security First Class</title>
      <link href="2020/09/14/Software-Security-First-Class/"/>
      <url>2020/09/14/Software-Security-First-Class/</url>
      
        <content type="html"><![CDATA[<h4>课外小说与视频</h4>零日<h4>调研报告</h4>暗网]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter1 网络安全引言</title>
      <link href="2020/09/14/Chapter1-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%BC%95%E8%A8%80/"/>
      <url>2020/09/14/Chapter1-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%BC%95%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<center><h1>1.1 计算机安全概念</h1></center><h4>计算机安全</h4>用于保护数据安全和防范黑客的工具集合的通用名称<h4>网络（互联网）安全</h4>分布式系统的引入、网络以及在计算机终端用户与计算机之间、计算机与计算机之间进行通信的工具应用，其中都包含数据传输，需要网络安全措施来保护数据。<h2>1.1.1 计算机安全定义</h2>对某个自动化信息系统的保护措施，其目的在于实现信息系统资源的**完整性**、**可用性**以及**机密性**（包括硬件、软件、固件、信息/数据、电信）。<h5>完整性</h5>1. 数据完整性：只能通过已授权的方式来更改数据2. 系统完整性：保证系统只做它被期待做的事，不会被奇怪的东西控制<h5>机密性</h5>1. 数据机密性：隐私数据不泄漏给未授权的个体2. 隐私性：每个人可以控制自己的信息<p>这三者取英文首字母组成CIA三元组。</p><p>另外，也有人说可以加入真实性、可计量性的概念。</p><h2>1.1.2 计算机安全挑战</h2>见书P5-6<center><h1>1.2 OSI安全体系结构</h1></center>OSI模型关注的包括以下三个方面：<h5>1. 安全攻击</h5><h5>2. 安全机制</h5>检测、防范与恢复<h5>3. 安全服务</h5>加强安全性，防范攻击<p>关于威胁和攻击：个人觉得威胁是潜在危险，攻击是破坏手段</p><center><h1>1.3 安全攻击</h1></center>可以分为两大类：主动和被动攻击<h2>1.3.1 被动攻击</h2><h5>内容</h5>本质：窃听或监视<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
          <category> 《网络安全基础：应用与标准（E5）》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problems during Solving 2020CUMCM-A</title>
      <link href="2020/09/10/Problems-during-Solving-2020CUMCM-A/"/>
      <url>2020/09/10/Problems-during-Solving-2020CUMCM-A/</url>
      
        <content type="html"><![CDATA[<center><h1>待查问题</h1></center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">怎么根据相邻温区之间的温度求温区间隙和边缘的温度？</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">什么关系？怎么预测？</span><br></pre></td></tr></table></figure><center><h1>可参考网址</h1></center><p><a href="https://zh.wikipedia.org/wiki/%E7%86%B1%E5%82%B3%E5%B0%8E%E6%96%B9%E7%A8%8B%E5%BC%8F">热传导方程式简介</a><br><a href="https://www.youtube.com/watch?v=Zw53kxy7yL0">回流炉视频</a><br><a href="https://www.youtube.com/watch?v=xn_oN8ZMaMk">回流炉原理更清晰</a><br><a href="https://www.youtube.com/watch?v=NQiAcJxYfAs">回流炉视频2</a><br><a href="https://www.youtube.com/watch?v=q37g3RflFQ0">物体走过对应温度曲线变化</a><br><a href="https://www.youtube.com/watch?v=4pVUMda2prQ">物体走过对应温度曲线变化2-best oven setup</a><br><a href="https://blog.51cto.com/9269309/1865554">牛顿冷却定律</a><br><a href></a><br><a href></a><br><a href></a><br><a href></a></p><center><h1>名词解释</h1></center><h3>PCB</h3>印刷电路板，又称印制电路板，印刷线路板，常用英文缩写PCB（Printed circuit board）或PWB（Printed wire board），是电子元件的支撑体，在这其中有金属导体作为连接电子元器件的线路。<p>reflow oven</p><p>reflow profile</p><p>soldering  焊接</p><p>SMT<br>SMT贴片指的是在PCB基础上进行加工的系列工艺流程的简称，PCB（Printed Circuit Board)为印刷电路板。SMT是表面组装技术（表面贴装技术）（Surface Mounted Technology的缩写），是电子组装行业里最流行的一种技术和工艺。</p><p>非稳态导热</p><p>导热和热传导的区别<br>材料直接传导热量的能力称为热传导率,或称热导率.热导率定义为单位截面、长度的材料在单位温差下和单位时间内直接传导的热量.热导率的单位为瓦每米每开尔文((W/m.K)). 导热率:物体传导热量的能力,又称为热导率 . 所以,我感觉你提出这两个概念没有区别</p><h3>辨析几个概念</h3>这些公式的适用范围？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">牛顿冷却定律</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">傅里叶导热定律</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">热传导与导热</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">牛顿冷却定律</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">稳态导热</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">非稳态导热</span><br></pre></td></tr></table></figure><center><h1>或许可用的公式</h1></center><p>热传导方程</p><p>牛顿冷却定律</p><p>傅里叶定律</p><p>Crank − Nicholson 方法</p><center><h1>一些假设</h1></center>1. 只考虑热对流、热传导2. 是从炉前区域就开始的3. 假设是热风回流焊炉，热对流传热为主<center><h1>一些想法</h1></center>]]></content>
      
      
      <categories>
          
          <category> Contest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math Modelling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Database Trigger</title>
      <link href="2020/09/07/Database-Trigger/"/>
      <url>2020/09/07/Database-Trigger/</url>
      
        <content type="html"><![CDATA[<p>触发器类似于约束，但比约束更灵活</p><h2>定义触发器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER &lt;触发器名&gt;</span><br><span class="line">  BEFORE|AFTER &lt;触发事件&gt; ON &lt;表名&gt;</span><br><span class="line">  FOR EACH ROW|STATEMENT</span><br><span class="line">  [WHEN &lt;触发条件&gt;]</span><br><span class="line">  &lt;触发动作体&gt;</span><br></pre></td></tr></table></figure>参数说明：- 表的创建者才能建立触发器，而且一个表上不是无限个- 触发事件：SQL语句动词，另外如UPDATE还可以加上 OF <触发列，...>- 触发器类型：行级：有多少行做多少次；语句级：有多少相关语句做多少次- 触发动作体：可以是AS + PL/SQL块<h2>激活触发器</h2>搞清楚触发器的激活顺序（定义时间先后）<h2>删除触发器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;</span><br></pre></td></tr></table></figure></触发列，...>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Clauses for Database Security</title>
      <link href="2020/09/07/SQL-Clauses-for-Database-Security/"/>
      <url>2020/09/07/SQL-Clauses-for-Database-Security/</url>
      
        <content type="html"><![CDATA[<center><h1>对数据的操作权限</h1></center><h2>授权</h2>GRANT语句：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GRANT &lt;权限&gt; [,&lt;权限&gt;]...</span><br><span class="line">ON &lt;对象类型&gt; &lt;对象名&gt; [,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line">TO &lt;用户&gt; [,&lt;用户&gt;]...</span><br><span class="line">[WITH GRANT OPTION];</span><br><span class="line"></span><br><span class="line">参数解释：</span><br><span class="line">- 权限：SQL语句动词、如UPDATE(Sno)、特定ALL PRIVILEGES......</span><br><span class="line">- 对象：其实一般就是写TABLE table-name这样子，也有直接“视图名”的</span><br><span class="line">- 用户：如U1、特定的PUBLIC.......</span><br><span class="line">- 最后一个可选子句：加上代表获得此权限的用户同时也有给别人授予它的权利</span><br></pre></td></tr></table></figure><h2>回收权限</h2>REVOKE语句：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REVOKE &lt;权限&gt; [,&lt;权限&gt;]...</span><br><span class="line">ON &lt;对象类型&gt; &lt;对象名&gt; [,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line">FROM &lt;用户&gt; [,&lt;用户&gt;]...[CASCADE|RESTRICT];</span><br><span class="line"></span><br><span class="line">参数说明：最后可选的是级联收回或限制操作</span><br></pre></td></tr></table></figure><center><h1>关于数据库模式的权限</h1></center>在DBA创建用户时实现<p>创建用户语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &lt;user-name&gt;</span><br><span class="line">[WITH] [DBA|RESOURCE|CONNECT];</span><br><span class="line"></span><br><span class="line">参数说明：最后括号里的是三种权限，默认最后一个，它们对应的可执行操作见下表</span><br></pre></td></tr></table></figure><p><img src="/2020/09/07/SQL-Clauses-for-Database-Security/%5CSQL-Clauses-for-Database-Security%5Cquan.png" alt></p><center><h1>数据库角色</h1></center>很神奇的是，角色居然是权限的集合（而非用户的集合）可以为拥有相同权限的一组用户创建一个角色<h2>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE ROLE &lt;角色名&gt;；</span><br></pre></td></tr></table></figure><h2>授权</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT &lt;权限&gt; [,&lt;权限&gt;]...</span><br><span class="line">ON &lt;对象类型&gt; &lt;对象名&gt; [,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line">TO &lt;角色&gt; [,&lt;角色&gt;]...</span><br></pre></td></tr></table></figure><h2>用角色授权</h2>因为角色本质是权限，所以我们可以：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT &lt;角色1&gt; [,&lt;角色2&gt;]...</span><br><span class="line">TO &lt;角色3&gt; [,&lt;角色4&gt;]...</span><br><span class="line">[WITH GRANT OPTION]</span><br></pre></td></tr></table></figure><h2>收回角色权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REVOKE &lt;权限&gt; [,&lt;权限&gt;]...</span><br><span class="line">ON &lt;对象类型&gt; &lt;对象名&gt; [,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line">FROM &lt;角色1&gt; [,&lt;角色2&gt;]...;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Database Important&amp;Difficult Exercises Collection</title>
      <link href="2020/09/06/Database-Important-Difficult-Exercises-Collection/"/>
      <url>2020/09/06/Database-Important-Difficult-Exercises-Collection/</url>
      
        <content type="html"><![CDATA[<center><h1>题目</h1></center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">证明：任何一个二目关系都是3NF的</span><br></pre></td></tr></table></figure>正确。因为关系模式中只有两个属性，所以无传递。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">证明：任何一个二目关系都是BCNF的</span><br></pre></td></tr></table></figure><p>正确。按BCNF的定义，若X-&gt;Y,且Y不是X的子集时，<strong>每个决定因素都包含码</strong>（如果不包含，那就有属性依赖于非码属性啦！就是存在传递依赖咯），对于二目关系决定因素必然包含码。详细证明如下：（任何二元关系模式必定是BCNF）。<br>证明：设R为一个二目关系R(A1，A2)，则属性A1和A2之间可能存在以下几种依赖关系：<br>A、A1-&gt;A2，但A2不-&gt;A1，则关系R的码为A1，决定因素都包含码，所以，R是BCNF。<br>B、A1不-&gt;A2，但A2-&gt;A1，则关系R的码为A2，所以决定因素都包含码，R是BCNF。<br>C、R的码为(A1，A2)（即A1-&gt;A2，A2-&gt;A1），决定因素都包含码，为BCNF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">证明：任何一个二目关系都是4NF的</span><br></pre></td></tr></table></figure><p>正确。因为只有两个属性，所以无非平凡的多值依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">判断：</span><br><span class="line">（1）若 R.B→R.A，R.C→R.A，则 R.(B, C)→R.A</span><br><span class="line">（2）若 R.(B, C)→R.A，则 R.B→R.A，R.C→R.A </span><br></pre></td></tr></table></figure><p>（1）正确，貌似还是可以反证的<br>（2）反例：关系模式 SC（S#，C#，G） 其中有（S#，C#）→G，但是S# 不→ G，C#不→G，也就是说少了一些决定因素就不行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">指出下列关系模式是第几范式？并说明理由。</span><br><span class="line">① R（X，Y，Z） F&#x3D;&#123;XY→Z&#125;</span><br><span class="line">② R（X，Y，Z） F&#x3D;&#123;Y→Z，XZ→Y&#125;</span><br><span class="line">③ R（X，Y，Z） F&#x3D;&#123;Y→Z，Y→X，X→Y ， X→ Z&#125;</span><br><span class="line">④ R（X，Y，Z） F&#x3D;&#123;X→Y，X→Z&#125;</span><br><span class="line">⑤ R（W，X，Y，Z） F&#x3D;&#123;X→Z，WX→Y&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">（1）码：（X，Y），主属性：X，Y，非主属性：Z</span><br><span class="line">不存在非主对码的部分函数依赖——2NF</span><br><span class="line">不存在非主对码的传递函数依赖——3NF</span><br><span class="line">每个决定因素都包含码——BCNF</span><br><span class="line">除了平凡的、函数依赖的，没有其他多值依赖——4NF</span><br><span class="line">4NF</span><br><span class="line">（2）码：（X，Z），主属性：X，Z，非主属性：Y</span><br><span class="line">不存在非主对码的部分函数依赖——2NF</span><br><span class="line">不存在非主对码的传递函数依赖——3NF</span><br><span class="line">不是每个决定因素都包含码</span><br><span class="line">3NF</span><br><span class="line">（3）码：X，Y，主属性：X，Y，非主属性：Z</span><br><span class="line">不存在非主对码的部分函数依赖——2NF</span><br><span class="line">不存在非主对码的传递函数依赖——3NF</span><br><span class="line">每个决定因素都包含码——BCNF</span><br><span class="line">除了平凡的、函数依赖的，没有其他多值依赖——4NF</span><br><span class="line">4NF</span><br><span class="line">（4）码：X，主属性：X，非主属性：Y，Z</span><br><span class="line">不存在非主对码的部分函数依赖——2NF</span><br><span class="line">不存在非主对码的传递函数依赖——3NF</span><br><span class="line">每个决定因素都包含码——BCNF</span><br><span class="line">除了平凡的、函数依赖的，没有其他多值依赖——4NF</span><br><span class="line">4NF</span><br><span class="line">（5）码：（W，X），主属性：W，X，非主属性：Y，Z</span><br><span class="line">存在非主对码的部分函数依赖</span><br><span class="line">1NF</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设有关系模式 R(U,F)，其中 U＝ABC，F＝｛A→B，B→C｝，求 F 的闭包 F＋</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">（注：K表示空集）</span><br><span class="line">（1）自反：</span><br><span class="line">k-&gt;K,</span><br><span class="line">A-&gt;K,B-&gt;K,C-&gt;K,</span><br><span class="line">A-&gt;A,B-&gt;B,C-&gt;C,</span><br><span class="line">AB-&gt;K,BC-&gt;K,AC-&gt;K,</span><br><span class="line">AB-&gt;A,AB-&gt;B,BC-&gt;B,BC-&gt;C,AC-&gt;A,AC-&gt;C,</span><br><span class="line">AB-&gt;AB,BC-&gt;BC,AC-&gt;AC,</span><br><span class="line">ABC-&gt;K,</span><br><span class="line">ABC-&gt;A,ABC-&gt;B,ABC-&gt;C,</span><br><span class="line">ABC-&gt;AB,ABC-&gt;BC,ABC-&gt;AC,</span><br><span class="line">ABC-&gt;ABC</span><br><span class="line">（2）增广：</span><br><span class="line">（对于A→B）：A→AB,AB→B,AC→BC</span><br><span class="line">（对于B→C）：AB→AC,B→BC,BC→C</span><br><span class="line">（对于A→C）：A→AC,AB→BC,AC→C</span><br><span class="line">（3）传递：</span><br><span class="line">A-&gt;C,AC-&gt;B,AB-&gt;C</span><br><span class="line"></span><br><span class="line">**如何不重不漏？**</span><br><span class="line">这好像是个NP问题啊....</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对题 6 的关系模式R，求其候选键并判断A→C和B→A是否属于F＋。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">候选键：A</span><br><span class="line">传递律所以A→C属于</span><br><span class="line">B→A不属于</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于关系模式R(ABC)，F={A→BC,BC→A}，求其候选键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">候选键：A，（B，C）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设有关系模式 R(U,F)，其中 U＝ABC，F＝｛A→{B,C},B→C, A→B, {A, B}→C｝，求 Fmin。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第一步：分解右边得到F＝｛A→B,A→C,B→C,&#123;A, B&#125;→C｝</span><br><span class="line">第二步：</span><br><span class="line">对于A→B：A在G上的闭包为&#123;A,C&#125;，不含B，可以保留</span><br><span class="line">对于A→C：A在G上的闭包为&#123;A,B,C&#125;,含C，不保留</span><br><span class="line">对于B→C：B在G上的闭包为&#123;B&#125;,不含C，保留</span><br><span class="line">对于&#123;A, B&#125;→C：AB在G上的闭包为&#123;A,B,C&#125;,含C，不保留</span><br><span class="line">F＝｛A→B,B→C｝</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;center&gt;&lt;h1&gt;一些小疑问&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;</span><br></pre></td></tr></table></figure><p>定义SQL表时，各种数据类型怎么用？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.runoob.com&#x2F;sql&#x2F;sql-datatypes-general.html&quot;&gt;是一个比较全面的整理&lt;&#x2F;a&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SQL语句和用户权限相关的那部分内容？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">见博客“SQL Clauses for Database Security”</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SQL编程这块我感觉还有好多没见过的词？？？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其实那些是PL&#x2F;SQL来的</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据字典和数据库的关系？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据字典实际上是“关于系统数据的数据库”</span><br><span class="line">感觉有点像**元数据**的意思</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有些复杂的引理记不清楚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>几种等价的表达：</p><ol><li>元组表达式</li><li>汉语查询句子</li><li>关系代数表达式（语言）</li><li>域演算表达式（语言）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 集合</span><br><span class="line">2. 中文</span><br><span class="line">3. π、ρ</span><br><span class="line">4. 基于屏幕表格的查询语言</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>触发器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">见博客“Database Trigger”</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>证明的规范写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>模式分解算法要背啊</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">背了！分成两组即可！</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>怎么从求一个函数依赖集在某属性集上的投影？怎么根据属性集求对应的函数依赖集（应该是一个意思）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">![](\Database-Important-Difficult-Exercises-Collection\p.png)</span><br><span class="line">说人话：</span><br><span class="line">假如我们要求F在U上的投影</span><br><span class="line">可以首先在F中剔掉那些左边X或右边Y不包含于U的函数依赖式，余下的应该就可以</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂的查询用SQL有点绕不来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">其实有时候，多层嵌套也可以用简单粗暴的自然连接连所有来代替，只是后者显然效率不好</span><br><span class="line">除法虽然还是不懂，但是背下来了！</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>几个连接</p><pre><code>笛卡尔积：简单粗暴的排列组合，一个X等值连接：下面有条件自然连接：下面没有条件&lt;center&gt;&lt;h1&gt;一句话知识点&lt;/h1&gt;&lt;/center&gt;1. 数据库系统中，数据独立性是指：应用程序与数据库的结构之间相互独立2. 关系数据库包含：内模式、模式、外模式三级模式；分别对应数据库的存储文件、基表、视图(外模式也就是：子模式/用户模式，是用户看到的数据视图)&lt;center&gt;&lt;h1&gt;要背的知识点&lt;/h1&gt;&lt;/center&gt;1. 数据库系统的特点（物理独立性、逻辑独立性）2. 数据库系统的三级结构模式3. 完整性约束条件4. DBMS主要功能5. 数据管理技术发展过程6. 视图和基表的区别7. SQL特点8. SQL四种语言（?DQMC）9. 数据库设计的基本步骤10. 数据库的维护方法11. 查询处理步骤12. 启发式规则13. 视图的优点&lt;center&gt;&lt;h1&gt;要注意的名词解释&lt;/h1&gt;&lt;/center&gt;&lt;center&gt;&lt;h1&gt;要熟悉的算法&lt;/h1&gt;&lt;/center&gt;1. 判别无损连接性2. 判别保持函数依赖性</code></pre>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Database Programming</title>
      <link href="2020/09/06/Database-Programming/"/>
      <url>2020/09/06/Database-Programming/</url>
      
        <content type="html"><![CDATA[<center><h1>静态嵌入式SQL（ESQL）</h1></center><center><h2>ESQL的通用使用过程</h2></center><h2>基本结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL &lt;SQL语句&gt;;</span><br></pre></td></tr></table></figure><h2>ESQL和主语言的通信</h2>1. 传递SQL语句执行状态：SQL通信区（SQLCA）2. 主语言向SQL语句传参：主变量3. SQL返回结果：主变量+游标<h2>SQL通信区</h2>SQLCA中有一个SQLCODE变量为SUCCESS代表执行成功，否则就是错误代码<p>定义SQLCA</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL INCLUDE SQLCA;</span><br></pre></td></tr></table></figure><h2>主变量</h2>SQL语句中用了主程序中的变量就叫做主变量分为输入主变量（主程序输入到SQL）和输出主变量主变量可以附带一个指示变量，对主变量的值加以说明（比如指示主变量是否为空值）<p>声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">声明主变量、指示变量&#x2F;*变量的定义就和主程序变量一样*&#x2F;</span><br><span class="line">char HSno[9];&#x2F;*比如这样*&#x2F;</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:主&#x2F;指示变量名&#x2F;*前面加冒号！*&#x2F;</span><br></pre></td></tr></table></figure><h2>游标</h2>游标可以看做一个数据缓冲区SQL语句输出->游标->主变量->主程序<p>定义游标（为了一个SQL语句）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL DECLARE [cursor-name] CURSOR FOR</span><br><span class="line">&lt;SQL语句&gt;；</span><br></pre></td></tr></table></figure><p>打开和关闭游标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL OPEN [cursor-name]；</span><br><span class="line"></span><br><span class="line">EXEC SQL CLOSE [cursor-name]；</span><br></pre></td></tr></table></figure><p>从游标中取数据到主变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ( ; ; )&#123;</span><br><span class="line">EXEC SQL FETCH [cursor-name] INTO :主变量1, :主变量2, ......</span><br><span class="line">其他操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>建立和关闭数据库连接</h2><h3>建立连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL CONNECT TO target[AS connection-name][USER user-name]；</span><br><span class="line">参数解释：</span><br><span class="line">- target:要连接的数据库服务器，标识方法有几种</span><br><span class="line">如：&lt;dbname&gt;@&lt;hostname&gt;:&lt;port&gt;</span><br><span class="line">- connection-name：应该就是按标识符的命名规矩来</span><br><span class="line">- </span><br></pre></td></tr></table></figure><h3>修改连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL SET CONNECTION connection-name;</span><br></pre></td></tr></table></figure><h3>关闭连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL DISCONNECT [connection];&#x2F;*这个方括号里的应该就用数据库的名字dbname*&#x2F;</span><br></pre></td></tr></table></figure><h3>关闭连接前可以来个“提交数据库更新”</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL COMMIT WORK;</span><br></pre></td></tr></table></figure><center><h2>不用游标的ESQL</h2></center><h3>查询结果为单记录的SELECT语句</h3>单记录通俗点就是：查询结果只有一行所以我们既不用循环，也不用游标，用一组主变量就可以了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL SELECT x,x,x,x</span><br><span class="line"> INTO :主变量1, :主变量2; :主变量3, :主变量4</span><br><span class="line"> FROM </span><br><span class="line"> WHERE</span><br></pre></td></tr></table></figure><h3>增删改语句</h3>UPDATE/DELETE/INSERT INTO<p>关于指示变量：</p><center><h2>用游标的ESQL</h2></center><h3>查询结果为多条记录的SELECT语句</h3>说明游标、打开游标、循环读记录、关闭游标<h3>CURRENT形式的UPDATE和DELETE语句</h3><h3>补充：什么是CURRENT形式？</h3><center><h1>动态嵌入式SQL（ESQL）</h1></center>包括动态组装SQL语句和动态参数两种形式<h2>使用SQL语句主变量</h2>程序主变量：就是输入输出主变量那些SQL语句主变量：内容是一句SQL语句<p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">const char *stmt&#x3D;&quot;SQL语句;&quot;;&#x2F;*SQL语句主变量，注意有两个分号*&#x2F;</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br><span class="line"></span><br><span class="line">EXEC SQL EXECUTE IMMEDIATE :stmt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2>动态参数</h2>- 第一步：声明SQL语句主变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">const char *stmt&#x3D;&quot;SQL语句;&quot;;&#x2F;*SQL语句主变量，注意这里面不确定的参数用？代表*&#x2F;</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br></pre></td></tr></table></figure>- 第二步：准备语句<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL PREPARE [语句名] FROM :[SQL语句主变量];</span><br></pre></td></tr></table></figure>- 第三步：执行语句<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL EXECUTE [语句名] &lt;INTO 主变量表&gt;&lt;USING 主变量或常量&gt;;</span><br></pre></td></tr></table></figure><center><h1>存储过程</h1></center>PL/SQL语言：是SQL的过程化扩展，是编写数据库存储过程的一种过程语言<h2>PL/SQL的块结构</h2>PL/SQL程序的基本结构是块分为匿名块和命名块这里是匿名的，存储过程和函数是命名块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*定义部分*&#x2F;</span><br><span class="line">DECLARE</span><br><span class="line">变量、常量、游标、异常etc</span><br><span class="line"></span><br><span class="line">&#x2F;*执行部分*&#x2F;</span><br><span class="line">BEGIN</span><br><span class="line">语句</span><br><span class="line">EXCEPTION</span><br><span class="line">异常处理</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><h2>变量常量的定义</h2>*注：方括号内的内容表示可选*变量：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 数据类型 [[NOT NULL]:&#x3D;初值表达式];</span><br></pre></td></tr></table></figure>常量：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常量名 数据类型 CONSTANT:&#x3D;常量表达式;</span><br></pre></td></tr></table></figure><p>赋值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名称:&#x3D;表达式;</span><br></pre></td></tr></table></figure><h2>控制结构</h2><h3>条件控制语句</h3>第一种<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IF condition THEN</span><br><span class="line">语句;</span><br><span class="line">END IF</span><br></pre></td></tr></table></figure>第二种<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IF condition THEN</span><br><span class="line">语句;</span><br><span class="line">ELSE</span><br><span class="line">语句;</span><br><span class="line">END IF</span><br></pre></td></tr></table></figure>第三种:THEN和ELSE里面可以再嵌套IF语句<h3>循环控制语句</h3>第一种<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOOP</span><br><span class="line">语句；</span><br><span class="line">END LOOP;</span><br></pre></td></tr></table></figure>第二种<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE condition LOOP</span><br><span class="line">语句；</span><br><span class="line">END LOOP;</span><br></pre></td></tr></table></figure>第三种<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR count IN [REVERSE] bound1,...,bound2 LOOP</span><br><span class="line">语句；</span><br><span class="line">END LOOP;</span><br></pre></td></tr></table></figure><h2>存储过程</h2><h3>创建存储过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE Procedure 过程名([参数1 数据类型，参数2 数据类型，...])&#x2F;*存储过程首部*&#x2F;</span><br><span class="line">AS</span><br><span class="line">&lt;PL&#x2F;SQL块&gt;;&#x2F;*存储过程体*&#x2F;</span><br></pre></td></tr></table></figure><h3>重命名存储过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER Procedure 旧过程名 RENAME TO 新过程名;</span><br></pre></td></tr></table></figure><h3>执行存储过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL&#x2F;PERFORM Procedure 过程名([参数1，参数2，...]);</span><br></pre></td></tr></table></figure><h3>删除存储过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP Procedure 过程名();</span><br></pre></td></tr></table></figure><h2>游标</h2>PL/SQL中也可以用游标]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to do E-R Design</title>
      <link href="2020/09/05/How-to-do-E-R-Design/"/>
      <url>2020/09/05/How-to-do-E-R-Design/</url>
      
        <content type="html"><![CDATA[<center><h1>区分实体和属性</h1></center><h2>什么能叫属性？</h2>两条准则：![](\How-to-do-E-R-Design\att.png)<p><img src="/2020/09/05/How-to-do-E-R-Design/%5CHow-to-do-E-R-Design%5Cexample.png" alt></p><h2>数据库设计过程</h2><h3>从数据流图到E-R图（概念模型）</h3>- 第一步：最开始我们有的是一个系统图，表示各个子系统之间的关系（子系统在这里也可以叫“局部应用”），例如这种：![](\How-to-do-E-R-Design\system.png)- 第二步：开一个循环（？）遍历所有子系统（局部应用），为每一个设计一个E-R图。- 第三步：针对一个子系统我们怎么设计它的E-R图呢？1. 首先从该子系统的数据流图找到设计E-R图的灵感**第一层数据流图**（整个子系统的）：![](\How-to-do-E-R-Design\first.png)**第二层数据流图**（再将这个子系统细分为几个）：这里分别是接受订单、处理订单、开发票、支付过账四个![](\How-to-do-E-R-Design\1.png)![](\How-to-do-E-R-Design\2.png)![](\How-to-do-E-R-Design\3.png)![](\How-to-do-E-R-Design\4.png)2. 根据这些数据流图，我们可以搭一个E-R图框架![](\How-to-do-E-R-Design\frame.png)3. 现在我们可以划分关系+定义属性了说得明白点，其实一个关系的名字应该就对应一个实体型，关系里的属性就对应实体型的属性。得到这样的结果：![](\How-to-do-E-R-Design\entity.png)4. 根据语义，确定实体型之间的关系（1：1/1:n/m:n）5. 最后就可以画E-R图啦！完整版本应该是带属性的![](\How-to-do-E-R-Design\ER.png)- 第四步：当我们把每个子系统的E-R图设计好，就可以开始合并了！1. 合并有两种方法，一种一步到位，另一种两两合并到最后（后一种方便些）——其实核心问题都集中在合并两个E-R图的时候怎么操作了2. 合并两个E-R图需要两步工作：（1）解决E-R图之间的冲突+合并为初步E-R图<pre><code>&gt; 冲突类型及解决方法详见Mindmap（2）消除冗余+生成基本E-R图&gt; 消除冗余见Mindmap</code></pre><h3>例子</h3><a href="https://blog.csdn.net/csdn_blog_lcl/article/details/78609119">一个完整的E-R模型设计过程</a>有一说一……感觉这个比书上的好懂door了！！！<h3>从E-R图（概念模型）到关系模型（逻辑模型）</h3>对于实体型：一个实体型——一个关系模式，属性就是属性，码就是码<p>对于联系：<br>1:1的关系<br>（1）成为独立的关系模式：U=与联系相连的各实体的码+联系本身属性；候选码=各实体的码<br>（2）与任意一端合并：被合并的那个加入另一端的码和联系的属性</p><p>1:n关系：<br>（1）成为独立的关系模式：U=与联系相连的各实体的码+联系本身属性；候选码=n端实体的码<br>（2）与n端合并</p><p>m:n关系与多元联系：<br>（1）成为独立的关系模式：U=与联系相连的各实体的码+联系本身属性；各实体的码为关系的码的子集</p><p>注：相同码的关系模式可以合并</p><h2>E-R图设计的一些练习题</h2><a href="https://blog.csdn.net/zxq1138634642/article/details/9121363">一些练习题</a>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skills for Database Exercises</title>
      <link href="2020/09/04/Skills-for-Database-Exercises/"/>
      <url>2020/09/04/Skills-for-Database-Exercises/</url>
      
        <content type="html"><![CDATA[<center><h1>如何求最小函数依赖集</h1></center><h2>教科书式的定理</h2>![](\Skills-for-Database-Exercises\min.png)<h2>说人话</h2>- 第一步：看到函数依赖式右边有多个属性的，用分解规则拆开- 第二步：考察F中的每个函数依赖，对于其中一个，令一个新的函数依赖集G，这个G就是在F中把这个函数依赖去掉所形成的。接下来，对于这个函数依赖的左边X，考察它在G上的闭包是什么，如果这个闭包包含了函数依赖的右边Y，那么就从F中去掉这个函数依赖；反之保留- 第三步：对于F中每一个左端包含多个属性的函数依赖式，选择左边X的每个子集Z,如果右边Y属于Z的在F上的闭包,则用Z->Y代替X->Y<h2>练练手</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关系模式R(U，F)中，U&#x3D;ABCDEG，F&#x3D;&#123;B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B,ADG-&gt;BC&#125;，求F的最小函数依赖集</span><br></pre></td></tr></table></figure>- 第一步：用分解规则拆右边，得到新的F={B->D，DG->C,BD->E,AG->B,ADG->B,ADG->C}- 第二步：对于B->D，B在G中的闭包是{B},不包含D，所以可以保留对于DG->C，DG在G中的闭包是{D，G}，不包含C，所以可以保留对于BD->E，BD在G中的闭包是{B，D}，不包含E，所以可以保留对于AG->B，AG在G中的闭包是{A，G}，不包含B，所以可以保留对于ADG->B，ADG在G中的闭包是{A，D，G，B，C，E}，包含B，所以丢弃对于ADG->C，ADG在G中的闭包是{A，D，G，B，C，E}，包含C，所以丢弃*注：这里每一步考察完，到下一步时用的还是原来那个F，一次考察就是一次考察，不会动态变化的，不然就很奇怪了。*好，现在的F={B->D，DG->C,BD->E,AG->B}- 第三步：对于DG->C，D在F上的闭包是{D}，没啥替换的；G在F上的闭包是{G}，同样没啥对于BD->E，B在F上的闭包是{B，D，E}，包含E，可用B->E替换BD->E对于AG->B，A在F上的闭包是{A}....所以现在的F={B->D，DG->C,B->E,AG->B}<center><h1>如何求一个属性(组)在某函数依赖集上的闭包</h1></center><h2>教科书式的定理</h2>![](\Skills-for-Database-Exercises\algorithm.png)<h2>说人话</h2>通过一个多次迭代的方法求。![](\Skills-for-Database-Exercises\algorithm1.png)*注：改正一下，应该是“在F中找到一些函数依赖式——它们的左边应该是**包含于**X(i)的”*<center><h1>如何求某函数依赖集的闭包</h1></center>其实就是用那些公理、推理规则之类的开始造作！**如何不重不漏？**这好像是个NP问题啊....<center><h1>如何判断一个函数依赖FD是否属于某函数依赖集F的闭包</h1></center>用公理+推理规则，能推导出来就是属于<center><h1>如何设计E-R图并转换</h1></center><center><h1>如何写好SQL查询</h1></center><center><h1>如何判断关系所属范式</h1></center>我觉得在实际判断中，下面这些判断方法应该一个个往后用，就像过五关斩六将一样<h2>准备工作</h2>- 第一步：找出数据表中所有的候选码。首先考察包含一个属性的所有属性组，看它们能否唯一确定别的所有属性；接下来看包含两个属性的、三个的...以此类推*Tips:假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是候选码了（因为作为码的要求里有一个“完全函数依赖”）*- 第二步：根据第一步所得到的候选码，找出所有的主属性。也就是其中用到的所有属性（候选码的并集）- 第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。<h2>判断是否为2NF</h2>**在关系模式中若没有非主属性对码的部分函数依赖即可称为2NF**<pre>考虑关系模式R（A,B,C,D），已知函数依赖有{B->D,AB->C}，关系模式R的码是（    ），R属于（    ）范式首先找码 码是AB，然后又有D依赖于B，而B属于AB，所以存在D部分函数依赖于AB，所以不是第二范式</pre><h2>判断是否为3NF</h2>**在关系模式中若没有非主属性对码的传递函数依赖即可称为3NF**<h2>判断是否为BCNF</h2>**在关系模式中，如果每一个决定因素都包含码，则属于BCNF**<h2>判断是否为4NF</h2><center><h1>如何将关系规范化（各种模式分解算法）</h1></center><center><h1>SQL语句转查询树</h1></center>给个例子你就懂了，叶子应该是关系。原SQL语句：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname</span><br><span class="line">FROM Student，SC</span><br><span class="line">WHERE Student.Sno&#x3D;SC.Sno AND SC.Cno&#x3D;&#39;2&#39;;</span><br></pre></td></tr></table></figure>优化后：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Student.Sno in (</span><br><span class="line">SELECT Sno</span><br><span class="line">FROM SC</span><br><span class="line">WHERE SC.Cno&#x3D;&#39;2&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>![](\Skills-for-Database-Exercises\tree.png)]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Model Decomposition</title>
      <link href="2020/09/03/Model-Decomposition/"/>
      <url>2020/09/03/Model-Decomposition/</url>
      
        <content type="html"><![CDATA[<h2>关系的一个分解</h2>![](\Model-Decomposition\definition.png)说人话：分解以后的关系，它们的属性集合并起来应该和原关系的属性集相等，此外呢，分解出来的各子关系，它们的属性集之间不能有包含关系那么如何确定某个子关系上的函数依赖呢？在原关系函数依赖的闭包上找，要左右两边的属性合并起来在此子关系的属性集内就可以纳入这个子关系的函数依赖中~<h2>模式分解的三种等价形式</h2>![](\Model-Decomposition\3.png)<h3>什么是“无损连接性”？</h3>个人理解：要从分解后的子关系恢复到原关系，一般是通过自然连接来实现的；假如分解后再用自然连接得到的关系并非原关系，而是一个“元组增加了，信息丢失了”的关系，这种就是有损连接性的分解<h3>什么是“保持函数依赖”？</h3>个人理解：原关系的各种函数依赖，每个应该在某子关系中出现至少一次<h2>引理</h2><h3>记号定义</h3>![](\Model-Decomposition\ydefinition.png)<h3>相关性质</h3>![](\Model-Decomposition\p.png)<h2>无损连接性</h2><h3>定义</h3>![](\Model-Decomposition\wdefinition.png)<h3>判别算法</h3>![](\Model-Decomposition\algorithm.png)<h3>说人话</h3>- 第一步：画一张初始表，所有属性按列排开，分解的有几个关系就几行- 第二步：填初始数据，一行行看，在每个关系模式的U包含的属性列那里写上a(j)，否则写b(ij)- 第三步：遍历所有FD，对于每个，左边X所在的那些列里面，找出填了相同值的那些行；这些行里面，再去看右边Y对应的属性下标对应的列，看里面是否有a(li)这个元素，有的话，全部改为a(li)注：假如有b相关的值在上一句的操作里被改掉了，那这一列所有这个值都要被改- 第四步：知道有一行是a1，a2，a3.....，就说明是无损连接性的<h3>特殊地</h3>![](\Model-Decomposition\adefinition.png)<h3>说人话</h3>如果是分解成两个关系要判别是否无损连接性，写出“U1交U2->U1-U2(谁先谁后看情况)”，看看这个函数依赖是否在F的闭包内，在的话就……<h2>保持函数依赖</h2><h3>定义</h3>![](\Model-Decomposition\depend.png)根据这个定义，我们再加上判断两个函数依赖集是否相等就可以完整地作为一个“保持函数依赖”的判别算法了！即：（原F的闭包）要和（分解后F们的并集的闭包）相等<h2>模式分解的算法</h2><h3>关于模式分解结果的几种情况</h3>1. 如果保持了“无损连接性”，则分解后的关系一定是4NF的2. 如果保持了“保持函数依赖性”，则分解后的关系一定是3NF的，不一定能到BCNF3. 如果保持了“无损连接性”和“保持函数依赖性”，则分解后的关系一定是3NF的，不一定能到BCNF（？？？）<h3>“保持函数依赖性”+3NF&emsp;模式分解算法</h3><h4>教科书式定义</h4>![](\Model-Decomposition\a1.png)<h4>说人话</h4>- 第一步：极小化F- 第二步：在U中去掉F中不包含的属性*注：接下来讨论的都是处理后的F和U了！！！*- 第三步：假如F中有函数依赖能使左右两边合并起来恰好是U，那没事了，R不用作分解，算法终止；不是的话就转第四步- 第四步：把F按照相同左边X的规则分组成几个小的函数依赖集F'(i)，对应地有它的U(i)，再用U(i)在F上找到对应的F(i)，R就这样被分解了<h3>“保持函数依赖性”+“无损连接性”+3NF&emsp;模式分解算法</h3><h4>教科书式定义</h4>![](\Model-Decomposition\a2.png)<h4>说人话</h4>- 第一步：先做算法6.3，也就是先让分解后的模式“保持函数依赖性”。- 第二步：找到原关系R的码X，和它在F上的闭包，形成一个对应关系R(x)- 第三步：在先前得到的几个子关系R(i)中，寻找一下有没有对应的U(i)包含了X的，要是有，那么这个R(x)就不用加到分解出的子关系里面了，反之是需要的<h3>“无损连接性”+BCNF&emsp;模式分解算法</h3><h4>教科书式定义</h4>![](\Model-Decomposition\a3.png)<h4>说人话</h4><ul><li>第一步：初始的状态就是从原关系R开始，</li><li>第二步：检查一下当前分解中是不是每个关系都符合BCNF了，如果是，就可以终止了；如果不是，跳第三步</li><li>第三步：对于那些不符合BCNF的关系，我们找到某个函数依赖——它的左边X并非此关系的码。我们把这个函数依赖的左右两边合并，这是一个属性集；然后在此关系属性集里面剔除“此函数依赖的右边Y”就形成另一个属性集。有了分解后的两个属性集，根据它们生成对应的F就好啦。这样就把这个关系分解好了。跳第二步</li></ul><h3>“无损连接性”+4NF&emsp;模式分解算法</h3><h4>教科书式定义</h4>![](\Model-Decomposition\a4.png)<h4>说人话</h4>- 第一步：用算法6.5做到“无损连接性”+BCNF- 第二步：考察分解中那些不符合4NF的关系，用定理6.6的方法分解- 第三步：分解中的每个子关系都属于4NF即可终止<h4>补充：什么是传说中的定理6.6呢？</h4>![](\Model-Decomposition\d1.png)这个定理的意思就是，既然这个关系不符合4NF吧，那就是有非平凡非函数依赖的多值依赖，也就是X-->Y。有了它我们把关系分成（X,Y）和（X,Z），有点奇怪的是，为什么关系可以这样表示啊？<h2>完整版数据依赖的公理系统</h2><h3>8条公理</h3>![](\Model-Decomposition\g1.png)<h3>4条推理规则</h3>![](\Model-Decomposition\g2.png)]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axiom System of Data Dependency</title>
      <link href="2020/09/02/Axiom-System-of-Data-Dependency/"/>
      <url>2020/09/02/Axiom-System-of-Data-Dependency/</url>
      
        <content type="html"><![CDATA[<center><h1>Armstrong公理系统</h1></center><h2>什么是逻辑蕴含？</h2>![](\Axiom-System-of-Data-Dependency\logical.png)<br><br><h2>如何确定一个函数依赖是否为F所蕴含？</h2>![](\Axiom-System-of-Data-Dependency\Armstrong.png)*注：XZ表示X并Z*对于Armstrong公理的简要说明：1. 自反律：其实这个和F无关，我们只要有一个大集合X和它的子集Y，就会有X->Y2. 增广率：需要推出XZ->YZ，也就是证明，如果有两个元组在XZ上的值相等，那么在YZ上的值也会相等；对于前半句：这个条件就给出两个元组在X上值相等，且在Z上值相等；根据X->Y，它们在Y上的值相等，和Z的一合并，就推出了这两个元组在YZ上的值也会相等3. 传递率：你懂的<p>顺带导出了3条推理规则：</p><ol><li>合并规则：X-&gt;Y与X-&gt;Z可得X-&gt;YZ</li><li>伪传递规则：X-&gt;Y与WY-&gt;Z可得XW-&gt;Z</li><li>分解规则：X-&gt;Y与Z包含于Y可得X-&gt;Z<br>还顺带有个小引理：<br>就是X-&gt;ABCDEF…与右边的分开写，是互为充要条件的<br><br><br></li></ol><h2>关于闭包</h2>函数依赖集F的闭包：是指运用Armstrong公理系统推导出来的所有F可蕴含的函数依赖，结果形式应该是一个函数依赖组成的集合属性集X关于函数依赖集F的闭包：有个推导算法可以用，结果形式应该是一个属性组成的集合算法如下：![](\Axiom-System-of-Data-Dependency\algorithm.png)<h2>极小函数依赖集</h2><h3>定义</h3>![](\Axiom-System-of-Data-Dependency\definition.png)*注：两个函数依赖集等价，就是函数依赖集的闭包相等*<h3>化简为极小函数依赖集（亦为判定）</h3>![](\Axiom-System-of-Data-Dependency\min.png)]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Without Faith</title>
      <link href="2020/08/27/Without-Faith/"/>
      <url>2020/08/27/Without-Faith/</url>
      
        <content type="html"><![CDATA[<p>我的孤独像一座花园<br>里面只有没有灵魂的美</p><p>我希望<br>自己能像<br>夜晚梦到白日那样<br>充满信念</p><p>在话语里有野火<br>灵魂憔悴不堪<br>头颅在黑暗中沉默</p>]]></content>
      
      
      <categories>
          
          <category> Insights on Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Faith </tag>
            
            <tag> Life </tag>
            
            <tag> Emotion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hard-to-Understand Concepts in Database</title>
      <link href="2020/08/26/Hard-to-Understand-Concepts-in-Database/"/>
      <url>2020/08/26/Hard-to-Understand-Concepts-in-Database/</url>
      
        <content type="html"><![CDATA[<center><h1>About Keys</h1></center>&emsp;&emsp;码、主码、候选码的关系:![](https://img-blog.csdnimg.cn/20190625173457198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bWFsaXFpbmdodWE=,size_16,color_FFFFFF,t_70)<p>貌似码=超键<br><a href="https://blog.csdn.net/sumaliqinghua/article/details/85872446">一篇不错的博客</a><br>全码：整个属性组是码</p><center><h1>About Dependencies</h1></center><h2>完全函数依赖</h2>&emsp;&emsp;设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。&emsp;&emsp;*举个例子*：通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB.<h2>部分函数依赖</h2>&emsp;&emsp;设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。&emsp;&emsp;*举个例子*：通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。<h2>传递函数依赖</h2>&emsp;&emsp;传递函数依赖：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。&emsp;&emsp;*举个例子*：通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么成C传递依赖于A<h2>多值依赖</h2>设R(U)是一个属性集合U上的一个关系模式，X, Y, 和Z是U的子集，并且Z=U-X-Y，多值依赖X->->Y成立当且仅当对R的任一个关系r，r在(X,Z)上的每个值对应一组Y的值，这组值仅仅决定于X值而与Z值无关。注：我突然觉得，这个与Z值无关，貌似不是什么很特别的言论。其实吧，我的理解就是，有一个X，有一个Y，一个X值对应多个Y值。（啊不过！Z的有无还是会决定这个多值依赖是非平凡/平凡的！）<p>若X-&gt;-&gt;Y，而Z=空集，则称X-&gt;-&gt;Y为平凡的多值依赖。否则，称X-&gt;-&gt;Y为非平凡的多值依赖。</p><p>平凡多值依赖就是，属性集合中分为两个真子集，每一个X对应一组Y的取值<br><img src="/2020/08/26/Hard-to-Understand-Concepts-in-Database/%5CHard-to-Understand-Concepts-in-Database%5Cpingdepend.png" alt><br>**<br>可以看出，如果把上面的一组改为一个，那么多值依赖就变成了函数依赖。当然一个值组成的组也是组，所以说，函数依赖是多值依赖的特殊情况。<br>（首先函数依赖和多值依赖的X、Y应该都可以是属性组吧，函数依赖是一个x值决定一个y值，多值依赖是一个x值决定多个y值）**<br><img src="/2020/08/26/Hard-to-Understand-Concepts-in-Database/%5CHard-to-Understand-Concepts-in-Database%5Cdepen.png" alt></p><h3>多值依赖的性质</h3>![](\Hard-to-Understand-Concepts-in-Database\mdependp.png)<h3>多值依赖与函数依赖区别</h3>![](\Hard-to-Understand-Concepts-in-Database\difference1.png)<h2>连接依赖</h2><h2>函数依赖图</h2>看了这个你就懂怎么操作了![](\Hard-to-Understand-Concepts-in-Database\fdepend.png)还有涉及到部分函数依赖时，可以用虚线表示![](\Hard-to-Understand-Concepts-in-Database\pdepend.png)多值依赖![](\Hard-to-Understand-Concepts-in-Database\mdepend.png)<center><h1>零散小知识</h1></center><h2>二目关系</h2>其实**目**或者说**度**，就是一个关系中有多少个属性而已......所以二目关系就是有两列的那种啦<h2>数据流图</h2>数据流程图（DFD）是一种能全面地描述信息系统逻辑模型的主要工具，它可以用少数几种符号综合地反映出信息在系统中的流动、处理和存储情况。数据流程图是表示**操作或数据的方向**。![](\Hard-to-Understand-Concepts-in-Database\DFD.png)数据流图有四种基本图形符号：- 箭头：表示数据流；- 圆或椭圆：表示加工；- 双杠：表示数据存储；- 方框：表示数据的源点或终点。<h2>决定因素</h2>貌似说的就是一个函数依赖的左边<h2>函数依赖集的覆盖</h2>F的最小覆盖其实就是它的极小函数依赖集<h2>表达查询的一堆语句形式</h2><h3>关系代数表达式</h3>应该就是π、ρ那些吧<h3>元组关系演算表达式</h3>就是那些集合的形式<h2>函数依赖集的覆盖</h2>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Understanding Paradigm in Database Design</title>
      <link href="2020/08/26/Understanding-Paradigm-in-Database-Design/"/>
      <url>2020/08/26/Understanding-Paradigm-in-Database-Design/</url>
      
        <content type="html"><![CDATA[<center><h1>1NF</h1></center>&emsp;&emsp;1NF的定义为：符合1NF的关系中的每个属性都不可再分，要求属性具有**原子性**，不可再分解;<p>  不符合的关系：<br><img src="https://pic4.zhimg.com/80/24afd11455ac34a280fa83e4e8d75ccc_1440w.jpg?source=1940ef5c" alt><br>  符合的关系：<br><img src="https://pic3.zhimg.com/80/6b735fb9503b0930e741faa474fed28e_1440w.jpg?source=1940ef5c" alt></p><center><h1>2NF</h1></center>2NF是对记录的**惟一性**，要求记录有惟一标识，即实体的惟一性，即不存在部分依赖；2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖，简而言之，第二范式就是非主属性完全依赖于主关键字。<h3>如何确定一个关系是否为2NF</h3>- 第一步：找出数据表中所有的候选码。首先考察包含一个属性的所有属性组，看它们能否唯一确定别的属性；接下来看包含两个属性的、三个的...以此类推*Tips:假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是候选码了（因为作为码的要求里有一个“完全函数依赖”）*- 第二步：根据第一步所得到的候选码，找出所有的主属性。也就是其中用到的所有属性（候选码的并集）- 第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。- 第四步：查看是否存在非主属性对码的部分函数依赖。![](\Understanding-Paradigm-in-Database-Design\2NF.png)<h3>如何把一个关系改造成2NF</h3>投影分解，把存在部分依赖的地方拆开<center><h1>3NF</h1></center>3NF是对字段的**冗余性**，它要求字段没有冗余，即不存在传递依赖；要求任何字段不能由其他字段派生出来每个**非主属性**都不传递依赖于R的候选键**简而言之，第三范式就是属性不依赖于其它非主属性。**> 表: 学号, 姓名, 年龄, 学院名称, 学院电话<h3>如何把一个关系改造成3NF</h3>投影分解，把存在传递依赖的地方拆开<center><h1>BCNF</h1></center>在 3NF 的基础上消除主属性对于码的部分与传递函数依赖（是修正的/扩充的第三范式），就是属性不依赖于其它非主属性（不能存在关键字段决定关键字段的情况）每个**属性**都不传递依赖于R的候选键一个满足BCNF的关系模式：- 所有非主属性对每一个码都是完全函数依赖（满足2NF）- 所有的主属性对每一个不包含它的码，是完全函数依赖（让主属性对码不存在部分函数依赖）- 没有任何属性完全函数依赖于非码的任何一组属性（主属性和非主属性都不能完全依赖于非码的任何一组属性，因为这样就存在属性对码的传递函数依赖）<p><em>Tips:全码的关系一定属于BCNF</em></p><center><h1>4NF</h1></center>![](Understanding-Paradigm-in-Database-Design\2.png)<center><h1>To put it Simple</h1></center>1、第一范式（1NF）：一个关系模式R的所有属性都是不可分的基本数据项。2、第二范式（2NF）：满足第一范式，然后消除部分依赖。（消除-非主-部分）3、第三范式（3NF）： 满足第二范式，消除传递依赖。（消除-非主-传递）4、BC范式（BCNF）：满足第三范式（消除-主与非主-部分与传递）5、第四范式（4NF）：满足BC范式，在多值依赖中，去掉了属于函数依赖的，也去掉了非平凡的（消除-非平凡与非函数依赖-多值依赖）![](https://img-blog.csdn.net/20170508213333607?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRG92ZV9Lbm93bGVkZ2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)<center><h1>规范化过程</h1></center>![](Understanding-Paradigm-in-Database-Design\1.png)<center><h1>可参考资料</h1></center><a href="https://zhuanlan.zhihu.com/p/20028672">有讲解有习题的讲范式的博客</a>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Understanding &#39;division&#39; and Its Implementation in SQL</title>
      <link href="2020/08/24/Understanding-division-and-Its-Implementation-in-SQL/"/>
      <url>2020/08/24/Understanding-division-and-Its-Implementation-in-SQL/</url>
      
        <content type="html"><![CDATA[<center><h1>What does Division really do</h1></center><h2>Process</h2>2. The result of Division of R/S, contains columns which are in R but not in S. (In other words, R's columns except which also in S.)3. Define T=R/S and T's columns is C.4. For each c in C, find their “象集” in R.5. Find S's projection on its common columns with R.6. If c's “象集” includes the result in 5, then add it to T.<h2>Example</h2>1. <br>![](https://img-blog.csdn.net/20161221185506785)2. 在R关系中A属性的值可以取{ a1，a2，a3，a4 }a1值对应的象集为 {  (b1,c2)  , (b2,c1) ,  (b2,c3)  }a2值对应的象集为 {  (b3,c7)  , (b2,c3) }a3值对应的象集为 {  (b4,c6)  }a4值对应的象集为 {  (b6,c6)  }3. 关系S在B、C上的投影为 {  (b1,c2)  , (b2,c1) ,  (b2,c3)  }4. 只有a1值对应的象集包含关系S的投影集，所以只有a1应该包含在A属性中5. R/S=<table><thead><tr><th>A</th></tr></thead><tbody><tr><td>a1</td></tr></tbody></table><center><h1>Implementation in SQL</h1></center><h2>How to do</h2>1. R(X，Y)÷S(Y，Z)的运算用结构化语言SQL 语句可表达为下列形式:2.  ![](/Understanding-division-and-Its-Implementation-in-SQL/division.png)3. 用双重`not exists`来实现，- 第一层：选出R表中，Y属性上的值和S中有相等的那些元组- 第二层：从S中排除这些元组，余下的都是在Y上S有但R没有的Y值- 第三层：<p><em>补充</em>：什么是not exists？<br>  exists，强调的是是否有返回集，不需知道具体返回的是什么,只要exists引导的子句有结果集返回，这个条件就算成立。</p>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summary for =Learn SQL= //Codecademy</title>
      <link href="2020/08/23/Summary-for-Learn-SQL-Codecademy/"/>
      <url>2020/08/23/Summary-for-Learn-SQL-Codecademy/</url>
      
        <content type="html"><![CDATA[<center><h1>Manipulation</h1></center>We’ve learned six commands commonly used to manage data stored in a relational database and how to set constraints on such data. What can we generalize so far?<ul><li>SQL is a programming language designed to manipulate and manage data stored in relational databases.</li><li>A relational database is a database that organizes information into one or more tables.</li><li>A table is a collection of data organized into rows and columns.</li><li>A statement is a string of characters that the database recognizes as a valid command.</li></ul><p>creates a new table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name(</span><br><span class="line">attribute1 type constraint,</span><br><span class="line">attribute1 type constraint</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>constraint:</p><ol><li><p><code>PRIMARY KEY</code> columns can be used to uniquely identify the row. Attempts to insert a row with an identical value to a row already in the table will result in a constraint violation which will not allow you to insert the new row.</p></li><li><p><code>UNIQUE</code> columns have a different value for every row. This is similar to PRIMARY KEY except a table can have many different UNIQUE columns.</p></li><li><p><code>NOT NULL</code> columns must have a value. Attempts to insert a row without a value for a NOT NULL column will result in a constraint violation and the new row will not be inserted.</p></li><li><p><code>DEFAULT</code> columns take an additional argument that will be the assumed value for an inserted row if the new row does not specify a value for that column.</p></li><li><p>关于外码（主码也可放最后）</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Orders</span><br><span class="line">(</span><br><span class="line">O_Id int NOT NULL,</span><br><span class="line">OrderNo int NOT NULL,</span><br><span class="line">P_Id int,</span><br><span class="line">PRIMARY KEY (O_Id),</span><br><span class="line">FOREIGN KEY (P_Id) REFERENCES Persons(P_Id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="6"><li>关于自定义约束</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">P_Id int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">CHECK (P_Id&gt;0)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;*可以给约束命名*&#x2F;</span><br><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">P_Id int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City&#x3D;&#39;Sandnes&#39;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注：如果建表时忘记加了，之后加也是可以的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City&#x3D;&#39;Sandnes&#39;)</span><br></pre></td></tr></table></figure><p>adds a new row to a table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name(a1,a2,a3) </span><br><span class="line">VALUES(v1,v2,v3);</span><br></pre></td></tr></table></figure><p>queries data from a table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT attributes</span><br><span class="line">FROM table_name </span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><p>changes an existing table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">ADD COLUMN c1_name type; </span><br></pre></td></tr></table></figure><p>edits a row in a table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line">SET .....</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><p>deletes rows from a table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><h1><center>Queries</center></h1><p><code>AS</code> is a keyword in SQL that allows you to rename a column or table using an alias. The new name can be anything you want as long as you put it inside of single quotes.</p><p>Some important things to note:</p><ul><li>Although it’s not always necessary, it’s best practice to surround your aliases with single quotes.</li><li>When using <code>AS</code>, the columns are not being renamed in the table. The aliases only appear in the result.</li><li><code>SELECT</code> is the clause we use every time we want to query information from a database.</li><li><code>AS</code> renames a column or table.</li><li><code>DISTINCT</code> return unique values.</li><li><code>WHERE</code> is a popular command that lets you filter the results of the query based on conditions that you specify.</li><li><code>LIKE</code> and <code>BETWEEN</code> are special operators.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIKE:</span><br><span class="line">The _ means you can substitute any individual character here without breaking the pattern.(一个对一个字符，汉字的话要用两个空空)</span><br><span class="line">% is a wildcard character that matches zero or more missing letters in the pattern. </span><br></pre></td></tr></table></figure><ul><li><code>AND</code> and <code>OR</code> combines multiple conditions.</li><li><code>ORDER BY</code> sorts the result.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认asc，降序是desc</span><br></pre></td></tr></table></figure><ul><li><code>LIMIT</code> specifies the maximum number of rows that the query will return.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT 数字 &#x2F;*数字就是最后显示的结果有多少行*&#x2F;</span><br></pre></td></tr></table></figure><ul><li><code>CASE</code> creates different outputs.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT name,</span><br><span class="line"> CASE</span><br><span class="line">  WHEN imdb_rating &gt; 8 THEN &#39;Fantastic&#39;</span><br><span class="line">  WHEN imdb_rating &gt; 6 THEN &#39;Poorly Received&#39;</span><br><span class="line">  ELSE &#39;Avoid at All Costs&#39;</span><br><span class="line"> END AS &#39;Review&#39;%表示新增的这一列的命名，没有貌似也可</span><br><span class="line">FROM movies;</span><br></pre></td></tr></table></figure><h1><center>Aggregate Functions</center></h1><ul><li><code>COUNT()</code>: count the number of rows</li><li><code>SUM()</code>: the sum of the values in a column</li><li><code>MAX()/MIN()</code>: the largest/smallest value</li><li><code>AVG()</code>: the average of the values in a column</li><li><code>ROUND()</code>: round the values in the column</li></ul><p>Aggregate functions combine multiple rows together to form a single value of more meaningful information.</p><ul><li><code>GROUP BY</code> is a clause used with aggregate functions to combine data from one or more columns.</li><li><code>HAVING</code> limit the results of a query based on an aggregate property.</li></ul><p>关于SQL语句的执行顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(1) from </span><br><span class="line">(3) join </span><br><span class="line">(2) on </span><br><span class="line">(4) where </span><br><span class="line">(5) group by(开始使用select中的别名，后面的语句中都可以使用)</span><br><span class="line">(6) avg,sum.... </span><br><span class="line">(7) having </span><br><span class="line">(8) select </span><br><span class="line">(9) distinct </span><br><span class="line">(10) order by</span><br><span class="line">(11) limit </span><br></pre></td></tr></table></figure><p>从这个顺序中我们不难发现，所有的查询语句都是从from开始执行的，在执行过程中，每个步骤都会为下一个步骤<strong>生成一个虚拟表</strong>，这个虚拟表将作为下一个执行步骤的输入。<br>第一步：首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 vt1（选择相对小的表做基础表）</p><p>第二步：接下来便是应用on筛选器，on 中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足on逻辑表达式的行，生成虚拟表 vt2</p><p>第三步：如果是outer join 那么这一步就将添加外部行，left outer jion 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 vt3</p><p>第四步：如果 from 子句中的表数目多余两个表，那么就将vt3和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3。</p><p>第五步：应用where筛选器，对上一步生产的虚拟表引用where筛选器，生成虚拟表vt4，在这有个比较重要的细节不得不说一下，对于包含outer join子句的查询，就有一个让人感到困惑的问题，到底在on筛选器还是用where筛选器指定逻辑表达式呢？on和where的最大区别在于，如果在on应用逻辑表达式那么在第三步outer join中还可以把移除的行再次添加回来，而where的移除的最终的。举个简单的例子，有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名=成绩.姓名）那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了,但是我们用left outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生，如果在on中应用学生.班级='x’的话，left outer join会把x班级的所有学生记录找回（感谢网友康钦谋__康钦苗的指正），所以只能在where筛选器中应用学生.班级=‘x’ 因为它的过滤是最终的。</p><p>第六步：group by 子句将中的唯一的值组合成为一组，得到虚拟表vt5。如果应用了group by，那么后面的所有步骤都只能得到的vt5的列或者是聚合函数（count、sum、avg等）。原因在于最终的结果集中只为每个组包含一行。这一点请牢记。</p><p>第七步：应用cube或者rollup选项，为vt5生成超组，生成vt6.</p><p>第八步：应用having筛选器，生成vt7。having筛选器是第一个也是为唯一一个应用到已分组数据的筛选器。</p><p>第九步：处理select子句。将vt7中的在select中出现的列筛选出来。生成vt8.</p><p>第十步：应用distinct子句，vt8中移除相同的行，生成vt9。事实上如果应用了group by子句那么distinct是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。</p><p>第十一步：应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表。sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定order by，最后，在这一步中是第一个也是唯一一个可以使用select列表中别名的步骤。</p><p>第十二步：应用top选项。此时才返回结果给请求者即用户。</p><h1><center>Multiple Tables</center></h1><p>Why is this important? The most common types of joins will be joining a foreign key from one table with the primary key from another table. For instance, when we join orders and customers, we join on customer_id, which is a foreign key in orders and the primary key in customers.</p><p>SQL has strict rules for appending data:<br>Tables must have the same number of columns.<br>The columns must have the same data types in the same order as the first table.</p><ul><li><p><code>JOIN</code> will combine rows from different tables if the join condition is true.</p></li><li><p><code>LEFT JOIN</code> will return every row in the left table, and if the join condition is not met, NULL values are used to fill in the columns from the right table.</p></li><li><p>Primary key is a column that serves a unique identifier for the rows in the table.</p></li><li><p>Foreign key is a column that contains the primary key to another table.</p></li><li><p><code>CROSS JOIN</code> lets us combine all rows of one table with all rows of another table.</p></li><li><p><code>UNION</code> stacks one dataset on top of another.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM table1</span><br><span class="line">UNION</span><br><span class="line">SELECT *</span><br><span class="line">FROM table2;</span><br></pre></td></tr></table></figure><ul><li><code>WITH</code> allows us to define one or more temporary tables that can be used in the final query.</li></ul><p>关于SQL语句的写法顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">WITH [临时表名] AS(</span><br><span class="line">&#x2F;*一段查询*&#x2F;</span><br><span class="line">)</span><br><span class="line">SELECT [列名称 *代表所有的列]</span><br><span class="line">CASE</span><br><span class="line">  WHEN [条件] THEN [对应的新属性上的值]</span><br><span class="line">  WHEN [条件] THEN [对应的新属性上的值]</span><br><span class="line">  ......</span><br><span class="line">  ELSE [对应的新属性上的值]</span><br><span class="line"> END AS [新属性名字]%表示新增的这一列的命名，没有貌似也可</span><br><span class="line">FROM [表名称]</span><br><span class="line">join_type JOIN [表名称]</span><br><span class="line">ON [join条件]</span><br><span class="line">WHERE [过滤条件]</span><br><span class="line">GROUP BY [分组字段]&#x2F;*可用select中的“列号”代表，就是直接写数字*&#x2F;</span><br><span class="line">HAVING [分组条件]</span><br><span class="line">ORDER BY [排序字段] [ASC&#x2F;DESC]</span><br><span class="line">LIMIT [输出组数]</span><br></pre></td></tr></table></figure><h1><center>小感想</center></h1><p>这门小小的SQL语句课程就结束了，虽然内容十分少，但是用SQL语句解决实际需求时，还是需要很好的逻辑和语句熟练度的！<br>过几天就要考试了，加油吧小可可！</p>]]></content>
      
      
      <categories>
          
          <category> Codecademy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summary for =Learn JavaScript= //Codecademy</title>
      <link href="2020/08/23/Summary-for-Learn-JavaScript-Codecademy/"/>
      <url>2020/08/23/Summary-for-Learn-JavaScript-Codecademy/</url>
      
        <content type="html"><![CDATA[<center><h1>Introduction</h1></center><h2>Introduction to JavaScript</h2>- Data is printed, or logged, to the console, a panel that displays messages, with `console.log()`.- We can write single-line comments with `//` and multi-line comments between `/*` and `*/`.- There are 7 fundamental data types in JavaScript: strings, numbers, booleans, null, undefined, symbol, and object.- Numbers are any number without quotes: 23.8879- Strings are characters wrapped in single or double quotes: 'Sample String'- The built-in arithmetic operators include `+`, `-`, `*`, `/`, and `%`.- Objects, including instances of data types, can have properties, stored information. The properties are denoted with a . after the name of the object, for example: `'Hello'.length`.- Objects, including instances of data types, can have methods which perform actions. Methods are called by appending the object or instance with a period, the method name, and parentheses. For example: `'hello'.toUpperCase()`.- We can access properties and methods by using the ., dot operator.- Built-in objects, including Math, are collections of **methods and properties** that JavaScript provides.<h2>Variables</h2>- Variables hold reusable data in a program and associate it with a name.- Variables are stored in memory.- The `var` keyword is used in *pre-ES6* versions of JS.- `let` is the preferred way to declare a variable when it can be **reassigned**, and `const` is the preferred way to declare a variable with a **constant** value.- Variables that have not been initialized store the primitive data type **undefined**.- Mathematical assignment operators make it easy to calculate a new value and assign it to the same variable.- The `+` operator is used to concatenate strings including string values held in variables- In ES6, template literals use `backticks` and `${}` to interpolate values into a string.- The `typeof` keyword returns the data type (as a string) of a value.<center><h1>Conditions</h1></center><h2>Conditional Statements</h2>- An `if` statement checks a condition and will execute a task if that condition evaluates to true.- `if...else` statements make binary decisions and execute different code blocks based on a provided condition.- We can add more conditions using `else if` statements.- Comparison operators, including `<`, `>`, `<=`, `>=`, `===`, and `!==` can compare two values.&emsp;*P.S. Mention that we use `===` rather than `==` in JS.*  - The logical and operator, `&&`, or “`and`”, checks if both provided expressions are truthy.- The logical operator `||`, or “`or`”, checks if either provided expression is truthy.- The bang operator, `!`, switches the truthiness and falsiness of a value.- The **ternary** operator is shorthand to simplify concise `if...else` statements.- A `switch` statement can be used to simplify the process of writing multiple else if statements. The **break** keyword stops the remaining cases from being checked and executed in a switch statement.<center><h1>Functions</h1></center><h2>Functions</h2></=`,></`,>]]></content>
      
      
      <categories>
          
          <category> Codecademy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summmary for =Learn CSS= //Codecademy</title>
      <link href="2020/08/22/Summmary-for-Learn-CSS-Codecademy/"/>
      <url>2020/08/22/Summmary-for-Learn-CSS-Codecademy/</url>
      
        <content type="html"><![CDATA[<h1>Selectors and Visual Rules</h1><h2> CSS Setup and Selectors </h2>- CSS can change the look of HTML elements. In order to do this, CSS must select HTML elements, then apply styles to them.- CSS can select HTML elements by **tag**, **class**, **or ID**.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   tag: p</span><br><span class="line">class: .</span><br><span class="line">ID: #</span><br></pre></td></tr></table></figure>- Multiple CSS classes can be applied to one HTML element.- Classes can be reusable, while IDs can only be used once.- IDs are more specific than classes, and classes are more specific than tags. That means IDs will override any styles from a class, and classes will override any styles from a tag selector.- Multiple selectors can be **chained** together to select an element. This raises the specificity, but can be necessary.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h5.description</span><br></pre></td></tr></table></figure>- Nested elements can be selected by separating selectors with a space.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.class li</span><br></pre></td></tr></table></figure>- Multiple unrelated selectors can receive the same styles by separating the selector names with **commas**.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p,</span><br><span class="line">h5</span><br></pre></td></tr></table></figure><h2>CSS Visual Rules</h2>I've learned concepts including:<ul><li>CSS declarations are structured into property and value pairs.</li><li>The <code>font-family</code> property defines the typeface of an element.</li><li><code>font-size</code> controls the size of text displayed.</li><li><code>font-weight</code> defines how thin or thick text is displayed.</li><li>The <code>text-align</code> property places text in the left, right, or center of its parent container.</li><li>Text can have two different color attributes: <code>color</code> and <code>background-color</code>. color defines the color of the text, while background-color defines the color behind the text.</li><li>CSS can make an element transparent with the <code>opacity</code> property.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opacity: 0.75;</span><br><span class="line">&#x2F;&#x2F;From 0 to 1, 0 means invisible;</span><br></pre></td></tr></table></figure><ul><li>CSS can also set the background of an element to an image with the <code>background-image</code> property.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image:url(&quot;http:&#x2F;&#x2F;....&quot;);</span><br></pre></td></tr></table></figure><ul><li>The <code>!important</code> flag will override any style, however it should almost never be used, as it is extremely difficult to override.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color: #FFF !important;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Codecademy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summary for =Learn HTML= //Codecademy</title>
      <link href="2020/08/21/A-Summary-for-Learn-HTML-Codecademy/"/>
      <url>2020/08/21/A-Summary-for-Learn-HTML-Codecademy/</url>
      
        <content type="html"><![CDATA[<h1><center>Learn HTML</center></h1><h2 id="0x01-Elements-and-Structure"><a class="header-anchor" href="#0x01-Elements-and-Structure">¶</a>0x01 Elements and Structure</h2><h3>1&emsp;Introduction to HTML</h3><h4>1.1&emsp;Summary</h4><ul><li>HTML stands for <strong>HyperText Markup Language</strong> and is used to create the structure and content of a webpage.</li><li>Most HTML elements contain opening and closing tags with raw text or other HTML tags between them.</li><li>HTML elements can be nested inside other elements. The enclosed element is <strong>the child of</strong> the enclosing parent element.</li><li>Any visible content should be placed within the opening and closing <body> tags.</body></li><li>Headings and sub-headings, <code>&lt;h1&gt;</code> to <code>&lt;h6&gt;</code> tags, are used to enlarge text.</li><li><code>&lt;p&gt;</code>, <code>&lt;span&gt;</code> and <code>&lt;div&gt;</code> tags specify text or blocks.</li><li>The <code>&lt;em&gt;</code> and <code>&lt;strong&gt;</code> tags are used to emphasize text.</li><li>Line breaks are created with the <code>&lt;br&gt;</code> tag.</li><li>Ordered lists (<code>&lt;ol&gt;</code>) are numbered and unordered lists (<code>&lt;ul&gt;</code>) are bulleted.</li><li>Images (<code>&lt;img&gt;</code>) and videos (<code>&lt;video&gt;</code>) can be added by linking to an existing source.</li></ul><aside>*P.S. `<img>` is a single tag.*</aside><h3>2&emsp;HTML Document Standards</h3><h4>2.1&emsp;Summary</h4><center>*HTML Tags*</center>&emsp;While some tags have a very specific purpose, such as image and video tags, most tags are used to describe the content that they surround, which helps us modify and style our content later. There are seemingly infinite numbers of tags to use (many more than we’ve taught). Knowing when to use each one is based on how you want to describe the content of your HTML. Descriptive, well-chosen tags are one key to high-quality web development. A full list of available HTML tags can be found in Mozilla documentation.<ul><li>The <code>&lt;!DOCTYPE html&gt;</code> declaration should always be the first line of code in your HTML files. This lets the browser know what version of HTML to expect.</li><li>The <code>&lt;html&gt;</code> element will contain all of your HTML code.</li><li>Information about the web page, like the title, belongs within the <code>&lt;head&gt;</code> of the page.</li><li>You can add a title to your web page by using the <code>&lt;title&gt;</code> element, inside of the head.A webpage’s title appears in a browser’s tab.</li><li>Anchor tags (<code>&lt;a&gt;</code>) are used to link to internal pages, external pages or content on the same page.You can create sections on a webpage and jump to them using <code>&lt;a&gt;</code> tags and adding ids to the elements you wish to jump to.</li><li>Whitespace between HTML elements helps make code easier to read while not changing how elements appear in the browser.Indentation also helps make code easier to read. It makes parent-child relationships visible.</li><li>Comments are written in HTML using the following syntax: <code>&lt;!-- comment --&gt;</code>.<br></li></ul><h4>2.2&emsp;Demo</h4><pre>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;Brown Bears&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;nav&gt;    &lt;a href=&quot;./index.html&quot;&gt;Brown Bear&lt;/a&gt;    &lt;a href=&quot;./aboutme.html&quot;&gt;About Me&lt;/a&gt;  &lt;/nav&gt;  &lt;h1&gt;The Brown Bear&lt;/h1&gt;  &lt;nav&gt;    &lt;ul&gt;      &lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href=&quot;#habitat&quot;&gt;Habitat&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href=&quot;#media&quot;&gt;Media&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;  &lt;/nav&gt;  &lt;div id=&quot;introduction&quot;&gt;    &lt;h2&gt;About Brown Bears&lt;/h2&gt;    &lt;p&gt;The brown bear (&lt;em&gt;Ursus arctos&lt;/em&gt;) is native to parts of northern Eurasia and North America. Its conservation status is currently &lt;strong&gt;Least Concern&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt; There are many subspecies within the brown bear species, including the      Atlas bear and the Himalayan brown bear.&lt;/p&gt;    &lt;a href=&quot;https://en.wikipedia.org/wiki/Brown_bear&quot; target=&quot;_blank&quot;&gt;Learn More&lt;/a&gt;    &lt;h3&gt;Species&lt;/h3&gt;    &lt;ul&gt;      &lt;li&gt;Arctos&lt;/li&gt;      &lt;li&gt;Collarus&lt;/li&gt;      &lt;li&gt;Horribilis&lt;/li&gt;      &lt;li&gt;Nelsoni (extinct)&lt;/li&gt;    &lt;/ul&gt;    &lt;h3&gt;Features&lt;/h3&gt;    &lt;p&gt;Brown bears are not always completely brown. Some can be reddish or yellowish. They have very large, curved claws and huge paws. Male brown bears are often 30% larger than female brown bears. They can range from 5 feet to 9 feet from head to toe.&lt;/p&gt;  &lt;/div&gt;  &lt;div id=&quot;habitat&quot;&gt;    &lt;h2&gt;Habitat&lt;/h2&gt;    &lt;h3&gt;Countries with Large Brown Bear Populations&lt;/h3&gt;    &lt;ol&gt;      &lt;li&gt;Russia&lt;/li&gt;      &lt;li&gt;United States&lt;/li&gt;      &lt;li&gt;Canada&lt;/li&gt;    &lt;/ol&gt;    &lt;h3&gt;Countries with Small Brown Bear Populations&lt;/h3&gt;    &lt;p&gt;Some countries with smaller brown bear populations include Armenia, Belarus, Bulgaria, China, Finland, France, Greece, India, Japan, Nepal, Poland, Romania, Slovenia, Turkmenistan, and Uzbekistan.&lt;/p&gt;  &lt;/div&gt;  &lt;div id=&quot;media&quot;&gt;    &lt;h2&gt;Media&lt;/h2&gt;    &lt;img src=&quot;https://s3.amazonaws.com/codecademy-content/courses/web-101/web101-image_brownbear.jpg&quot; /&gt;    &lt;video src=&quot;https://s3.amazonaws.com/codecademy-content/courses/freelance-1/unit-1/lesson-2/htmlcss1-vid_brown-bear.mp4&quot; height=&quot;240&quot; width=&quot;320&quot; controls&gt;Video not supported&lt;/video&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</pre><p> Let’ see what it looks like in a browser:<br><img src="/.com//%5CA-Summary-for-Learn-HTML-Codecademy%5Cwebsite1.png" alt><br><img src="/.com//%5CA-Summary-for-Learn-HTML-Codecademy%5Cwebsite2.png" alt></p><h2 id="0x02-Tables"><a class="header-anchor" href="#0x02-Tables">¶</a>0x02 Tables</h2><h4>2.1&emsp;Summary</h4>&emsp;In this lesson, we learned how to create a table, add data to it, and section the table into smaller parts that make it easier to read.<ul><li>The <code>&lt;table&gt;</code> element creates a table.</li><li>The <code>&lt;tr&gt;</code> element adds rows to a table.</li><li>To add data to a row, you can use the <code>&lt;td&gt;</code> element.</li><li>Table headings clarify the meaning of data. Headings are added with the <code>&lt;th&gt;</code> element.</li><li>Table data can span columns using the colspan attribute; Table data can span rows using the rowspan attribute.</li><li>Tables can be split into three main sections: a head, a body, and a footer.<br>  A table’s head is created with the <code>&lt;thead&gt;</code> element.<br>  A table’s body is created with the <code>&lt;tbody&gt;</code> element.<br>  A table’s footer is created with the <code>&lt;tfoot&gt;</code> element.</li><li>All the CSS properties you learned about in this course can be applied to tables and their data.</li></ul><h4>2.2&emsp;Demo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;thead&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;th&gt;Company Name&lt;&#x2F;th&gt;</span><br><span class="line">    &lt;th&gt;Number of Items to Ship&lt;&#x2F;th&gt;</span><br><span class="line">    &lt;th&gt;Next Action&lt;&#x2F;th&gt;</span><br><span class="line">  &lt;&#x2F;tr&gt;</span><br><span class="line">  &lt;&#x2F;thead&gt;</span><br><span class="line">  &lt;tbody&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td colspan&#x3D;&quot;2&quot;&gt;Adam’s Greenworks&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;14&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;Package Items&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;&#x2F;tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Davie&#39;s Burgers&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td rowspan&#x3D;&quot;2&quot;&gt;2&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;Send Invoice&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;&#x2F;tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Baker&#39;s Bike Shop&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;3&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;Send Invoice&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;&#x2F;tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Miss Sally&#39;s Southern&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;4&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;Ship&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;&#x2F;tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Summit Resort Rentals&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;4&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;Ship&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;&#x2F;tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Strike Fitness&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;1&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;Enter Order&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;&#x2F;tr&gt;</span><br><span class="line">  &lt;tfoot&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;td&gt;Total&lt;&#x2F;td&gt;</span><br><span class="line">      &lt;td&gt;28&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">  &lt;&#x2F;tfoot&gt;</span><br><span class="line">  &lt;&#x2F;tbody&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure>&emsp;This is what it looks like: ![](\A-Summary-for-Learn-HTML-Codecademy\table.png)<br><h1>To be continued......</h1>************0x03 Forms---<h2 id="0x04-Semantic-HTML"><a class="header-anchor" href="#0x04-Semantic-HTML">¶</a>0x04 Semantic HTML</h2>]]></content>
      
      
      <categories>
          
          <category> Codecademy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Merge Two Binary Trees //Leetcode</title>
      <link href="2020/08/21/Merge-Two-Binary-Trees-Leetcode/"/>
      <url>2020/08/21/Merge-Two-Binary-Trees-Leetcode/</url>
      
        <content type="html"><![CDATA[<h1>Description</h1><blockquote><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p><p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p></blockquote><h1>Input</h1><p><img src="/2020/08/21/Merge-Two-Binary-Trees-Leetcode/%5CMerge-Two-Binary-Trees-Leetcode%5Cinput.png" alt=""></p><h1>Output</h1><p><img src="/2020/08/21/Merge-Two-Binary-Trees-Leetcode/%5CMerge-Two-Binary-Trees-Leetcode%5Coutput.png" alt=""></p><h1>Analysis</h1><h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>默认代码中给出了“TreeNode”数据结构的定义。每个节点有一个值，这个值可以通过两种函数给出，之后就把它们叫函数1和函数2。<br>我们先来想想不用代码自己手动合并的话会怎么做——核心问题在于怎么算出一个结点的值，以及确定结果树的结构（哪里有结点哪里没有）。<br>好的，先考虑第一个问题，对于一个结点，假如它没有左右孩子，那么它的值应该用函数1计算，也就是直接赋值——因此，我们应该对那些叶节点直接赋值；除这种情况以外，剩下的用函数2计算结点值。说得程序化一点会是什么样呢？处理树可以用递归与循环两种方式来考虑。</p><h1>WAY1：Recursion</h1><h2 id="Explanation"><a class="header-anchor" href="#Explanation">¶</a>Explanation</h2><p>既然用递归，我们可以想象这个调用过程大概是：从两棵树的头部开始，一直往下往下，到叶子节点开始向上返回，两两合并组在一起。<br>编写一个mergeTrees函数，输入是两个结点。<br>假如其中一个是空的，合并结果就是另一个，直接返回就好了<br>假如两者都不空，就应该此处结点的值赋为两个相加，然后此结点的左子树等于参数1的左子树+参数2的左子树，右子树等于参数1的右子树+参数2的右子树。这个+其实就是在调用mergeTrees函数，所以是递归。</p><h2 id="Code"><a class="header-anchor" href="#Code">¶</a>Code</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() {}</span><br><span class="line"> *     TreeNode(int val) { this.val = val; }</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     }</span><br><span class="line"> * }</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {</span><br><span class="line">        if (t1==null){</span><br><span class="line">            return t2;</span><br><span class="line">        }</span><br><span class="line">        if (t2==null){</span><br><span class="line">            return t1;</span><br><span class="line">        }</span><br><span class="line">        t1.val+=t2.val;</span><br><span class="line">        t1.left=mergeTrees(t1.left,t2.left);</span><br><span class="line">        t1.right=mergeTrees(t1.right,t2.right);</span><br><span class="line">return t1;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Complexity"><a class="header-anchor" href="#Complexity">¶</a>Complexity</h2><h2 id="Attention"><a class="header-anchor" href="#Attention">¶</a>Attention</h2><ol><li>一个函数如果作为主要的递归函数，应该在每个条件分支处都有return</li><li>多画图还是很有帮助的</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leetcode Top 100 Liked Questions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to start Markdown</title>
      <link href="2020/08/18/How-to-start-Markdown/"/>
      <url>2020/08/18/How-to-start-Markdown/</url>
      
        <content type="html"><![CDATA[<p>#一、快捷键</p><p><strong>加粗ctrl+B</strong></p><p><em>斜体</em></p><blockquote><p>引用</p></blockquote><p><a href="https://blog.csdn.net/u014061630/article/details/81359144">链接</a></p><pre><code>代码</code></pre><p>图片</p><p>提升标题</p><p>有序列表</p><hr><p>#二、基本语法</p><p>#一级标题</p><h1>一级标题</h1><p>##二级标题</p><h2 id="二级标题"><a class="header-anchor" href="#二级标题">¶</a>二级标题</h2><p>本地图片</p><p><img src="/.com//%E5%9B%BE%E7%89%87.png" alt="链接"></p><p>互联网图片</p><p><img src="https://img-blog.csdn.net/20180802154402427?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQwNjE2MzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="链接"></p><p><a href="https://www.jianshu.com/p/10aa8ba19802">https://www.jianshu.com/p/10aa8ba19802</a></p><hr><hr><hr><p>行内代码：<code>code</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code here</span><br></pre></td></tr></table></figure><pre><code>code here</code></pre><ul><li><p>无序列表1</p></li><li><p>无序列表2</p></li></ul><p>1</p><ol><li>为什么没有1</li><li>原来中间要隔字</li></ol><p>对策<br>我</p><table><thead><tr><th>学号</th><th>姓名</th></tr></thead><tbody><tr><td>820810203</td><td>胡可</td></tr></tbody></table><p>#三、常用技巧</p><p>换行是要在后面加两个空格的！</p><font color="#87CEFA" size="7" face="楷体">很漂亮</font>  ]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/08/13/hello-world/"/>
      <url>2020/08/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
